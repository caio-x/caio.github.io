{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/spade-logo-next.png","path":"images/spade-logo-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/spade-logo-next.svg","path":"images/spade-logo-next.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/spade-logo.png","path":"images/spade-logo.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/spade-logo.svg","path":"images/spade-logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/timg.gif","path":"images/timg.gif","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_drafts/2022-06-16_swift-SIL.md","hash":"193dbe23ede2910afdafd949669467feee2ee4ef","modified":1659015520205},{"_id":"source/_drafts/2022-07-05_Objective-C-Trampoline.md","hash":"eacddbccec04dabd7df8e216dd2032598447db3b","modified":1659015520205},{"_id":"source/_drafts/2022-07-07_Segment-Tree.md","hash":"d57cdd67498fbd7b914c1c06f8fa8e4daa25dcd7","modified":1659015520205},{"_id":"source/_drafts/top值规则.md","hash":"e7511de2ceb2e5cbad81a6d9019590be3bf8d039","modified":1659015520206},{"_id":"source/categories/index.md","hash":"757adf3ab3e18694862b139cba48ec70a71e5c67","modified":1653127626072},{"_id":"source/_posts/1.leetcode41.md","hash":"8be8e8a750a11785dd4103698ab0c9ce284efc82","modified":1653126938818},{"_id":"source/_posts/10.runloop-binary-search.md","hash":"13d23476f336b6812db0d07b939203a4c7abb6aa","modified":1659015520207},{"_id":"source/_posts/11.dyld.md","hash":"200133a8e7369eac70b977df40d41f3203c70780","modified":1659015520207},{"_id":"source/_posts/12.compiler-autorelease-opt.md","hash":"09ea095507b7a7b40c0e1a6fcbd2bec55bd83aec","modified":1659015520208},{"_id":"source/.DS_Store","hash":"76ae52c1c473bf25f8cec32970afc256f356951b","modified":1661092709072},{"_id":"source/_drafts/.DS_Store","hash":"69ce9d922130493d0e10c94c1445c922038659ee","modified":1661063083025},{"_id":"source/_posts/13.sqlite-os-shm.md","hash":"e51d2e6117ef8dbbec44e80248c2da6e58821e76","modified":1659015520208},{"_id":"source/_posts/14.gomobile-bind.md","hash":"cb1125dbe3a1884b108f5a8bdc8eece13094f58d","modified":1659015520209},{"_id":"source/_posts/17.inside-sqlite-chapter-6.md","hash":"943e8ac0c94d7b0f143e2c67650288eef125b9a9","modified":1659015520210},{"_id":"source/_posts/.DS_Store","hash":"a1f2ca00beff3380a87ca0a70ae58ed09dd74dfd","modified":1659086734600},{"_id":"source/_posts/18.db-system-design-imp(VM).md","hash":"ef4d7cf1b35c86b43646666d673d160766e304bc","modified":1659015520211},{"_id":"source/_posts/15.Sqlite-OS.md","hash":"a60678a17aef5f3460f2b40b7f85dfbb8e200cfd","modified":1659015520209},{"_id":"source/_posts/19.SQLite-KeywordHash.md","hash":"8ea43ffbaf7c1eedf2358ce28775cd85af358c21","modified":1659015520212},{"_id":"source/_posts/2.leetcode5.md","hash":"2c01adccd4b0bcc9133191b7c6097807a7c120fc","modified":1598712178499},{"_id":"source/_posts/2019-12-20_synchronized.md","hash":"5f9709025186cba2d7e563c342d13e74f6004ba8","modified":1659015520238},{"_id":"source/_posts/20.SQLite-Tokenize.md","hash":"db195bbbc917d4cf45cd53d5dd2f730c3e1fbb7b","modified":1659015520212},{"_id":"source/_posts/2020-08-17_db-system-design-imp(Pager).md","hash":"e0cad15b1a934dbd0c65a1eebc0765aad7006f28","modified":1659015520213},{"_id":"source/_posts/2020-08-21_db-system-design-imp(Transaction).md","hash":"cba6a73049c8f0fbc06376772536b980ae7f175f","modified":1659015520214},{"_id":"source/_posts/2020-08-25_db-system-design-im(storage).md","hash":"96ead5a01c48a7dd6b986355d39c80823e459653","modified":1659015520214},{"_id":"source/_posts/2020-08-29_db_system_design_imp(WAL).md","hash":"942c9717c82e5413c6579abf43ebd62c4bd124c0","modified":1659015520215},{"_id":"source/_posts/2022-07-20_C++_memory_order.md","hash":"5c1f9f2fc80d74eaef1c5758938219f7af2dc6a6","modified":1661092817775},{"_id":"source/_posts/2022-07-20_ARM64_assmble.md","hash":"4bb8877b1cf1b80f7ff036b7fdedaed7aabfc7d6","modified":1661063180381},{"_id":"source/_posts/3.binding-symbols.md","hash":"73643da9c59fb5d7b78abe686e90f6bb2bbeddaf","modified":1659015520216},{"_id":"source/_posts/5.OC-Block-imp.md","hash":"961a17ff8b599866f851d72870d4dc0658061313","modified":1659015520216},{"_id":"source/_posts/6.leetcode32.md","hash":"b2a8ab82a4d374d06deac99b1827823d6d2ee614","modified":1598712178502},{"_id":"source/_posts/7.leetcode46.md","hash":"9fcd6e50f7fd812ab1a3335f05d90155c50e5e96","modified":1598712178502},{"_id":"source/_posts/9.LeetCode-week-match.md","hash":"6647510b98c99b6266aa2687bc44eb8356242c2f","modified":1598712178503},{"_id":"source/_posts/8.leetcode47.md","hash":"bb9720e537822af51c82a4baa669b3befee70880","modified":1598712178503},{"_id":"source/tags/index.md","hash":"ed1a418b9e2b717d5d53e6d61c4838b1ae95d7dd","modified":1653127587933},{"_id":"source/_drafts/Sprague-Grundy定理/Sprague-Grundy定理.md","hash":"5a994cb5072d2484ccb1dd7e0d08f6b6fa5ba812","modified":1659015366216},{"_id":"source/_posts/2022-07-20_C++_memory_order/memory_reorder_case1.jpg","hash":"bf871c5647688d27ad5ea6cd7fb544e3907737a3","modified":1661063180381},{"_id":"source/_posts/2022-07-20_C++_memory_order/CPU_memory_struct.jpg","hash":"7b372e2cd1877fb085665973696aab986a0b5327","modified":1661063180379},{"_id":"source/_posts/2022-07-20_C++_memory_order/mutex_memory_case.jpg","hash":"0891ef49bf6ae1fcb2b43eabbbeecc029afdf96d","modified":1661081405004},{"_id":"source/_posts/2022-07-20_C++_memory_order/shared_ptr_delete2.jpg","hash":"b058f9117f1ef0401e730a7652a405f9773e3605","modified":1661088507516},{"_id":"source/_posts/2022-07-20_C++_memory_order/shared_ptr_delete.jpg","hash":"c54f0452c4663fa11528efeda4fd8dc07b6f2022","modified":1661088482256},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1653121430560},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1653121430560},{"_id":"themes/next/.gitignore","hash":"417520c4dbbeab9c7e3ab10d944da0886366a0ee","modified":1653122276870},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1653121430560},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1653121430564},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1653122240655},{"_id":"themes/next/README.md","hash":"fb9016c2af9687beb68af174506ae54b11b8dbdf","modified":1653123114891},{"_id":"themes/next/_config.yml","hash":"db64b0b4e77c00a31cac711334ad6324d4265dce","modified":1653179364928},{"_id":"themes/next/_vendors.yml","hash":"bd8c9077ea59f836a6384d991178dfc22c7ad642","modified":1653123114891},{"_id":"themes/next/package.json","hash":"cad27a427487eb491b6309773296a478c1caf068","modified":1653123114894},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1653121430565},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1653121430582},{"_id":"themes/next/.githooks/install.js","hash":"4d77dbddf2eac1f3fc78f151d12ed22208ed655b","modified":1653122240653},{"_id":"themes/next/.githooks/pre-commit","hash":"f473eac1aaaa96c947d67988bbed140bbab1a821","modified":1653122240654},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"21cbff565a0445d3a880fff1ee417e309740a9ab","modified":1653122240654},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"330656d93b6c03df9fb1f2f0e3534c971969473b","modified":1653122276868},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"3e9fbb78e3dee0ca1dc886d0c28b0148ba0ca499","modified":1653121430562},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1653121430562},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1653121430562},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1653121430562},{"_id":"themes/next/.github/labeler.yml","hash":"5c4bc2bd561e6d9b33ee118cc12218c5de46f72d","modified":1653122276869},{"_id":"themes/next/.github/release-drafter.yml","hash":"423275ec021104b263cd88776936a8c8d6872b66","modified":1653122276869},{"_id":"themes/next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":1653122276873},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1653121430581},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1653122276882},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1653122276882},{"_id":"themes/next/layout/page.njk","hash":"6c40aa438c658eb7f0cd0f6a759f18b43e7e8f93","modified":1653122276882},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1653121430582},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1653122276882},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1653121430567},{"_id":"themes/next/languages/bn.yml","hash":"b5e2a35eb6fff56b6e32ce479e63b6fc5e44d5cb","modified":1653122292019},{"_id":"themes/next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1653122240658},{"_id":"themes/next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1653122240658},{"_id":"themes/next/languages/default.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1653122240658},{"_id":"themes/next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1653122240658},{"_id":"themes/next/languages/es.yml","hash":"b813da5aed9d73b809133db4dfb08f90ec56afd9","modified":1653122292019},{"_id":"themes/next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1653122240658},{"_id":"themes/next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1653122240659},{"_id":"themes/next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1653122240659},{"_id":"themes/next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1653122240659},{"_id":"themes/next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1653122240659},{"_id":"themes/next/languages/ko.yml","hash":"819c19eb9d142e5411f77cf3821d90f740ee114a","modified":1653123114892},{"_id":"themes/next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1653122240660},{"_id":"themes/next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1653122240660},{"_id":"themes/next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1653122240660},{"_id":"themes/next/languages/ru.yml","hash":"8c2b6361f2de17561c1a3eede2bf47b4e2ba6ce5","modified":1653122292019},{"_id":"themes/next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1653122276872},{"_id":"themes/next/languages/tk.yml","hash":"519239e35c3bda7b62b00ff5d34644f45b16fe6a","modified":1653122276872},{"_id":"themes/next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1653122276872},{"_id":"themes/next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1653122240661},{"_id":"themes/next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1653122240661},{"_id":"themes/next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":1653122240661},{"_id":"themes/next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1653122276872},{"_id":"themes/next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1653122276873},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1653121430565},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1653121430565},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1653122240656},{"_id":"themes/next/source/.DS_Store","hash":"f3182c6e82811060eb1c71f969bf6c7eaef6e8f4","modified":1653915610328},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1653121430615},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"fc4dce84ed9a5d21d3a8833ff6d776c46f876115","modified":1653121430561},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"c40ae7903b6cc99f94c9d45ac7ba8c2850bb1309","modified":1653122240654},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4ecac91716eac59d7c2bc53cf6e95612d44da97b","modified":1653121430562},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"8cc5b5c116f6a052865a324512362f145d699202","modified":1653122240654},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"434cc0674290958b1e9bbc46c3486f073c0722db","modified":1653123114890},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"e9d51e93f239a2d4b69722c69db3463b4baf0f4c","modified":1653123114890},{"_id":"themes/next/.github/workflows/linter.yml","hash":"b6c111344bc0f3500ca69d7590791ff85ef1090d","modified":1653123114890},{"_id":"themes/next/.github/workflows/lock.yml","hash":"e48d1ced9a673d3f0911a700d3e68c0f4ca79263","modified":1653122276869},{"_id":"themes/next/.github/workflows/release-drafter.yml","hash":"4f3af81009cb922be91f718a67425377515ea69d","modified":1653121430563},{"_id":"themes/next/.github/workflows/tester.yml","hash":"80a20c3a7522249f051a48239db41d1317e9b552","modified":1653123114890},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1653121430571},{"_id":"themes/next/layout/_macro/post.njk","hash":"434b3e76a040a816169e1929657e4176e7b8164c","modified":1653123114892},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1653134253678},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1653123114892},{"_id":"themes/next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1653122276873},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1653122240663},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1653121430574},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1653122240664},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1653122276876},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1653122276876},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1653122276879},{"_id":"themes/next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1653122276879},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1653122276880},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1653122276880},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1653122276880},{"_id":"themes/next/docs/ru/README.md","hash":"3125f0cb4cdb448d9b92292f64d7612013fdd165","modified":1653123114892},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1653122240657},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1653122276871},{"_id":"themes/next/docs/zh-CN/README.md","hash":"ef609aa9174ad61b7ab0bb578de57fec86d9b767","modified":1653123114892},{"_id":"themes/next/scripts/events/index.js","hash":"3ce10d4cce94e3d4c482c2e18bb6f0f0ca380d3d","modified":1653123114894},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1653121430585},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1653122292023},{"_id":"themes/next/scripts/filters/minify.js","hash":"3abdcb715562414063e0fb3eeb6244ce59c477e0","modified":1653122292024},{"_id":"themes/next/scripts/filters/post.js","hash":"30e03a1d4828259f82d46e64cbfe2955b6cff9a9","modified":1653123114895},{"_id":"themes/next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1653123114896},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1653122240668},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1653123114896},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"9a07f2d979fc8fe0c5e07d48304187b9b03ea7ff","modified":1653122276887},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1653122276887},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1653121430586},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1653121430587},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1653121430587},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1653121430587},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1653122276887},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1653121430587},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1653121430587},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1653122276887},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1653122240669},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1653121430588},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1653121430588},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1653122276888},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1653121430588},{"_id":"themes/next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1653122276888},{"_id":"themes/next/source/css/_mixins.styl","hash":"32d31cb5a155681c19f5ad0bb56dcb08429f93ef","modified":1653122292025},{"_id":"themes/next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1653122240678},{"_id":"themes/next/source/css/noscript.styl","hash":"263eddabfae40e54c0591e7baa8403ade8cdd56d","modified":1653123114897},{"_id":"themes/next/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1653134969848},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1653121430606},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1653122276902},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1653121430606},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1653121430606},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1653121430607},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1653122276903},{"_id":"themes/next/source/images/spade-logo-next.png","hash":"28778f643f771955bda170923f842c21bb567d32","modified":1653134928389},{"_id":"themes/next/source/images/spade-logo-next.svg","hash":"5f1736ed90b046f36374919090822b96894f9090","modified":1653134930282},{"_id":"themes/next/source/images/spade-logo.png","hash":"96977336310ca4a0401c1cc396179012ddf6b5f8","modified":1653120339042},{"_id":"themes/next/source/images/spade-logo.svg","hash":"4fd1156094ba99ceebb68436bfdcdcc529ed8cda","modified":1653120524719},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1653122276903},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1653122276903},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1653122276903},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1653122276903},{"_id":"themes/next/source/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1653123114898},{"_id":"themes/next/source/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1653122276903},{"_id":"themes/next/source/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1653122276903},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1653123114898},{"_id":"themes/next/source/js/utils.js","hash":"e447160d342b1f93df5214b6a733441039ced439","modified":1653122276908},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1653122240681},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1653121430615},{"_id":"themes/next/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1653122276909},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1653121430616},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1653121430616},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1653121430616},{"_id":"themes/next/test/tags/group-pictures.js","hash":"5c68ae0184f9da6e00ba199f2554d503d8e6da71","modified":1653122276909},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1653121430617},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1653121430617},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1653122276909},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1653122240681},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1653121430617},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1653121430617},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1653121430617},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1653121430618},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1653122240681},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1653123114893},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"aff4613756456be26415febc668860fdab8d33c5","modified":1653122276874},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"0ba2bf0266f1fcb8edbd961869f8521b29685c56","modified":1653122292020},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1653122276874},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1653123114893},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1653123114893},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1653123114893},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1653121430573},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1653123114894},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1653121430573},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1653121430574},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1653121430573},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1653123114894},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1653121430574},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1653122276875},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1653122276875},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"57eca76cfbbe9a65bc2a77f1deebf003ed335673","modified":1653122292021},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1653122276875},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1653122240663},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1653121430575},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1653122240664},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"3d8591bb92df77ceb9d5b07bc76da1ca89e5bd76","modified":1653122276876},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1653122276876},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":1653122240664},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1653122276876},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1653122276877},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"45477a04cf2b3c077061c8c3ada216c1ae288e0e","modified":1653122292021},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1653123114894},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1653122276877},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1653122276877},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1653122276877},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1653122276877},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1653122276878},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1653122276878},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1653122276878},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1653122276878},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1653122276878},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1653122276879},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1653122276879},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":1653122276879},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1653122276879},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1653122276880},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1653122276881},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1653121430580},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1653122276881},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1653122240665},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1653122276881},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1653122276881},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1653122276881},{"_id":"themes/next/scripts/events/lib/config.js","hash":"c8b59b404f5d2a0b3b5cd1a6c9a10af5f30e43b5","modified":1653122292022},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1653121430583},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1653122276883},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1653123114895},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":1653123114895},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"0d94ac5daa95f99046d66160d9f0f34ee786736c","modified":1653123114895},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"7fa8701c86485b2fe7324e017101a32417902397","modified":1653122276884},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1653123114895},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1653121430584},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1653122276884},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":1653122276884},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1653122276885},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1653122240667},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1653122276885},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1653122240668},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1653121430604},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1653121430604},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1653121430605},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1653121430605},{"_id":"themes/next/source/css/_variables/base.styl","hash":"163c7441d777bee87042d475e6ce0fde199add28","modified":1653122276902},{"_id":"themes/next/source/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1653123114898},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1653122276906},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1653122276907},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1653122276907},{"_id":"themes/next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1653122276907},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1653122276889},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1653122276889},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1653122276892},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1653122276897},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1653122276897},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1653121430596},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1653122276899},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1653121430596},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1653121430597},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1653121430597},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1653122276899},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1653122240675},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1653121430600},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1653122240676},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1653122240676},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1653121430601},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1653123114897},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"be6cf377ae8f4a01ee76f9b3014e74161d4d5d17","modified":1653123114897},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1653121430602},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1653121430602},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1653121430602},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1653123114897},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1653122276901},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1653121430603},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1653121430603},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1653122276901},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1653121430603},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1653122240677},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1653122276902},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1653122240678},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1653121430604},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1653122276904},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1653122276904},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1653122276904},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1653122276905},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1653122276905},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1653122276905},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1653122276905},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1653122276905},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1653122276905},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1653122276906},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1653122276906},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1653122276906},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1653122276906},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1653122276906},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1653122276906},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1653123114899},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1653122276908},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1653123114898},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1653123114899},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1653123114899},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1653122276908},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1653121430589},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1653121430589},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1653122240669},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1653122240669},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1653121430590},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":1653122276889},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1653123114896},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1653122240670},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":1653122276890},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1653122240670},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1653121430591},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1653122276890},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1653122240670},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1653122276891},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1653122276891},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"c2326ee3e8b724d99c24a818ddee32813ea5bf89","modified":1653122276892},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1653122276893},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1653122292024},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"979486a41a81f2a9fd8b0b87c4f87d6416c68c7d","modified":1653122292025},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1653122276894},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1653122276894},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1653122276894},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1653122276895},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1653122276896},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1653122276896},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"ff642130354a0b3be0d708c43044ed4d710b5e83","modified":1653123114896},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1653122240672},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"759e582d34d08e3386c55d87a835a9523608619f","modified":1653122276896},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1653122240673},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1653122276895},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1653122276897},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1653122240673},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1653121430595},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1653121430595},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1653122276897},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1653121430595},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1653122276898},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1653122276898},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1653122276898},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1653122276898},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1653121430597},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"f2328caa94645836e06fb39a6a9c9a84ed68a8b5","modified":1653122276899},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1653122276899},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1653121430598},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1653122276900},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1653122240675},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1653122276900},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1653122276900},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1653122276900},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1653122276900},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1653123114896},{"_id":"themes/next/source/images/timg.gif","hash":"1ff7e8df9671f590629a9c2228fa1e4b3bba8af3","modified":1653123761030},{"_id":"public/categories/index.html","hash":"94365515105f56152da0af0d4942be7515280673","modified":1661093003423},{"_id":"public/tags/index.html","hash":"088c89a79b2fd13cf61d92db9f0f5e75378c2e75","modified":1661093003423},{"_id":"public/2020/01/13/9.LeetCode-week-match/index.html","hash":"7b26f387f098acb474bb9d9e58d9250d640b6f3f","modified":1661093003423},{"_id":"public/archives/index.html","hash":"9a9f0b472c987c68b773697d5d53f8102175c701","modified":1661093003423},{"_id":"public/archives/page/2/index.html","hash":"bf45c658a8fd2a815255ea458f80f045c7ba95c7","modified":1661093003423},{"_id":"public/archives/page/3/index.html","hash":"a741ce9889334d0aa66262f3dc8da7dc39616b8a","modified":1661093003423},{"_id":"public/archives/2019/index.html","hash":"3c0e72dbe980b804b96512d586a090a193df56ca","modified":1661093003423},{"_id":"public/archives/2019/12/index.html","hash":"ea82d67b693378749b6c6e79a732b84550c33147","modified":1661093003423},{"_id":"public/archives/2020/index.html","hash":"11e31c0db71647f1e423fa41d943b1307b277fc4","modified":1661093003423},{"_id":"public/archives/2020/page/2/index.html","hash":"7bb812c79e79807e01fdd83997629af16c40afd1","modified":1661093003423},{"_id":"public/archives/2020/01/index.html","hash":"c6325a3bb26abdb9e2c8c2157ee4c8755bde256b","modified":1661093003423},{"_id":"public/archives/2020/03/index.html","hash":"176238c6e5c13b82465c8a1b76aab4b9160824c7","modified":1661093003423},{"_id":"public/archives/2020/04/index.html","hash":"67467f569ed752b80b34abb5ab34cafcc2897f4e","modified":1661093003423},{"_id":"public/archives/2020/06/index.html","hash":"45ab20ed9865e10c11c043903e9d0c2cf56ad2e0","modified":1661093003423},{"_id":"public/archives/2020/07/index.html","hash":"9758e35fc8062d0f8cc1c7fc2faabf0e6dfda406","modified":1661093003423},{"_id":"public/archives/2020/08/index.html","hash":"ba85f4114938cbb71f09e85d8f7b222b5a370943","modified":1661093003423},{"_id":"public/archives/2022/index.html","hash":"473167885bfe21cbbd787283928a8974c49a98bb","modified":1661093003423},{"_id":"public/archives/2022/07/index.html","hash":"1c35b0ba470cb3571a1e011677b34f2c27aa9a6c","modified":1661093003423},{"_id":"public/categories/算法/index.html","hash":"ce6396e1902d30f215e777049eb2cc502a568657","modified":1661093003423},{"_id":"public/categories/动态库/index.html","hash":"128039fdbb6389c8821676ca190284d3483339ce","modified":1661093003423},{"_id":"public/categories/sqlite3/index.html","hash":"d7b413e803aecd3f6ecc0183db57e8e0f062717a","modified":1661093003423},{"_id":"public/categories/object-c/index.html","hash":"d94613f4dec074b2144c158a500996c8ea92607f","modified":1661093003423},{"_id":"public/categories/GoMobile/index.html","hash":"920e3eb22cbd5656198f62d13e9a473ddb2774af","modified":1661093003423},{"_id":"public/categories/语法糖/index.html","hash":"59decacd0a7c31dc8b07cdb67c076e97fc508103","modified":1661093003423},{"_id":"public/categories/汇编/index.html","hash":"69ad71d5caf227fe2e45673fce2b9c70251338aa","modified":1661093003423},{"_id":"public/categories/C/index.html","hash":"8dc3800227c13876ae319ed461211fce590b22f4","modified":1661093003423},{"_id":"public/tags/leetcode/index.html","hash":"8fc4a3aa5fa68f399ac9fbf9c4ba9da6ad09d9e5","modified":1661093003423},{"_id":"public/tags/数组/index.html","hash":"ac6086de170f3bfd0c8eb7f78550a56a3f7ff8f7","modified":1661093003423},{"_id":"public/tags/object-c/index.html","hash":"1cba7498bf29323cecc5461b3e766b0ca43b35c6","modified":1661093003423},{"_id":"public/tags/二分法/index.html","hash":"08ed56d2288cebac6058dd900b52bfae84bb418d","modified":1661093003423},{"_id":"public/tags/动态链接/index.html","hash":"dae0cfaf3709bd6d67ad7f94a1e8b260dd2dbbfd","modified":1661093003423},{"_id":"public/tags/sqlite3/index.html","hash":"b7309ffcff8797f676db76ed198e9566dc4e5773","modified":1661093003423},{"_id":"public/tags/os/index.html","hash":"5b92d3ae909c406d54c6ccbfaf23ee9f4bec4331","modified":1661093003423},{"_id":"public/tags/shm/index.html","hash":"572c5a83115e4f224dd53aacbe32618e4686729d","modified":1661093003423},{"_id":"public/tags/GoMobile/index.html","hash":"17bd51274e445cd39df944aec7a09ed3ce428a02","modified":1661093003423},{"_id":"public/tags/回文/index.html","hash":"54404f65caedf47f048ed222fcbe8a09f79d51e4","modified":1661093003423},{"_id":"public/tags/锁/index.html","hash":"987326a75eaee2eaf40a3259e477f18b46bcb0c4","modified":1661093003423},{"_id":"public/tags/汇编/index.html","hash":"550d483f88fd7bdcd9fc328d242f156c1f92cb2c","modified":1661093003423},{"_id":"public/tags/C/index.html","hash":"f2df45bd9581b8c92365d6fd21dc15c15e68a344","modified":1661093003423},{"_id":"public/tags/符号绑定/index.html","hash":"5a8dc1fe03da9cb1a3e52a187b2993ee73772085","modified":1661093003423},{"_id":"public/tags/回溯法/index.html","hash":"6dd701ea11b1928516eab570bc2371fe81a5127f","modified":1661093003423},{"_id":"public/tags/动态规划/index.html","hash":"7784a2c02425faf12e99cf67e6e9423bf08d937a","modified":1661093003423},{"_id":"public/tags/周赛/index.html","hash":"29e9175be5fcae738a81258ffcd7c481acf8d67d","modified":1661093003423},{"_id":"public/2022/07/20/2022-07-20_ARM64_assmble/index.html","hash":"d21a93c14010369030a93d5cedac80c068277553","modified":1661093003423},{"_id":"public/2022/07/20/2022-07-20_C++_memory_order/index.html","hash":"ca0f69201d42a7b9ff9eb8015d371a02d98a79c8","modified":1661093003423},{"_id":"public/2020/08/29/2020-08-29_db_system_design_imp(WAL)/index.html","hash":"aa7177d2a43795d134855401c73dd4d0aa52b426","modified":1661093003423},{"_id":"public/2020/08/25/2020-08-25_db-system-design-im(storage)/index.html","hash":"b936cd63fa667a9d79c54f239a3e72111b42bf52","modified":1661093003423},{"_id":"public/2020/08/21/2020-08-21_db-system-design-imp(Transaction)/index.html","hash":"066d9c3ca0ccb93332eca366213ebe6a72ab8d9b","modified":1661093003423},{"_id":"public/2020/08/17/2020-08-17_db-system-design-imp(Pager)/index.html","hash":"5138871f22ac9ea6c290cd275ba726919ff3aa3c","modified":1661093003423},{"_id":"public/2020/07/21/20.SQLite-Tokenize/index.html","hash":"d2178e73d3be41fdcdfc63d6e1c2ecb55454e00d","modified":1661093003423},{"_id":"public/2020/07/16/19.SQLite-KeywordHash/index.html","hash":"e30f3df382a97aca54db7997b6c5688f695f3f58","modified":1661093003423},{"_id":"public/2020/06/29/18.db-system-design-imp(VM)/index.html","hash":"7c3267839105522030c5e0a1cc52ca0185bad0d7","modified":1661093003423},{"_id":"public/2020/06/12/17.inside-sqlite-chapter-6/index.html","hash":"63b889465e830f8f5bc2ce6dcdc709ab44410ffb","modified":1661093003423},{"_id":"public/2020/04/19/15.Sqlite-OS/index.html","hash":"b0306392cab1c8db024c00b76937d2f2b6bb4888","modified":1661093003423},{"_id":"public/2020/04/01/14.gomobile-bind/index.html","hash":"cefbf3bc851aa9e808c0ecb150ea3cd32dc630b0","modified":1661093003423},{"_id":"public/2020/03/18/13.sqlite-os-shm/index.html","hash":"9f800e7ffb126f013addb5b2405176c8cbf1622c","modified":1661093003423},{"_id":"public/2020/03/15/12.compiler-autorelease-opt/index.html","hash":"195cc163075bbb2481efcb5fe7c8724f60eb7da5","modified":1661093003423},{"_id":"public/2020/03/13/11.dyld/index.html","hash":"299a59027edc40395d36185bd689e7d92b7bfae8","modified":1661093003423},{"_id":"public/2020/03/04/10.runloop-binary-search/index.html","hash":"3e32627e3d51aec6dc412bef3aebdfe12b8816eb","modified":1661093003423},{"_id":"public/2020/01/07/8.leetcode47/index.html","hash":"42bf17c991048d7cf64a7deb8df2b5e3999d6eae","modified":1661093003423},{"_id":"public/2020/01/05/7.leetcode46/index.html","hash":"d9e3a354576c14e2b59f45279fc9f3e185eb58ac","modified":1661093003423},{"_id":"public/2019/12/21/5.OC-Block-imp/index.html","hash":"a05adae1bff8cb5835c0c83b0d87946c5e9297f7","modified":1661093003423},{"_id":"public/2019/12/21/6.leetcode32/index.html","hash":"26b1218ca79abb892a0e8422e48031436aeef84c","modified":1661093003423},{"_id":"public/2019/12/20/2019-12-20_synchronized/index.html","hash":"836ff924edf9aeb7d90d6fd4a36e2331d73c04a2","modified":1661093003423},{"_id":"public/2019/12/17/3.binding-symbols/index.html","hash":"11f981f9922cd648d52738be9f419ee3c8b125fe","modified":1661093003423},{"_id":"public/2019/12/11/2.leetcode5/index.html","hash":"66d221759aae63ddfa449378ce1b066a1ff5d619","modified":1661093003423},{"_id":"public/2019/12/10/1.leetcode41/index.html","hash":"14345d4aa8893908dcbb5248b093fc1f1c8686fc","modified":1661093003423},{"_id":"public/index.html","hash":"42f0f4a082f2c85f5edd8a09aed26d6341db7223","modified":1661093003423},{"_id":"public/page/2/index.html","hash":"b38dd90c548d7265cc030473b68913c741787120","modified":1661093003423},{"_id":"public/page/3/index.html","hash":"80bd8042accf362f64028c83e70ae209d809c880","modified":1661093003423},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1661093003423},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1661093003423},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1661093003423},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1661093003423},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1661093003423},{"_id":"public/images/spade-logo-next.png","hash":"28778f643f771955bda170923f842c21bb567d32","modified":1661093003423},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1661093003423},{"_id":"public/images/spade-logo.png","hash":"96977336310ca4a0401c1cc396179012ddf6b5f8","modified":1661093003423},{"_id":"public/images/spade-logo-next.svg","hash":"5f1736ed90b046f36374919090822b96894f9090","modified":1661093003423},{"_id":"public/images/spade-logo.svg","hash":"4fd1156094ba99ceebb68436bfdcdcc529ed8cda","modified":1661093003423},{"_id":"public/css/noscript.css","hash":"ec89b3425fbce20863d554c6fd495ea29c3c303d","modified":1661093003423},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1661093003423},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1661093003423},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1661093003423},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1661093003423},{"_id":"public/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1661093003423},{"_id":"public/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1661093003423},{"_id":"public/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1661093003423},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1661093003423},{"_id":"public/js/utils.js","hash":"e447160d342b1f93df5214b6a733441039ced439","modified":1661093003423},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1661093003423},{"_id":"public/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1661093003423},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1661093003423},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1661093003423},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1661093003423},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1661093003423},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1661093003423},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1661093003423},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1661093003423},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1661093003423},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1661093003423},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1661093003423},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1661093003423},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1661093003423},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1661093003423},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1661093003423},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1661093003423},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1661093003423},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1661093003423},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1661093003423},{"_id":"public/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1661093003423},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1661093003423},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1661093003423},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1661093003423},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1661093003423},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1661093003423},{"_id":"public/css/main.css","hash":"8426410004fa72340fe24f8e092f3a703943d9c1","modified":1661093003423},{"_id":"public/2022/07/20/2022-07-20_C++_memory_order/memory_reorder_case1.jpg","hash":"bf871c5647688d27ad5ea6cd7fb544e3907737a3","modified":1661093003423},{"_id":"public/2022/07/20/2022-07-20_C++_memory_order/CPU_memory_struct.jpg","hash":"7b372e2cd1877fb085665973696aab986a0b5327","modified":1661093003423},{"_id":"public/images/timg.gif","hash":"1ff7e8df9671f590629a9c2228fa1e4b3bba8af3","modified":1661093003423},{"_id":"public/2022/07/20/2022-07-20_C++_memory_order/mutex_memory_case.jpg","hash":"0891ef49bf6ae1fcb2b43eabbbeecc029afdf96d","modified":1661093003423},{"_id":"public/2022/07/20/2022-07-20_C++_memory_order/shared_ptr_delete2.jpg","hash":"b058f9117f1ef0401e730a7652a405f9773e3605","modified":1661093003423},{"_id":"public/2022/07/20/2022-07-20_C++_memory_order/shared_ptr_delete.jpg","hash":"c54f0452c4663fa11528efeda4fd8dc07b6f2022","modified":1661093003423}],"Category":[{"name":"Swift","_id":"cl73fvwnx0004p9c9ft9agv21"},{"name":"算法","_id":"cl73fvwo00009p9c9botc3v98"},{"name":"动态库","_id":"cl73fvwo4000lp9c969j92pzs"},{"name":"sqlite3","_id":"cl73fvwo6000rp9c96bvs15c7"},{"name":"object-c","_id":"cl73fvwo7000yp9c984hpc9qm"},{"name":"GoMobile","_id":"cl73fvwo90015p9c9bvfd9bq4"},{"name":"语法糖","_id":"cl73fvwoc001kp9c9h6nu61rn"},{"name":"汇编","_id":"cl73fvwoe001wp9c9gvkmajyh"},{"name":"C++","_id":"cl73fvwog0023p9c960krhgk4"}],"Data":[],"Page":[{"title":"categories","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: \"categories\"\ntype: categories\nlayout: \"categories\"\n---\n","date":"2022-05-21T10:07:06.072Z","updated":"2022-05-21T10:07:06.072Z","path":"categories/index.html","comments":1,"_id":"cl73fvwns0000p9c9gdf0bmcv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: \"tags\"\ntype: tags\nlayout: \"tags\"\n---\n","date":"2022-05-21T10:06:27.933Z","updated":"2022-05-21T10:06:27.933Z","path":"tags/index.html","comments":1,"_id":"cl73fvwnw0002p9c99sqt8wzq","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Swift - SIL","date":"2022-06-15T16:00:00.000Z","_content":"\n\n## Swift 编译流程\n\n## SIL概要\n\n在Swift源码的官方文档中是这么写的\n> Swift Intermediate Language (SIL). SIL is an SSA-form IR with high-level semantic information designed to implement\nthe Swift programming language.\n\n简单的来说(翻译)：SIL是一种携带高级语法信息的SSA格式的IR，会参与Swift语言的实现。\n\nIR(Intermediate Representation)可以理解，是llvm三段式编译的中间产物，那SSA是什么？\n\n### SSA 概要\n\nSSA(Static single assignment) - 静态单赋值形式。在编译器设计中，SSA是一种IR的设计特性，**每个变量只会被赋值一次**。\n\nSSA的作用是用来这种简化变量的方式，来简化改进编译器优化的结果。举个例子：\n\n```\n y := 1\n y := 2\n x := y\n```\n\n从优化的角度来说，第一行代码是不必要的，为了让编译器更简单地识别出这种场景，在SSA下，这个IR就会变成下面这种形式。\n\n```\n y1 := 1\n y2 := 2\n x1 := y2\n```\n\n编译器可以通过一些可达性的分析，来测定和优化。除了可以做上面这种，消除无用代码的改进，借助SSA还可以做到很多其他的改进，详细的可以看[维基百科](https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F)\n\nφ函数","source":"_drafts/2022-06-16_swift-SIL.md","raw":"---\ntitle: Swift - SIL\ndate: 2022-06-16\ntags: [Swift]\ncategories: Swift\n---\n\n\n## Swift 编译流程\n\n## SIL概要\n\n在Swift源码的官方文档中是这么写的\n> Swift Intermediate Language (SIL). SIL is an SSA-form IR with high-level semantic information designed to implement\nthe Swift programming language.\n\n简单的来说(翻译)：SIL是一种携带高级语法信息的SSA格式的IR，会参与Swift语言的实现。\n\nIR(Intermediate Representation)可以理解，是llvm三段式编译的中间产物，那SSA是什么？\n\n### SSA 概要\n\nSSA(Static single assignment) - 静态单赋值形式。在编译器设计中，SSA是一种IR的设计特性，**每个变量只会被赋值一次**。\n\nSSA的作用是用来这种简化变量的方式，来简化改进编译器优化的结果。举个例子：\n\n```\n y := 1\n y := 2\n x := y\n```\n\n从优化的角度来说，第一行代码是不必要的，为了让编译器更简单地识别出这种场景，在SSA下，这个IR就会变成下面这种形式。\n\n```\n y1 := 1\n y2 := 2\n x1 := y2\n```\n\n编译器可以通过一些可达性的分析，来测定和优化。除了可以做上面这种，消除无用代码的改进，借助SSA还可以做到很多其他的改进，详细的可以看[维基百科](https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F)\n\nφ函数","slug":"2022-06-16_swift-SIL","published":0,"updated":"2022-07-28T13:38:40.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwnu0001p9c91wff9lf6","content":"<h2 id=\"Swift-编译流程\"><a href=\"#Swift-编译流程\" class=\"headerlink\" title=\"Swift 编译流程\"></a>Swift 编译流程</h2><h2 id=\"SIL概要\"><a href=\"#SIL概要\" class=\"headerlink\" title=\"SIL概要\"></a>SIL概要</h2><p>在Swift源码的官方文档中是这么写的</p>\n<blockquote>\n<p>Swift Intermediate Language (SIL). SIL is an SSA-form IR with high-level semantic information designed to implement<br>the Swift programming language.</p>\n</blockquote>\n<p>简单的来说(翻译)：SIL是一种携带高级语法信息的SSA格式的IR，会参与Swift语言的实现。</p>\n<p>IR(Intermediate Representation)可以理解，是llvm三段式编译的中间产物，那SSA是什么？</p>\n<h3 id=\"SSA-概要\"><a href=\"#SSA-概要\" class=\"headerlink\" title=\"SSA 概要\"></a>SSA 概要</h3><p>SSA(Static single assignment) - 静态单赋值形式。在编译器设计中，SSA是一种IR的设计特性，<strong>每个变量只会被赋值一次</strong>。</p>\n<p>SSA的作用是用来这种简化变量的方式，来简化改进编译器优化的结果。举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y := 1</span><br><span class=\"line\">y := 2</span><br><span class=\"line\">x := y</span><br></pre></td></tr></table></figure>\n\n<p>从优化的角度来说，第一行代码是不必要的，为了让编译器更简单地识别出这种场景，在SSA下，这个IR就会变成下面这种形式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y1 := 1</span><br><span class=\"line\">y2 := 2</span><br><span class=\"line\">x1 := y2</span><br></pre></td></tr></table></figure>\n\n<p>编译器可以通过一些可达性的分析，来测定和优化。除了可以做上面这种，消除无用代码的改进，借助SSA还可以做到很多其他的改进，详细的可以看<a href=\"https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F\">维基百科</a></p>\n<p>φ函数</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Swift-编译流程\"><a href=\"#Swift-编译流程\" class=\"headerlink\" title=\"Swift 编译流程\"></a>Swift 编译流程</h2><h2 id=\"SIL概要\"><a href=\"#SIL概要\" class=\"headerlink\" title=\"SIL概要\"></a>SIL概要</h2><p>在Swift源码的官方文档中是这么写的</p>\n<blockquote>\n<p>Swift Intermediate Language (SIL). SIL is an SSA-form IR with high-level semantic information designed to implement<br>the Swift programming language.</p>\n</blockquote>\n<p>简单的来说(翻译)：SIL是一种携带高级语法信息的SSA格式的IR，会参与Swift语言的实现。</p>\n<p>IR(Intermediate Representation)可以理解，是llvm三段式编译的中间产物，那SSA是什么？</p>\n<h3 id=\"SSA-概要\"><a href=\"#SSA-概要\" class=\"headerlink\" title=\"SSA 概要\"></a>SSA 概要</h3><p>SSA(Static single assignment) - 静态单赋值形式。在编译器设计中，SSA是一种IR的设计特性，<strong>每个变量只会被赋值一次</strong>。</p>\n<p>SSA的作用是用来这种简化变量的方式，来简化改进编译器优化的结果。举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y := 1</span><br><span class=\"line\">y := 2</span><br><span class=\"line\">x := y</span><br></pre></td></tr></table></figure>\n\n<p>从优化的角度来说，第一行代码是不必要的，为了让编译器更简单地识别出这种场景，在SSA下，这个IR就会变成下面这种形式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y1 := 1</span><br><span class=\"line\">y2 := 2</span><br><span class=\"line\">x1 := y2</span><br></pre></td></tr></table></figure>\n\n<p>编译器可以通过一些可达性的分析，来测定和优化。除了可以做上面这种，消除无用代码的改进，借助SSA还可以做到很多其他的改进，详细的可以看<a href=\"https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F\">维基百科</a></p>\n<p>φ函数</p>\n"},{"_content":"\n\n\nTrampolines are small pieces of code that, when called, perform some intermediary operations and then jump to the actual target destination. When you call imp_implementationWithBlock(), a function pointer to a trampoline is returned; it's this trampoline's responsibility to modify the function arguments and then jump to the actual code corresponding to the block's implementation.\n\n","source":"_drafts/2022-07-05_Objective-C-Trampoline.md","raw":"\n\n\nTrampolines are small pieces of code that, when called, perform some intermediary operations and then jump to the actual target destination. When you call imp_implementationWithBlock(), a function pointer to a trampoline is returned; it's this trampoline's responsibility to modify the function arguments and then jump to the actual code corresponding to the block's implementation.\n\n","slug":"2022-07-05_Objective-C-Trampoline","published":0,"date":"2022-07-28T13:38:40.205Z","updated":"2022-07-28T13:38:40.205Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwnw0003p9c96skl7dh8","content":"<p>Trampolines are small pieces of code that, when called, perform some intermediary operations and then jump to the actual target destination. When you call imp_implementationWithBlock(), a function pointer to a trampoline is returned; it’s this trampoline’s responsibility to modify the function arguments and then jump to the actual code corresponding to the block’s implementation.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Trampolines are small pieces of code that, when called, perform some intermediary operations and then jump to the actual target destination. When you call imp_implementationWithBlock(), a function pointer to a trampoline is returned; it’s this trampoline’s responsibility to modify the function arguments and then jump to the actual code corresponding to the block’s implementation.</p>\n"},{"title":"Segment-Tree","date":"2022-07-06T16:00:00.000Z","_content":"\n算法数据结构之 - 线段树\n\n<!-- more -->\n\n## 线段树\n\n线段树本质上是一个**满二叉数**形式的数据结构，用来组织离散型的区间数据，\n\n### 线段树的构建\n\n下面，以求任意区间的和为例，构建一棵线段树\n\n#### 构建\n```java\n/*\n* @param datas      表示需要构建线段树的原始数据\n* @param nodes      表示截止目前递归为止的已经构建好的线段树\n* @param start      表示需要构建线段树的原始数据的起点(包含)\n* @param end        表示需要构建线段树的原始数据的终点(包含)\n* @param node_idx   表示在当次递归中，需要构建的线段树在tree内的节点索引号。\n*/\npublic void buildTree(int[] datas, int[] tree, int start, int end, int node_idx) {\n\n    if (start == end) {\n        tree[node_idx] = datas[start]; // 递归结束条件\n        return;\n    }\n\n    int mid             =  start + (end - start) / 2; // mid 为原始数据在[start, end]范围内的需要做分割的点位\n    int left_node_idx    = node_idx * 2 + 1;\n    int right_node_idx   = node_idx * 2 + 2;\n\n    buildTree(datas, nodes, start, mid, left_node_idx);\n    buildTree(datas, nodes, mid + 1, end, right_node_idx);\n\n    nodes[node_idx] = nodes[left_node_idx] + nodes[right_node_idx]; // fun(nodes[left_nodeIdx], nodes[right_nodeIdx]);\n}\n```\n\n#### 查询\n查询某个范围内的和\n\n```java\n/*\n*/\npublic int queryTree(int[] tree, int start, int end, int node_idx, int L, int R, int val) {\n\n    if (L <= start && R >= end) {\n        return tree[node_idx];\n    } else if (L > end && R < start) {\n        return 0;\n    }\n\n    int mid = start + (end - start) / 2;;\n    int left_node_idx = node_idx * 2 + 1;\n    int right_node_idx = node_idx * 2 + 2;\n\n    int left_sum = queryTree(tree, start, mid, left_node_idx, L, R, val);\n    int right_sum = queryTree(tree, mid + 1, end, right_node_idx, L, R, val);\n\n    return left_sum + right_sum;\n}\n```\n\n#### 更新\n更新某个叶子节点上的值\n\n```java\npublic void updateTree(int[] tree, int start, int end, int node_idx, int idx, int new_val) {\n    \n    if (start == end && start == idx) { // 如果要求更新的idx没有出错的话，叶子节点一定就是需要更新的这个节点\n        tree[node_idx] = new_val; \n        return;\n    }\n\n    int mid = start + (end - start) / 2;\n    int left_node_idx = node_idx * 2 + 1;\n    int right_node_idx = node_idx * 2 + 2;\n    \n    if (idx <= mid) {\n        updateTree(tree, start, mid, left_node_idx, idx, new_val);\n    } else {\n        updateTree(tree, mid + 1, end, right_node_idx, idx, new_val);\n    }\n    \n    tree[node_idx] = tree[left_node_idx] + tree[right_node_idx];\n}\n```\n\n#### 懒标记\n\n```java\n\n```\n## 实例","source":"_drafts/2022-07-07_Segment-Tree.md","raw":"---\ntitle: Segment-Tree\ndate: 2022-07-07\ntags: [Segment-Tree]\ncategories: [算法]\n---\n\n算法数据结构之 - 线段树\n\n<!-- more -->\n\n## 线段树\n\n线段树本质上是一个**满二叉数**形式的数据结构，用来组织离散型的区间数据，\n\n### 线段树的构建\n\n下面，以求任意区间的和为例，构建一棵线段树\n\n#### 构建\n```java\n/*\n* @param datas      表示需要构建线段树的原始数据\n* @param nodes      表示截止目前递归为止的已经构建好的线段树\n* @param start      表示需要构建线段树的原始数据的起点(包含)\n* @param end        表示需要构建线段树的原始数据的终点(包含)\n* @param node_idx   表示在当次递归中，需要构建的线段树在tree内的节点索引号。\n*/\npublic void buildTree(int[] datas, int[] tree, int start, int end, int node_idx) {\n\n    if (start == end) {\n        tree[node_idx] = datas[start]; // 递归结束条件\n        return;\n    }\n\n    int mid             =  start + (end - start) / 2; // mid 为原始数据在[start, end]范围内的需要做分割的点位\n    int left_node_idx    = node_idx * 2 + 1;\n    int right_node_idx   = node_idx * 2 + 2;\n\n    buildTree(datas, nodes, start, mid, left_node_idx);\n    buildTree(datas, nodes, mid + 1, end, right_node_idx);\n\n    nodes[node_idx] = nodes[left_node_idx] + nodes[right_node_idx]; // fun(nodes[left_nodeIdx], nodes[right_nodeIdx]);\n}\n```\n\n#### 查询\n查询某个范围内的和\n\n```java\n/*\n*/\npublic int queryTree(int[] tree, int start, int end, int node_idx, int L, int R, int val) {\n\n    if (L <= start && R >= end) {\n        return tree[node_idx];\n    } else if (L > end && R < start) {\n        return 0;\n    }\n\n    int mid = start + (end - start) / 2;;\n    int left_node_idx = node_idx * 2 + 1;\n    int right_node_idx = node_idx * 2 + 2;\n\n    int left_sum = queryTree(tree, start, mid, left_node_idx, L, R, val);\n    int right_sum = queryTree(tree, mid + 1, end, right_node_idx, L, R, val);\n\n    return left_sum + right_sum;\n}\n```\n\n#### 更新\n更新某个叶子节点上的值\n\n```java\npublic void updateTree(int[] tree, int start, int end, int node_idx, int idx, int new_val) {\n    \n    if (start == end && start == idx) { // 如果要求更新的idx没有出错的话，叶子节点一定就是需要更新的这个节点\n        tree[node_idx] = new_val; \n        return;\n    }\n\n    int mid = start + (end - start) / 2;\n    int left_node_idx = node_idx * 2 + 1;\n    int right_node_idx = node_idx * 2 + 2;\n    \n    if (idx <= mid) {\n        updateTree(tree, start, mid, left_node_idx, idx, new_val);\n    } else {\n        updateTree(tree, mid + 1, end, right_node_idx, idx, new_val);\n    }\n    \n    tree[node_idx] = tree[left_node_idx] + tree[right_node_idx];\n}\n```\n\n#### 懒标记\n\n```java\n\n```\n## 实例","slug":"2022-07-07_Segment-Tree","published":0,"updated":"2022-07-28T13:38:40.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwny0006p9c943knbpsu","content":"<p>算法数据结构之 - 线段树</p>\n<span id=\"more\"></span>\n\n<h2 id=\"线段树\"><a href=\"#线段树\" class=\"headerlink\" title=\"线段树\"></a>线段树</h2><p>线段树本质上是一个<strong>满二叉数</strong>形式的数据结构，用来组织离散型的区间数据，</p>\n<h3 id=\"线段树的构建\"><a href=\"#线段树的构建\" class=\"headerlink\" title=\"线段树的构建\"></a>线段树的构建</h3><p>下面，以求任意区间的和为例，构建一棵线段树</p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* @param datas      表示需要构建线段树的原始数据</span></span><br><span class=\"line\"><span class=\"comment\">* @param nodes      表示截止目前递归为止的已经构建好的线段树</span></span><br><span class=\"line\"><span class=\"comment\">* @param start      表示需要构建线段树的原始数据的起点(包含)</span></span><br><span class=\"line\"><span class=\"comment\">* @param end        表示需要构建线段树的原始数据的终点(包含)</span></span><br><span class=\"line\"><span class=\"comment\">* @param node_idx   表示在当次递归中，需要构建的线段树在tree内的节点索引号。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildTree</span><span class=\"params\">(<span class=\"type\">int</span>[] datas, <span class=\"type\">int</span>[] tree, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> node_idx)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start == end) &#123;</span><br><span class=\"line\">        tree[node_idx] = datas[start]; <span class=\"comment\">// 递归结束条件</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span>             <span class=\"operator\">=</span>  start + (end - start) / <span class=\"number\">2</span>; <span class=\"comment\">// mid 为原始数据在[start, end]范围内的需要做分割的点位</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left_node_idx</span>    <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">right_node_idx</span>   <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    buildTree(datas, nodes, start, mid, left_node_idx);</span><br><span class=\"line\">    buildTree(datas, nodes, mid + <span class=\"number\">1</span>, end, right_node_idx);</span><br><span class=\"line\"></span><br><span class=\"line\">    nodes[node_idx] = nodes[left_node_idx] + nodes[right_node_idx]; <span class=\"comment\">// fun(nodes[left_nodeIdx], nodes[right_nodeIdx]);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><p>查询某个范围内的和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">queryTree</span><span class=\"params\">(<span class=\"type\">int</span>[] tree, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> node_idx, <span class=\"type\">int</span> L, <span class=\"type\">int</span> R, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L &lt;= start &amp;&amp; R &gt;= end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[node_idx];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (L &gt; end &amp;&amp; R &lt; start) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> start + (end - start) / <span class=\"number\">2</span>;;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left_node_idx</span> <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">right_node_idx</span> <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left_sum</span> <span class=\"operator\">=</span> queryTree(tree, start, mid, left_node_idx, L, R, val);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">right_sum</span> <span class=\"operator\">=</span> queryTree(tree, mid + <span class=\"number\">1</span>, end, right_node_idx, L, R, val);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> left_sum + right_sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><p>更新某个叶子节点上的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateTree</span><span class=\"params\">(<span class=\"type\">int</span>[] tree, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> node_idx, <span class=\"type\">int</span> idx, <span class=\"type\">int</span> new_val)</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start == end &amp;&amp; start == idx) &#123; <span class=\"comment\">// 如果要求更新的idx没有出错的话，叶子节点一定就是需要更新的这个节点</span></span><br><span class=\"line\">        tree[node_idx] = new_val; </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> start + (end - start) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left_node_idx</span> <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">right_node_idx</span> <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt;= mid) &#123;</span><br><span class=\"line\">        updateTree(tree, start, mid, left_node_idx, idx, new_val);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        updateTree(tree, mid + <span class=\"number\">1</span>, end, right_node_idx, idx, new_val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    tree[node_idx] = tree[left_node_idx] + tree[right_node_idx];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"懒标记\"><a href=\"#懒标记\" class=\"headerlink\" title=\"懒标记\"></a>懒标记</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2>","site":{"data":{}},"excerpt":"<p>算法数据结构之 - 线段树</p>","more":"<h2 id=\"线段树\"><a href=\"#线段树\" class=\"headerlink\" title=\"线段树\"></a>线段树</h2><p>线段树本质上是一个<strong>满二叉数</strong>形式的数据结构，用来组织离散型的区间数据，</p>\n<h3 id=\"线段树的构建\"><a href=\"#线段树的构建\" class=\"headerlink\" title=\"线段树的构建\"></a>线段树的构建</h3><p>下面，以求任意区间的和为例，构建一棵线段树</p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* @param datas      表示需要构建线段树的原始数据</span></span><br><span class=\"line\"><span class=\"comment\">* @param nodes      表示截止目前递归为止的已经构建好的线段树</span></span><br><span class=\"line\"><span class=\"comment\">* @param start      表示需要构建线段树的原始数据的起点(包含)</span></span><br><span class=\"line\"><span class=\"comment\">* @param end        表示需要构建线段树的原始数据的终点(包含)</span></span><br><span class=\"line\"><span class=\"comment\">* @param node_idx   表示在当次递归中，需要构建的线段树在tree内的节点索引号。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildTree</span><span class=\"params\">(<span class=\"type\">int</span>[] datas, <span class=\"type\">int</span>[] tree, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> node_idx)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start == end) &#123;</span><br><span class=\"line\">        tree[node_idx] = datas[start]; <span class=\"comment\">// 递归结束条件</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span>             <span class=\"operator\">=</span>  start + (end - start) / <span class=\"number\">2</span>; <span class=\"comment\">// mid 为原始数据在[start, end]范围内的需要做分割的点位</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left_node_idx</span>    <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">right_node_idx</span>   <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    buildTree(datas, nodes, start, mid, left_node_idx);</span><br><span class=\"line\">    buildTree(datas, nodes, mid + <span class=\"number\">1</span>, end, right_node_idx);</span><br><span class=\"line\"></span><br><span class=\"line\">    nodes[node_idx] = nodes[left_node_idx] + nodes[right_node_idx]; <span class=\"comment\">// fun(nodes[left_nodeIdx], nodes[right_nodeIdx]);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><p>查询某个范围内的和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">queryTree</span><span class=\"params\">(<span class=\"type\">int</span>[] tree, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> node_idx, <span class=\"type\">int</span> L, <span class=\"type\">int</span> R, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L &lt;= start &amp;&amp; R &gt;= end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[node_idx];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (L &gt; end &amp;&amp; R &lt; start) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> start + (end - start) / <span class=\"number\">2</span>;;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left_node_idx</span> <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">right_node_idx</span> <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left_sum</span> <span class=\"operator\">=</span> queryTree(tree, start, mid, left_node_idx, L, R, val);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">right_sum</span> <span class=\"operator\">=</span> queryTree(tree, mid + <span class=\"number\">1</span>, end, right_node_idx, L, R, val);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> left_sum + right_sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><p>更新某个叶子节点上的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateTree</span><span class=\"params\">(<span class=\"type\">int</span>[] tree, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> node_idx, <span class=\"type\">int</span> idx, <span class=\"type\">int</span> new_val)</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start == end &amp;&amp; start == idx) &#123; <span class=\"comment\">// 如果要求更新的idx没有出错的话，叶子节点一定就是需要更新的这个节点</span></span><br><span class=\"line\">        tree[node_idx] = new_val; </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> start + (end - start) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left_node_idx</span> <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">right_node_idx</span> <span class=\"operator\">=</span> node_idx * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt;= mid) &#123;</span><br><span class=\"line\">        updateTree(tree, start, mid, left_node_idx, idx, new_val);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        updateTree(tree, mid + <span class=\"number\">1</span>, end, right_node_idx, idx, new_val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    tree[node_idx] = tree[left_node_idx] + tree[right_node_idx];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"懒标记\"><a href=\"#懒标记\" class=\"headerlink\" title=\"懒标记\"></a>懒标记</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2>"},{"title":"缺失的第一个正整数 -- LeetCode[41]","date":"2019-12-09T16:00:00.000Z","type":"tags","_content":"\n> 给定一个未排序的整数数组，找出其中没有出现的最小的正整数，要求O(n)时间，常数空间。\n\n<!-- more -->\n\n一道 hard 题，感觉这种题，能想到的话最多到Medium，想不到可能就是Hard了...\n\n在思考的时候一直在纠结于，如何转换题中的条件 \"没有出现的最小正整数\"。\n\n条件中只有一个约束就是 “最小正整数”。\n\n不考虑时间和空间要求\n\n开辟一个与给出的数组等量的数组空间，排序一下，然后放入这个新的数组。然后从1开始遍历这个数组，出现不连续整数的时候即是需要的结果了。\n\n------------\n\n\n**优化：**\n其实我们只是需要前面连续的数组，后面不连续的部分其实不需要。那么排序其实是不必须的，空间是不是可以使用数组原有的空间呢。\n\n因为整数数组要求从1开始，而数组的索引也是要求从0开始。\n那么第一次遍历数组的时候，可以直接把对应的值放入对应的索引下。\n再次遍历数组的时候，一旦出现索引和值不一致了，那么就说明，这就是没有出现的最小正整数。\n\n**注：**\n1. 考虑索引和值的偏差（索引从0开始，值从1开始）\n2. 复用原数组的时候，从前往后遍历，大于的数组容量的值都可以被忽略\n3. 复用原数组，对数据的操作是swap而不是赋值\n4. 如果被交换的索引上的值已经是与索引对应了，则放弃交换,否则会引起死循环（exp:[1,1]）\n\n**细节是魔鬼，看代码**\n```go\nfunc firstMissingPositive(nums []int) int {\n\tfor index := 0; index < len(nums); index++ {\n\t\tval := nums[index]\n\t\tif val > 0 && val <= len(nums) {\n\t\t\tif val != index+1 && nums[val-1] != val {\n\t\t\t\tnums[val-1], nums[index] = val, nums[val-1]\n\t\t\t\tindex--\n\t\t\t}\n\t\t}\n\t}\n\n\tfor index := 0; index < len(nums); index++ {\n\t\tval := nums[index]\n\t\tif val != index+1 {\n\t\t\treturn index + 1\n\t\t}\n\t}\n\n\treturn len(nums) + 1\n}\n```","source":"_posts/1.leetcode41.md","raw":"---\ntitle: 缺失的第一个正整数 -- LeetCode[41]\ndate: 2019-12-10\ntype: tags\ntags: [leetcode,数组]\ncategories: 算法\n---\n\n> 给定一个未排序的整数数组，找出其中没有出现的最小的正整数，要求O(n)时间，常数空间。\n\n<!-- more -->\n\n一道 hard 题，感觉这种题，能想到的话最多到Medium，想不到可能就是Hard了...\n\n在思考的时候一直在纠结于，如何转换题中的条件 \"没有出现的最小正整数\"。\n\n条件中只有一个约束就是 “最小正整数”。\n\n不考虑时间和空间要求\n\n开辟一个与给出的数组等量的数组空间，排序一下，然后放入这个新的数组。然后从1开始遍历这个数组，出现不连续整数的时候即是需要的结果了。\n\n------------\n\n\n**优化：**\n其实我们只是需要前面连续的数组，后面不连续的部分其实不需要。那么排序其实是不必须的，空间是不是可以使用数组原有的空间呢。\n\n因为整数数组要求从1开始，而数组的索引也是要求从0开始。\n那么第一次遍历数组的时候，可以直接把对应的值放入对应的索引下。\n再次遍历数组的时候，一旦出现索引和值不一致了，那么就说明，这就是没有出现的最小正整数。\n\n**注：**\n1. 考虑索引和值的偏差（索引从0开始，值从1开始）\n2. 复用原数组的时候，从前往后遍历，大于的数组容量的值都可以被忽略\n3. 复用原数组，对数据的操作是swap而不是赋值\n4. 如果被交换的索引上的值已经是与索引对应了，则放弃交换,否则会引起死循环（exp:[1,1]）\n\n**细节是魔鬼，看代码**\n```go\nfunc firstMissingPositive(nums []int) int {\n\tfor index := 0; index < len(nums); index++ {\n\t\tval := nums[index]\n\t\tif val > 0 && val <= len(nums) {\n\t\t\tif val != index+1 && nums[val-1] != val {\n\t\t\t\tnums[val-1], nums[index] = val, nums[val-1]\n\t\t\t\tindex--\n\t\t\t}\n\t\t}\n\t}\n\n\tfor index := 0; index < len(nums); index++ {\n\t\tval := nums[index]\n\t\tif val != index+1 {\n\t\t\treturn index + 1\n\t\t}\n\t}\n\n\treturn len(nums) + 1\n}\n```","slug":"1.leetcode41","published":1,"updated":"2022-05-21T09:55:38.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwnz0007p9c99q026vlk","content":"<blockquote>\n<p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数，要求O(n)时间，常数空间。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>一道 hard 题，感觉这种题，能想到的话最多到Medium，想不到可能就是Hard了…</p>\n<p>在思考的时候一直在纠结于，如何转换题中的条件 “没有出现的最小正整数”。</p>\n<p>条件中只有一个约束就是 “最小正整数”。</p>\n<p>不考虑时间和空间要求</p>\n<p>开辟一个与给出的数组等量的数组空间，排序一下，然后放入这个新的数组。然后从1开始遍历这个数组，出现不连续整数的时候即是需要的结果了。</p>\n<hr>\n<p><strong>优化：</strong><br>其实我们只是需要前面连续的数组，后面不连续的部分其实不需要。那么排序其实是不必须的，空间是不是可以使用数组原有的空间呢。</p>\n<p>因为整数数组要求从1开始，而数组的索引也是要求从0开始。<br>那么第一次遍历数组的时候，可以直接把对应的值放入对应的索引下。<br>再次遍历数组的时候，一旦出现索引和值不一致了，那么就说明，这就是没有出现的最小正整数。</p>\n<p><strong>注：</strong></p>\n<ol>\n<li>考虑索引和值的偏差（索引从0开始，值从1开始）</li>\n<li>复用原数组的时候，从前往后遍历，大于的数组容量的值都可以被忽略</li>\n<li>复用原数组，对数据的操作是swap而不是赋值</li>\n<li>如果被交换的索引上的值已经是与索引对应了，则放弃交换,否则会引起死循环（exp:[1,1]）</li>\n</ol>\n<p><strong>细节是魔鬼，看代码</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> index := <span class=\"number\">0</span>; index &lt; <span class=\"built_in\">len</span>(nums); index++ &#123;</span><br><span class=\"line\">\t\tval := nums[index]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> val &gt; <span class=\"number\">0</span> &amp;&amp; val &lt;= <span class=\"built_in\">len</span>(nums) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> val != index+<span class=\"number\">1</span> &amp;&amp; nums[val<span class=\"number\">-1</span>] != val &#123;</span><br><span class=\"line\">\t\t\t\tnums[val<span class=\"number\">-1</span>], nums[index] = val, nums[val<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t\t\t\tindex--</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> index := <span class=\"number\">0</span>; index &lt; <span class=\"built_in\">len</span>(nums); index++ &#123;</span><br><span class=\"line\">\t\tval := nums[index]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> val != index+<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> index + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(nums) + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote>\n<p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数，要求O(n)时间，常数空间。</p>\n</blockquote>","more":"<p>一道 hard 题，感觉这种题，能想到的话最多到Medium，想不到可能就是Hard了…</p>\n<p>在思考的时候一直在纠结于，如何转换题中的条件 “没有出现的最小正整数”。</p>\n<p>条件中只有一个约束就是 “最小正整数”。</p>\n<p>不考虑时间和空间要求</p>\n<p>开辟一个与给出的数组等量的数组空间，排序一下，然后放入这个新的数组。然后从1开始遍历这个数组，出现不连续整数的时候即是需要的结果了。</p>\n<hr>\n<p><strong>优化：</strong><br>其实我们只是需要前面连续的数组，后面不连续的部分其实不需要。那么排序其实是不必须的，空间是不是可以使用数组原有的空间呢。</p>\n<p>因为整数数组要求从1开始，而数组的索引也是要求从0开始。<br>那么第一次遍历数组的时候，可以直接把对应的值放入对应的索引下。<br>再次遍历数组的时候，一旦出现索引和值不一致了，那么就说明，这就是没有出现的最小正整数。</p>\n<p><strong>注：</strong></p>\n<ol>\n<li>考虑索引和值的偏差（索引从0开始，值从1开始）</li>\n<li>复用原数组的时候，从前往后遍历，大于的数组容量的值都可以被忽略</li>\n<li>复用原数组，对数据的操作是swap而不是赋值</li>\n<li>如果被交换的索引上的值已经是与索引对应了，则放弃交换,否则会引起死循环（exp:[1,1]）</li>\n</ol>\n<p><strong>细节是魔鬼，看代码</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> index := <span class=\"number\">0</span>; index &lt; <span class=\"built_in\">len</span>(nums); index++ &#123;</span><br><span class=\"line\">\t\tval := nums[index]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> val &gt; <span class=\"number\">0</span> &amp;&amp; val &lt;= <span class=\"built_in\">len</span>(nums) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> val != index+<span class=\"number\">1</span> &amp;&amp; nums[val<span class=\"number\">-1</span>] != val &#123;</span><br><span class=\"line\">\t\t\t\tnums[val<span class=\"number\">-1</span>], nums[index] = val, nums[val<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t\t\t\tindex--</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> index := <span class=\"number\">0</span>; index &lt; <span class=\"built_in\">len</span>(nums); index++ &#123;</span><br><span class=\"line\">\t\tval := nums[index]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> val != index+<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> index + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(nums) + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"_content":"top 值用来做文章首页排序，值越大，排序越靠前\n\n约定:\n\nC++相关 500 - 600 \n当前最大值：\n\nOC-Swift相关 400 - 500\nautorelase-opt: 400\nsynchronized: 400\noc-block: 400\n\nSQLite相关 300\n\n操作系统/基础 200 - 300\nbind-symbol: 200\ndyld : 200\n\n其他\ngomobilebind - 51\nrunloop-binary-search -- 50\n\n","source":"_drafts/top值规则.md","raw":"top 值用来做文章首页排序，值越大，排序越靠前\n\n约定:\n\nC++相关 500 - 600 \n当前最大值：\n\nOC-Swift相关 400 - 500\nautorelase-opt: 400\nsynchronized: 400\noc-block: 400\n\nSQLite相关 300\n\n操作系统/基础 200 - 300\nbind-symbol: 200\ndyld : 200\n\n其他\ngomobilebind - 51\nrunloop-binary-search -- 50\n\n","slug":"top值规则","published":0,"date":"2022-07-28T13:38:40.206Z","updated":"2022-07-28T13:38:40.206Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwnz0008p9c91eus59p7","content":"<p>top 值用来做文章首页排序，值越大，排序越靠前</p>\n<p>约定:</p>\n<p>C++相关 500 - 600<br>当前最大值：</p>\n<p>OC-Swift相关 400 - 500<br>autorelase-opt: 400<br>synchronized: 400<br>oc-block: 400</p>\n<p>SQLite相关 300</p>\n<p>操作系统&#x2F;基础 200 - 300<br>bind-symbol: 200<br>dyld : 200</p>\n<p>其他<br>gomobilebind - 51<br>runloop-binary-search – 50</p>\n","site":{"data":{}},"excerpt":"","more":"<p>top 值用来做文章首页排序，值越大，排序越靠前</p>\n<p>约定:</p>\n<p>C++相关 500 - 600<br>当前最大值：</p>\n<p>OC-Swift相关 400 - 500<br>autorelase-opt: 400<br>synchronized: 400<br>oc-block: 400</p>\n<p>SQLite相关 300</p>\n<p>操作系统&#x2F;基础 200 - 300<br>bind-symbol: 200<br>dyld : 200</p>\n<p>其他<br>gomobilebind - 51<br>runloop-binary-search – 50</p>\n"},{"title":"RunLoop中\"奇怪\"的二分查找","date":"2020-03-03T16:00:00.000Z","top":100,"_content":"\n> 在RunLoop的Timer管理中，需要对每定时器进行有序管理------按照时间先后排序。这个必然会带来一个查找和排序。在RunLoop 中使用的是二分查找法，但是这个二分查找与平时的二分查找不太一样。\n\n<!-- more -->\n\n### 先上代码\n````objective-c\n//利用二分法按照fireTSR的大小插入排序\nstatic CFIndex __CFRunLoopInsertionIndexInTimerArray(CFArrayRef array, CFRunLoopTimerRef rlt) __attribute__((noinline));\nstatic CFIndex __CFRunLoopInsertionIndexInTimerArray(CFArrayRef array, CFRunLoopTimerRef rlt) {\n    CFIndex cnt = CFArrayGetCount(array);\n    if (cnt <= 0) {\n        return 0;\n    }\n    if (256 < cnt) {//count 小于256个时候优先判断 第一个和最后一个\n        CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, cnt - 1);\n        if (item->_fireTSR <= rlt->_fireTSR) {\n            return cnt;\n        }\n        item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, 0);\n        if (rlt->_fireTSR < item->_fireTSR) {\n            return 0;\n        }\n    }\n\n\t//开始二分查找\n    CFIndex add = (1 << flsl(cnt)) * 2;\n    CFIndex idx = 0;\n    Boolean lastTestLEQ;\n    do {\n        add = add / 2;\n\t    lastTestLEQ = false;\n        CFIndex testIdx = idx + add;\n        if (testIdx < cnt) {\n            CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, testIdx);\n            if (item->_fireTSR <= rlt->_fireTSR) {\n                idx = testIdx;\n\t\t        lastTestLEQ = true;\n            }\n        }\n    } while (0 < add);\n\n    return lastTestLEQ ? idx + 1 : idx;\n}\n````\n\n这里不详细讲述普通二分查找算法了，直接看这个算法。\n\n二分查找的时间复杂度是在O(log N)，也就是说，在log N次查询之内必然是可以有搜索结果的。\n\n> 下图就是两次搜索的演示过程\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/639b55053de9d6dc5d2307c9d3787fb1.png)\n\n传统的二分查找，是二分区间，每次从一个区间中去选择前半区或者后半区。而这里的二分分的是 `add` 的长度。代码中的`idx`是 `区间查找法` 中的区间 start，因为每次二分的 `idx` 是否需要指向 `testIdx`，这个判断就是 `区间查找法`中的前后半区选择，其中 `end = idx + start` 所以说，add 隐藏了区间的 end。\n\n\n代码很简短，输入一个数组，一个定时器，返回这个定时器应该在这个数组中插入的Index。\n\n1. 先判断如果当前数组内的数量少于256个，优先判断最后一个和第一个。这个问题我想，是否是因为在大部分情况下，定时器都不会超过256个，并且，定时器一般..大部分情况下都是往后增加。所以算法在最开始的时候，通过一个if判断快速处理了，大部分的使用情况。避免了每次都要进行O(log n)时间的搜索。\n\n2. 按照上面的演示过程，执行二分查找。但是在二分查找之前还有一段代码:`CFIndex add = (1 << flsl(cnt)) * 2;` 为什么add的起始点不是`cnt`？`flsl()`函数是获得`cnt`用二进制表示时最大有效位数。例如，(flsl(256) 的结果是 9)。如果cnt是256，add的值将会变成1024。1左移9位是512，512再乘2，1024。`向上取整`：保证add是2的n次幂，这样就不用考虑奇偶问题了。\n\nps：上面那个例子，为什么需要左移9位再乘2？直接左移8位不行？","source":"_posts/10.runloop-binary-search.md","raw":"---\ntitle: RunLoop中\"奇怪\"的二分查找\ndate: 2020-03-04\ntags: [object-c,二分法]\ntop: 100\ncategories: 算法\n---\n\n> 在RunLoop的Timer管理中，需要对每定时器进行有序管理------按照时间先后排序。这个必然会带来一个查找和排序。在RunLoop 中使用的是二分查找法，但是这个二分查找与平时的二分查找不太一样。\n\n<!-- more -->\n\n### 先上代码\n````objective-c\n//利用二分法按照fireTSR的大小插入排序\nstatic CFIndex __CFRunLoopInsertionIndexInTimerArray(CFArrayRef array, CFRunLoopTimerRef rlt) __attribute__((noinline));\nstatic CFIndex __CFRunLoopInsertionIndexInTimerArray(CFArrayRef array, CFRunLoopTimerRef rlt) {\n    CFIndex cnt = CFArrayGetCount(array);\n    if (cnt <= 0) {\n        return 0;\n    }\n    if (256 < cnt) {//count 小于256个时候优先判断 第一个和最后一个\n        CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, cnt - 1);\n        if (item->_fireTSR <= rlt->_fireTSR) {\n            return cnt;\n        }\n        item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, 0);\n        if (rlt->_fireTSR < item->_fireTSR) {\n            return 0;\n        }\n    }\n\n\t//开始二分查找\n    CFIndex add = (1 << flsl(cnt)) * 2;\n    CFIndex idx = 0;\n    Boolean lastTestLEQ;\n    do {\n        add = add / 2;\n\t    lastTestLEQ = false;\n        CFIndex testIdx = idx + add;\n        if (testIdx < cnt) {\n            CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, testIdx);\n            if (item->_fireTSR <= rlt->_fireTSR) {\n                idx = testIdx;\n\t\t        lastTestLEQ = true;\n            }\n        }\n    } while (0 < add);\n\n    return lastTestLEQ ? idx + 1 : idx;\n}\n````\n\n这里不详细讲述普通二分查找算法了，直接看这个算法。\n\n二分查找的时间复杂度是在O(log N)，也就是说，在log N次查询之内必然是可以有搜索结果的。\n\n> 下图就是两次搜索的演示过程\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/639b55053de9d6dc5d2307c9d3787fb1.png)\n\n传统的二分查找，是二分区间，每次从一个区间中去选择前半区或者后半区。而这里的二分分的是 `add` 的长度。代码中的`idx`是 `区间查找法` 中的区间 start，因为每次二分的 `idx` 是否需要指向 `testIdx`，这个判断就是 `区间查找法`中的前后半区选择，其中 `end = idx + start` 所以说，add 隐藏了区间的 end。\n\n\n代码很简短，输入一个数组，一个定时器，返回这个定时器应该在这个数组中插入的Index。\n\n1. 先判断如果当前数组内的数量少于256个，优先判断最后一个和第一个。这个问题我想，是否是因为在大部分情况下，定时器都不会超过256个，并且，定时器一般..大部分情况下都是往后增加。所以算法在最开始的时候，通过一个if判断快速处理了，大部分的使用情况。避免了每次都要进行O(log n)时间的搜索。\n\n2. 按照上面的演示过程，执行二分查找。但是在二分查找之前还有一段代码:`CFIndex add = (1 << flsl(cnt)) * 2;` 为什么add的起始点不是`cnt`？`flsl()`函数是获得`cnt`用二进制表示时最大有效位数。例如，(flsl(256) 的结果是 9)。如果cnt是256，add的值将会变成1024。1左移9位是512，512再乘2，1024。`向上取整`：保证add是2的n次幂，这样就不用考虑奇偶问题了。\n\nps：上面那个例子，为什么需要左移9位再乘2？直接左移8位不行？","slug":"10.runloop-binary-search","published":1,"updated":"2022-07-28T13:38:40.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwo1000cp9c9buwt4cfl","content":"<blockquote>\n<p>在RunLoop的Timer管理中，需要对每定时器进行有序管理——按照时间先后排序。这个必然会带来一个查找和排序。在RunLoop 中使用的是二分查找法，但是这个二分查找与平时的二分查找不太一样。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h3 id=\"先上代码\"><a href=\"#先上代码\" class=\"headerlink\" title=\"先上代码\"></a>先上代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//利用二分法按照fireTSR的大小插入排序</span><br><span class=\"line\">static CFIndex __CFRunLoopInsertionIndexInTimerArray(CFArrayRef array, CFRunLoopTimerRef rlt) __attribute__((noinline));</span><br><span class=\"line\">static CFIndex __CFRunLoopInsertionIndexInTimerArray(CFArrayRef array, CFRunLoopTimerRef rlt) &#123;</span><br><span class=\"line\">    CFIndex cnt = CFArrayGetCount(array);</span><br><span class=\"line\">    if (cnt &lt;= 0) &#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (256 &lt; cnt) &#123;//count 小于256个时候优先判断 第一个和最后一个</span><br><span class=\"line\">        CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, cnt - 1);</span><br><span class=\"line\">        if (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) &#123;</span><br><span class=\"line\">            return cnt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, 0);</span><br><span class=\"line\">        if (rlt-&gt;_fireTSR &lt; item-&gt;_fireTSR) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//开始二分查找</span><br><span class=\"line\">    CFIndex add = (1 &lt;&lt; flsl(cnt)) * 2;</span><br><span class=\"line\">    CFIndex idx = 0;</span><br><span class=\"line\">    Boolean lastTestLEQ;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        add = add / 2;</span><br><span class=\"line\">\t    lastTestLEQ = false;</span><br><span class=\"line\">        CFIndex testIdx = idx + add;</span><br><span class=\"line\">        if (testIdx &lt; cnt) &#123;</span><br><span class=\"line\">            CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, testIdx);</span><br><span class=\"line\">            if (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) &#123;</span><br><span class=\"line\">                idx = testIdx;</span><br><span class=\"line\">\t\t        lastTestLEQ = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; while (0 &lt; add);</span><br><span class=\"line\"></span><br><span class=\"line\">    return lastTestLEQ ? idx + 1 : idx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里不详细讲述普通二分查找算法了，直接看这个算法。</p>\n<p>二分查找的时间复杂度是在O(log N)，也就是说，在log N次查询之内必然是可以有搜索结果的。</p>\n<blockquote>\n<p>下图就是两次搜索的演示过程</p>\n</blockquote>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/639b55053de9d6dc5d2307c9d3787fb1.png\"></p>\n<p>传统的二分查找，是二分区间，每次从一个区间中去选择前半区或者后半区。而这里的二分分的是 <code>add</code> 的长度。代码中的<code>idx</code>是 <code>区间查找法</code> 中的区间 start，因为每次二分的 <code>idx</code> 是否需要指向 <code>testIdx</code>，这个判断就是 <code>区间查找法</code>中的前后半区选择，其中 <code>end = idx + start</code> 所以说，add 隐藏了区间的 end。</p>\n<p>代码很简短，输入一个数组，一个定时器，返回这个定时器应该在这个数组中插入的Index。</p>\n<ol>\n<li><p>先判断如果当前数组内的数量少于256个，优先判断最后一个和第一个。这个问题我想，是否是因为在大部分情况下，定时器都不会超过256个，并且，定时器一般..大部分情况下都是往后增加。所以算法在最开始的时候，通过一个if判断快速处理了，大部分的使用情况。避免了每次都要进行O(log n)时间的搜索。</p>\n</li>\n<li><p>按照上面的演示过程，执行二分查找。但是在二分查找之前还有一段代码:<code>CFIndex add = (1 &lt;&lt; flsl(cnt)) * 2;</code> 为什么add的起始点不是<code>cnt</code>？<code>flsl()</code>函数是获得<code>cnt</code>用二进制表示时最大有效位数。例如，(flsl(256) 的结果是 9)。如果cnt是256，add的值将会变成1024。1左移9位是512，512再乘2，1024。<code>向上取整</code>：保证add是2的n次幂，这样就不用考虑奇偶问题了。</p>\n</li>\n</ol>\n<p>ps：上面那个例子，为什么需要左移9位再乘2？直接左移8位不行？</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在RunLoop的Timer管理中，需要对每定时器进行有序管理——按照时间先后排序。这个必然会带来一个查找和排序。在RunLoop 中使用的是二分查找法，但是这个二分查找与平时的二分查找不太一样。</p>\n</blockquote>","more":"<h3 id=\"先上代码\"><a href=\"#先上代码\" class=\"headerlink\" title=\"先上代码\"></a>先上代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//利用二分法按照fireTSR的大小插入排序</span><br><span class=\"line\">static CFIndex __CFRunLoopInsertionIndexInTimerArray(CFArrayRef array, CFRunLoopTimerRef rlt) __attribute__((noinline));</span><br><span class=\"line\">static CFIndex __CFRunLoopInsertionIndexInTimerArray(CFArrayRef array, CFRunLoopTimerRef rlt) &#123;</span><br><span class=\"line\">    CFIndex cnt = CFArrayGetCount(array);</span><br><span class=\"line\">    if (cnt &lt;= 0) &#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (256 &lt; cnt) &#123;//count 小于256个时候优先判断 第一个和最后一个</span><br><span class=\"line\">        CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, cnt - 1);</span><br><span class=\"line\">        if (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) &#123;</span><br><span class=\"line\">            return cnt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, 0);</span><br><span class=\"line\">        if (rlt-&gt;_fireTSR &lt; item-&gt;_fireTSR) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//开始二分查找</span><br><span class=\"line\">    CFIndex add = (1 &lt;&lt; flsl(cnt)) * 2;</span><br><span class=\"line\">    CFIndex idx = 0;</span><br><span class=\"line\">    Boolean lastTestLEQ;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        add = add / 2;</span><br><span class=\"line\">\t    lastTestLEQ = false;</span><br><span class=\"line\">        CFIndex testIdx = idx + add;</span><br><span class=\"line\">        if (testIdx &lt; cnt) &#123;</span><br><span class=\"line\">            CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, testIdx);</span><br><span class=\"line\">            if (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) &#123;</span><br><span class=\"line\">                idx = testIdx;</span><br><span class=\"line\">\t\t        lastTestLEQ = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; while (0 &lt; add);</span><br><span class=\"line\"></span><br><span class=\"line\">    return lastTestLEQ ? idx + 1 : idx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里不详细讲述普通二分查找算法了，直接看这个算法。</p>\n<p>二分查找的时间复杂度是在O(log N)，也就是说，在log N次查询之内必然是可以有搜索结果的。</p>\n<blockquote>\n<p>下图就是两次搜索的演示过程</p>\n</blockquote>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/639b55053de9d6dc5d2307c9d3787fb1.png\"></p>\n<p>传统的二分查找，是二分区间，每次从一个区间中去选择前半区或者后半区。而这里的二分分的是 <code>add</code> 的长度。代码中的<code>idx</code>是 <code>区间查找法</code> 中的区间 start，因为每次二分的 <code>idx</code> 是否需要指向 <code>testIdx</code>，这个判断就是 <code>区间查找法</code>中的前后半区选择，其中 <code>end = idx + start</code> 所以说，add 隐藏了区间的 end。</p>\n<p>代码很简短，输入一个数组，一个定时器，返回这个定时器应该在这个数组中插入的Index。</p>\n<ol>\n<li><p>先判断如果当前数组内的数量少于256个，优先判断最后一个和第一个。这个问题我想，是否是因为在大部分情况下，定时器都不会超过256个，并且，定时器一般..大部分情况下都是往后增加。所以算法在最开始的时候，通过一个if判断快速处理了，大部分的使用情况。避免了每次都要进行O(log n)时间的搜索。</p>\n</li>\n<li><p>按照上面的演示过程，执行二分查找。但是在二分查找之前还有一段代码:<code>CFIndex add = (1 &lt;&lt; flsl(cnt)) * 2;</code> 为什么add的起始点不是<code>cnt</code>？<code>flsl()</code>函数是获得<code>cnt</code>用二进制表示时最大有效位数。例如，(flsl(256) 的结果是 9)。如果cnt是256，add的值将会变成1024。1左移9位是512，512再乘2，1024。<code>向上取整</code>：保证add是2的n次幂，这样就不用考虑奇偶问题了。</p>\n</li>\n</ol>\n<p>ps：上面那个例子，为什么需要左移9位再乘2？直接左移8位不行？</p>"},{"title":"详解 dyld 加载过程","date":"2020-03-12T16:00:00.000Z","top":200,"_content":"\n超长预警.......\n\n本文将会从dyld接管进程开始，超级详细的分析/解释，dyld 是如何把若干个动态库“组装”在一起，在ASLR的影响下形成一个完整的可执行进程，以及objc的runtime如何在dyld的初始化过程中进行实例化。\n\n<!-- more -->\n\n## dyld 加载过程\ndyld的启动入口在 dyldStartup.s 文件的汇编代码中，代码入口说明了:在内核初始化完成进程，并且load 完可执行文件之后，把环境变量等参数压栈，并且调用dyld的入口函数`__dyld_start`，而这个函数则根据调用约定，准备完调用参数之后，就直接跳转到`dyld::start` 这个函数。\n\n接下来看`dyld::start`\n\n```cpp\nuintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], \n\t\t\t\tintptr_t slide, const struct macho_header* dyldsMachHeader,\n\t\t\t\tuintptr_t* startGlue)\n{\n\t// if kernel had to slide dyld, we need to fix up load sensitive locations\n\t// we have to do this before using any global variables\n    //获取内核对于dyld本身的动态偏移\n    slide = slideOfMainExecutable(dyldsMachHeader);\n    bool shouldRebase = slide != 0;\n    if ( shouldRebase ) {\n        //rebase Dyld\n        rebaseDyld(dyldsMachHeader, slide);\n    }\n\n\t// allow dyld to use mach messaging\n    //mach消息初始化。\n\tmach_init();\n\n\t// kernel sets up env pointer to be just past end of agv array\n    //环境变量\n\tconst char** envp = &argv[argc+1];\n\t\n\t// kernel sets up apple pointer to be just past end of envp array\n\tconst char** apple = envp;\n\twhile(*apple != NULL) { ++apple; }\n\t++apple;\n\n\t// set up random value for stack canary\n\t__guard_setup(apple);\n\n#if DYLD_INITIALIZER_SUPPORT\n\t// run all C++ initializers inside dyld\n    //初始化 在dyld中的 所有的C++构造器\n\trunDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);\n#endif\n\n\t// now that we are done bootstrapping dyld, call dyld's main\n    //至此bootstrap dyld已经全部完成，调用 dyld 的 main 函数\n\tuintptr_t appsSlide = slideOfMainExecutable(appsMachHeader);\n\treturn dyld::   _main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);\n}\n```\n\n`dyld::start`的函数分为以下几步骤：\n1. <span id=\"return_rebaseDyld\">rebase dyld本身</span>\n[rebase dyld](#jump_rebaseDyld)\n2. 初始化进程间通讯 mach_msg\n\t直接调用<mach/mach_init.h>内的某个内核调用\n3. 初始化环境变量\n\t从调用参数中拿到apple指针，内核会把这个指针紧跟在envp的数组最后\n4. 设置栈保护\n\t从第三步拿到的apple指针中找到“stack_guard=xx”的字符串，自定义重置栈保护\n5. <span id=\"return_runDyldInitializers\">初始化 dyld 中的所有构造器函数</span>\n\t因为dyld本身是一个动态库，我们知道，动态库是共享的，但是共享的只是代码段(PIC 位置无关代码)。在内核给每一个进程的虚拟地址映射完dyld之后，dyld本身这个动态库的数据段是没有初始化的，需要自己做自己的初始化。[具体代码看这里](#jump_runDyldInitializers)\n6. 前五步已经完成 dyld 的自启动(bootstrap)，后面就是进入真正的 dyld main函数。\n\n这里可以总结一下，start的工作内容主要是一些全局环境，以及dyld自身的初始化。\n\n[开始 分析 dyld 的_main函数](#jump__main)\n\n### <span id=\"jump_rebaseDyld\">RebaseDyld</span>\n因为Dyld也是一个动态库，和普通的动态库一样，会在mach_o的load_command中指定要求需要加载到某个虚拟地址下。但是内核还是会对dyld做地址随机偏移，如果是这样，dyld需要修复数据段的数据。\n\n1. 找到Load_Commands中 __LINKEDIT 和 LC_DYLD_INFO_ONLY 两段，__LINKEDIT段内包含了链接信息，符号表，动态符号表等等，而LC_DYLD_INFO_ONLY内标明了：Rebase,Bind,WeakBind,LazyBind,Export 这个5类，而这5类都会存储在Dynamic Loader Info这一节中。\n2. 根据rebase 和 bind 的 Opcodes等，循环进行。\n\n在后文rebase/bind 可执行文件依赖的动态库时，会进行详细说明。\n\n[回去继续](#return_rebaseDyld)\n\n### <span id=\"jump_runDyldInitializers\">初始化Dyld的构造器函数</span>\n\n```cpp\nextern const Initializer  inits_start  __asm(\"section$start$__DATA$__mod_init_func\");\nextern const Initializer  inits_end    __asm(\"section$end$__DATA$__mod_init_func\");\n\n//\n// For a regular executable, the crt code calls dyld to run the executables initializers.\n// For a static executable, crt directly runs the initializers.\n// dyld (should be static) but is a dynamic executable and needs this hack to run its own initializers.\n// We pass argc, argv, etc in case libc.a uses those arguments\n//\nstatic void runDyldInitializers(const struct macho_header* mh, intptr_t slide, int argc, const char* argv[], const char* envp[], const char* apple[])\n{\n\tfor (const Initializer* p = &inits_start; p < &inits_end; ++p) {\n\t\t(*p)(argc, argv, envp, apple);\n\t}\n}\n```\n\n在dyld的该方法的注释上，苹果写的很清楚：对于常规的可执行文件，crt代码会通过调用dyld来初始化这个可执行文件的初始化构造器。但是对于静态可执行文件，crt会自己去执行初始化。dyld可以认为是“静态”的，但是本质是一个动态库，所以需要自己来初始化自己，但是苹果称之为hack的方式。\n\n实际上这是一段内联汇编，`__asm(\"section$start$__DATA$__mod_init_func\")`意思是：获取`__DATA`段`__mod_init_func`的起始地址，当然下面那行就是获取结束地址了。\n\n在Demo代码中加入两个构造器：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/81503ddc20aec519b01d09370a4d1628.png)\n\n然后再看这个mach-o 文件：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d61a14b2aeeb66a2eea1be2d8be6b85f.png)\n\n可以看到在数据段增加了一节`__mod_init_func`,编译期会把所有构造器的函数地址，都放在这节中。例如这个Section中第一个地址存储的是demo_init1的函数地址，去掉虚拟起始地址，文件内偏移地址就是0xED0：\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/9ac92176b89d0c92d76d1d98ecddd5f4.png)\n\n可以直接验证确实是这个函数，`demo_init2`也是如此。\n\n回过头来看，dyld的代码：这个`inits_start`中就是构造器列表中第一个构造器的函数地址了。`inits_end`就是结束地址，循环即可依次按照约定，初始化dyld自己内部的所有构造器函数了。\n\n在dyld的内部还会有很多诸如此类的用法。\n具体可以看[参考文献](#jump_end)中 1 和 2\n\n[回去继续](#return_runDyldInitializers)\n\n## <span id=\"jump__main\">dyld::_main函数</span>\n在dyld自身的rebase和bind、mach_msg初始化、环境变量初始化、构造函数初始化全部完成之后，开始dyld的真正工作内容，`dyld::_main` 函数。\n\n`dyld::_main`函数最终是返回了主进程App可执行文件的main函数入口，并且由`dyld::start`函数再返回给调用它的`__dyld_start`这个汇编函数，最终由最开始的这个汇编函数，准备好调用参数之后，直接调用我们所熟悉的可执行文件的main函数。\n\n这个_main函数很长，我们只看步骤。\n\n1. 进入函数的最开始是对环境变量的初始化加载和控制，例如 crashlog，环境变量控制log，主进程可执行文件路径...\n2. 加载共享缓存。`// iOS cannot run without shared region`,iOS必须开启共享共享缓存。\n\t在所有libpath中搜索不到对应名字的动态库的时候，就会尝试从共享缓存中找。（当然这里为了便于理解，只是简单这样描述，实际的搜索方式远比这个要复杂）\n3. <span id=\"return_initMainExecutable\">实例化可执行文件:</span>\n\t实例化可执行程序，生成`ImageLoaderMachO`对象。[实例化主程序](#jump_initMainExecutable)\n\t实例化可执行文件有两种（Classic和Compressed），分别由`ImageLoaderMachOCompressed`和`ImageLoaderMachOClassic`来创建可执行文件对象，这两者均继承于`ImageLoaderMachO`。\n4. 加载从参数插入的动态库`loadInsertedDylib`，只做加载，不做链接。[Load 插入的动态库](#jump_loaddylib)<span id=\"return_loaddylib\">.</span>\n5. <span id=\"return_link_execution\">链接可执行程序。</span>[链接可执行程序](#jump_link_execution)\n6. 链接从参数插入的动态库。\n7. 从可执行文件，递归开始调用初始化。\n\n### <span id=\"jump_initMainExecutable\">实例化主程序</span>\n在dyld获得控制权之前，内核已经把可执行文件映射到了某个线性地址空间了，所以dyld可以直接获取到 macho_header，dyld会为可执行文件创建一个ImageLoader实例对象，每一个MachO在dyld中都会有一个这个对象与之对应。\n\n```cpp\nstatic ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)\n{\n\t// try mach-o loader\n\tif ( isCompatibleMachO((const uint8_t*)mh, path) ) {\n\t\tImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);\n\t\taddImage(image);\n\t\treturn (ImageLoaderMachO*)image;\n\t}\n\t\n\tthrow \"main executable not a known format\";\n}\n```\n\n`instantiateMainExecutable`这个方法内还会根据不同的mach-o类型(compress 或者 classic)来返回ImageLoader的不同实现的子类对象。\n\n`addImage(image);`这个函数有两个作用：\n1. 把生成的镜像实例（ImageLoader）加入到一个全局镜像容器`sAllImages`内。之后加载的所有动态库都会被加入这个容器。\n2. 把可执行文件的每一个段所占据的实际线性地址范围，映射到一个全局链表 `sMappedRangesStart`内，而这个全局链表的作用就是为了能够快速的通过 地址 反向获取到对应的`ImageLoader`。\n\n[回去继续](#return_initMainExecutable)\n\n### <span id=\"jump_loaddylib\">加载动态库</span>\n这一步循环遍历DYLD_INSERT_LIBRARIES环境变量中指定的动态库列表，并调用loadInsertedDylib()将其加载。\n\n该函数调用load()完成加载工作。load()会调用loadPhase0()尝试从文件加载，loadPhase0()会向下调用下一层phase来查找动态库的路径，直到loadPhase6()，查找的顺序为DYLD_ROOT_PATH->LD_LIBRARY_PATH->DYLD_FRAMEWORK_PATH->原始路径->DYLD_FALLBACK_LIBRARY_PATH。\n\n找到后调用ImageLoaderMachO::instantiateFromFile()来实例化一个 ImageLoader，之后调用 checkandAddImage() 验证映像并将其加入到全局镜像列表中。\n\n如果loadPhase0()返回为空，表示在路径中没有找到动态库，就尝试从共享缓存中查找，找到就调用ImageLoaderMachO::instantiateFromCache()从缓存中加载。\n\n否则就抛出没找到镜像的异常。\n\n看加载动态库部分的源代码：\n```cpp\n// map in file and instantiate an ImageLoader\n// 映射某个动态库文件并且实例化一个ImagerLoader\nstatic ImageLoader* loadPhase6(int fd, const struct stat& stat_buf, const char* path, const LoadContext& context)\n{\n\t//dyld::log(\"%s(%s)\\n\", __func__ , path);\n\tuint64_t fileOffset = 0;\n\tuint64_t fileLength = stat_buf.st_size;\n\n\t// validate it is a file (not directory)\n\tif ( (stat_buf.st_mode & S_IFMT) != S_IFREG ) \n\t\tthrow \"not a file\";\n\n\tuint8_t firstPages[MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE];\n\tuint8_t *firstPagesPtr = firstPages;\n\tbool shortPage = false;\n\t\n\t// min mach-o file is 4K\n\t// 最小的mach-o文件就是4k（保证一个页框大小）\n\tif ( fileLength < 4096 ) {\n\t\tif ( pread(fd, firstPages, (size_t)fileLength, 0) != (ssize_t)fileLength )\n\t\t\tthrowf(\"pread of short file failed: %d\", errno);\n\t\tshortPage = true;\n\t} \n\telse {\n\t\t// optimistically read only first 4KB\n\t\t// 优先读取header文件的4kb，因为一个分页最小是4k。\n\t\tif ( pread(fd, firstPages, 4096, 0) != 4096 )\n\t\t\tthrowf(\"pread of first 4K failed: %d\", errno);\n\t}\n\t\n\t// if fat wrapper, find usable sub-file\n\t// 如果这个动态库是个fat文件，就直接找到合适的“子文件”\n\tconst fat_header* fileStartAsFat = (fat_header*)firstPages;\n\tif ( fileStartAsFat->magic == OSSwapBigToHostInt32(FAT_MAGIC) ) {\n\t\tif ( OSSwapBigToHostInt32(fileStartAsFat->nfat_arch) > ((4096 - sizeof(fat_header)) / sizeof(fat_arch)) )\n\t\t\tthrowf(\"fat header too large: %u entries\", OSSwapBigToHostInt32(fileStartAsFat->nfat_arch));\n\t\tif ( fatFindBest(fileStartAsFat, &fileOffset, &fileLength) ) {\n\t\t\tif ( (fileOffset+fileLength) > (uint64_t)(stat_buf.st_size) )\n\t\t\t\tthrowf(\"truncated fat file.  file length=%llu, but needed slice goes to %llu\", stat_buf.st_size, fileOffset+fileLength);\n\t\t\tif (pread(fd, firstPages, 4096, fileOffset) != 4096)\n\t\t\t\tthrowf(\"pread of fat file failed: %d\", errno);\n\t\t}\n\t\telse {\n\t\t\tthrow \"no matching architecture in universal wrapper\";\n\t\t}\n\t}\n\t\n\t// try mach-o loader\n\tif ( shortPage ) \n\t\tthrow \"file too short\";\n\n\tif ( isCompatibleMachO(firstPages, path) ) {\n\n\t\t// only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded\n\t\tconst mach_header* mh = (mach_header*)firstPages;\n\t\tswitch ( mh->filetype ) {\n\t\t\tcase MH_EXECUTE:\n\t\t\tcase MH_DYLIB:\n\t\t\tcase MH_BUNDLE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow \"mach-o, but wrong filetype\";\n\t\t}\n\n\t\tuint32_t headerAndLoadCommandsSize = sizeof(macho_header) + mh->sizeofcmds;\n\t\tif ( headerAndLoadCommandsSize > MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE )\n\t\t\tthrowf(\"malformed mach-o: load commands size (%u) > %u\", headerAndLoadCommandsSize, MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE);\n\n\t\tif ( headerAndLoadCommandsSize > fileLength )\n\t\t\tdyld::throwf(\"malformed mach-o: load commands size (%u) > mach-o file size (%llu)\", headerAndLoadCommandsSize, fileLength);\n\n\t\tif ( headerAndLoadCommandsSize > 4096 ) {\n\t\t\t// read more pages\n\t\t\t// 如果 head 和 LC_COMMANDS的大小大于已读取的4096，那么就继续把 headerAndLoadCommandsSize 读完\n\t\t\tunsigned readAmount = headerAndLoadCommandsSize - 4096;\n\t\t\tif ( pread(fd, &firstPages[4096], readAmount, fileOffset+4096) != readAmount )\n\t\t\t\tthrowf(\"pread of extra load commands past 4KB failed: %d\", errno);\n\t\t}\n\n#if TARGET_IPHONE_SIMULATOR\t\n\t\t// <rdar://problem/14168872> dyld_sim should restrict loading osx binaries\n\t\tif ( !isSimulatorBinary(firstPages, path) ) {\n\t#if TARGET_OS_WATCH\n\t\t\tthrow \"mach-o, but not built for watchOS simulator\";\n\t#elif TARGET_OS_TV\n\t\t\tthrow \"mach-o, but not built for tvOS simulator\";\n\t#else\n\t\t\tthrow \"mach-o, but not built for iOS simulator\";\n\t#endif\n\t\t}\n#endif\n\n#if __MAC_OS_X_VERSION_MIN_REQUIRED\n\t\tif ( gLinkContext.marzipan ) {\n\t\t\tconst dyld3::MachOFile* mf = (dyld3::MachOFile*)firstPages;\n\t\t\tbool isiOSMacBinary = mf->supportsPlatform(dyld3::Platform::iOSMac) || iOSMacWhiteListed(path);\n\t\t\tbool isProhibitedMacOSBinary = !isiOSMacBinary && iOSMacBlackListed(path);\n\t\t\tif ( (context.enforceIOSMac && !isiOSMacBinary) || isProhibitedMacOSBinary ) {\n\t\t\t\tthrow \"mach-o, but not built for iOSMac\";\n\t\t\t}\n\t\t}\n#endif\n\n#if __arm64e__\n\t\tif ( (sMainExecutableMachHeader->cpusubtype == CPU_SUBTYPE_ARM64_E) && (mh->cpusubtype != CPU_SUBTYPE_ARM64_E) )\n\t\t\tthrow \"arm64 dylibs cannot be loaded into arm64e processes\";\n#endif\n\t\tImageLoader* image = nullptr;\n\t\t{\n\t\t\tdyld3::ScopedTimer timer(DBG_DYLD_TIMING_MAP_IMAGE, path, 0, 0);\n\t\t\t//调用 instantiateFromFile 来实例化 ImageLoader\n\t\t\timage = ImageLoaderMachO::instantiateFromFile(path, fd, firstPagesPtr, headerAndLoadCommandsSize, fileOffset, fileLength, stat_buf, gLinkContext);\n\t\t\ttimer.setData4((uint64_t)image->machHeader());\n\t\t}\n\t\t\n\t\t// validate\n\t\t// 加入全局链表\n\t\treturn checkandAddImage(image, context);\n\t}\n\t\n\t// try other file formats here...\n\t\n\t\n\t// throw error about what was found\n\tswitch (*(uint32_t*)firstPages) {\n\t\tcase MH_MAGIC:\n\t\tcase MH_CIGAM:\n\t\tcase MH_MAGIC_64:\n\t\tcase MH_CIGAM_64:\n\t\t\tthrow \"mach-o, but wrong architecture\";\n\t\tdefault:\n\t\tthrowf(\"unknown file type, first eight bytes: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\", \n\t\t\tfirstPages[0], firstPages[1], firstPages[2], firstPages[3], firstPages[4], firstPages[5], firstPages[6],firstPages[7]);\n\t}\n}\n```\n\n这部分的主要任务就是，从本地文件中加载指定的动态库，并且返回`ImageLoader`实例对象。\n\n步骤如下：\n1. 优先读取这个文件的4k，因为一个分页最小是4k,并且解析为 fat_header。\n2. 如果这个动态库是个fat文件，就直接找到合适CPU架构的“子文件”\n3. 检查文件类型，大小等。\n4. 如果 head 和 Load_Commands 的大小大于已读取的4k，那么就继续把剩下的 headerAndLoadCommandsSize 读完，实例化`ImageLoader`。因为实例化`ImageLoader`需要整个 Load_Commands 部分。\n5. checkandAddImage。\n\n\n再来看 checkandAddImage：\n```cpp\nstatic ImageLoader* checkandAddImage(ImageLoader* image, const LoadContext& context)\n{\n\t// now sanity check that this loaded image does not have the same install path as any existing image\n\t// 在sAllImages 中检查一下，是否有同样路径的动态库，如果有，则返回链表中原有的那个镜像\n\tconst char* loadedImageInstallPath = image->getInstallPath();\n\tif ( image->isDylib() && (loadedImageInstallPath != NULL) && (loadedImageInstallPath[0] == '/') ) {\n\t\tfor (std::vector<ImageLoader*>::iterator it=sAllImages.begin(); it != sAllImages.end(); it++) {\n\t\t\tImageLoader* anImage = *it;\n\t\t\tconst char* installPath = anImage->getInstallPath();\n\t\t\tif ( installPath != NULL) {\n\t\t\t\tif ( strcmp(loadedImageInstallPath, installPath) == 0 ) {\n\t\t\t\t\t//dyld::log(\"duplicate(%s) => %p\\n\", installPath, anImage);\n\t\t\t\t\tremoveImage(image);\n\t\t\t\t\tImageLoader::deleteImage(image);\n\t\t\t\t\treturn anImage;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// some API's restrict what they can load\n\tif ( context.mustBeBundle && !image->isBundle() )\n\t\tthrow \"not a bundle\";\n\tif ( context.mustBeDylib && !image->isDylib() )\n\t\tthrow \"not a dylib\";\n\n\t// regular main executables cannot be loaded \n\tif ( image->isExecutable() ) {\n\t\tif ( !context.canBePIE || !image->isPositionIndependentExecutable() )\n\t\t\tthrow \"can't load a main executable\";\n\t}\n\t\n\t// don't add bundles to global list, they can be loaded but not linked.  When linked it will be added to list\n\tif ( ! image->isBundle() )\n\t\t//加入全局链表中\n\t\taddImage(image);\n\t\n\treturn image;\n}\n```\n\n代码很简单，判断这个路径的动态库是不是已经在全局链表中了，已经在的话就直接返回，否则就`AddImage`\n\n[返回继续](#return_loaddylib)\n\n### <span id=\"jump_link_execution\">Link 可执行文件</span>\n标题是链接可执行文件，但是因为这是一个递归操作，所以这一节主要是讲述dyld如何链接所有的动态库。\n\n`void link(ImageLoader* image, bool forceLazysBound, bool neverUnload, const ImageLoader::RPathChain& loaderRPaths, unsigned cacheIndex)`\n\n上面是这个函数的方法签名，在_main的执行过程中，首先是可执行文件的 mach-o 镜像 调用，其次紧跟着的是环境变量中插入的动态库会依次调用，这个函数内部最终还是调用到了 `ImageLoader.link`函数\n\n```cpp\nvoid ImageLoader::link(const LinkContext& context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain& loaderRPaths, const char* imagePath)\n{\n\t//dyld::log(\"ImageLoader::link(%s) refCount=%d, neverUnload=%d\\n\", imagePath, fDlopenReferenceCount, fNeverUnload);\n\t\n\t// clear error strings\n\t(*context.setErrorStrings)(0, NULL, NULL, NULL);\n\n\tuint64_t t0 = mach_absolute_time();\n\tthis->recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);\n\tcontext.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);\n\n\t// we only do the loading step for preflights\n\tif ( preflightOnly )\n\t\treturn;\n\n\tuint64_t t1 = mach_absolute_time();\n\tcontext.clearAllDepths();\n\tthis->recursiveUpdateDepth(context.imageCount());\n\n\t__block uint64_t t2, t3, t4, t5;\n\t{\n\t\tdyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, 0, 0, 0);\n\t\tt2 = mach_absolute_time();\n\t\tthis->recursiveRebase(context);\n\t\tcontext.notifyBatch(dyld_image_state_rebased, false);\n\n\t\tt3 = mach_absolute_time();\n\t\tif ( !context.linkingMainExecutable )\n\t\t\tthis->recursiveBindWithAccounting(context, forceLazysBound, neverUnload);\n\n\t\tt4 = mach_absolute_time();\n\t\tif ( !context.linkingMainExecutable )\n\t\t\tthis->weakBind(context);\n\t\tt5 = mach_absolute_time();\n\t}\n\n    if ( !context.linkingMainExecutable )\n        context.notifyBatch(dyld_image_state_bound, false);\n\tuint64_t t6 = mach_absolute_time();\t\n\n\tstd::vector<DOFInfo> dofs;\n\tthis->recursiveGetDOFSections(context, dofs);\n\tcontext.registerDOFs(dofs);\n\tuint64_t t7 = mach_absolute_time();\t\n\n\t// interpose any dynamically loaded images\n\tif ( !context.linkingMainExecutable && (fgInterposingTuples.size() != 0) ) {\n\t\tdyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0);\n\t\tthis->recursiveApplyInterposing(context);\n\t}\n\n\t// clear error strings\n\t(*context.setErrorStrings)(0, NULL, NULL, NULL);\n\n\t//计算时间，控制log输出\n\tfgTotalLoadLibrariesTime += t1 - t0;\n\tfgTotalRebaseTime += t3 - t2;\n\tfgTotalBindTime += t4 - t3;\n\tfgTotalWeakBindTime += t5 - t4;\n\tfgTotalDOF += t7 - t6;\n\t\n\t// done with initial dylib loads\n\tfgNextPIEDylibAddress = 0;\n}\n```\n\n链接函数的操作思路很清晰：\n1. `this->recursiveLoadLibraries` 递归加载依赖的所有动态库 (这里仅仅是Load，Load包含open文件以及实例化ImageLoader)，最终的结果和Load通过参数插入的动态库一样。\n2. `this->recursiveUpdateDepth` 递归刷新依赖库的层级\n3. <span id=\"return_rebase\">`this->recursiveRebase`</span>\n\t每一个动态库的递归rebase无非就是再次依次调用，当前动态库所依赖的其他动态库的recursiveRebase。真正rebase是在`rebase(const LinkContext& context, uintptr_t slide)`。[Rebase](#jump_rebase)\n4. `this->recursiveBindWithAccounting`\n\t这里就是经典的non-lazy bind和lazy bind了。和Rebase的代码结构类似，真正的rebind是在`doBind(const LinkContext& context, bool forceLazysBound)`。\n5. `this->weakBind` 弱符号绑定\n6. `this->recursiveGetDOFSections` 注册DOF节\n7. `this->recursiveApplyInterposing`\n\n其中每一个步骤都会有一个时间戳，用来根据可控的环境变量来输出log。\n\n### <span id=\"jump_rebase\">Rebase</span>\n首先解释一下 Rebase ：\n\n都知道，Rebase是调整动态库内部的符号，因为ASLR，内核加载的时候会在随机的地址中映射动态库。一开始我的想法是，mach-o的动态库在编译期已经做了PIC（地址无关代码），为什么还会有\"rebase\"这个过程？\n\n事实上PIC确实存在，但是rebase也是必须的。\n\n举个例子：在动态库/可执行文件 初始化 的过程中有一个步骤是构造器初始化(这个步骤本文也有具体说明)，而实现这个这个步骤的，实际上是在mach-o的数据段中有一个名为`__mod_init_func`的段，而这个段存储的指针数组就是构造器初始化函数的地址。说到这就比较明显了，在dyld 寻找构造器初始化地址指针的时候，已经不再是以数据段中的vmaddr为基准了，而是需要加上一个偏移 -- slide。\n\n下面就按照上面例子，看看代码中是如何实现这一步骤的，compressed mach-o(现代版本的好像几乎都是这个压缩的mach-o格式了) 在这一节上做了压缩，因此实现都在`ImageLoaderMachOCompressed`中。\n\n先分析一下 rebase 这一节在mach-o内的数据结构\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/ffdc0da28d16d220f66e8d638a7d5198.png)\n\n每一个 rebase 信息都由若干个 操作码 -- 操作数 来描述，每一个记录都包含两个元素（opcode 和 immediate），可以理解为一个操作码，一个是操作数，这两个都可以通过掩码来获取。\n\n以第一个为例：\nREBASE_OPCODE_TYPE_IMM == 11:标识操作数是一个Type，而Type是个指针\nREBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB == 22:当前rebase的数据在第2个segment，并且偏移是用uleb表示\nuleb128 == 24:上面提到的uleb值\nREBASE_OPCODE_DO_REBASE_IMM_TIMES == 2:当前rebase操作执行2次。\n\n总结：在第2个段开始往后偏移24个字节的指针地址，连续执行两次rebase。\n\n再看看：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/69f3c8a3511f6c75d8798c62db21d597.png)\n\n0是起始段，那么第2段就是数据段。我们再找，段的文件偏移 0x3000 + 偏移 24 =0x3018 。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/8479e0316c7f0447ff14dd0a1b98ed69.png)\n\n没错，就是这两个构造器，并且当前节就是`__mod_init_func`~。\n\n下面是rebase的源码，当然在本例中有些 操作码 和 操作数 并没有用到。\n```cpp\nvoid ImageLoaderMachOCompressed::rebase(const LinkContext& context, uintptr_t slide)\n{\n\tCRSetCrashLogMessage2(this->getPath());\n\t// fLinkEditBase 是__LINKEDIT段在 内存实际偏移与预期偏移 的 差值 （== slide？）\n\t// start 的值是 rebase信息在内存中的实际起始地址\n\tconst uint8_t* const start = fLinkEditBase + fDyldInfo->rebase_off;\n\t// end 的值是 rebase信息在内存中的实际结束地址\n\tconst uint8_t* const end = &start[fDyldInfo->rebase_size];\n\tconst uint8_t* p = start;\n\n\ttry {\n\t\tuint8_t type = 0;\n\t\tint segmentIndex = 0;\n\t\tuintptr_t address = segActualLoadAddress(0);\n\t\tuintptr_t segmentStartAddress = segActualLoadAddress(0);//第N个段地址的实际开始地址\n\t\tuintptr_t segmentEndAddress = segActualEndAddress(0);//第N个段的实际结束地址\n\t\tuintptr_t count;\n\t\tuintptr_t skip;\n\t\tbool done = false;\n\t\twhile ( !done && (p < end) ) {\n\t\t\tuint8_t immediate = *p & REBASE_IMMEDIATE_MASK;\n\t\t\tuint8_t opcode = *p & REBASE_OPCODE_MASK;\n\t\t\t++p;\n\t\t\tswitch (opcode) {\n\t\t\t\tcase REBASE_OPCODE_DONE:\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_SET_TYPE_IMM:\n\t\t\t\t\ttype = immediate;\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\t\t\tsegmentIndex = immediate;\n\t\t\t\t\tif ( segmentIndex >= fSegmentsCount )\n\t\t\t\t\t\tdyld::throwf(\"REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is too large (0..%d)\",\n\t\t\t\t\t\t\t\tsegmentIndex, fSegmentsCount-1);\n\t\t\t#if TEXT_RELOC_SUPPORT\n\t\t\t\t\tif ( !segWriteable(segmentIndex) && !segHasRebaseFixUps(segmentIndex) && !segHasBindFixUps(segmentIndex) )\n\t\t\t#else\n\t\t\t\t\tif ( !segWriteable(segmentIndex) )\n\t\t\t#endif\n\t\t\t\t\t\tdyld::throwf(\"REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is not a writable segment (%s)\",\n\t\t\t\t\t\t\t\tsegmentIndex, segName(segmentIndex));\n\t\t\t\t\t//读取当前段的实际开始和结束地址\n\t\t\t\t\tsegmentStartAddress = segActualLoadAddress(segmentIndex);\n\t\t\t\t\tsegmentEndAddress = segActualEndAddress(segmentIndex);\n\t\t\t\t\t\n\t\t\t\t\taddress = segmentStartAddress + read_uleb128(p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_ADD_ADDR_ULEB:\n\t\t\t\t\taddress += read_uleb128(p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_ADD_ADDR_IMM_SCALED:\n\t\t\t\t\taddress += immediate*sizeof(uintptr_t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_DO_REBASE_IMM_TIMES:\n\t\t\t\t\tfor (int i=0; i < immediate; ++i) {//循环N次\n\t\t\t\t\t\tif ( (address < segmentStartAddress) || (address >= segmentEndAddress) )\n\t\t\t\t\t\t\tthrowBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);\n\t\t\t\t\t\trebaseAt(context, address, slide, type);\n\t\t\t\t\t\taddress += sizeof(uintptr_t);\n\t\t\t\t\t}\n\t\t\t\t\tfgTotalRebaseFixups += immediate;\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_DO_REBASE_ULEB_TIMES:\n\t\t\t\t\tcount = read_uleb128(p, end);\n\t\t\t\t\tfor (uint32_t i=0; i < count; ++i) {\n\t\t\t\t\t\tif ( (address < segmentStartAddress) || (address >= segmentEndAddress) )\n\t\t\t\t\t\t\tthrowBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);\n\t\t\t\t\t\trebaseAt(context, address, slide, type);\n\t\t\t\t\t\taddress += sizeof(uintptr_t);\n\t\t\t\t\t}\n\t\t\t\t\tfgTotalRebaseFixups += count;\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB:\n\t\t\t\t\tif ( (address < segmentStartAddress) || (address >= segmentEndAddress) )\n\t\t\t\t\t\tthrowBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);\n\t\t\t\t\trebaseAt(context, address, slide, type);\n\t\t\t\t\taddress += read_uleb128(p, end) + sizeof(uintptr_t);\n\t\t\t\t\t++fgTotalRebaseFixups;\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\t\t\tcount = read_uleb128(p, end);\n\t\t\t\t\tskip = read_uleb128(p, end);\n\t\t\t\t\tfor (uint32_t i=0; i < count; ++i) {\n\t\t\t\t\t\tif ( (address < segmentStartAddress) || (address >= segmentEndAddress) )\n\t\t\t\t\t\t\tthrowBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);\n\t\t\t\t\t\trebaseAt(context, address, slide, type);\n\t\t\t\t\t\taddress += skip + sizeof(uintptr_t);\n\t\t\t\t\t}\n\t\t\t\t\tfgTotalRebaseFixups += count;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdyld::throwf(\"bad rebase opcode %d\", *(p-1));\n\t\t\t}\n\t\t}\n\t}\n\tcatch (const char* msg) {\n\t\tconst char* newMsg = dyld::mkstringf(\"%s in %s\", msg, this->getPath());\n\t\tfree((void*)msg);\n\t\tthrow newMsg;\n\t}\n\tCRSetCrashLogMessage2(NULL);\n}\n```\n## <span id=\"jump_init_main_execution\">initializeMainExecutable</span>\n其实到这里动态库的加载/rebase/bind...都已经完成了，而这一步要做的就是初始化构造器函数了，这里也就是runtime初始化的过程。\n\n```cpp\nvoid initializeMainExecutable()\n{\n\t// record that we've reached this step\n\tgLinkContext.startedInitializingMainExecutable = true;\n\n\t// run initialzers for any inserted dylibs\n\tImageLoader::InitializerTimingList initializerTimes[allImagesCount()];\n\tinitializerTimes[0].count = 0;\n\tconst size_t rootCount = sImageRoots.size();\n\tif ( rootCount > 1 ) {\n\t\tfor(size_t i=1; i < rootCount; ++i) {\n\t\t\tsImageRoots[i]->runInitializers(gLinkContext, initializerTimes[0]);\n\t\t}\n\t}\n\t\n\t// run initializers for main executable and everything it brings up \n\tsMainExecutable->runInitializers(gLinkContext, initializerTimes[0]);\n\t\n\t// register cxa_atexit() handler to run static terminators in all loaded images when this process exits\n\tif ( gLibSystemHelpers != NULL ) \n\t\t(*gLibSystemHelpers->cxa_atexit)(&runAllStaticTerminators, NULL, NULL);\n\n\t// dump info if requested\n\tif ( sEnv.DYLD_PRINT_STATISTICS )\n\t\tImageLoader::printStatistics((unsigned int)allImagesCount(), initializerTimes[0]);\n\tif ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )\n\t\tImageLoaderMachO::printStatisticsDetails((unsigned int)allImagesCount(), initializerTimes[0]);\n}\n\n```\n\n优先初始化插入的动态库，再初始化可执行文件。\n\nsMainExecutable->runInitializers 函数：\n```cpp\nvoid ImageLoader::runInitializers(const LinkContext& context, InitializerTimingList& timingInfo)\n{\n\tuint64_t t1 = mach_absolute_time();\n\tmach_port_t thisThread = mach_thread_self();\n\tImageLoader::UninitedUpwards up;\n\tup.count = 1;\n\tup.images[0] = this;\n\tprocessInitializers(context, thisThread, timingInfo, up);\n\tcontext.notifyBatch(dyld_image_state_initialized, false);\n\tmach_port_deallocate(mach_task_self(), thisThread);\n\tuint64_t t2 = mach_absolute_time();\n\tfgTotalInitTime += (t2 - t1);\n}\n```\nprocessInitializers 函数：\n```cpp\nvoid ImageLoader::processInitializers(const LinkContext& context, mach_port_t thisThread,\n\t\t\t\t\t\t\t\t\t InitializerTimingList& timingInfo, ImageLoader::UninitedUpwards& images)\n{\n\tuint32_t maxImageCount = context.imageCount()+2;\n\tImageLoader::UninitedUpwards upsBuffer[maxImageCount];\n\tImageLoader::UninitedUpwards& ups = upsBuffer[0];\n\tups.count = 0;\n\t// Calling recursive init on all images in images list, building a new list of\n\t// uninitialized upward dependencies.\n\tfor (uintptr_t i=0; i < images.count; ++i) {\n\t\timages.images[i]->recursiveInitialization(context, thisThread, images.images[i]->getPath(), timingInfo, ups);\n\t}\n\t// If any upward dependencies remain, init them.\n\tif ( ups.count > 0 )\n\t\tprocessInitializers(context, thisThread, timingInfo, ups);\n}\n```\n\nrecursiveInitialization 函数：\n```cpp\nvoid ImageLoader::recursiveInitialization(const LinkContext& context, mach_port_t this_thread, const char* pathToInitialize,\n\t\t\t\t\t\t\t\t\t\t  InitializerTimingList& timingInfo, UninitedUpwards& uninitUps)\n{\n\trecursive_lock lock_info(this_thread);\n\trecursiveSpinLock(lock_info);\n\n\tif ( fState < dyld_image_state_dependents_initialized-1 ) {\n\t\tuint8_t oldState = fState;\n\t\t// break cycles\n\t\tfState = dyld_image_state_dependents_initialized-1;\n\t\ttry {\n\t\t\t// initialize lower level libraries first\n\t\t\tfor(unsigned int i=0; i < libraryCount(); ++i) {\n\t\t\t\tImageLoader* dependentImage = libImage(i);\n\t\t\t\tif ( dependentImage != NULL ) {\n\t\t\t\t\t// don't try to initialize stuff \"above\" me yet\n\t\t\t\t\tif ( libIsUpward(i) ) {\n\t\t\t\t\t\tuninitUps.images[uninitUps.count] = dependentImage;\n\t\t\t\t\t\tuninitUps.count++;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( dependentImage->fDepth >= fDepth ) {\n\t\t\t\t\t\tdependentImage->recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);\n\t\t\t\t\t}\n                }\n\t\t\t}\n\t\t\t\n\t\t\t// record termination order\n\t\t\tif ( this->needsTermination() )\n\t\t\t\tcontext.terminationRecorder(this);\n\t\t\t\n\t\t\t// let objc know we are about to initialize this image\n\t\t\tuint64_t t1 = mach_absolute_time();\n\t\t\tfState = dyld_image_state_dependents_initialized;\n\t\t\toldState = fState;\n\t\t\tcontext.notifySingle(dyld_image_state_dependents_initialized, this, &timingInfo);\n\t\t\t\n\t\t\t// initialize this image\n\t\t\tbool hasInitializers = this->doInitialization(context);\n\n\t\t\t// let anyone know we finished initializing this image\n\t\t\tfState = dyld_image_state_initialized;\n\t\t\toldState = fState;\n\t\t\tcontext.notifySingle(dyld_image_state_initialized, this, NULL);\n\t\t\t\n\t\t\tif ( hasInitializers ) {\n\t\t\t\tuint64_t t2 = mach_absolute_time();\n\t\t\t\ttimingInfo.addTime(this->getShortName(), t2-t1);\n\t\t\t}\n\t\t}\n\t\tcatch (const char* msg) {\n\t\t\t// this image is not initialized\n\t\t\tfState = oldState;\n\t\t\trecursiveSpinUnLock();\n\t\t\tthrow;\n\t\t}\n\t}\n\t\n\trecursiveSpinUnLock();\n}\n```\n\ndoInitialization 函数：\n```cpp\nbool ImageLoaderMachO::doInitialization(const LinkContext& context)\n{\n\tCRSetCrashLogMessage2(this->getPath());\n\n\t// mach-o has -init and static initializers\n\tdoImageInit(context);\n\tdoModInitFunctions(context);\n\t\n\tCRSetCrashLogMessage2(NULL);\n\t\n\treturn (fHasDashInit || fHasInitializers);\n}\n```\n\n最终调到 doModInitFunctions 函数，实现逻辑和上文提到的dyld的自身的初始化一样，遍历调用_mod_init_func中的方法指针。\n\nruntime就是在这里被初始化的，调试一下就可以看到:\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/6880c3f245ce10b72f214d8851b959e5.png)\n\n调用栈和上面描述的一样，最终由 libSystem.B.dylib -> libdispatch.dylib -> libobjc.A.dylib 这个调用顺序初始化了runtime。\n而runtime 的这个函数，在dyld反向注册了三个回调函数。\n`_dyld_objc_notify_register(&map_images, load_images, unmap_image);`\n\n而这个注册函数会把每个已经load完的镜像同步地回调给runtime：\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d26ee1e5057ed5fc0c63d13baac4b77b.png)\n\n从代码中我们也可以确认：\n```cpp\nvoid registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)\n{\n\t// record functions to call\n\tsNotifyObjCMapped\t= mapped;\n\tsNotifyObjCInit\t\t= init;\n\tsNotifyObjCUnmapped = unmapped;\n\n\t// call 'mapped' function with all images mapped so far\n\ttry {\n\t\tnotifyBatchPartial(dyld_image_state_bound, true, NULL, false, true);\n\t}\n\tcatch (const char* msg) {\n\t\t// ignore request to abort during registration\n\t}\n\n\t// <rdar://problem/32209809> call 'init' function on all images already init'ed (below libSystem)\n\tfor (std::vector<ImageLoader*>::iterator it=sAllImages.begin(); it != sAllImages.end(); it++) {\n\t\tImageLoader* image = *it;\n\t\tif ( (image->getState() == dyld_image_state_initialized) && image->notifyObjC() ) {\n\t\t\tdyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image->machHeader(), 0, 0);\n\t\t\t(*sNotifyObjCInit)(image->getRealPath(), image->machHeader());\n\t\t}\n\t}\n}\n```\n\n遍历 sAllImages ，回调给 `_dyld_objc_notify_init init`函数。runtime就可以根据mach-o的 class 有关的 section 开始初始化了。\n\n## <span id=\"jump_end\">参考文献</span>\n1. [内嵌汇编的一些黑科技：访问自身Mach-O、调用函数等](https://www.dllhook.com/post/249.html)\n2. [Mach-O脱壳技巧](https://paper.seebug.org/202/)\n3. [dyld详解](https://www.dllhook.com/post/238.html)\n4. [iOS 程序 main 函数之前发生了什么](http://blog.sunnyxx.com/2014/08/30/objc-pre-main/)\n5. [dylib动态库加载过程分析](https://feicong.github.io/2017/01/14/dylib/index.html)\n\n","source":"_posts/11.dyld.md","raw":"---\ntitle: 详解 dyld 加载过程\ndate: 2020-03-13\ntags: [动态链接]\ntop: 200\ncategories: 动态库\n---\n\n超长预警.......\n\n本文将会从dyld接管进程开始，超级详细的分析/解释，dyld 是如何把若干个动态库“组装”在一起，在ASLR的影响下形成一个完整的可执行进程，以及objc的runtime如何在dyld的初始化过程中进行实例化。\n\n<!-- more -->\n\n## dyld 加载过程\ndyld的启动入口在 dyldStartup.s 文件的汇编代码中，代码入口说明了:在内核初始化完成进程，并且load 完可执行文件之后，把环境变量等参数压栈，并且调用dyld的入口函数`__dyld_start`，而这个函数则根据调用约定，准备完调用参数之后，就直接跳转到`dyld::start` 这个函数。\n\n接下来看`dyld::start`\n\n```cpp\nuintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], \n\t\t\t\tintptr_t slide, const struct macho_header* dyldsMachHeader,\n\t\t\t\tuintptr_t* startGlue)\n{\n\t// if kernel had to slide dyld, we need to fix up load sensitive locations\n\t// we have to do this before using any global variables\n    //获取内核对于dyld本身的动态偏移\n    slide = slideOfMainExecutable(dyldsMachHeader);\n    bool shouldRebase = slide != 0;\n    if ( shouldRebase ) {\n        //rebase Dyld\n        rebaseDyld(dyldsMachHeader, slide);\n    }\n\n\t// allow dyld to use mach messaging\n    //mach消息初始化。\n\tmach_init();\n\n\t// kernel sets up env pointer to be just past end of agv array\n    //环境变量\n\tconst char** envp = &argv[argc+1];\n\t\n\t// kernel sets up apple pointer to be just past end of envp array\n\tconst char** apple = envp;\n\twhile(*apple != NULL) { ++apple; }\n\t++apple;\n\n\t// set up random value for stack canary\n\t__guard_setup(apple);\n\n#if DYLD_INITIALIZER_SUPPORT\n\t// run all C++ initializers inside dyld\n    //初始化 在dyld中的 所有的C++构造器\n\trunDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);\n#endif\n\n\t// now that we are done bootstrapping dyld, call dyld's main\n    //至此bootstrap dyld已经全部完成，调用 dyld 的 main 函数\n\tuintptr_t appsSlide = slideOfMainExecutable(appsMachHeader);\n\treturn dyld::   _main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);\n}\n```\n\n`dyld::start`的函数分为以下几步骤：\n1. <span id=\"return_rebaseDyld\">rebase dyld本身</span>\n[rebase dyld](#jump_rebaseDyld)\n2. 初始化进程间通讯 mach_msg\n\t直接调用<mach/mach_init.h>内的某个内核调用\n3. 初始化环境变量\n\t从调用参数中拿到apple指针，内核会把这个指针紧跟在envp的数组最后\n4. 设置栈保护\n\t从第三步拿到的apple指针中找到“stack_guard=xx”的字符串，自定义重置栈保护\n5. <span id=\"return_runDyldInitializers\">初始化 dyld 中的所有构造器函数</span>\n\t因为dyld本身是一个动态库，我们知道，动态库是共享的，但是共享的只是代码段(PIC 位置无关代码)。在内核给每一个进程的虚拟地址映射完dyld之后，dyld本身这个动态库的数据段是没有初始化的，需要自己做自己的初始化。[具体代码看这里](#jump_runDyldInitializers)\n6. 前五步已经完成 dyld 的自启动(bootstrap)，后面就是进入真正的 dyld main函数。\n\n这里可以总结一下，start的工作内容主要是一些全局环境，以及dyld自身的初始化。\n\n[开始 分析 dyld 的_main函数](#jump__main)\n\n### <span id=\"jump_rebaseDyld\">RebaseDyld</span>\n因为Dyld也是一个动态库，和普通的动态库一样，会在mach_o的load_command中指定要求需要加载到某个虚拟地址下。但是内核还是会对dyld做地址随机偏移，如果是这样，dyld需要修复数据段的数据。\n\n1. 找到Load_Commands中 __LINKEDIT 和 LC_DYLD_INFO_ONLY 两段，__LINKEDIT段内包含了链接信息，符号表，动态符号表等等，而LC_DYLD_INFO_ONLY内标明了：Rebase,Bind,WeakBind,LazyBind,Export 这个5类，而这5类都会存储在Dynamic Loader Info这一节中。\n2. 根据rebase 和 bind 的 Opcodes等，循环进行。\n\n在后文rebase/bind 可执行文件依赖的动态库时，会进行详细说明。\n\n[回去继续](#return_rebaseDyld)\n\n### <span id=\"jump_runDyldInitializers\">初始化Dyld的构造器函数</span>\n\n```cpp\nextern const Initializer  inits_start  __asm(\"section$start$__DATA$__mod_init_func\");\nextern const Initializer  inits_end    __asm(\"section$end$__DATA$__mod_init_func\");\n\n//\n// For a regular executable, the crt code calls dyld to run the executables initializers.\n// For a static executable, crt directly runs the initializers.\n// dyld (should be static) but is a dynamic executable and needs this hack to run its own initializers.\n// We pass argc, argv, etc in case libc.a uses those arguments\n//\nstatic void runDyldInitializers(const struct macho_header* mh, intptr_t slide, int argc, const char* argv[], const char* envp[], const char* apple[])\n{\n\tfor (const Initializer* p = &inits_start; p < &inits_end; ++p) {\n\t\t(*p)(argc, argv, envp, apple);\n\t}\n}\n```\n\n在dyld的该方法的注释上，苹果写的很清楚：对于常规的可执行文件，crt代码会通过调用dyld来初始化这个可执行文件的初始化构造器。但是对于静态可执行文件，crt会自己去执行初始化。dyld可以认为是“静态”的，但是本质是一个动态库，所以需要自己来初始化自己，但是苹果称之为hack的方式。\n\n实际上这是一段内联汇编，`__asm(\"section$start$__DATA$__mod_init_func\")`意思是：获取`__DATA`段`__mod_init_func`的起始地址，当然下面那行就是获取结束地址了。\n\n在Demo代码中加入两个构造器：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/81503ddc20aec519b01d09370a4d1628.png)\n\n然后再看这个mach-o 文件：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d61a14b2aeeb66a2eea1be2d8be6b85f.png)\n\n可以看到在数据段增加了一节`__mod_init_func`,编译期会把所有构造器的函数地址，都放在这节中。例如这个Section中第一个地址存储的是demo_init1的函数地址，去掉虚拟起始地址，文件内偏移地址就是0xED0：\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/9ac92176b89d0c92d76d1d98ecddd5f4.png)\n\n可以直接验证确实是这个函数，`demo_init2`也是如此。\n\n回过头来看，dyld的代码：这个`inits_start`中就是构造器列表中第一个构造器的函数地址了。`inits_end`就是结束地址，循环即可依次按照约定，初始化dyld自己内部的所有构造器函数了。\n\n在dyld的内部还会有很多诸如此类的用法。\n具体可以看[参考文献](#jump_end)中 1 和 2\n\n[回去继续](#return_runDyldInitializers)\n\n## <span id=\"jump__main\">dyld::_main函数</span>\n在dyld自身的rebase和bind、mach_msg初始化、环境变量初始化、构造函数初始化全部完成之后，开始dyld的真正工作内容，`dyld::_main` 函数。\n\n`dyld::_main`函数最终是返回了主进程App可执行文件的main函数入口，并且由`dyld::start`函数再返回给调用它的`__dyld_start`这个汇编函数，最终由最开始的这个汇编函数，准备好调用参数之后，直接调用我们所熟悉的可执行文件的main函数。\n\n这个_main函数很长，我们只看步骤。\n\n1. 进入函数的最开始是对环境变量的初始化加载和控制，例如 crashlog，环境变量控制log，主进程可执行文件路径...\n2. 加载共享缓存。`// iOS cannot run without shared region`,iOS必须开启共享共享缓存。\n\t在所有libpath中搜索不到对应名字的动态库的时候，就会尝试从共享缓存中找。（当然这里为了便于理解，只是简单这样描述，实际的搜索方式远比这个要复杂）\n3. <span id=\"return_initMainExecutable\">实例化可执行文件:</span>\n\t实例化可执行程序，生成`ImageLoaderMachO`对象。[实例化主程序](#jump_initMainExecutable)\n\t实例化可执行文件有两种（Classic和Compressed），分别由`ImageLoaderMachOCompressed`和`ImageLoaderMachOClassic`来创建可执行文件对象，这两者均继承于`ImageLoaderMachO`。\n4. 加载从参数插入的动态库`loadInsertedDylib`，只做加载，不做链接。[Load 插入的动态库](#jump_loaddylib)<span id=\"return_loaddylib\">.</span>\n5. <span id=\"return_link_execution\">链接可执行程序。</span>[链接可执行程序](#jump_link_execution)\n6. 链接从参数插入的动态库。\n7. 从可执行文件，递归开始调用初始化。\n\n### <span id=\"jump_initMainExecutable\">实例化主程序</span>\n在dyld获得控制权之前，内核已经把可执行文件映射到了某个线性地址空间了，所以dyld可以直接获取到 macho_header，dyld会为可执行文件创建一个ImageLoader实例对象，每一个MachO在dyld中都会有一个这个对象与之对应。\n\n```cpp\nstatic ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)\n{\n\t// try mach-o loader\n\tif ( isCompatibleMachO((const uint8_t*)mh, path) ) {\n\t\tImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);\n\t\taddImage(image);\n\t\treturn (ImageLoaderMachO*)image;\n\t}\n\t\n\tthrow \"main executable not a known format\";\n}\n```\n\n`instantiateMainExecutable`这个方法内还会根据不同的mach-o类型(compress 或者 classic)来返回ImageLoader的不同实现的子类对象。\n\n`addImage(image);`这个函数有两个作用：\n1. 把生成的镜像实例（ImageLoader）加入到一个全局镜像容器`sAllImages`内。之后加载的所有动态库都会被加入这个容器。\n2. 把可执行文件的每一个段所占据的实际线性地址范围，映射到一个全局链表 `sMappedRangesStart`内，而这个全局链表的作用就是为了能够快速的通过 地址 反向获取到对应的`ImageLoader`。\n\n[回去继续](#return_initMainExecutable)\n\n### <span id=\"jump_loaddylib\">加载动态库</span>\n这一步循环遍历DYLD_INSERT_LIBRARIES环境变量中指定的动态库列表，并调用loadInsertedDylib()将其加载。\n\n该函数调用load()完成加载工作。load()会调用loadPhase0()尝试从文件加载，loadPhase0()会向下调用下一层phase来查找动态库的路径，直到loadPhase6()，查找的顺序为DYLD_ROOT_PATH->LD_LIBRARY_PATH->DYLD_FRAMEWORK_PATH->原始路径->DYLD_FALLBACK_LIBRARY_PATH。\n\n找到后调用ImageLoaderMachO::instantiateFromFile()来实例化一个 ImageLoader，之后调用 checkandAddImage() 验证映像并将其加入到全局镜像列表中。\n\n如果loadPhase0()返回为空，表示在路径中没有找到动态库，就尝试从共享缓存中查找，找到就调用ImageLoaderMachO::instantiateFromCache()从缓存中加载。\n\n否则就抛出没找到镜像的异常。\n\n看加载动态库部分的源代码：\n```cpp\n// map in file and instantiate an ImageLoader\n// 映射某个动态库文件并且实例化一个ImagerLoader\nstatic ImageLoader* loadPhase6(int fd, const struct stat& stat_buf, const char* path, const LoadContext& context)\n{\n\t//dyld::log(\"%s(%s)\\n\", __func__ , path);\n\tuint64_t fileOffset = 0;\n\tuint64_t fileLength = stat_buf.st_size;\n\n\t// validate it is a file (not directory)\n\tif ( (stat_buf.st_mode & S_IFMT) != S_IFREG ) \n\t\tthrow \"not a file\";\n\n\tuint8_t firstPages[MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE];\n\tuint8_t *firstPagesPtr = firstPages;\n\tbool shortPage = false;\n\t\n\t// min mach-o file is 4K\n\t// 最小的mach-o文件就是4k（保证一个页框大小）\n\tif ( fileLength < 4096 ) {\n\t\tif ( pread(fd, firstPages, (size_t)fileLength, 0) != (ssize_t)fileLength )\n\t\t\tthrowf(\"pread of short file failed: %d\", errno);\n\t\tshortPage = true;\n\t} \n\telse {\n\t\t// optimistically read only first 4KB\n\t\t// 优先读取header文件的4kb，因为一个分页最小是4k。\n\t\tif ( pread(fd, firstPages, 4096, 0) != 4096 )\n\t\t\tthrowf(\"pread of first 4K failed: %d\", errno);\n\t}\n\t\n\t// if fat wrapper, find usable sub-file\n\t// 如果这个动态库是个fat文件，就直接找到合适的“子文件”\n\tconst fat_header* fileStartAsFat = (fat_header*)firstPages;\n\tif ( fileStartAsFat->magic == OSSwapBigToHostInt32(FAT_MAGIC) ) {\n\t\tif ( OSSwapBigToHostInt32(fileStartAsFat->nfat_arch) > ((4096 - sizeof(fat_header)) / sizeof(fat_arch)) )\n\t\t\tthrowf(\"fat header too large: %u entries\", OSSwapBigToHostInt32(fileStartAsFat->nfat_arch));\n\t\tif ( fatFindBest(fileStartAsFat, &fileOffset, &fileLength) ) {\n\t\t\tif ( (fileOffset+fileLength) > (uint64_t)(stat_buf.st_size) )\n\t\t\t\tthrowf(\"truncated fat file.  file length=%llu, but needed slice goes to %llu\", stat_buf.st_size, fileOffset+fileLength);\n\t\t\tif (pread(fd, firstPages, 4096, fileOffset) != 4096)\n\t\t\t\tthrowf(\"pread of fat file failed: %d\", errno);\n\t\t}\n\t\telse {\n\t\t\tthrow \"no matching architecture in universal wrapper\";\n\t\t}\n\t}\n\t\n\t// try mach-o loader\n\tif ( shortPage ) \n\t\tthrow \"file too short\";\n\n\tif ( isCompatibleMachO(firstPages, path) ) {\n\n\t\t// only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded\n\t\tconst mach_header* mh = (mach_header*)firstPages;\n\t\tswitch ( mh->filetype ) {\n\t\t\tcase MH_EXECUTE:\n\t\t\tcase MH_DYLIB:\n\t\t\tcase MH_BUNDLE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow \"mach-o, but wrong filetype\";\n\t\t}\n\n\t\tuint32_t headerAndLoadCommandsSize = sizeof(macho_header) + mh->sizeofcmds;\n\t\tif ( headerAndLoadCommandsSize > MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE )\n\t\t\tthrowf(\"malformed mach-o: load commands size (%u) > %u\", headerAndLoadCommandsSize, MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE);\n\n\t\tif ( headerAndLoadCommandsSize > fileLength )\n\t\t\tdyld::throwf(\"malformed mach-o: load commands size (%u) > mach-o file size (%llu)\", headerAndLoadCommandsSize, fileLength);\n\n\t\tif ( headerAndLoadCommandsSize > 4096 ) {\n\t\t\t// read more pages\n\t\t\t// 如果 head 和 LC_COMMANDS的大小大于已读取的4096，那么就继续把 headerAndLoadCommandsSize 读完\n\t\t\tunsigned readAmount = headerAndLoadCommandsSize - 4096;\n\t\t\tif ( pread(fd, &firstPages[4096], readAmount, fileOffset+4096) != readAmount )\n\t\t\t\tthrowf(\"pread of extra load commands past 4KB failed: %d\", errno);\n\t\t}\n\n#if TARGET_IPHONE_SIMULATOR\t\n\t\t// <rdar://problem/14168872> dyld_sim should restrict loading osx binaries\n\t\tif ( !isSimulatorBinary(firstPages, path) ) {\n\t#if TARGET_OS_WATCH\n\t\t\tthrow \"mach-o, but not built for watchOS simulator\";\n\t#elif TARGET_OS_TV\n\t\t\tthrow \"mach-o, but not built for tvOS simulator\";\n\t#else\n\t\t\tthrow \"mach-o, but not built for iOS simulator\";\n\t#endif\n\t\t}\n#endif\n\n#if __MAC_OS_X_VERSION_MIN_REQUIRED\n\t\tif ( gLinkContext.marzipan ) {\n\t\t\tconst dyld3::MachOFile* mf = (dyld3::MachOFile*)firstPages;\n\t\t\tbool isiOSMacBinary = mf->supportsPlatform(dyld3::Platform::iOSMac) || iOSMacWhiteListed(path);\n\t\t\tbool isProhibitedMacOSBinary = !isiOSMacBinary && iOSMacBlackListed(path);\n\t\t\tif ( (context.enforceIOSMac && !isiOSMacBinary) || isProhibitedMacOSBinary ) {\n\t\t\t\tthrow \"mach-o, but not built for iOSMac\";\n\t\t\t}\n\t\t}\n#endif\n\n#if __arm64e__\n\t\tif ( (sMainExecutableMachHeader->cpusubtype == CPU_SUBTYPE_ARM64_E) && (mh->cpusubtype != CPU_SUBTYPE_ARM64_E) )\n\t\t\tthrow \"arm64 dylibs cannot be loaded into arm64e processes\";\n#endif\n\t\tImageLoader* image = nullptr;\n\t\t{\n\t\t\tdyld3::ScopedTimer timer(DBG_DYLD_TIMING_MAP_IMAGE, path, 0, 0);\n\t\t\t//调用 instantiateFromFile 来实例化 ImageLoader\n\t\t\timage = ImageLoaderMachO::instantiateFromFile(path, fd, firstPagesPtr, headerAndLoadCommandsSize, fileOffset, fileLength, stat_buf, gLinkContext);\n\t\t\ttimer.setData4((uint64_t)image->machHeader());\n\t\t}\n\t\t\n\t\t// validate\n\t\t// 加入全局链表\n\t\treturn checkandAddImage(image, context);\n\t}\n\t\n\t// try other file formats here...\n\t\n\t\n\t// throw error about what was found\n\tswitch (*(uint32_t*)firstPages) {\n\t\tcase MH_MAGIC:\n\t\tcase MH_CIGAM:\n\t\tcase MH_MAGIC_64:\n\t\tcase MH_CIGAM_64:\n\t\t\tthrow \"mach-o, but wrong architecture\";\n\t\tdefault:\n\t\tthrowf(\"unknown file type, first eight bytes: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\", \n\t\t\tfirstPages[0], firstPages[1], firstPages[2], firstPages[3], firstPages[4], firstPages[5], firstPages[6],firstPages[7]);\n\t}\n}\n```\n\n这部分的主要任务就是，从本地文件中加载指定的动态库，并且返回`ImageLoader`实例对象。\n\n步骤如下：\n1. 优先读取这个文件的4k，因为一个分页最小是4k,并且解析为 fat_header。\n2. 如果这个动态库是个fat文件，就直接找到合适CPU架构的“子文件”\n3. 检查文件类型，大小等。\n4. 如果 head 和 Load_Commands 的大小大于已读取的4k，那么就继续把剩下的 headerAndLoadCommandsSize 读完，实例化`ImageLoader`。因为实例化`ImageLoader`需要整个 Load_Commands 部分。\n5. checkandAddImage。\n\n\n再来看 checkandAddImage：\n```cpp\nstatic ImageLoader* checkandAddImage(ImageLoader* image, const LoadContext& context)\n{\n\t// now sanity check that this loaded image does not have the same install path as any existing image\n\t// 在sAllImages 中检查一下，是否有同样路径的动态库，如果有，则返回链表中原有的那个镜像\n\tconst char* loadedImageInstallPath = image->getInstallPath();\n\tif ( image->isDylib() && (loadedImageInstallPath != NULL) && (loadedImageInstallPath[0] == '/') ) {\n\t\tfor (std::vector<ImageLoader*>::iterator it=sAllImages.begin(); it != sAllImages.end(); it++) {\n\t\t\tImageLoader* anImage = *it;\n\t\t\tconst char* installPath = anImage->getInstallPath();\n\t\t\tif ( installPath != NULL) {\n\t\t\t\tif ( strcmp(loadedImageInstallPath, installPath) == 0 ) {\n\t\t\t\t\t//dyld::log(\"duplicate(%s) => %p\\n\", installPath, anImage);\n\t\t\t\t\tremoveImage(image);\n\t\t\t\t\tImageLoader::deleteImage(image);\n\t\t\t\t\treturn anImage;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// some API's restrict what they can load\n\tif ( context.mustBeBundle && !image->isBundle() )\n\t\tthrow \"not a bundle\";\n\tif ( context.mustBeDylib && !image->isDylib() )\n\t\tthrow \"not a dylib\";\n\n\t// regular main executables cannot be loaded \n\tif ( image->isExecutable() ) {\n\t\tif ( !context.canBePIE || !image->isPositionIndependentExecutable() )\n\t\t\tthrow \"can't load a main executable\";\n\t}\n\t\n\t// don't add bundles to global list, they can be loaded but not linked.  When linked it will be added to list\n\tif ( ! image->isBundle() )\n\t\t//加入全局链表中\n\t\taddImage(image);\n\t\n\treturn image;\n}\n```\n\n代码很简单，判断这个路径的动态库是不是已经在全局链表中了，已经在的话就直接返回，否则就`AddImage`\n\n[返回继续](#return_loaddylib)\n\n### <span id=\"jump_link_execution\">Link 可执行文件</span>\n标题是链接可执行文件，但是因为这是一个递归操作，所以这一节主要是讲述dyld如何链接所有的动态库。\n\n`void link(ImageLoader* image, bool forceLazysBound, bool neverUnload, const ImageLoader::RPathChain& loaderRPaths, unsigned cacheIndex)`\n\n上面是这个函数的方法签名，在_main的执行过程中，首先是可执行文件的 mach-o 镜像 调用，其次紧跟着的是环境变量中插入的动态库会依次调用，这个函数内部最终还是调用到了 `ImageLoader.link`函数\n\n```cpp\nvoid ImageLoader::link(const LinkContext& context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain& loaderRPaths, const char* imagePath)\n{\n\t//dyld::log(\"ImageLoader::link(%s) refCount=%d, neverUnload=%d\\n\", imagePath, fDlopenReferenceCount, fNeverUnload);\n\t\n\t// clear error strings\n\t(*context.setErrorStrings)(0, NULL, NULL, NULL);\n\n\tuint64_t t0 = mach_absolute_time();\n\tthis->recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);\n\tcontext.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);\n\n\t// we only do the loading step for preflights\n\tif ( preflightOnly )\n\t\treturn;\n\n\tuint64_t t1 = mach_absolute_time();\n\tcontext.clearAllDepths();\n\tthis->recursiveUpdateDepth(context.imageCount());\n\n\t__block uint64_t t2, t3, t4, t5;\n\t{\n\t\tdyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, 0, 0, 0);\n\t\tt2 = mach_absolute_time();\n\t\tthis->recursiveRebase(context);\n\t\tcontext.notifyBatch(dyld_image_state_rebased, false);\n\n\t\tt3 = mach_absolute_time();\n\t\tif ( !context.linkingMainExecutable )\n\t\t\tthis->recursiveBindWithAccounting(context, forceLazysBound, neverUnload);\n\n\t\tt4 = mach_absolute_time();\n\t\tif ( !context.linkingMainExecutable )\n\t\t\tthis->weakBind(context);\n\t\tt5 = mach_absolute_time();\n\t}\n\n    if ( !context.linkingMainExecutable )\n        context.notifyBatch(dyld_image_state_bound, false);\n\tuint64_t t6 = mach_absolute_time();\t\n\n\tstd::vector<DOFInfo> dofs;\n\tthis->recursiveGetDOFSections(context, dofs);\n\tcontext.registerDOFs(dofs);\n\tuint64_t t7 = mach_absolute_time();\t\n\n\t// interpose any dynamically loaded images\n\tif ( !context.linkingMainExecutable && (fgInterposingTuples.size() != 0) ) {\n\t\tdyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0);\n\t\tthis->recursiveApplyInterposing(context);\n\t}\n\n\t// clear error strings\n\t(*context.setErrorStrings)(0, NULL, NULL, NULL);\n\n\t//计算时间，控制log输出\n\tfgTotalLoadLibrariesTime += t1 - t0;\n\tfgTotalRebaseTime += t3 - t2;\n\tfgTotalBindTime += t4 - t3;\n\tfgTotalWeakBindTime += t5 - t4;\n\tfgTotalDOF += t7 - t6;\n\t\n\t// done with initial dylib loads\n\tfgNextPIEDylibAddress = 0;\n}\n```\n\n链接函数的操作思路很清晰：\n1. `this->recursiveLoadLibraries` 递归加载依赖的所有动态库 (这里仅仅是Load，Load包含open文件以及实例化ImageLoader)，最终的结果和Load通过参数插入的动态库一样。\n2. `this->recursiveUpdateDepth` 递归刷新依赖库的层级\n3. <span id=\"return_rebase\">`this->recursiveRebase`</span>\n\t每一个动态库的递归rebase无非就是再次依次调用，当前动态库所依赖的其他动态库的recursiveRebase。真正rebase是在`rebase(const LinkContext& context, uintptr_t slide)`。[Rebase](#jump_rebase)\n4. `this->recursiveBindWithAccounting`\n\t这里就是经典的non-lazy bind和lazy bind了。和Rebase的代码结构类似，真正的rebind是在`doBind(const LinkContext& context, bool forceLazysBound)`。\n5. `this->weakBind` 弱符号绑定\n6. `this->recursiveGetDOFSections` 注册DOF节\n7. `this->recursiveApplyInterposing`\n\n其中每一个步骤都会有一个时间戳，用来根据可控的环境变量来输出log。\n\n### <span id=\"jump_rebase\">Rebase</span>\n首先解释一下 Rebase ：\n\n都知道，Rebase是调整动态库内部的符号，因为ASLR，内核加载的时候会在随机的地址中映射动态库。一开始我的想法是，mach-o的动态库在编译期已经做了PIC（地址无关代码），为什么还会有\"rebase\"这个过程？\n\n事实上PIC确实存在，但是rebase也是必须的。\n\n举个例子：在动态库/可执行文件 初始化 的过程中有一个步骤是构造器初始化(这个步骤本文也有具体说明)，而实现这个这个步骤的，实际上是在mach-o的数据段中有一个名为`__mod_init_func`的段，而这个段存储的指针数组就是构造器初始化函数的地址。说到这就比较明显了，在dyld 寻找构造器初始化地址指针的时候，已经不再是以数据段中的vmaddr为基准了，而是需要加上一个偏移 -- slide。\n\n下面就按照上面例子，看看代码中是如何实现这一步骤的，compressed mach-o(现代版本的好像几乎都是这个压缩的mach-o格式了) 在这一节上做了压缩，因此实现都在`ImageLoaderMachOCompressed`中。\n\n先分析一下 rebase 这一节在mach-o内的数据结构\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/ffdc0da28d16d220f66e8d638a7d5198.png)\n\n每一个 rebase 信息都由若干个 操作码 -- 操作数 来描述，每一个记录都包含两个元素（opcode 和 immediate），可以理解为一个操作码，一个是操作数，这两个都可以通过掩码来获取。\n\n以第一个为例：\nREBASE_OPCODE_TYPE_IMM == 11:标识操作数是一个Type，而Type是个指针\nREBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB == 22:当前rebase的数据在第2个segment，并且偏移是用uleb表示\nuleb128 == 24:上面提到的uleb值\nREBASE_OPCODE_DO_REBASE_IMM_TIMES == 2:当前rebase操作执行2次。\n\n总结：在第2个段开始往后偏移24个字节的指针地址，连续执行两次rebase。\n\n再看看：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/69f3c8a3511f6c75d8798c62db21d597.png)\n\n0是起始段，那么第2段就是数据段。我们再找，段的文件偏移 0x3000 + 偏移 24 =0x3018 。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/8479e0316c7f0447ff14dd0a1b98ed69.png)\n\n没错，就是这两个构造器，并且当前节就是`__mod_init_func`~。\n\n下面是rebase的源码，当然在本例中有些 操作码 和 操作数 并没有用到。\n```cpp\nvoid ImageLoaderMachOCompressed::rebase(const LinkContext& context, uintptr_t slide)\n{\n\tCRSetCrashLogMessage2(this->getPath());\n\t// fLinkEditBase 是__LINKEDIT段在 内存实际偏移与预期偏移 的 差值 （== slide？）\n\t// start 的值是 rebase信息在内存中的实际起始地址\n\tconst uint8_t* const start = fLinkEditBase + fDyldInfo->rebase_off;\n\t// end 的值是 rebase信息在内存中的实际结束地址\n\tconst uint8_t* const end = &start[fDyldInfo->rebase_size];\n\tconst uint8_t* p = start;\n\n\ttry {\n\t\tuint8_t type = 0;\n\t\tint segmentIndex = 0;\n\t\tuintptr_t address = segActualLoadAddress(0);\n\t\tuintptr_t segmentStartAddress = segActualLoadAddress(0);//第N个段地址的实际开始地址\n\t\tuintptr_t segmentEndAddress = segActualEndAddress(0);//第N个段的实际结束地址\n\t\tuintptr_t count;\n\t\tuintptr_t skip;\n\t\tbool done = false;\n\t\twhile ( !done && (p < end) ) {\n\t\t\tuint8_t immediate = *p & REBASE_IMMEDIATE_MASK;\n\t\t\tuint8_t opcode = *p & REBASE_OPCODE_MASK;\n\t\t\t++p;\n\t\t\tswitch (opcode) {\n\t\t\t\tcase REBASE_OPCODE_DONE:\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_SET_TYPE_IMM:\n\t\t\t\t\ttype = immediate;\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\t\t\tsegmentIndex = immediate;\n\t\t\t\t\tif ( segmentIndex >= fSegmentsCount )\n\t\t\t\t\t\tdyld::throwf(\"REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is too large (0..%d)\",\n\t\t\t\t\t\t\t\tsegmentIndex, fSegmentsCount-1);\n\t\t\t#if TEXT_RELOC_SUPPORT\n\t\t\t\t\tif ( !segWriteable(segmentIndex) && !segHasRebaseFixUps(segmentIndex) && !segHasBindFixUps(segmentIndex) )\n\t\t\t#else\n\t\t\t\t\tif ( !segWriteable(segmentIndex) )\n\t\t\t#endif\n\t\t\t\t\t\tdyld::throwf(\"REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is not a writable segment (%s)\",\n\t\t\t\t\t\t\t\tsegmentIndex, segName(segmentIndex));\n\t\t\t\t\t//读取当前段的实际开始和结束地址\n\t\t\t\t\tsegmentStartAddress = segActualLoadAddress(segmentIndex);\n\t\t\t\t\tsegmentEndAddress = segActualEndAddress(segmentIndex);\n\t\t\t\t\t\n\t\t\t\t\taddress = segmentStartAddress + read_uleb128(p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_ADD_ADDR_ULEB:\n\t\t\t\t\taddress += read_uleb128(p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_ADD_ADDR_IMM_SCALED:\n\t\t\t\t\taddress += immediate*sizeof(uintptr_t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_DO_REBASE_IMM_TIMES:\n\t\t\t\t\tfor (int i=0; i < immediate; ++i) {//循环N次\n\t\t\t\t\t\tif ( (address < segmentStartAddress) || (address >= segmentEndAddress) )\n\t\t\t\t\t\t\tthrowBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);\n\t\t\t\t\t\trebaseAt(context, address, slide, type);\n\t\t\t\t\t\taddress += sizeof(uintptr_t);\n\t\t\t\t\t}\n\t\t\t\t\tfgTotalRebaseFixups += immediate;\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_DO_REBASE_ULEB_TIMES:\n\t\t\t\t\tcount = read_uleb128(p, end);\n\t\t\t\t\tfor (uint32_t i=0; i < count; ++i) {\n\t\t\t\t\t\tif ( (address < segmentStartAddress) || (address >= segmentEndAddress) )\n\t\t\t\t\t\t\tthrowBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);\n\t\t\t\t\t\trebaseAt(context, address, slide, type);\n\t\t\t\t\t\taddress += sizeof(uintptr_t);\n\t\t\t\t\t}\n\t\t\t\t\tfgTotalRebaseFixups += count;\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB:\n\t\t\t\t\tif ( (address < segmentStartAddress) || (address >= segmentEndAddress) )\n\t\t\t\t\t\tthrowBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);\n\t\t\t\t\trebaseAt(context, address, slide, type);\n\t\t\t\t\taddress += read_uleb128(p, end) + sizeof(uintptr_t);\n\t\t\t\t\t++fgTotalRebaseFixups;\n\t\t\t\t\tbreak;\n\t\t\t\tcase REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\t\t\tcount = read_uleb128(p, end);\n\t\t\t\t\tskip = read_uleb128(p, end);\n\t\t\t\t\tfor (uint32_t i=0; i < count; ++i) {\n\t\t\t\t\t\tif ( (address < segmentStartAddress) || (address >= segmentEndAddress) )\n\t\t\t\t\t\t\tthrowBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);\n\t\t\t\t\t\trebaseAt(context, address, slide, type);\n\t\t\t\t\t\taddress += skip + sizeof(uintptr_t);\n\t\t\t\t\t}\n\t\t\t\t\tfgTotalRebaseFixups += count;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdyld::throwf(\"bad rebase opcode %d\", *(p-1));\n\t\t\t}\n\t\t}\n\t}\n\tcatch (const char* msg) {\n\t\tconst char* newMsg = dyld::mkstringf(\"%s in %s\", msg, this->getPath());\n\t\tfree((void*)msg);\n\t\tthrow newMsg;\n\t}\n\tCRSetCrashLogMessage2(NULL);\n}\n```\n## <span id=\"jump_init_main_execution\">initializeMainExecutable</span>\n其实到这里动态库的加载/rebase/bind...都已经完成了，而这一步要做的就是初始化构造器函数了，这里也就是runtime初始化的过程。\n\n```cpp\nvoid initializeMainExecutable()\n{\n\t// record that we've reached this step\n\tgLinkContext.startedInitializingMainExecutable = true;\n\n\t// run initialzers for any inserted dylibs\n\tImageLoader::InitializerTimingList initializerTimes[allImagesCount()];\n\tinitializerTimes[0].count = 0;\n\tconst size_t rootCount = sImageRoots.size();\n\tif ( rootCount > 1 ) {\n\t\tfor(size_t i=1; i < rootCount; ++i) {\n\t\t\tsImageRoots[i]->runInitializers(gLinkContext, initializerTimes[0]);\n\t\t}\n\t}\n\t\n\t// run initializers for main executable and everything it brings up \n\tsMainExecutable->runInitializers(gLinkContext, initializerTimes[0]);\n\t\n\t// register cxa_atexit() handler to run static terminators in all loaded images when this process exits\n\tif ( gLibSystemHelpers != NULL ) \n\t\t(*gLibSystemHelpers->cxa_atexit)(&runAllStaticTerminators, NULL, NULL);\n\n\t// dump info if requested\n\tif ( sEnv.DYLD_PRINT_STATISTICS )\n\t\tImageLoader::printStatistics((unsigned int)allImagesCount(), initializerTimes[0]);\n\tif ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )\n\t\tImageLoaderMachO::printStatisticsDetails((unsigned int)allImagesCount(), initializerTimes[0]);\n}\n\n```\n\n优先初始化插入的动态库，再初始化可执行文件。\n\nsMainExecutable->runInitializers 函数：\n```cpp\nvoid ImageLoader::runInitializers(const LinkContext& context, InitializerTimingList& timingInfo)\n{\n\tuint64_t t1 = mach_absolute_time();\n\tmach_port_t thisThread = mach_thread_self();\n\tImageLoader::UninitedUpwards up;\n\tup.count = 1;\n\tup.images[0] = this;\n\tprocessInitializers(context, thisThread, timingInfo, up);\n\tcontext.notifyBatch(dyld_image_state_initialized, false);\n\tmach_port_deallocate(mach_task_self(), thisThread);\n\tuint64_t t2 = mach_absolute_time();\n\tfgTotalInitTime += (t2 - t1);\n}\n```\nprocessInitializers 函数：\n```cpp\nvoid ImageLoader::processInitializers(const LinkContext& context, mach_port_t thisThread,\n\t\t\t\t\t\t\t\t\t InitializerTimingList& timingInfo, ImageLoader::UninitedUpwards& images)\n{\n\tuint32_t maxImageCount = context.imageCount()+2;\n\tImageLoader::UninitedUpwards upsBuffer[maxImageCount];\n\tImageLoader::UninitedUpwards& ups = upsBuffer[0];\n\tups.count = 0;\n\t// Calling recursive init on all images in images list, building a new list of\n\t// uninitialized upward dependencies.\n\tfor (uintptr_t i=0; i < images.count; ++i) {\n\t\timages.images[i]->recursiveInitialization(context, thisThread, images.images[i]->getPath(), timingInfo, ups);\n\t}\n\t// If any upward dependencies remain, init them.\n\tif ( ups.count > 0 )\n\t\tprocessInitializers(context, thisThread, timingInfo, ups);\n}\n```\n\nrecursiveInitialization 函数：\n```cpp\nvoid ImageLoader::recursiveInitialization(const LinkContext& context, mach_port_t this_thread, const char* pathToInitialize,\n\t\t\t\t\t\t\t\t\t\t  InitializerTimingList& timingInfo, UninitedUpwards& uninitUps)\n{\n\trecursive_lock lock_info(this_thread);\n\trecursiveSpinLock(lock_info);\n\n\tif ( fState < dyld_image_state_dependents_initialized-1 ) {\n\t\tuint8_t oldState = fState;\n\t\t// break cycles\n\t\tfState = dyld_image_state_dependents_initialized-1;\n\t\ttry {\n\t\t\t// initialize lower level libraries first\n\t\t\tfor(unsigned int i=0; i < libraryCount(); ++i) {\n\t\t\t\tImageLoader* dependentImage = libImage(i);\n\t\t\t\tif ( dependentImage != NULL ) {\n\t\t\t\t\t// don't try to initialize stuff \"above\" me yet\n\t\t\t\t\tif ( libIsUpward(i) ) {\n\t\t\t\t\t\tuninitUps.images[uninitUps.count] = dependentImage;\n\t\t\t\t\t\tuninitUps.count++;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( dependentImage->fDepth >= fDepth ) {\n\t\t\t\t\t\tdependentImage->recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);\n\t\t\t\t\t}\n                }\n\t\t\t}\n\t\t\t\n\t\t\t// record termination order\n\t\t\tif ( this->needsTermination() )\n\t\t\t\tcontext.terminationRecorder(this);\n\t\t\t\n\t\t\t// let objc know we are about to initialize this image\n\t\t\tuint64_t t1 = mach_absolute_time();\n\t\t\tfState = dyld_image_state_dependents_initialized;\n\t\t\toldState = fState;\n\t\t\tcontext.notifySingle(dyld_image_state_dependents_initialized, this, &timingInfo);\n\t\t\t\n\t\t\t// initialize this image\n\t\t\tbool hasInitializers = this->doInitialization(context);\n\n\t\t\t// let anyone know we finished initializing this image\n\t\t\tfState = dyld_image_state_initialized;\n\t\t\toldState = fState;\n\t\t\tcontext.notifySingle(dyld_image_state_initialized, this, NULL);\n\t\t\t\n\t\t\tif ( hasInitializers ) {\n\t\t\t\tuint64_t t2 = mach_absolute_time();\n\t\t\t\ttimingInfo.addTime(this->getShortName(), t2-t1);\n\t\t\t}\n\t\t}\n\t\tcatch (const char* msg) {\n\t\t\t// this image is not initialized\n\t\t\tfState = oldState;\n\t\t\trecursiveSpinUnLock();\n\t\t\tthrow;\n\t\t}\n\t}\n\t\n\trecursiveSpinUnLock();\n}\n```\n\ndoInitialization 函数：\n```cpp\nbool ImageLoaderMachO::doInitialization(const LinkContext& context)\n{\n\tCRSetCrashLogMessage2(this->getPath());\n\n\t// mach-o has -init and static initializers\n\tdoImageInit(context);\n\tdoModInitFunctions(context);\n\t\n\tCRSetCrashLogMessage2(NULL);\n\t\n\treturn (fHasDashInit || fHasInitializers);\n}\n```\n\n最终调到 doModInitFunctions 函数，实现逻辑和上文提到的dyld的自身的初始化一样，遍历调用_mod_init_func中的方法指针。\n\nruntime就是在这里被初始化的，调试一下就可以看到:\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/6880c3f245ce10b72f214d8851b959e5.png)\n\n调用栈和上面描述的一样，最终由 libSystem.B.dylib -> libdispatch.dylib -> libobjc.A.dylib 这个调用顺序初始化了runtime。\n而runtime 的这个函数，在dyld反向注册了三个回调函数。\n`_dyld_objc_notify_register(&map_images, load_images, unmap_image);`\n\n而这个注册函数会把每个已经load完的镜像同步地回调给runtime：\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d26ee1e5057ed5fc0c63d13baac4b77b.png)\n\n从代码中我们也可以确认：\n```cpp\nvoid registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)\n{\n\t// record functions to call\n\tsNotifyObjCMapped\t= mapped;\n\tsNotifyObjCInit\t\t= init;\n\tsNotifyObjCUnmapped = unmapped;\n\n\t// call 'mapped' function with all images mapped so far\n\ttry {\n\t\tnotifyBatchPartial(dyld_image_state_bound, true, NULL, false, true);\n\t}\n\tcatch (const char* msg) {\n\t\t// ignore request to abort during registration\n\t}\n\n\t// <rdar://problem/32209809> call 'init' function on all images already init'ed (below libSystem)\n\tfor (std::vector<ImageLoader*>::iterator it=sAllImages.begin(); it != sAllImages.end(); it++) {\n\t\tImageLoader* image = *it;\n\t\tif ( (image->getState() == dyld_image_state_initialized) && image->notifyObjC() ) {\n\t\t\tdyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image->machHeader(), 0, 0);\n\t\t\t(*sNotifyObjCInit)(image->getRealPath(), image->machHeader());\n\t\t}\n\t}\n}\n```\n\n遍历 sAllImages ，回调给 `_dyld_objc_notify_init init`函数。runtime就可以根据mach-o的 class 有关的 section 开始初始化了。\n\n## <span id=\"jump_end\">参考文献</span>\n1. [内嵌汇编的一些黑科技：访问自身Mach-O、调用函数等](https://www.dllhook.com/post/249.html)\n2. [Mach-O脱壳技巧](https://paper.seebug.org/202/)\n3. [dyld详解](https://www.dllhook.com/post/238.html)\n4. [iOS 程序 main 函数之前发生了什么](http://blog.sunnyxx.com/2014/08/30/objc-pre-main/)\n5. [dylib动态库加载过程分析](https://feicong.github.io/2017/01/14/dylib/index.html)\n\n","slug":"11.dyld","published":1,"updated":"2022-07-28T13:38:40.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwo1000dp9c94e31e2ws","content":"<p>超长预警…….</p>\n<p>本文将会从dyld接管进程开始，超级详细的分析&#x2F;解释，dyld 是如何把若干个动态库“组装”在一起，在ASLR的影响下形成一个完整的可执行进程，以及objc的runtime如何在dyld的初始化过程中进行实例化。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"dyld-加载过程\"><a href=\"#dyld-加载过程\" class=\"headerlink\" title=\"dyld 加载过程\"></a>dyld 加载过程</h2><p>dyld的启动入口在 dyldStartup.s 文件的汇编代码中，代码入口说明了:在内核初始化完成进程，并且load 完可执行文件之后，把环境变量等参数压栈，并且调用dyld的入口函数<code>__dyld_start</code>，而这个函数则根据调用约定，准备完调用参数之后，就直接跳转到<code>dyld::start</code> 这个函数。</p>\n<p>接下来看<code>dyld::start</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">uintptr_t</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> macho_header* appsMachHeader, <span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span>* argv[], </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t<span class=\"type\">intptr_t</span> slide, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> macho_header* dyldsMachHeader,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t<span class=\"type\">uintptr_t</span>* startGlue)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class=\"line\">\t<span class=\"comment\">// we have to do this before using any global variables</span></span><br><span class=\"line\">    <span class=\"comment\">//获取内核对于dyld本身的动态偏移</span></span><br><span class=\"line\">    slide = <span class=\"built_in\">slideOfMainExecutable</span>(dyldsMachHeader);</span><br><span class=\"line\">    <span class=\"type\">bool</span> shouldRebase = slide != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( shouldRebase ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//rebase Dyld</span></span><br><span class=\"line\">        <span class=\"built_in\">rebaseDyld</span>(dyldsMachHeader, slide);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// allow dyld to use mach messaging</span></span><br><span class=\"line\">    <span class=\"comment\">//mach消息初始化。</span></span><br><span class=\"line\">\t<span class=\"built_in\">mach_init</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class=\"line\">    <span class=\"comment\">//环境变量</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>** envp = &amp;argv[argc+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>** apple = envp;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(*apple != <span class=\"literal\">NULL</span>) &#123; ++apple; &#125;</span><br><span class=\"line\">\t++apple;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// set up random value for stack canary</span></span><br><span class=\"line\">\t__guard_setup(apple);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class=\"line\">\t<span class=\"comment\">// run all C++ initializers inside dyld</span></span><br><span class=\"line\">    <span class=\"comment\">//初始化 在dyld中的 所有的C++构造器</span></span><br><span class=\"line\">\t<span class=\"built_in\">runDyldInitializers</span>(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class=\"line\">    <span class=\"comment\">//至此bootstrap dyld已经全部完成，调用 dyld 的 main 函数</span></span><br><span class=\"line\">\t<span class=\"type\">uintptr_t</span> appsSlide = <span class=\"built_in\">slideOfMainExecutable</span>(appsMachHeader);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dyld::   _main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dyld::start</code>的函数分为以下几步骤：</p>\n<ol>\n<li><span id=\"return_rebaseDyld\">rebase dyld本身</span><br><a href=\"#jump_rebaseDyld\">rebase dyld</a></li>\n<li>初始化进程间通讯 mach_msg<br> 直接调用&lt;mach&#x2F;mach_init.h&gt;内的某个内核调用</li>\n<li>初始化环境变量<br> 从调用参数中拿到apple指针，内核会把这个指针紧跟在envp的数组最后</li>\n<li>设置栈保护<br> 从第三步拿到的apple指针中找到“stack_guard&#x3D;xx”的字符串，自定义重置栈保护</li>\n<li><span id=\"return_runDyldInitializers\">初始化 dyld 中的所有构造器函数</span><br> 因为dyld本身是一个动态库，我们知道，动态库是共享的，但是共享的只是代码段(PIC 位置无关代码)。在内核给每一个进程的虚拟地址映射完dyld之后，dyld本身这个动态库的数据段是没有初始化的，需要自己做自己的初始化。<a href=\"#jump_runDyldInitializers\">具体代码看这里</a></li>\n<li>前五步已经完成 dyld 的自启动(bootstrap)，后面就是进入真正的 dyld main函数。</li>\n</ol>\n<p>这里可以总结一下，start的工作内容主要是一些全局环境，以及dyld自身的初始化。</p>\n<p><a href=\"#jump__main\">开始 分析 dyld 的_main函数</a></p>\n<h3 id=\"RebaseDyld\"><a href=\"#RebaseDyld\" class=\"headerlink\" title=\"RebaseDyld\"></a><span id=\"jump_rebaseDyld\">RebaseDyld</span></h3><p>因为Dyld也是一个动态库，和普通的动态库一样，会在mach_o的load_command中指定要求需要加载到某个虚拟地址下。但是内核还是会对dyld做地址随机偏移，如果是这样，dyld需要修复数据段的数据。</p>\n<ol>\n<li>找到Load_Commands中 __LINKEDIT 和 LC_DYLD_INFO_ONLY 两段，__LINKEDIT段内包含了链接信息，符号表，动态符号表等等，而LC_DYLD_INFO_ONLY内标明了：Rebase,Bind,WeakBind,LazyBind,Export 这个5类，而这5类都会存储在Dynamic Loader Info这一节中。</li>\n<li>根据rebase 和 bind 的 Opcodes等，循环进行。</li>\n</ol>\n<p>在后文rebase&#x2F;bind 可执行文件依赖的动态库时，会进行详细说明。</p>\n<p><a href=\"#return_rebaseDyld\">回去继续</a></p>\n<h3 id=\"初始化Dyld的构造器函数\"><a href=\"#初始化Dyld的构造器函数\" class=\"headerlink\" title=\"初始化Dyld的构造器函数\"></a><span id=\"jump_runDyldInitializers\">初始化Dyld的构造器函数</span></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">const</span> Initializer  inits_start  __asm(<span class=\"string\">&quot;section$start$__DATA$__mod_init_func&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">const</span> Initializer  inits_end    __asm(<span class=\"string\">&quot;section$end$__DATA$__mod_init_func&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// For a regular executable, the crt code calls dyld to run the executables initializers.</span></span><br><span class=\"line\"><span class=\"comment\">// For a static executable, crt directly runs the initializers.</span></span><br><span class=\"line\"><span class=\"comment\">// dyld (should be static) but is a dynamic executable and needs this hack to run its own initializers.</span></span><br><span class=\"line\"><span class=\"comment\">// We pass argc, argv, etc in case libc.a uses those arguments</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">runDyldInitializers</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> macho_header* mh, <span class=\"type\">intptr_t</span> slide, <span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span>* argv[], <span class=\"type\">const</span> <span class=\"type\">char</span>* envp[], <span class=\"type\">const</span> <span class=\"type\">char</span>* apple[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">const</span> Initializer* p = &amp;inits_start; p &lt; &amp;inits_end; ++p) &#123;</span><br><span class=\"line\">\t\t(*p)(argc, argv, envp, apple);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在dyld的该方法的注释上，苹果写的很清楚：对于常规的可执行文件，crt代码会通过调用dyld来初始化这个可执行文件的初始化构造器。但是对于静态可执行文件，crt会自己去执行初始化。dyld可以认为是“静态”的，但是本质是一个动态库，所以需要自己来初始化自己，但是苹果称之为hack的方式。</p>\n<p>实际上这是一段内联汇编，<code>__asm(&quot;section$start$__DATA$__mod_init_func&quot;)</code>意思是：获取<code>__DATA</code>段<code>__mod_init_func</code>的起始地址，当然下面那行就是获取结束地址了。</p>\n<p>在Demo代码中加入两个构造器：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/81503ddc20aec519b01d09370a4d1628.png\"></p>\n<p>然后再看这个mach-o 文件：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d61a14b2aeeb66a2eea1be2d8be6b85f.png\"></p>\n<p>可以看到在数据段增加了一节<code>__mod_init_func</code>,编译期会把所有构造器的函数地址，都放在这节中。例如这个Section中第一个地址存储的是demo_init1的函数地址，去掉虚拟起始地址，文件内偏移地址就是0xED0：</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/9ac92176b89d0c92d76d1d98ecddd5f4.png\"></p>\n<p>可以直接验证确实是这个函数，<code>demo_init2</code>也是如此。</p>\n<p>回过头来看，dyld的代码：这个<code>inits_start</code>中就是构造器列表中第一个构造器的函数地址了。<code>inits_end</code>就是结束地址，循环即可依次按照约定，初始化dyld自己内部的所有构造器函数了。</p>\n<p>在dyld的内部还会有很多诸如此类的用法。<br>具体可以看<a href=\"#jump_end\">参考文献</a>中 1 和 2</p>\n<p><a href=\"#return_runDyldInitializers\">回去继续</a></p>\n<h2 id=\"dyld-main函数\"><a href=\"#dyld-main函数\" class=\"headerlink\" title=\"dyld::_main函数\"></a><span id=\"jump__main\">dyld::_main函数</span></h2><p>在dyld自身的rebase和bind、mach_msg初始化、环境变量初始化、构造函数初始化全部完成之后，开始dyld的真正工作内容，<code>dyld::_main</code> 函数。</p>\n<p><code>dyld::_main</code>函数最终是返回了主进程App可执行文件的main函数入口，并且由<code>dyld::start</code>函数再返回给调用它的<code>__dyld_start</code>这个汇编函数，最终由最开始的这个汇编函数，准备好调用参数之后，直接调用我们所熟悉的可执行文件的main函数。</p>\n<p>这个_main函数很长，我们只看步骤。</p>\n<ol>\n<li>进入函数的最开始是对环境变量的初始化加载和控制，例如 crashlog，环境变量控制log，主进程可执行文件路径…</li>\n<li>加载共享缓存。<code>// iOS cannot run without shared region</code>,iOS必须开启共享共享缓存。<br> 在所有libpath中搜索不到对应名字的动态库的时候，就会尝试从共享缓存中找。（当然这里为了便于理解，只是简单这样描述，实际的搜索方式远比这个要复杂）</li>\n<li><span id=\"return_initMainExecutable\">实例化可执行文件:</span><br> 实例化可执行程序，生成<code>ImageLoaderMachO</code>对象。<a href=\"#jump_initMainExecutable\">实例化主程序</a><br> 实例化可执行文件有两种（Classic和Compressed），分别由<code>ImageLoaderMachOCompressed</code>和<code>ImageLoaderMachOClassic</code>来创建可执行文件对象，这两者均继承于<code>ImageLoaderMachO</code>。</li>\n<li>加载从参数插入的动态库<code>loadInsertedDylib</code>，只做加载，不做链接。<a href=\"#jump_loaddylib\">Load 插入的动态库</a><span id=\"return_loaddylib\">.</span></li>\n<li><span id=\"return_link_execution\">链接可执行程序。</span><a href=\"#jump_link_execution\">链接可执行程序</a></li>\n<li>链接从参数插入的动态库。</li>\n<li>从可执行文件，递归开始调用初始化。</li>\n</ol>\n<h3 id=\"实例化主程序\"><a href=\"#实例化主程序\" class=\"headerlink\" title=\"实例化主程序\"></a><span id=\"jump_initMainExecutable\">实例化主程序</span></h3><p>在dyld获得控制权之前，内核已经把可执行文件映射到了某个线性地址空间了，所以dyld可以直接获取到 macho_header，dyld会为可执行文件创建一个ImageLoader实例对象，每一个MachO在dyld中都会有一个这个对象与之对应。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> ImageLoaderMachO* <span class=\"title\">instantiateFromLoadedImage</span><span class=\"params\">(<span class=\"type\">const</span> macho_header* mh, <span class=\"type\">uintptr_t</span> slide, <span class=\"type\">const</span> <span class=\"type\">char</span>* path)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// try mach-o loader</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">isCompatibleMachO</span>((<span class=\"type\">const</span> <span class=\"type\">uint8_t</span>*)mh, path) ) &#123;</span><br><span class=\"line\">\t\tImageLoader* image = ImageLoaderMachO::<span class=\"built_in\">instantiateMainExecutable</span>(mh, slide, path, gLinkContext);</span><br><span class=\"line\">\t\t<span class=\"built_in\">addImage</span>(image);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (ImageLoaderMachO*)image;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;main executable not a known format&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>instantiateMainExecutable</code>这个方法内还会根据不同的mach-o类型(compress 或者 classic)来返回ImageLoader的不同实现的子类对象。</p>\n<p><code>addImage(image);</code>这个函数有两个作用：</p>\n<ol>\n<li>把生成的镜像实例（ImageLoader）加入到一个全局镜像容器<code>sAllImages</code>内。之后加载的所有动态库都会被加入这个容器。</li>\n<li>把可执行文件的每一个段所占据的实际线性地址范围，映射到一个全局链表 <code>sMappedRangesStart</code>内，而这个全局链表的作用就是为了能够快速的通过 地址 反向获取到对应的<code>ImageLoader</code>。</li>\n</ol>\n<p><a href=\"#return_initMainExecutable\">回去继续</a></p>\n<h3 id=\"加载动态库\"><a href=\"#加载动态库\" class=\"headerlink\" title=\"加载动态库\"></a><span id=\"jump_loaddylib\">加载动态库</span></h3><p>这一步循环遍历DYLD_INSERT_LIBRARIES环境变量中指定的动态库列表，并调用loadInsertedDylib()将其加载。</p>\n<p>该函数调用load()完成加载工作。load()会调用loadPhase0()尝试从文件加载，loadPhase0()会向下调用下一层phase来查找动态库的路径，直到loadPhase6()，查找的顺序为DYLD_ROOT_PATH-&gt;LD_LIBRARY_PATH-&gt;DYLD_FRAMEWORK_PATH-&gt;原始路径-&gt;DYLD_FALLBACK_LIBRARY_PATH。</p>\n<p>找到后调用ImageLoaderMachO::instantiateFromFile()来实例化一个 ImageLoader，之后调用 checkandAddImage() 验证映像并将其加入到全局镜像列表中。</p>\n<p>如果loadPhase0()返回为空，表示在路径中没有找到动态库，就尝试从共享缓存中查找，找到就调用ImageLoaderMachO::instantiateFromCache()从缓存中加载。</p>\n<p>否则就抛出没找到镜像的异常。</p>\n<p>看加载动态库部分的源代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// map in file and instantiate an ImageLoader</span></span><br><span class=\"line\"><span class=\"comment\">// 映射某个动态库文件并且实例化一个ImagerLoader</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> ImageLoader* <span class=\"title\">loadPhase6</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> stat&amp; stat_buf, <span class=\"type\">const</span> <span class=\"type\">char</span>* path, <span class=\"type\">const</span> LoadContext&amp; context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//dyld::log(&quot;%s(%s)\\n&quot;, __func__ , path);</span></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> fileOffset = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> fileLength = stat_buf.st_size;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// validate it is a file (not directory)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( (stat_buf.st_mode &amp; S_IFMT) != S_IFREG ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;not a file&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> firstPages[MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE];</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> *firstPagesPtr = firstPages;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> shortPage = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// min mach-o file is 4K</span></span><br><span class=\"line\">\t<span class=\"comment\">// 最小的mach-o文件就是4k（保证一个页框大小）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( fileLength &lt; <span class=\"number\">4096</span> ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">pread</span>(fd, firstPages, (<span class=\"type\">size_t</span>)fileLength, <span class=\"number\">0</span>) != (<span class=\"type\">ssize_t</span>)fileLength )</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;pread of short file failed: %d&quot;</span>, errno);</span><br><span class=\"line\">\t\tshortPage = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// optimistically read only first 4KB</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 优先读取header文件的4kb，因为一个分页最小是4k。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">pread</span>(fd, firstPages, <span class=\"number\">4096</span>, <span class=\"number\">0</span>) != <span class=\"number\">4096</span> )</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;pread of first 4K failed: %d&quot;</span>, errno);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// if fat wrapper, find usable sub-file</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果这个动态库是个fat文件，就直接找到合适的“子文件”</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> fat_header* fileStartAsFat = (fat_header*)firstPages;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( fileStartAsFat-&gt;magic == <span class=\"built_in\">OSSwapBigToHostInt32</span>(FAT_MAGIC) ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">OSSwapBigToHostInt32</span>(fileStartAsFat-&gt;nfat_arch) &gt; ((<span class=\"number\">4096</span> - <span class=\"built_in\">sizeof</span>(fat_header)) / <span class=\"built_in\">sizeof</span>(fat_arch)) )</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;fat header too large: %u entries&quot;</span>, <span class=\"built_in\">OSSwapBigToHostInt32</span>(fileStartAsFat-&gt;nfat_arch));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">fatFindBest</span>(fileStartAsFat, &amp;fileOffset, &amp;fileLength) ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( (fileOffset+fileLength) &gt; (<span class=\"type\">uint64_t</span>)(stat_buf.st_size) )</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;truncated fat file.  file length=%llu, but needed slice goes to %llu&quot;</span>, stat_buf.st_size, fileOffset+fileLength);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">pread</span>(fd, firstPages, <span class=\"number\">4096</span>, fileOffset) != <span class=\"number\">4096</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;pread of fat file failed: %d&quot;</span>, errno);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;no matching architecture in universal wrapper&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// try mach-o loader</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( shortPage ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;file too short&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">isCompatibleMachO</span>(firstPages, path) ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded</span></span><br><span class=\"line\">\t\t<span class=\"type\">const</span> mach_header* mh = (mach_header*)firstPages;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> ( mh-&gt;filetype ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> MH_EXECUTE:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> MH_DYLIB:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> MH_BUNDLE:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but wrong filetype&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">uint32_t</span> headerAndLoadCommandsSize = <span class=\"built_in\">sizeof</span>(macho_header) + mh-&gt;sizeofcmds;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( headerAndLoadCommandsSize &gt; MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE )</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;malformed mach-o: load commands size (%u) &gt; %u&quot;</span>, headerAndLoadCommandsSize, MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( headerAndLoadCommandsSize &gt; fileLength )</span><br><span class=\"line\">\t\t\tdyld::<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;malformed mach-o: load commands size (%u) &gt; mach-o file size (%llu)&quot;</span>, headerAndLoadCommandsSize, fileLength);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( headerAndLoadCommandsSize &gt; <span class=\"number\">4096</span> ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// read more pages</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果 head 和 LC_COMMANDS的大小大于已读取的4096，那么就继续把 headerAndLoadCommandsSize 读完</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">unsigned</span> readAmount = headerAndLoadCommandsSize - <span class=\"number\">4096</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">pread</span>(fd, &amp;firstPages[<span class=\"number\">4096</span>], readAmount, fileOffset+<span class=\"number\">4096</span>) != readAmount )</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;pread of extra load commands past 4KB failed: %d&quot;</span>, errno);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> TARGET_IPHONE_SIMULATOR\t</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// &lt;rdar://problem/14168872&gt; dyld_sim should restrict loading osx binaries</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( !<span class=\"built_in\">isSimulatorBinary</span>(firstPages, path) ) &#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">if</span> TARGET_OS_WATCH</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but not built for watchOS simulator&quot;</span>;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">elif</span> TARGET_OS_TV</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but not built for tvOS simulator&quot;</span>;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but not built for iOS simulator&quot;</span>;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( gLinkContext.marzipan ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">const</span> dyld3::MachOFile* mf = (dyld3::MachOFile*)firstPages;</span><br><span class=\"line\">\t\t\t<span class=\"type\">bool</span> isiOSMacBinary = mf-&gt;<span class=\"built_in\">supportsPlatform</span>(dyld3::Platform::iOSMac) || <span class=\"built_in\">iOSMacWhiteListed</span>(path);</span><br><span class=\"line\">\t\t\t<span class=\"type\">bool</span> isProhibitedMacOSBinary = !isiOSMacBinary &amp;&amp; <span class=\"built_in\">iOSMacBlackListed</span>(path);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( (context.enforceIOSMac &amp;&amp; !isiOSMacBinary) || isProhibitedMacOSBinary ) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but not built for iOSMac&quot;</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> __arm64e__</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( (sMainExecutableMachHeader-&gt;cpusubtype == CPU_SUBTYPE_ARM64_E) &amp;&amp; (mh-&gt;cpusubtype != CPU_SUBTYPE_ARM64_E) )</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;arm64 dylibs cannot be loaded into arm64e processes&quot;</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\tImageLoader* image = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\">dyld3::ScopedTimer <span class=\"title\">timer</span><span class=\"params\">(DBG_DYLD_TIMING_MAP_IMAGE, path, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//调用 instantiateFromFile 来实例化 ImageLoader</span></span><br><span class=\"line\">\t\t\timage = ImageLoaderMachO::<span class=\"built_in\">instantiateFromFile</span>(path, fd, firstPagesPtr, headerAndLoadCommandsSize, fileOffset, fileLength, stat_buf, gLinkContext);</span><br><span class=\"line\">\t\t\ttimer.<span class=\"built_in\">setData4</span>((<span class=\"type\">uint64_t</span>)image-&gt;<span class=\"built_in\">machHeader</span>());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// validate</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 加入全局链表</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">checkandAddImage</span>(image, context);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// try other file formats here...</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// throw error about what was found</span></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (*(<span class=\"type\">uint32_t</span>*)firstPages) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> MH_MAGIC:</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> MH_CIGAM:</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> MH_MAGIC_64:</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> MH_CIGAM_64:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but wrong architecture&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;unknown file type, first eight bytes: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X&quot;</span>, </span><br><span class=\"line\">\t\t\tfirstPages[<span class=\"number\">0</span>], firstPages[<span class=\"number\">1</span>], firstPages[<span class=\"number\">2</span>], firstPages[<span class=\"number\">3</span>], firstPages[<span class=\"number\">4</span>], firstPages[<span class=\"number\">5</span>], firstPages[<span class=\"number\">6</span>],firstPages[<span class=\"number\">7</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这部分的主要任务就是，从本地文件中加载指定的动态库，并且返回<code>ImageLoader</code>实例对象。</p>\n<p>步骤如下：</p>\n<ol>\n<li>优先读取这个文件的4k，因为一个分页最小是4k,并且解析为 fat_header。</li>\n<li>如果这个动态库是个fat文件，就直接找到合适CPU架构的“子文件”</li>\n<li>检查文件类型，大小等。</li>\n<li>如果 head 和 Load_Commands 的大小大于已读取的4k，那么就继续把剩下的 headerAndLoadCommandsSize 读完，实例化<code>ImageLoader</code>。因为实例化<code>ImageLoader</code>需要整个 Load_Commands 部分。</li>\n<li>checkandAddImage。</li>\n</ol>\n<p>再来看 checkandAddImage：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> ImageLoader* <span class=\"title\">checkandAddImage</span><span class=\"params\">(ImageLoader* image, <span class=\"type\">const</span> LoadContext&amp; context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// now sanity check that this loaded image does not have the same install path as any existing image</span></span><br><span class=\"line\">\t<span class=\"comment\">// 在sAllImages 中检查一下，是否有同样路径的动态库，如果有，则返回链表中原有的那个镜像</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>* loadedImageInstallPath = image-&gt;<span class=\"built_in\">getInstallPath</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( image-&gt;<span class=\"built_in\">isDylib</span>() &amp;&amp; (loadedImageInstallPath != <span class=\"literal\">NULL</span>) &amp;&amp; (loadedImageInstallPath[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;/&#x27;</span>) ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (std::vector&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class=\"built_in\">begin</span>(); it != sAllImages.<span class=\"built_in\">end</span>(); it++) &#123;</span><br><span class=\"line\">\t\t\tImageLoader* anImage = *it;</span><br><span class=\"line\">\t\t\t<span class=\"type\">const</span> <span class=\"type\">char</span>* installPath = anImage-&gt;<span class=\"built_in\">getInstallPath</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( installPath != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">strcmp</span>(loadedImageInstallPath, installPath) == <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//dyld::log(&quot;duplicate(%s) =&gt; %p\\n&quot;, installPath, anImage);</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">removeImage</span>(image);</span><br><span class=\"line\">\t\t\t\t\tImageLoader::<span class=\"built_in\">deleteImage</span>(image);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> anImage;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// some API&#x27;s restrict what they can load</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( context.mustBeBundle &amp;&amp; !image-&gt;<span class=\"built_in\">isBundle</span>() )</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;not a bundle&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( context.mustBeDylib &amp;&amp; !image-&gt;<span class=\"built_in\">isDylib</span>() )</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;not a dylib&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// regular main executables cannot be loaded </span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( image-&gt;<span class=\"built_in\">isExecutable</span>() ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( !context.canBePIE || !image-&gt;<span class=\"built_in\">isPositionIndependentExecutable</span>() )</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;can&#x27;t load a main executable&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// don&#x27;t add bundles to global list, they can be loaded but not linked.  When linked it will be added to list</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( ! image-&gt;<span class=\"built_in\">isBundle</span>() )</span><br><span class=\"line\">\t\t<span class=\"comment\">//加入全局链表中</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">addImage</span>(image);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简单，判断这个路径的动态库是不是已经在全局链表中了，已经在的话就直接返回，否则就<code>AddImage</code></p>\n<p><a href=\"#return_loaddylib\">返回继续</a></p>\n<h3 id=\"Link-可执行文件\"><a href=\"#Link-可执行文件\" class=\"headerlink\" title=\"Link 可执行文件\"></a><span id=\"jump_link_execution\">Link 可执行文件</span></h3><p>标题是链接可执行文件，但是因为这是一个递归操作，所以这一节主要是讲述dyld如何链接所有的动态库。</p>\n<p><code>void link(ImageLoader* image, bool forceLazysBound, bool neverUnload, const ImageLoader::RPathChain&amp; loaderRPaths, unsigned cacheIndex)</code></p>\n<p>上面是这个函数的方法签名，在_main的执行过程中，首先是可执行文件的 mach-o 镜像 调用，其次紧跟着的是环境变量中插入的动态库会依次调用，这个函数内部最终还是调用到了 <code>ImageLoader.link</code>函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ImageLoader::link</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context, <span class=\"type\">bool</span> forceLazysBound, <span class=\"type\">bool</span> preflightOnly, <span class=\"type\">bool</span> neverUnload, <span class=\"type\">const</span> RPathChain&amp; loaderRPaths, <span class=\"type\">const</span> <span class=\"type\">char</span>* imagePath)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload);</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// clear error strings</span></span><br><span class=\"line\">\t(*context.setErrorStrings)(<span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t0 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveLoadLibraries</span>(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class=\"line\">\tcontext.<span class=\"built_in\">notifyBatch</span>(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// we only do the loading step for preflights</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( preflightOnly )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t1 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\tcontext.<span class=\"built_in\">clearAllDepths</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveUpdateDepth</span>(context.<span class=\"built_in\">imageCount</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t__block <span class=\"type\">uint64_t</span> t2, t3, t4, t5;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdyld3::<span class=\"built_in\">ScopedTimer</span>(DBG_DYLD_TIMING_APPLY_FIXUPS, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tt2 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveRebase</span>(context);</span><br><span class=\"line\">\t\tcontext.<span class=\"built_in\">notifyBatch</span>(dyld_image_state_rebased, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tt3 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( !context.linkingMainExecutable )</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveBindWithAccounting</span>(context, forceLazysBound, neverUnload);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tt4 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( !context.linkingMainExecutable )</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">weakBind</span>(context);</span><br><span class=\"line\">\t\tt5 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !context.linkingMainExecutable )</span><br><span class=\"line\">        context.<span class=\"built_in\">notifyBatch</span>(dyld_image_state_bound, <span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t6 = <span class=\"built_in\">mach_absolute_time</span>();\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::vector&lt;DOFInfo&gt; dofs;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveGetDOFSections</span>(context, dofs);</span><br><span class=\"line\">\tcontext.<span class=\"built_in\">registerDOFs</span>(dofs);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t7 = <span class=\"built_in\">mach_absolute_time</span>();\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// interpose any dynamically loaded images</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.<span class=\"built_in\">size</span>() != <span class=\"number\">0</span>) ) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\">dyld3::ScopedTimer <span class=\"title\">timer</span><span class=\"params\">(DBG_DYLD_TIMING_APPLY_INTERPOSING, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveApplyInterposing</span>(context);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// clear error strings</span></span><br><span class=\"line\">\t(*context.setErrorStrings)(<span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//计算时间，控制log输出</span></span><br><span class=\"line\">\tfgTotalLoadLibrariesTime += t1 - t0;</span><br><span class=\"line\">\tfgTotalRebaseTime += t3 - t2;</span><br><span class=\"line\">\tfgTotalBindTime += t4 - t3;</span><br><span class=\"line\">\tfgTotalWeakBindTime += t5 - t4;</span><br><span class=\"line\">\tfgTotalDOF += t7 - t6;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// done with initial dylib loads</span></span><br><span class=\"line\">\tfgNextPIEDylibAddress = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>链接函数的操作思路很清晰：</p>\n<ol>\n<li><code>this-&gt;recursiveLoadLibraries</code> 递归加载依赖的所有动态库 (这里仅仅是Load，Load包含open文件以及实例化ImageLoader)，最终的结果和Load通过参数插入的动态库一样。</li>\n<li><code>this-&gt;recursiveUpdateDepth</code> 递归刷新依赖库的层级</li>\n<li><span id=\"return_rebase\"><code>this-&gt;recursiveRebase</code></span><br> 每一个动态库的递归rebase无非就是再次依次调用，当前动态库所依赖的其他动态库的recursiveRebase。真正rebase是在<code>rebase(const LinkContext&amp; context, uintptr_t slide)</code>。<a href=\"#jump_rebase\">Rebase</a></li>\n<li><code>this-&gt;recursiveBindWithAccounting</code><br> 这里就是经典的non-lazy bind和lazy bind了。和Rebase的代码结构类似，真正的rebind是在<code>doBind(const LinkContext&amp; context, bool forceLazysBound)</code>。</li>\n<li><code>this-&gt;weakBind</code> 弱符号绑定</li>\n<li><code>this-&gt;recursiveGetDOFSections</code> 注册DOF节</li>\n<li><code>this-&gt;recursiveApplyInterposing</code></li>\n</ol>\n<p>其中每一个步骤都会有一个时间戳，用来根据可控的环境变量来输出log。</p>\n<h3 id=\"Rebase\"><a href=\"#Rebase\" class=\"headerlink\" title=\"Rebase\"></a><span id=\"jump_rebase\">Rebase</span></h3><p>首先解释一下 Rebase ：</p>\n<p>都知道，Rebase是调整动态库内部的符号，因为ASLR，内核加载的时候会在随机的地址中映射动态库。一开始我的想法是，mach-o的动态库在编译期已经做了PIC（地址无关代码），为什么还会有”rebase”这个过程？</p>\n<p>事实上PIC确实存在，但是rebase也是必须的。</p>\n<p>举个例子：在动态库&#x2F;可执行文件 初始化 的过程中有一个步骤是构造器初始化(这个步骤本文也有具体说明)，而实现这个这个步骤的，实际上是在mach-o的数据段中有一个名为<code>__mod_init_func</code>的段，而这个段存储的指针数组就是构造器初始化函数的地址。说到这就比较明显了，在dyld 寻找构造器初始化地址指针的时候，已经不再是以数据段中的vmaddr为基准了，而是需要加上一个偏移 – slide。</p>\n<p>下面就按照上面例子，看看代码中是如何实现这一步骤的，compressed mach-o(现代版本的好像几乎都是这个压缩的mach-o格式了) 在这一节上做了压缩，因此实现都在<code>ImageLoaderMachOCompressed</code>中。</p>\n<p>先分析一下 rebase 这一节在mach-o内的数据结构<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/ffdc0da28d16d220f66e8d638a7d5198.png\"></p>\n<p>每一个 rebase 信息都由若干个 操作码 – 操作数 来描述，每一个记录都包含两个元素（opcode 和 immediate），可以理解为一个操作码，一个是操作数，这两个都可以通过掩码来获取。</p>\n<p>以第一个为例：<br>REBASE_OPCODE_TYPE_IMM &#x3D;&#x3D; 11:标识操作数是一个Type，而Type是个指针<br>REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB &#x3D;&#x3D; 22:当前rebase的数据在第2个segment，并且偏移是用uleb表示<br>uleb128 &#x3D;&#x3D; 24:上面提到的uleb值<br>REBASE_OPCODE_DO_REBASE_IMM_TIMES &#x3D;&#x3D; 2:当前rebase操作执行2次。</p>\n<p>总结：在第2个段开始往后偏移24个字节的指针地址，连续执行两次rebase。</p>\n<p>再看看：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/69f3c8a3511f6c75d8798c62db21d597.png\"></p>\n<p>0是起始段，那么第2段就是数据段。我们再找，段的文件偏移 0x3000 + 偏移 24 &#x3D;0x3018 。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/8479e0316c7f0447ff14dd0a1b98ed69.png\"></p>\n<p>没错，就是这两个构造器，并且当前节就是<code>__mod_init_func</code>~。</p>\n<p>下面是rebase的源码，当然在本例中有些 操作码 和 操作数 并没有用到。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ImageLoaderMachOCompressed::rebase</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context, <span class=\"type\">uintptr_t</span> slide)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">CRSetCrashLogMessage2</span>(<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">getPath</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// fLinkEditBase 是__LINKEDIT段在 内存实际偏移与预期偏移 的 差值 （== slide？）</span></span><br><span class=\"line\">\t<span class=\"comment\">// start 的值是 rebase信息在内存中的实际起始地址</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">uint8_t</span>* <span class=\"type\">const</span> start = fLinkEditBase + fDyldInfo-&gt;rebase_off;</span><br><span class=\"line\">\t<span class=\"comment\">// end 的值是 rebase信息在内存中的实际结束地址</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">uint8_t</span>* <span class=\"type\">const</span> end = &amp;start[fDyldInfo-&gt;rebase_size];</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">uint8_t</span>* p = start;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">uint8_t</span> type = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> segmentIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">uintptr_t</span> address = <span class=\"built_in\">segActualLoadAddress</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">uintptr_t</span> segmentStartAddress = <span class=\"built_in\">segActualLoadAddress</span>(<span class=\"number\">0</span>);<span class=\"comment\">//第N个段地址的实际开始地址</span></span><br><span class=\"line\">\t\t<span class=\"type\">uintptr_t</span> segmentEndAddress = <span class=\"built_in\">segActualEndAddress</span>(<span class=\"number\">0</span>);<span class=\"comment\">//第N个段的实际结束地址</span></span><br><span class=\"line\">\t\t<span class=\"type\">uintptr_t</span> count;</span><br><span class=\"line\">\t\t<span class=\"type\">uintptr_t</span> skip;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> done = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> ( !done &amp;&amp; (p &lt; end) ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">uint8_t</span> immediate = *p &amp; REBASE_IMMEDIATE_MASK;</span><br><span class=\"line\">\t\t\t<span class=\"type\">uint8_t</span> opcode = *p &amp; REBASE_OPCODE_MASK;</span><br><span class=\"line\">\t\t\t++p;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (opcode) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_DONE:</span><br><span class=\"line\">\t\t\t\t\tdone = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_SET_TYPE_IMM:</span><br><span class=\"line\">\t\t\t\t\ttype = immediate;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:</span><br><span class=\"line\">\t\t\t\t\tsegmentIndex = immediate;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( segmentIndex &gt;= fSegmentsCount )</span><br><span class=\"line\">\t\t\t\t\t\tdyld::<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is too large (0..%d)&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\t\t\t\tsegmentIndex, fSegmentsCount<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"keyword\">if</span> TEXT_RELOC_SUPPORT</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( !<span class=\"built_in\">segWriteable</span>(segmentIndex) &amp;&amp; !<span class=\"built_in\">segHasRebaseFixUps</span>(segmentIndex) &amp;&amp; !<span class=\"built_in\">segHasBindFixUps</span>(segmentIndex) )</span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( !<span class=\"built_in\">segWriteable</span>(segmentIndex) )</span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\t\t\t\t\tdyld::<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is not a writable segment (%s)&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\t\t\t\tsegmentIndex, <span class=\"built_in\">segName</span>(segmentIndex));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//读取当前段的实际开始和结束地址</span></span><br><span class=\"line\">\t\t\t\t\tsegmentStartAddress = <span class=\"built_in\">segActualLoadAddress</span>(segmentIndex);</span><br><span class=\"line\">\t\t\t\t\tsegmentEndAddress = <span class=\"built_in\">segActualEndAddress</span>(segmentIndex);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\taddress = segmentStartAddress + <span class=\"built_in\">read_uleb128</span>(p, end);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_ADD_ADDR_ULEB:</span><br><span class=\"line\">\t\t\t\t\taddress += <span class=\"built_in\">read_uleb128</span>(p, end);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_ADD_ADDR_IMM_SCALED:</span><br><span class=\"line\">\t\t\t\t\taddress += immediate*<span class=\"built_in\">sizeof</span>(<span class=\"type\">uintptr_t</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_DO_REBASE_IMM_TIMES:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i &lt; immediate; ++i) &#123;<span class=\"comment\">//循环N次</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">rebaseAt</span>(context, address, slide, type);</span><br><span class=\"line\">\t\t\t\t\t\taddress += <span class=\"built_in\">sizeof</span>(<span class=\"type\">uintptr_t</span>);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tfgTotalRebaseFixups += immediate;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_DO_REBASE_ULEB_TIMES:</span><br><span class=\"line\">\t\t\t\t\tcount = <span class=\"built_in\">read_uleb128</span>(p, end);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i=<span class=\"number\">0</span>; i &lt; count; ++i) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">rebaseAt</span>(context, address, slide, type);</span><br><span class=\"line\">\t\t\t\t\t\taddress += <span class=\"built_in\">sizeof</span>(<span class=\"type\">uintptr_t</span>);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tfgTotalRebaseFixups += count;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">rebaseAt</span>(context, address, slide, type);</span><br><span class=\"line\">\t\t\t\t\taddress += <span class=\"built_in\">read_uleb128</span>(p, end) + <span class=\"built_in\">sizeof</span>(<span class=\"type\">uintptr_t</span>);</span><br><span class=\"line\">\t\t\t\t\t++fgTotalRebaseFixups;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB:</span><br><span class=\"line\">\t\t\t\t\tcount = <span class=\"built_in\">read_uleb128</span>(p, end);</span><br><span class=\"line\">\t\t\t\t\tskip = <span class=\"built_in\">read_uleb128</span>(p, end);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i=<span class=\"number\">0</span>; i &lt; count; ++i) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">rebaseAt</span>(context, address, slide, type);</span><br><span class=\"line\">\t\t\t\t\t\taddress += skip + <span class=\"built_in\">sizeof</span>(<span class=\"type\">uintptr_t</span>);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tfgTotalRebaseFixups += count;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t\tdyld::<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;bad rebase opcode %d&quot;</span>, *(p<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">catch</span> (<span class=\"type\">const</span> <span class=\"type\">char</span>* msg) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">const</span> <span class=\"type\">char</span>* newMsg = dyld::<span class=\"built_in\">mkstringf</span>(<span class=\"string\">&quot;%s in %s&quot;</span>, msg, <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">getPath</span>());</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>((<span class=\"type\">void</span>*)msg);</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> newMsg;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">CRSetCrashLogMessage2</span>(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"initializeMainExecutable\"><a href=\"#initializeMainExecutable\" class=\"headerlink\" title=\"initializeMainExecutable\"></a><span id=\"jump_init_main_execution\">initializeMainExecutable</span></h2><p>其实到这里动态库的加载&#x2F;rebase&#x2F;bind…都已经完成了，而这一步要做的就是初始化构造器函数了，这里也就是runtime初始化的过程。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initializeMainExecutable</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// record that we&#x27;ve reached this step</span></span><br><span class=\"line\">\tgLinkContext.startedInitializingMainExecutable = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// run initialzers for any inserted dylibs</span></span><br><span class=\"line\">\tImageLoader::InitializerTimingList initializerTimes[<span class=\"built_in\">allImagesCount</span>()];</span><br><span class=\"line\">\tinitializerTimes[<span class=\"number\">0</span>].count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">size_t</span> rootCount = sImageRoots.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( rootCount &gt; <span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">size_t</span> i=<span class=\"number\">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class=\"line\">\t\t\tsImageRoots[i]-&gt;<span class=\"built_in\">runInitializers</span>(gLinkContext, initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// run initializers for main executable and everything it brings up </span></span><br><span class=\"line\">\tsMainExecutable-&gt;<span class=\"built_in\">runInitializers</span>(gLinkContext, initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( gLibSystemHelpers != <span class=\"literal\">NULL</span> ) </span><br><span class=\"line\">\t\t(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// dump info if requested</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class=\"line\">\t\tImageLoader::<span class=\"built_in\">printStatistics</span>((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)<span class=\"built_in\">allImagesCount</span>(), initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class=\"line\">\t\tImageLoaderMachO::<span class=\"built_in\">printStatisticsDetails</span>((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)<span class=\"built_in\">allImagesCount</span>(), initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>优先初始化插入的动态库，再初始化可执行文件。</p>\n<p>sMainExecutable-&gt;runInitializers 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ImageLoader::runInitializers</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t1 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t<span class=\"type\">mach_port_t</span> thisThread = <span class=\"built_in\">mach_thread_self</span>();</span><br><span class=\"line\">\tImageLoader::UninitedUpwards up;</span><br><span class=\"line\">\tup.count = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tup.images[<span class=\"number\">0</span>] = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">processInitializers</span>(context, thisThread, timingInfo, up);</span><br><span class=\"line\">\tcontext.<span class=\"built_in\">notifyBatch</span>(dyld_image_state_initialized, <span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">mach_port_deallocate</span>(<span class=\"built_in\">mach_task_self</span>(), thisThread);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t2 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\tfgTotalInitTime += (t2 - t1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>processInitializers 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ImageLoader::processInitializers</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context, <span class=\"type\">mach_port_t</span> thisThread,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t\t\t\t\t\t InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> maxImageCount = context.<span class=\"built_in\">imageCount</span>()+<span class=\"number\">2</span>;</span><br><span class=\"line\">\tImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class=\"line\">\tImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tups.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class=\"line\">\t<span class=\"comment\">// uninitialized upward dependencies.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">uintptr_t</span> i=<span class=\"number\">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class=\"line\">\t\timages.images[i]-&gt;<span class=\"built_in\">recursiveInitialization</span>(context, thisThread, images.images[i]-&gt;<span class=\"built_in\">getPath</span>(), timingInfo, ups);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// If any upward dependencies remain, init them.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( ups.count &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">\t\t<span class=\"built_in\">processInitializers</span>(context, thisThread, timingInfo, ups);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>recursiveInitialization 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ImageLoader::recursiveInitialization</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context, <span class=\"type\">mach_port_t</span> this_thread, <span class=\"type\">const</span> <span class=\"type\">char</span>* pathToInitialize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t\t\t\t\t\t\t  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">recursive_lock <span class=\"title\">lock_info</span><span class=\"params\">(this_thread)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">recursiveSpinLock</span>(lock_info);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class=\"number\">-1</span> ) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">uint8_t</span> oldState = fState;</span><br><span class=\"line\">\t\t<span class=\"comment\">// break cycles</span></span><br><span class=\"line\">\t\tfState = dyld_image_state_dependents_initialized<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// initialize lower level libraries first</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"built_in\">libraryCount</span>(); ++i) &#123;</span><br><span class=\"line\">\t\t\t\tImageLoader* dependentImage = <span class=\"built_in\">libImage</span>(i);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ( dependentImage != <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// don&#x27;t try to initialize stuff &quot;above&quot; me yet</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">libIsUpward</span>(i) ) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tuninitUps.images[uninitUps.count] = dependentImage;</span><br><span class=\"line\">\t\t\t\t\t\tuninitUps.count++;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tdependentImage-&gt;<span class=\"built_in\">recursiveInitialization</span>(context, this_thread, <span class=\"built_in\">libPath</span>(i), timingInfo, uninitUps);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// record termination order</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">needsTermination</span>() )</span><br><span class=\"line\">\t\t\t\tcontext.<span class=\"built_in\">terminationRecorder</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// let objc know we are about to initialize this image</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">uint64_t</span> t1 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t\t\tfState = dyld_image_state_dependents_initialized;</span><br><span class=\"line\">\t\t\toldState = fState;</span><br><span class=\"line\">\t\t\tcontext.<span class=\"built_in\">notifySingle</span>(dyld_image_state_dependents_initialized, <span class=\"keyword\">this</span>, &amp;timingInfo);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// initialize this image</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">bool</span> hasInitializers = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">doInitialization</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// let anyone know we finished initializing this image</span></span><br><span class=\"line\">\t\t\tfState = dyld_image_state_initialized;</span><br><span class=\"line\">\t\t\toldState = fState;</span><br><span class=\"line\">\t\t\tcontext.<span class=\"built_in\">notifySingle</span>(dyld_image_state_initialized, <span class=\"keyword\">this</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( hasInitializers ) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">uint64_t</span> t2 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t\t\t\ttimingInfo.<span class=\"built_in\">addTime</span>(<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">getShortName</span>(), t2-t1);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">catch</span> (<span class=\"type\">const</span> <span class=\"type\">char</span>* msg) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// this image is not initialized</span></span><br><span class=\"line\">\t\t\tfState = oldState;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">recursiveSpinUnLock</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">recursiveSpinUnLock</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>doInitialization 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ImageLoaderMachO::doInitialization</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">CRSetCrashLogMessage2</span>(<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">getPath</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// mach-o has -init and static initializers</span></span><br><span class=\"line\">\t<span class=\"built_in\">doImageInit</span>(context);</span><br><span class=\"line\">\t<span class=\"built_in\">doModInitFunctions</span>(context);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">CRSetCrashLogMessage2</span>(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (fHasDashInit || fHasInitializers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终调到 doModInitFunctions 函数，实现逻辑和上文提到的dyld的自身的初始化一样，遍历调用_mod_init_func中的方法指针。</p>\n<p>runtime就是在这里被初始化的，调试一下就可以看到:<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/6880c3f245ce10b72f214d8851b959e5.png\"></p>\n<p>调用栈和上面描述的一样，最终由 libSystem.B.dylib -&gt; libdispatch.dylib -&gt; libobjc.A.dylib 这个调用顺序初始化了runtime。<br>而runtime 的这个函数，在dyld反向注册了三个回调函数。<br><code>_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</code></p>\n<p>而这个注册函数会把每个已经load完的镜像同步地回调给runtime：</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d26ee1e5057ed5fc0c63d13baac4b77b.png\"></p>\n<p>从代码中我们也可以确认：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">registerObjCNotifiers</span><span class=\"params\">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// record functions to call</span></span><br><span class=\"line\">\tsNotifyObjCMapped\t= mapped;</span><br><span class=\"line\">\tsNotifyObjCInit\t\t= init;</span><br><span class=\"line\">\tsNotifyObjCUnmapped = unmapped;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// call &#x27;mapped&#x27; function with all images mapped so far</span></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">notifyBatchPartial</span>(dyld_image_state_bound, <span class=\"literal\">true</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">catch</span> (<span class=\"type\">const</span> <span class=\"type\">char</span>* msg) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ignore request to abort during registration</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// &lt;rdar://problem/32209809&gt; call &#x27;init&#x27; function on all images already init&#x27;ed (below libSystem)</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (std::vector&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class=\"built_in\">begin</span>(); it != sAllImages.<span class=\"built_in\">end</span>(); it++) &#123;</span><br><span class=\"line\">\t\tImageLoader* image = *it;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( (image-&gt;<span class=\"built_in\">getState</span>() == dyld_image_state_initialized) &amp;&amp; image-&gt;<span class=\"built_in\">notifyObjC</span>() ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\">dyld3::ScopedTimer <span class=\"title\">timer</span><span class=\"params\">(DBG_DYLD_TIMING_OBJC_INIT, (<span class=\"type\">uint64_t</span>)image-&gt;machHeader(), <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t\t(*sNotifyObjCInit)(image-&gt;<span class=\"built_in\">getRealPath</span>(), image-&gt;<span class=\"built_in\">machHeader</span>());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>遍历 sAllImages ，回调给 <code>_dyld_objc_notify_init init</code>函数。runtime就可以根据mach-o的 class 有关的 section 开始初始化了。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a><span id=\"jump_end\">参考文献</span></h2><ol>\n<li><a href=\"https://www.dllhook.com/post/249.html\">内嵌汇编的一些黑科技：访问自身Mach-O、调用函数等</a></li>\n<li><a href=\"https://paper.seebug.org/202/\">Mach-O脱壳技巧</a></li>\n<li><a href=\"https://www.dllhook.com/post/238.html\">dyld详解</a></li>\n<li><a href=\"http://blog.sunnyxx.com/2014/08/30/objc-pre-main/\">iOS 程序 main 函数之前发生了什么</a></li>\n<li><a href=\"https://feicong.github.io/2017/01/14/dylib/index.html\">dylib动态库加载过程分析</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>超长预警…….</p>\n<p>本文将会从dyld接管进程开始，超级详细的分析&#x2F;解释，dyld 是如何把若干个动态库“组装”在一起，在ASLR的影响下形成一个完整的可执行进程，以及objc的runtime如何在dyld的初始化过程中进行实例化。</p>","more":"<h2 id=\"dyld-加载过程\"><a href=\"#dyld-加载过程\" class=\"headerlink\" title=\"dyld 加载过程\"></a>dyld 加载过程</h2><p>dyld的启动入口在 dyldStartup.s 文件的汇编代码中，代码入口说明了:在内核初始化完成进程，并且load 完可执行文件之后，把环境变量等参数压栈，并且调用dyld的入口函数<code>__dyld_start</code>，而这个函数则根据调用约定，准备完调用参数之后，就直接跳转到<code>dyld::start</code> 这个函数。</p>\n<p>接下来看<code>dyld::start</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">uintptr_t</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> macho_header* appsMachHeader, <span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span>* argv[], </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t<span class=\"type\">intptr_t</span> slide, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> macho_header* dyldsMachHeader,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t<span class=\"type\">uintptr_t</span>* startGlue)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class=\"line\">\t<span class=\"comment\">// we have to do this before using any global variables</span></span><br><span class=\"line\">    <span class=\"comment\">//获取内核对于dyld本身的动态偏移</span></span><br><span class=\"line\">    slide = <span class=\"built_in\">slideOfMainExecutable</span>(dyldsMachHeader);</span><br><span class=\"line\">    <span class=\"type\">bool</span> shouldRebase = slide != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( shouldRebase ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//rebase Dyld</span></span><br><span class=\"line\">        <span class=\"built_in\">rebaseDyld</span>(dyldsMachHeader, slide);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// allow dyld to use mach messaging</span></span><br><span class=\"line\">    <span class=\"comment\">//mach消息初始化。</span></span><br><span class=\"line\">\t<span class=\"built_in\">mach_init</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class=\"line\">    <span class=\"comment\">//环境变量</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>** envp = &amp;argv[argc+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>** apple = envp;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(*apple != <span class=\"literal\">NULL</span>) &#123; ++apple; &#125;</span><br><span class=\"line\">\t++apple;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// set up random value for stack canary</span></span><br><span class=\"line\">\t__guard_setup(apple);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class=\"line\">\t<span class=\"comment\">// run all C++ initializers inside dyld</span></span><br><span class=\"line\">    <span class=\"comment\">//初始化 在dyld中的 所有的C++构造器</span></span><br><span class=\"line\">\t<span class=\"built_in\">runDyldInitializers</span>(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class=\"line\">    <span class=\"comment\">//至此bootstrap dyld已经全部完成，调用 dyld 的 main 函数</span></span><br><span class=\"line\">\t<span class=\"type\">uintptr_t</span> appsSlide = <span class=\"built_in\">slideOfMainExecutable</span>(appsMachHeader);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dyld::   _main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dyld::start</code>的函数分为以下几步骤：</p>\n<ol>\n<li><span id=\"return_rebaseDyld\">rebase dyld本身</span><br><a href=\"#jump_rebaseDyld\">rebase dyld</a></li>\n<li>初始化进程间通讯 mach_msg<br> 直接调用&lt;mach&#x2F;mach_init.h&gt;内的某个内核调用</li>\n<li>初始化环境变量<br> 从调用参数中拿到apple指针，内核会把这个指针紧跟在envp的数组最后</li>\n<li>设置栈保护<br> 从第三步拿到的apple指针中找到“stack_guard&#x3D;xx”的字符串，自定义重置栈保护</li>\n<li><span id=\"return_runDyldInitializers\">初始化 dyld 中的所有构造器函数</span><br> 因为dyld本身是一个动态库，我们知道，动态库是共享的，但是共享的只是代码段(PIC 位置无关代码)。在内核给每一个进程的虚拟地址映射完dyld之后，dyld本身这个动态库的数据段是没有初始化的，需要自己做自己的初始化。<a href=\"#jump_runDyldInitializers\">具体代码看这里</a></li>\n<li>前五步已经完成 dyld 的自启动(bootstrap)，后面就是进入真正的 dyld main函数。</li>\n</ol>\n<p>这里可以总结一下，start的工作内容主要是一些全局环境，以及dyld自身的初始化。</p>\n<p><a href=\"#jump__main\">开始 分析 dyld 的_main函数</a></p>\n<h3 id=\"RebaseDyld\"><a href=\"#RebaseDyld\" class=\"headerlink\" title=\"RebaseDyld\"></a><span id=\"jump_rebaseDyld\">RebaseDyld</span></h3><p>因为Dyld也是一个动态库，和普通的动态库一样，会在mach_o的load_command中指定要求需要加载到某个虚拟地址下。但是内核还是会对dyld做地址随机偏移，如果是这样，dyld需要修复数据段的数据。</p>\n<ol>\n<li>找到Load_Commands中 __LINKEDIT 和 LC_DYLD_INFO_ONLY 两段，__LINKEDIT段内包含了链接信息，符号表，动态符号表等等，而LC_DYLD_INFO_ONLY内标明了：Rebase,Bind,WeakBind,LazyBind,Export 这个5类，而这5类都会存储在Dynamic Loader Info这一节中。</li>\n<li>根据rebase 和 bind 的 Opcodes等，循环进行。</li>\n</ol>\n<p>在后文rebase&#x2F;bind 可执行文件依赖的动态库时，会进行详细说明。</p>\n<p><a href=\"#return_rebaseDyld\">回去继续</a></p>\n<h3 id=\"初始化Dyld的构造器函数\"><a href=\"#初始化Dyld的构造器函数\" class=\"headerlink\" title=\"初始化Dyld的构造器函数\"></a><span id=\"jump_runDyldInitializers\">初始化Dyld的构造器函数</span></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">const</span> Initializer  inits_start  __asm(<span class=\"string\">&quot;section$start$__DATA$__mod_init_func&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">const</span> Initializer  inits_end    __asm(<span class=\"string\">&quot;section$end$__DATA$__mod_init_func&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// For a regular executable, the crt code calls dyld to run the executables initializers.</span></span><br><span class=\"line\"><span class=\"comment\">// For a static executable, crt directly runs the initializers.</span></span><br><span class=\"line\"><span class=\"comment\">// dyld (should be static) but is a dynamic executable and needs this hack to run its own initializers.</span></span><br><span class=\"line\"><span class=\"comment\">// We pass argc, argv, etc in case libc.a uses those arguments</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">runDyldInitializers</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> macho_header* mh, <span class=\"type\">intptr_t</span> slide, <span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span>* argv[], <span class=\"type\">const</span> <span class=\"type\">char</span>* envp[], <span class=\"type\">const</span> <span class=\"type\">char</span>* apple[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">const</span> Initializer* p = &amp;inits_start; p &lt; &amp;inits_end; ++p) &#123;</span><br><span class=\"line\">\t\t(*p)(argc, argv, envp, apple);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在dyld的该方法的注释上，苹果写的很清楚：对于常规的可执行文件，crt代码会通过调用dyld来初始化这个可执行文件的初始化构造器。但是对于静态可执行文件，crt会自己去执行初始化。dyld可以认为是“静态”的，但是本质是一个动态库，所以需要自己来初始化自己，但是苹果称之为hack的方式。</p>\n<p>实际上这是一段内联汇编，<code>__asm(&quot;section$start$__DATA$__mod_init_func&quot;)</code>意思是：获取<code>__DATA</code>段<code>__mod_init_func</code>的起始地址，当然下面那行就是获取结束地址了。</p>\n<p>在Demo代码中加入两个构造器：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/81503ddc20aec519b01d09370a4d1628.png\"></p>\n<p>然后再看这个mach-o 文件：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d61a14b2aeeb66a2eea1be2d8be6b85f.png\"></p>\n<p>可以看到在数据段增加了一节<code>__mod_init_func</code>,编译期会把所有构造器的函数地址，都放在这节中。例如这个Section中第一个地址存储的是demo_init1的函数地址，去掉虚拟起始地址，文件内偏移地址就是0xED0：</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/9ac92176b89d0c92d76d1d98ecddd5f4.png\"></p>\n<p>可以直接验证确实是这个函数，<code>demo_init2</code>也是如此。</p>\n<p>回过头来看，dyld的代码：这个<code>inits_start</code>中就是构造器列表中第一个构造器的函数地址了。<code>inits_end</code>就是结束地址，循环即可依次按照约定，初始化dyld自己内部的所有构造器函数了。</p>\n<p>在dyld的内部还会有很多诸如此类的用法。<br>具体可以看<a href=\"#jump_end\">参考文献</a>中 1 和 2</p>\n<p><a href=\"#return_runDyldInitializers\">回去继续</a></p>\n<h2 id=\"dyld-main函数\"><a href=\"#dyld-main函数\" class=\"headerlink\" title=\"dyld::_main函数\"></a><span id=\"jump__main\">dyld::_main函数</span></h2><p>在dyld自身的rebase和bind、mach_msg初始化、环境变量初始化、构造函数初始化全部完成之后，开始dyld的真正工作内容，<code>dyld::_main</code> 函数。</p>\n<p><code>dyld::_main</code>函数最终是返回了主进程App可执行文件的main函数入口，并且由<code>dyld::start</code>函数再返回给调用它的<code>__dyld_start</code>这个汇编函数，最终由最开始的这个汇编函数，准备好调用参数之后，直接调用我们所熟悉的可执行文件的main函数。</p>\n<p>这个_main函数很长，我们只看步骤。</p>\n<ol>\n<li>进入函数的最开始是对环境变量的初始化加载和控制，例如 crashlog，环境变量控制log，主进程可执行文件路径…</li>\n<li>加载共享缓存。<code>// iOS cannot run without shared region</code>,iOS必须开启共享共享缓存。<br> 在所有libpath中搜索不到对应名字的动态库的时候，就会尝试从共享缓存中找。（当然这里为了便于理解，只是简单这样描述，实际的搜索方式远比这个要复杂）</li>\n<li><span id=\"return_initMainExecutable\">实例化可执行文件:</span><br> 实例化可执行程序，生成<code>ImageLoaderMachO</code>对象。<a href=\"#jump_initMainExecutable\">实例化主程序</a><br> 实例化可执行文件有两种（Classic和Compressed），分别由<code>ImageLoaderMachOCompressed</code>和<code>ImageLoaderMachOClassic</code>来创建可执行文件对象，这两者均继承于<code>ImageLoaderMachO</code>。</li>\n<li>加载从参数插入的动态库<code>loadInsertedDylib</code>，只做加载，不做链接。<a href=\"#jump_loaddylib\">Load 插入的动态库</a><span id=\"return_loaddylib\">.</span></li>\n<li><span id=\"return_link_execution\">链接可执行程序。</span><a href=\"#jump_link_execution\">链接可执行程序</a></li>\n<li>链接从参数插入的动态库。</li>\n<li>从可执行文件，递归开始调用初始化。</li>\n</ol>\n<h3 id=\"实例化主程序\"><a href=\"#实例化主程序\" class=\"headerlink\" title=\"实例化主程序\"></a><span id=\"jump_initMainExecutable\">实例化主程序</span></h3><p>在dyld获得控制权之前，内核已经把可执行文件映射到了某个线性地址空间了，所以dyld可以直接获取到 macho_header，dyld会为可执行文件创建一个ImageLoader实例对象，每一个MachO在dyld中都会有一个这个对象与之对应。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> ImageLoaderMachO* <span class=\"title\">instantiateFromLoadedImage</span><span class=\"params\">(<span class=\"type\">const</span> macho_header* mh, <span class=\"type\">uintptr_t</span> slide, <span class=\"type\">const</span> <span class=\"type\">char</span>* path)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// try mach-o loader</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">isCompatibleMachO</span>((<span class=\"type\">const</span> <span class=\"type\">uint8_t</span>*)mh, path) ) &#123;</span><br><span class=\"line\">\t\tImageLoader* image = ImageLoaderMachO::<span class=\"built_in\">instantiateMainExecutable</span>(mh, slide, path, gLinkContext);</span><br><span class=\"line\">\t\t<span class=\"built_in\">addImage</span>(image);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (ImageLoaderMachO*)image;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;main executable not a known format&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>instantiateMainExecutable</code>这个方法内还会根据不同的mach-o类型(compress 或者 classic)来返回ImageLoader的不同实现的子类对象。</p>\n<p><code>addImage(image);</code>这个函数有两个作用：</p>\n<ol>\n<li>把生成的镜像实例（ImageLoader）加入到一个全局镜像容器<code>sAllImages</code>内。之后加载的所有动态库都会被加入这个容器。</li>\n<li>把可执行文件的每一个段所占据的实际线性地址范围，映射到一个全局链表 <code>sMappedRangesStart</code>内，而这个全局链表的作用就是为了能够快速的通过 地址 反向获取到对应的<code>ImageLoader</code>。</li>\n</ol>\n<p><a href=\"#return_initMainExecutable\">回去继续</a></p>\n<h3 id=\"加载动态库\"><a href=\"#加载动态库\" class=\"headerlink\" title=\"加载动态库\"></a><span id=\"jump_loaddylib\">加载动态库</span></h3><p>这一步循环遍历DYLD_INSERT_LIBRARIES环境变量中指定的动态库列表，并调用loadInsertedDylib()将其加载。</p>\n<p>该函数调用load()完成加载工作。load()会调用loadPhase0()尝试从文件加载，loadPhase0()会向下调用下一层phase来查找动态库的路径，直到loadPhase6()，查找的顺序为DYLD_ROOT_PATH-&gt;LD_LIBRARY_PATH-&gt;DYLD_FRAMEWORK_PATH-&gt;原始路径-&gt;DYLD_FALLBACK_LIBRARY_PATH。</p>\n<p>找到后调用ImageLoaderMachO::instantiateFromFile()来实例化一个 ImageLoader，之后调用 checkandAddImage() 验证映像并将其加入到全局镜像列表中。</p>\n<p>如果loadPhase0()返回为空，表示在路径中没有找到动态库，就尝试从共享缓存中查找，找到就调用ImageLoaderMachO::instantiateFromCache()从缓存中加载。</p>\n<p>否则就抛出没找到镜像的异常。</p>\n<p>看加载动态库部分的源代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// map in file and instantiate an ImageLoader</span></span><br><span class=\"line\"><span class=\"comment\">// 映射某个动态库文件并且实例化一个ImagerLoader</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> ImageLoader* <span class=\"title\">loadPhase6</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> stat&amp; stat_buf, <span class=\"type\">const</span> <span class=\"type\">char</span>* path, <span class=\"type\">const</span> LoadContext&amp; context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//dyld::log(&quot;%s(%s)\\n&quot;, __func__ , path);</span></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> fileOffset = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> fileLength = stat_buf.st_size;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// validate it is a file (not directory)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( (stat_buf.st_mode &amp; S_IFMT) != S_IFREG ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;not a file&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> firstPages[MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE];</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> *firstPagesPtr = firstPages;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> shortPage = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// min mach-o file is 4K</span></span><br><span class=\"line\">\t<span class=\"comment\">// 最小的mach-o文件就是4k（保证一个页框大小）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( fileLength &lt; <span class=\"number\">4096</span> ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">pread</span>(fd, firstPages, (<span class=\"type\">size_t</span>)fileLength, <span class=\"number\">0</span>) != (<span class=\"type\">ssize_t</span>)fileLength )</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;pread of short file failed: %d&quot;</span>, errno);</span><br><span class=\"line\">\t\tshortPage = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// optimistically read only first 4KB</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 优先读取header文件的4kb，因为一个分页最小是4k。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">pread</span>(fd, firstPages, <span class=\"number\">4096</span>, <span class=\"number\">0</span>) != <span class=\"number\">4096</span> )</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;pread of first 4K failed: %d&quot;</span>, errno);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// if fat wrapper, find usable sub-file</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果这个动态库是个fat文件，就直接找到合适的“子文件”</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> fat_header* fileStartAsFat = (fat_header*)firstPages;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( fileStartAsFat-&gt;magic == <span class=\"built_in\">OSSwapBigToHostInt32</span>(FAT_MAGIC) ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">OSSwapBigToHostInt32</span>(fileStartAsFat-&gt;nfat_arch) &gt; ((<span class=\"number\">4096</span> - <span class=\"built_in\">sizeof</span>(fat_header)) / <span class=\"built_in\">sizeof</span>(fat_arch)) )</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;fat header too large: %u entries&quot;</span>, <span class=\"built_in\">OSSwapBigToHostInt32</span>(fileStartAsFat-&gt;nfat_arch));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">fatFindBest</span>(fileStartAsFat, &amp;fileOffset, &amp;fileLength) ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( (fileOffset+fileLength) &gt; (<span class=\"type\">uint64_t</span>)(stat_buf.st_size) )</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;truncated fat file.  file length=%llu, but needed slice goes to %llu&quot;</span>, stat_buf.st_size, fileOffset+fileLength);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">pread</span>(fd, firstPages, <span class=\"number\">4096</span>, fileOffset) != <span class=\"number\">4096</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;pread of fat file failed: %d&quot;</span>, errno);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;no matching architecture in universal wrapper&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// try mach-o loader</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( shortPage ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;file too short&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">isCompatibleMachO</span>(firstPages, path) ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded</span></span><br><span class=\"line\">\t\t<span class=\"type\">const</span> mach_header* mh = (mach_header*)firstPages;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> ( mh-&gt;filetype ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> MH_EXECUTE:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> MH_DYLIB:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> MH_BUNDLE:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but wrong filetype&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">uint32_t</span> headerAndLoadCommandsSize = <span class=\"built_in\">sizeof</span>(macho_header) + mh-&gt;sizeofcmds;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( headerAndLoadCommandsSize &gt; MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE )</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;malformed mach-o: load commands size (%u) &gt; %u&quot;</span>, headerAndLoadCommandsSize, MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( headerAndLoadCommandsSize &gt; fileLength )</span><br><span class=\"line\">\t\t\tdyld::<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;malformed mach-o: load commands size (%u) &gt; mach-o file size (%llu)&quot;</span>, headerAndLoadCommandsSize, fileLength);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( headerAndLoadCommandsSize &gt; <span class=\"number\">4096</span> ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// read more pages</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果 head 和 LC_COMMANDS的大小大于已读取的4096，那么就继续把 headerAndLoadCommandsSize 读完</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">unsigned</span> readAmount = headerAndLoadCommandsSize - <span class=\"number\">4096</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">pread</span>(fd, &amp;firstPages[<span class=\"number\">4096</span>], readAmount, fileOffset+<span class=\"number\">4096</span>) != readAmount )</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;pread of extra load commands past 4KB failed: %d&quot;</span>, errno);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> TARGET_IPHONE_SIMULATOR\t</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// &lt;rdar://problem/14168872&gt; dyld_sim should restrict loading osx binaries</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( !<span class=\"built_in\">isSimulatorBinary</span>(firstPages, path) ) &#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">if</span> TARGET_OS_WATCH</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but not built for watchOS simulator&quot;</span>;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">elif</span> TARGET_OS_TV</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but not built for tvOS simulator&quot;</span>;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but not built for iOS simulator&quot;</span>;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( gLinkContext.marzipan ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">const</span> dyld3::MachOFile* mf = (dyld3::MachOFile*)firstPages;</span><br><span class=\"line\">\t\t\t<span class=\"type\">bool</span> isiOSMacBinary = mf-&gt;<span class=\"built_in\">supportsPlatform</span>(dyld3::Platform::iOSMac) || <span class=\"built_in\">iOSMacWhiteListed</span>(path);</span><br><span class=\"line\">\t\t\t<span class=\"type\">bool</span> isProhibitedMacOSBinary = !isiOSMacBinary &amp;&amp; <span class=\"built_in\">iOSMacBlackListed</span>(path);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( (context.enforceIOSMac &amp;&amp; !isiOSMacBinary) || isProhibitedMacOSBinary ) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but not built for iOSMac&quot;</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> __arm64e__</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( (sMainExecutableMachHeader-&gt;cpusubtype == CPU_SUBTYPE_ARM64_E) &amp;&amp; (mh-&gt;cpusubtype != CPU_SUBTYPE_ARM64_E) )</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;arm64 dylibs cannot be loaded into arm64e processes&quot;</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\tImageLoader* image = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\">dyld3::ScopedTimer <span class=\"title\">timer</span><span class=\"params\">(DBG_DYLD_TIMING_MAP_IMAGE, path, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//调用 instantiateFromFile 来实例化 ImageLoader</span></span><br><span class=\"line\">\t\t\timage = ImageLoaderMachO::<span class=\"built_in\">instantiateFromFile</span>(path, fd, firstPagesPtr, headerAndLoadCommandsSize, fileOffset, fileLength, stat_buf, gLinkContext);</span><br><span class=\"line\">\t\t\ttimer.<span class=\"built_in\">setData4</span>((<span class=\"type\">uint64_t</span>)image-&gt;<span class=\"built_in\">machHeader</span>());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// validate</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 加入全局链表</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">checkandAddImage</span>(image, context);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// try other file formats here...</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// throw error about what was found</span></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (*(<span class=\"type\">uint32_t</span>*)firstPages) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> MH_MAGIC:</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> MH_CIGAM:</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> MH_MAGIC_64:</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> MH_CIGAM_64:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;mach-o, but wrong architecture&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;unknown file type, first eight bytes: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X&quot;</span>, </span><br><span class=\"line\">\t\t\tfirstPages[<span class=\"number\">0</span>], firstPages[<span class=\"number\">1</span>], firstPages[<span class=\"number\">2</span>], firstPages[<span class=\"number\">3</span>], firstPages[<span class=\"number\">4</span>], firstPages[<span class=\"number\">5</span>], firstPages[<span class=\"number\">6</span>],firstPages[<span class=\"number\">7</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这部分的主要任务就是，从本地文件中加载指定的动态库，并且返回<code>ImageLoader</code>实例对象。</p>\n<p>步骤如下：</p>\n<ol>\n<li>优先读取这个文件的4k，因为一个分页最小是4k,并且解析为 fat_header。</li>\n<li>如果这个动态库是个fat文件，就直接找到合适CPU架构的“子文件”</li>\n<li>检查文件类型，大小等。</li>\n<li>如果 head 和 Load_Commands 的大小大于已读取的4k，那么就继续把剩下的 headerAndLoadCommandsSize 读完，实例化<code>ImageLoader</code>。因为实例化<code>ImageLoader</code>需要整个 Load_Commands 部分。</li>\n<li>checkandAddImage。</li>\n</ol>\n<p>再来看 checkandAddImage：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> ImageLoader* <span class=\"title\">checkandAddImage</span><span class=\"params\">(ImageLoader* image, <span class=\"type\">const</span> LoadContext&amp; context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// now sanity check that this loaded image does not have the same install path as any existing image</span></span><br><span class=\"line\">\t<span class=\"comment\">// 在sAllImages 中检查一下，是否有同样路径的动态库，如果有，则返回链表中原有的那个镜像</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span>* loadedImageInstallPath = image-&gt;<span class=\"built_in\">getInstallPath</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( image-&gt;<span class=\"built_in\">isDylib</span>() &amp;&amp; (loadedImageInstallPath != <span class=\"literal\">NULL</span>) &amp;&amp; (loadedImageInstallPath[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;/&#x27;</span>) ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (std::vector&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class=\"built_in\">begin</span>(); it != sAllImages.<span class=\"built_in\">end</span>(); it++) &#123;</span><br><span class=\"line\">\t\t\tImageLoader* anImage = *it;</span><br><span class=\"line\">\t\t\t<span class=\"type\">const</span> <span class=\"type\">char</span>* installPath = anImage-&gt;<span class=\"built_in\">getInstallPath</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( installPath != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">strcmp</span>(loadedImageInstallPath, installPath) == <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//dyld::log(&quot;duplicate(%s) =&gt; %p\\n&quot;, installPath, anImage);</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">removeImage</span>(image);</span><br><span class=\"line\">\t\t\t\t\tImageLoader::<span class=\"built_in\">deleteImage</span>(image);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> anImage;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// some API&#x27;s restrict what they can load</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( context.mustBeBundle &amp;&amp; !image-&gt;<span class=\"built_in\">isBundle</span>() )</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;not a bundle&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( context.mustBeDylib &amp;&amp; !image-&gt;<span class=\"built_in\">isDylib</span>() )</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;not a dylib&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// regular main executables cannot be loaded </span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( image-&gt;<span class=\"built_in\">isExecutable</span>() ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( !context.canBePIE || !image-&gt;<span class=\"built_in\">isPositionIndependentExecutable</span>() )</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"string\">&quot;can&#x27;t load a main executable&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// don&#x27;t add bundles to global list, they can be loaded but not linked.  When linked it will be added to list</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( ! image-&gt;<span class=\"built_in\">isBundle</span>() )</span><br><span class=\"line\">\t\t<span class=\"comment\">//加入全局链表中</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">addImage</span>(image);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简单，判断这个路径的动态库是不是已经在全局链表中了，已经在的话就直接返回，否则就<code>AddImage</code></p>\n<p><a href=\"#return_loaddylib\">返回继续</a></p>\n<h3 id=\"Link-可执行文件\"><a href=\"#Link-可执行文件\" class=\"headerlink\" title=\"Link 可执行文件\"></a><span id=\"jump_link_execution\">Link 可执行文件</span></h3><p>标题是链接可执行文件，但是因为这是一个递归操作，所以这一节主要是讲述dyld如何链接所有的动态库。</p>\n<p><code>void link(ImageLoader* image, bool forceLazysBound, bool neverUnload, const ImageLoader::RPathChain&amp; loaderRPaths, unsigned cacheIndex)</code></p>\n<p>上面是这个函数的方法签名，在_main的执行过程中，首先是可执行文件的 mach-o 镜像 调用，其次紧跟着的是环境变量中插入的动态库会依次调用，这个函数内部最终还是调用到了 <code>ImageLoader.link</code>函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ImageLoader::link</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context, <span class=\"type\">bool</span> forceLazysBound, <span class=\"type\">bool</span> preflightOnly, <span class=\"type\">bool</span> neverUnload, <span class=\"type\">const</span> RPathChain&amp; loaderRPaths, <span class=\"type\">const</span> <span class=\"type\">char</span>* imagePath)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload);</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// clear error strings</span></span><br><span class=\"line\">\t(*context.setErrorStrings)(<span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t0 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveLoadLibraries</span>(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class=\"line\">\tcontext.<span class=\"built_in\">notifyBatch</span>(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// we only do the loading step for preflights</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( preflightOnly )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t1 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\tcontext.<span class=\"built_in\">clearAllDepths</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveUpdateDepth</span>(context.<span class=\"built_in\">imageCount</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t__block <span class=\"type\">uint64_t</span> t2, t3, t4, t5;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdyld3::<span class=\"built_in\">ScopedTimer</span>(DBG_DYLD_TIMING_APPLY_FIXUPS, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tt2 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveRebase</span>(context);</span><br><span class=\"line\">\t\tcontext.<span class=\"built_in\">notifyBatch</span>(dyld_image_state_rebased, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tt3 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( !context.linkingMainExecutable )</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveBindWithAccounting</span>(context, forceLazysBound, neverUnload);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tt4 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( !context.linkingMainExecutable )</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">weakBind</span>(context);</span><br><span class=\"line\">\t\tt5 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !context.linkingMainExecutable )</span><br><span class=\"line\">        context.<span class=\"built_in\">notifyBatch</span>(dyld_image_state_bound, <span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t6 = <span class=\"built_in\">mach_absolute_time</span>();\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tstd::vector&lt;DOFInfo&gt; dofs;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveGetDOFSections</span>(context, dofs);</span><br><span class=\"line\">\tcontext.<span class=\"built_in\">registerDOFs</span>(dofs);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t7 = <span class=\"built_in\">mach_absolute_time</span>();\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// interpose any dynamically loaded images</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.<span class=\"built_in\">size</span>() != <span class=\"number\">0</span>) ) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\">dyld3::ScopedTimer <span class=\"title\">timer</span><span class=\"params\">(DBG_DYLD_TIMING_APPLY_INTERPOSING, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">recursiveApplyInterposing</span>(context);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// clear error strings</span></span><br><span class=\"line\">\t(*context.setErrorStrings)(<span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//计算时间，控制log输出</span></span><br><span class=\"line\">\tfgTotalLoadLibrariesTime += t1 - t0;</span><br><span class=\"line\">\tfgTotalRebaseTime += t3 - t2;</span><br><span class=\"line\">\tfgTotalBindTime += t4 - t3;</span><br><span class=\"line\">\tfgTotalWeakBindTime += t5 - t4;</span><br><span class=\"line\">\tfgTotalDOF += t7 - t6;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// done with initial dylib loads</span></span><br><span class=\"line\">\tfgNextPIEDylibAddress = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>链接函数的操作思路很清晰：</p>\n<ol>\n<li><code>this-&gt;recursiveLoadLibraries</code> 递归加载依赖的所有动态库 (这里仅仅是Load，Load包含open文件以及实例化ImageLoader)，最终的结果和Load通过参数插入的动态库一样。</li>\n<li><code>this-&gt;recursiveUpdateDepth</code> 递归刷新依赖库的层级</li>\n<li><span id=\"return_rebase\"><code>this-&gt;recursiveRebase</code></span><br> 每一个动态库的递归rebase无非就是再次依次调用，当前动态库所依赖的其他动态库的recursiveRebase。真正rebase是在<code>rebase(const LinkContext&amp; context, uintptr_t slide)</code>。<a href=\"#jump_rebase\">Rebase</a></li>\n<li><code>this-&gt;recursiveBindWithAccounting</code><br> 这里就是经典的non-lazy bind和lazy bind了。和Rebase的代码结构类似，真正的rebind是在<code>doBind(const LinkContext&amp; context, bool forceLazysBound)</code>。</li>\n<li><code>this-&gt;weakBind</code> 弱符号绑定</li>\n<li><code>this-&gt;recursiveGetDOFSections</code> 注册DOF节</li>\n<li><code>this-&gt;recursiveApplyInterposing</code></li>\n</ol>\n<p>其中每一个步骤都会有一个时间戳，用来根据可控的环境变量来输出log。</p>\n<h3 id=\"Rebase\"><a href=\"#Rebase\" class=\"headerlink\" title=\"Rebase\"></a><span id=\"jump_rebase\">Rebase</span></h3><p>首先解释一下 Rebase ：</p>\n<p>都知道，Rebase是调整动态库内部的符号，因为ASLR，内核加载的时候会在随机的地址中映射动态库。一开始我的想法是，mach-o的动态库在编译期已经做了PIC（地址无关代码），为什么还会有”rebase”这个过程？</p>\n<p>事实上PIC确实存在，但是rebase也是必须的。</p>\n<p>举个例子：在动态库&#x2F;可执行文件 初始化 的过程中有一个步骤是构造器初始化(这个步骤本文也有具体说明)，而实现这个这个步骤的，实际上是在mach-o的数据段中有一个名为<code>__mod_init_func</code>的段，而这个段存储的指针数组就是构造器初始化函数的地址。说到这就比较明显了，在dyld 寻找构造器初始化地址指针的时候，已经不再是以数据段中的vmaddr为基准了，而是需要加上一个偏移 – slide。</p>\n<p>下面就按照上面例子，看看代码中是如何实现这一步骤的，compressed mach-o(现代版本的好像几乎都是这个压缩的mach-o格式了) 在这一节上做了压缩，因此实现都在<code>ImageLoaderMachOCompressed</code>中。</p>\n<p>先分析一下 rebase 这一节在mach-o内的数据结构<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/ffdc0da28d16d220f66e8d638a7d5198.png\"></p>\n<p>每一个 rebase 信息都由若干个 操作码 – 操作数 来描述，每一个记录都包含两个元素（opcode 和 immediate），可以理解为一个操作码，一个是操作数，这两个都可以通过掩码来获取。</p>\n<p>以第一个为例：<br>REBASE_OPCODE_TYPE_IMM &#x3D;&#x3D; 11:标识操作数是一个Type，而Type是个指针<br>REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB &#x3D;&#x3D; 22:当前rebase的数据在第2个segment，并且偏移是用uleb表示<br>uleb128 &#x3D;&#x3D; 24:上面提到的uleb值<br>REBASE_OPCODE_DO_REBASE_IMM_TIMES &#x3D;&#x3D; 2:当前rebase操作执行2次。</p>\n<p>总结：在第2个段开始往后偏移24个字节的指针地址，连续执行两次rebase。</p>\n<p>再看看：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/69f3c8a3511f6c75d8798c62db21d597.png\"></p>\n<p>0是起始段，那么第2段就是数据段。我们再找，段的文件偏移 0x3000 + 偏移 24 &#x3D;0x3018 。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/8479e0316c7f0447ff14dd0a1b98ed69.png\"></p>\n<p>没错，就是这两个构造器，并且当前节就是<code>__mod_init_func</code>~。</p>\n<p>下面是rebase的源码，当然在本例中有些 操作码 和 操作数 并没有用到。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ImageLoaderMachOCompressed::rebase</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context, <span class=\"type\">uintptr_t</span> slide)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">CRSetCrashLogMessage2</span>(<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">getPath</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// fLinkEditBase 是__LINKEDIT段在 内存实际偏移与预期偏移 的 差值 （== slide？）</span></span><br><span class=\"line\">\t<span class=\"comment\">// start 的值是 rebase信息在内存中的实际起始地址</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">uint8_t</span>* <span class=\"type\">const</span> start = fLinkEditBase + fDyldInfo-&gt;rebase_off;</span><br><span class=\"line\">\t<span class=\"comment\">// end 的值是 rebase信息在内存中的实际结束地址</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">uint8_t</span>* <span class=\"type\">const</span> end = &amp;start[fDyldInfo-&gt;rebase_size];</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">uint8_t</span>* p = start;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">uint8_t</span> type = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> segmentIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">uintptr_t</span> address = <span class=\"built_in\">segActualLoadAddress</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">uintptr_t</span> segmentStartAddress = <span class=\"built_in\">segActualLoadAddress</span>(<span class=\"number\">0</span>);<span class=\"comment\">//第N个段地址的实际开始地址</span></span><br><span class=\"line\">\t\t<span class=\"type\">uintptr_t</span> segmentEndAddress = <span class=\"built_in\">segActualEndAddress</span>(<span class=\"number\">0</span>);<span class=\"comment\">//第N个段的实际结束地址</span></span><br><span class=\"line\">\t\t<span class=\"type\">uintptr_t</span> count;</span><br><span class=\"line\">\t\t<span class=\"type\">uintptr_t</span> skip;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> done = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> ( !done &amp;&amp; (p &lt; end) ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">uint8_t</span> immediate = *p &amp; REBASE_IMMEDIATE_MASK;</span><br><span class=\"line\">\t\t\t<span class=\"type\">uint8_t</span> opcode = *p &amp; REBASE_OPCODE_MASK;</span><br><span class=\"line\">\t\t\t++p;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (opcode) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_DONE:</span><br><span class=\"line\">\t\t\t\t\tdone = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_SET_TYPE_IMM:</span><br><span class=\"line\">\t\t\t\t\ttype = immediate;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:</span><br><span class=\"line\">\t\t\t\t\tsegmentIndex = immediate;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( segmentIndex &gt;= fSegmentsCount )</span><br><span class=\"line\">\t\t\t\t\t\tdyld::<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is too large (0..%d)&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\t\t\t\tsegmentIndex, fSegmentsCount<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"keyword\">if</span> TEXT_RELOC_SUPPORT</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( !<span class=\"built_in\">segWriteable</span>(segmentIndex) &amp;&amp; !<span class=\"built_in\">segHasRebaseFixUps</span>(segmentIndex) &amp;&amp; !<span class=\"built_in\">segHasBindFixUps</span>(segmentIndex) )</span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( !<span class=\"built_in\">segWriteable</span>(segmentIndex) )</span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\t\t\t\t\tdyld::<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is not a writable segment (%s)&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\t\t\t\tsegmentIndex, <span class=\"built_in\">segName</span>(segmentIndex));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//读取当前段的实际开始和结束地址</span></span><br><span class=\"line\">\t\t\t\t\tsegmentStartAddress = <span class=\"built_in\">segActualLoadAddress</span>(segmentIndex);</span><br><span class=\"line\">\t\t\t\t\tsegmentEndAddress = <span class=\"built_in\">segActualEndAddress</span>(segmentIndex);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\taddress = segmentStartAddress + <span class=\"built_in\">read_uleb128</span>(p, end);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_ADD_ADDR_ULEB:</span><br><span class=\"line\">\t\t\t\t\taddress += <span class=\"built_in\">read_uleb128</span>(p, end);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_ADD_ADDR_IMM_SCALED:</span><br><span class=\"line\">\t\t\t\t\taddress += immediate*<span class=\"built_in\">sizeof</span>(<span class=\"type\">uintptr_t</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_DO_REBASE_IMM_TIMES:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i &lt; immediate; ++i) &#123;<span class=\"comment\">//循环N次</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">rebaseAt</span>(context, address, slide, type);</span><br><span class=\"line\">\t\t\t\t\t\taddress += <span class=\"built_in\">sizeof</span>(<span class=\"type\">uintptr_t</span>);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tfgTotalRebaseFixups += immediate;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_DO_REBASE_ULEB_TIMES:</span><br><span class=\"line\">\t\t\t\t\tcount = <span class=\"built_in\">read_uleb128</span>(p, end);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i=<span class=\"number\">0</span>; i &lt; count; ++i) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">rebaseAt</span>(context, address, slide, type);</span><br><span class=\"line\">\t\t\t\t\t\taddress += <span class=\"built_in\">sizeof</span>(<span class=\"type\">uintptr_t</span>);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tfgTotalRebaseFixups += count;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">rebaseAt</span>(context, address, slide, type);</span><br><span class=\"line\">\t\t\t\t\taddress += <span class=\"built_in\">read_uleb128</span>(p, end) + <span class=\"built_in\">sizeof</span>(<span class=\"type\">uintptr_t</span>);</span><br><span class=\"line\">\t\t\t\t\t++fgTotalRebaseFixups;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB:</span><br><span class=\"line\">\t\t\t\t\tcount = <span class=\"built_in\">read_uleb128</span>(p, end);</span><br><span class=\"line\">\t\t\t\t\tskip = <span class=\"built_in\">read_uleb128</span>(p, end);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i=<span class=\"number\">0</span>; i &lt; count; ++i) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">rebaseAt</span>(context, address, slide, type);</span><br><span class=\"line\">\t\t\t\t\t\taddress += skip + <span class=\"built_in\">sizeof</span>(<span class=\"type\">uintptr_t</span>);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tfgTotalRebaseFixups += count;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t\tdyld::<span class=\"built_in\">throwf</span>(<span class=\"string\">&quot;bad rebase opcode %d&quot;</span>, *(p<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">catch</span> (<span class=\"type\">const</span> <span class=\"type\">char</span>* msg) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">const</span> <span class=\"type\">char</span>* newMsg = dyld::<span class=\"built_in\">mkstringf</span>(<span class=\"string\">&quot;%s in %s&quot;</span>, msg, <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">getPath</span>());</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>((<span class=\"type\">void</span>*)msg);</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> newMsg;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">CRSetCrashLogMessage2</span>(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"initializeMainExecutable\"><a href=\"#initializeMainExecutable\" class=\"headerlink\" title=\"initializeMainExecutable\"></a><span id=\"jump_init_main_execution\">initializeMainExecutable</span></h2><p>其实到这里动态库的加载&#x2F;rebase&#x2F;bind…都已经完成了，而这一步要做的就是初始化构造器函数了，这里也就是runtime初始化的过程。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initializeMainExecutable</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// record that we&#x27;ve reached this step</span></span><br><span class=\"line\">\tgLinkContext.startedInitializingMainExecutable = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// run initialzers for any inserted dylibs</span></span><br><span class=\"line\">\tImageLoader::InitializerTimingList initializerTimes[<span class=\"built_in\">allImagesCount</span>()];</span><br><span class=\"line\">\tinitializerTimes[<span class=\"number\">0</span>].count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">size_t</span> rootCount = sImageRoots.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( rootCount &gt; <span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">size_t</span> i=<span class=\"number\">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class=\"line\">\t\t\tsImageRoots[i]-&gt;<span class=\"built_in\">runInitializers</span>(gLinkContext, initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// run initializers for main executable and everything it brings up </span></span><br><span class=\"line\">\tsMainExecutable-&gt;<span class=\"built_in\">runInitializers</span>(gLinkContext, initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( gLibSystemHelpers != <span class=\"literal\">NULL</span> ) </span><br><span class=\"line\">\t\t(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// dump info if requested</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class=\"line\">\t\tImageLoader::<span class=\"built_in\">printStatistics</span>((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)<span class=\"built_in\">allImagesCount</span>(), initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class=\"line\">\t\tImageLoaderMachO::<span class=\"built_in\">printStatisticsDetails</span>((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)<span class=\"built_in\">allImagesCount</span>(), initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>优先初始化插入的动态库，再初始化可执行文件。</p>\n<p>sMainExecutable-&gt;runInitializers 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ImageLoader::runInitializers</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t1 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t<span class=\"type\">mach_port_t</span> thisThread = <span class=\"built_in\">mach_thread_self</span>();</span><br><span class=\"line\">\tImageLoader::UninitedUpwards up;</span><br><span class=\"line\">\tup.count = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tup.images[<span class=\"number\">0</span>] = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">processInitializers</span>(context, thisThread, timingInfo, up);</span><br><span class=\"line\">\tcontext.<span class=\"built_in\">notifyBatch</span>(dyld_image_state_initialized, <span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">mach_port_deallocate</span>(<span class=\"built_in\">mach_task_self</span>(), thisThread);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> t2 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\tfgTotalInitTime += (t2 - t1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>processInitializers 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ImageLoader::processInitializers</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context, <span class=\"type\">mach_port_t</span> thisThread,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t\t\t\t\t\t InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> maxImageCount = context.<span class=\"built_in\">imageCount</span>()+<span class=\"number\">2</span>;</span><br><span class=\"line\">\tImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class=\"line\">\tImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tups.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class=\"line\">\t<span class=\"comment\">// uninitialized upward dependencies.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">uintptr_t</span> i=<span class=\"number\">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class=\"line\">\t\timages.images[i]-&gt;<span class=\"built_in\">recursiveInitialization</span>(context, thisThread, images.images[i]-&gt;<span class=\"built_in\">getPath</span>(), timingInfo, ups);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// If any upward dependencies remain, init them.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( ups.count &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">\t\t<span class=\"built_in\">processInitializers</span>(context, thisThread, timingInfo, ups);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>recursiveInitialization 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ImageLoader::recursiveInitialization</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context, <span class=\"type\">mach_port_t</span> this_thread, <span class=\"type\">const</span> <span class=\"type\">char</span>* pathToInitialize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t\t\t\t\t\t\t\t  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">recursive_lock <span class=\"title\">lock_info</span><span class=\"params\">(this_thread)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">recursiveSpinLock</span>(lock_info);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class=\"number\">-1</span> ) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">uint8_t</span> oldState = fState;</span><br><span class=\"line\">\t\t<span class=\"comment\">// break cycles</span></span><br><span class=\"line\">\t\tfState = dyld_image_state_dependents_initialized<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// initialize lower level libraries first</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"built_in\">libraryCount</span>(); ++i) &#123;</span><br><span class=\"line\">\t\t\t\tImageLoader* dependentImage = <span class=\"built_in\">libImage</span>(i);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ( dependentImage != <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// don&#x27;t try to initialize stuff &quot;above&quot; me yet</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( <span class=\"built_in\">libIsUpward</span>(i) ) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tuninitUps.images[uninitUps.count] = dependentImage;</span><br><span class=\"line\">\t\t\t\t\t\tuninitUps.count++;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tdependentImage-&gt;<span class=\"built_in\">recursiveInitialization</span>(context, this_thread, <span class=\"built_in\">libPath</span>(i), timingInfo, uninitUps);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// record termination order</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">needsTermination</span>() )</span><br><span class=\"line\">\t\t\t\tcontext.<span class=\"built_in\">terminationRecorder</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// let objc know we are about to initialize this image</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">uint64_t</span> t1 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t\t\tfState = dyld_image_state_dependents_initialized;</span><br><span class=\"line\">\t\t\toldState = fState;</span><br><span class=\"line\">\t\t\tcontext.<span class=\"built_in\">notifySingle</span>(dyld_image_state_dependents_initialized, <span class=\"keyword\">this</span>, &amp;timingInfo);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// initialize this image</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">bool</span> hasInitializers = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">doInitialization</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// let anyone know we finished initializing this image</span></span><br><span class=\"line\">\t\t\tfState = dyld_image_state_initialized;</span><br><span class=\"line\">\t\t\toldState = fState;</span><br><span class=\"line\">\t\t\tcontext.<span class=\"built_in\">notifySingle</span>(dyld_image_state_initialized, <span class=\"keyword\">this</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( hasInitializers ) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">uint64_t</span> t2 = <span class=\"built_in\">mach_absolute_time</span>();</span><br><span class=\"line\">\t\t\t\ttimingInfo.<span class=\"built_in\">addTime</span>(<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">getShortName</span>(), t2-t1);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">catch</span> (<span class=\"type\">const</span> <span class=\"type\">char</span>* msg) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// this image is not initialized</span></span><br><span class=\"line\">\t\t\tfState = oldState;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">recursiveSpinUnLock</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">recursiveSpinUnLock</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>doInitialization 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ImageLoaderMachO::doInitialization</span><span class=\"params\">(<span class=\"type\">const</span> LinkContext&amp; context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">CRSetCrashLogMessage2</span>(<span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">getPath</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// mach-o has -init and static initializers</span></span><br><span class=\"line\">\t<span class=\"built_in\">doImageInit</span>(context);</span><br><span class=\"line\">\t<span class=\"built_in\">doModInitFunctions</span>(context);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">CRSetCrashLogMessage2</span>(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (fHasDashInit || fHasInitializers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终调到 doModInitFunctions 函数，实现逻辑和上文提到的dyld的自身的初始化一样，遍历调用_mod_init_func中的方法指针。</p>\n<p>runtime就是在这里被初始化的，调试一下就可以看到:<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/6880c3f245ce10b72f214d8851b959e5.png\"></p>\n<p>调用栈和上面描述的一样，最终由 libSystem.B.dylib -&gt; libdispatch.dylib -&gt; libobjc.A.dylib 这个调用顺序初始化了runtime。<br>而runtime 的这个函数，在dyld反向注册了三个回调函数。<br><code>_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</code></p>\n<p>而这个注册函数会把每个已经load完的镜像同步地回调给runtime：</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d26ee1e5057ed5fc0c63d13baac4b77b.png\"></p>\n<p>从代码中我们也可以确认：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">registerObjCNotifiers</span><span class=\"params\">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// record functions to call</span></span><br><span class=\"line\">\tsNotifyObjCMapped\t= mapped;</span><br><span class=\"line\">\tsNotifyObjCInit\t\t= init;</span><br><span class=\"line\">\tsNotifyObjCUnmapped = unmapped;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// call &#x27;mapped&#x27; function with all images mapped so far</span></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">notifyBatchPartial</span>(dyld_image_state_bound, <span class=\"literal\">true</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">catch</span> (<span class=\"type\">const</span> <span class=\"type\">char</span>* msg) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ignore request to abort during registration</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// &lt;rdar://problem/32209809&gt; call &#x27;init&#x27; function on all images already init&#x27;ed (below libSystem)</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (std::vector&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class=\"built_in\">begin</span>(); it != sAllImages.<span class=\"built_in\">end</span>(); it++) &#123;</span><br><span class=\"line\">\t\tImageLoader* image = *it;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( (image-&gt;<span class=\"built_in\">getState</span>() == dyld_image_state_initialized) &amp;&amp; image-&gt;<span class=\"built_in\">notifyObjC</span>() ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\">dyld3::ScopedTimer <span class=\"title\">timer</span><span class=\"params\">(DBG_DYLD_TIMING_OBJC_INIT, (<span class=\"type\">uint64_t</span>)image-&gt;machHeader(), <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t\t(*sNotifyObjCInit)(image-&gt;<span class=\"built_in\">getRealPath</span>(), image-&gt;<span class=\"built_in\">machHeader</span>());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>遍历 sAllImages ，回调给 <code>_dyld_objc_notify_init init</code>函数。runtime就可以根据mach-o的 class 有关的 section 开始初始化了。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a><span id=\"jump_end\">参考文献</span></h2><ol>\n<li><a href=\"https://www.dllhook.com/post/249.html\">内嵌汇编的一些黑科技：访问自身Mach-O、调用函数等</a></li>\n<li><a href=\"https://paper.seebug.org/202/\">Mach-O脱壳技巧</a></li>\n<li><a href=\"https://www.dllhook.com/post/238.html\">dyld详解</a></li>\n<li><a href=\"http://blog.sunnyxx.com/2014/08/30/objc-pre-main/\">iOS 程序 main 函数之前发生了什么</a></li>\n<li><a href=\"https://feicong.github.io/2017/01/14/dylib/index.html\">dylib动态库加载过程分析</a></li>\n</ol>"},{"title":"SQLite--OS【共享内存】","date":"2020-03-17T16:00:00.000Z","top":300,"_content":"\n>在开启sqlite wal功能的时候，会在db文件的同级目录下多出一个，与db同名的，后缀为-shm的文件，这个文件就是本文需要讨论的shared-memory（shm）。文章只讨论sqlite在os层中shm的实现，而不关注shm中存储的内容和数据结构。\n\n<!-- more -->\n\n## Shm-共享内存\nshm-shared memory 是在开启wal的时候被用来存储wal-index(这个不是本层考虑的)。所以在没有定义`SQLITE_OMIT_WAL`这个宏的时候，sqlite os层提供了shm的能力。\n\n从暴露的接口上来开一共只有4个接口函数，分别是：\n```c\nint sqlite3OsShmMap(sqlite3_file *,int,int,int,void volatile **);//映射文件\nint sqlite3OsShmLock(sqlite3_file *id, int, int, int);//mmap锁\nvoid sqlite3OsShmBarrier(sqlite3_file *id);//内存屏障\nint sqlite3OsShmUnmap(sqlite3_file *id, int);//取消映射文件\n```\n\n暂先不看代码，需要先从mmap开始说起...\n\n### 关于mmap\n\n这也是在看源码的时候，发现知识盲区了...然后去查了大量关于mmap的资料。这样虽然效率低了一点，但是还是便于之后的代码理解的。\n\nmmap其实之前也有遇到用过，它的两个特性印象比较深刻，一个是mmap是内存文件映射，可以用读写内存的方式读写文件内容，二是在应用crash的时候或者系统掉电的时候可以把内存中数据的flush到文件中。但这些似乎不太够...\n\n首先看**普通**的文件读写：\n\n在此之前，再了解一个**页缓存**，页缓存是内核的一个重要的磁盘高速缓存，**以页为单位进行缓存**。可以简单的把它理解为...memory cache。读数据的时候会优先的从页缓存中读，而写数据的时候，也是优先写入页缓存，并且不会立刻回写文件，而是标记dirty，延迟一段时间或者手动调用sync的时候才会回写。\n\n这时候我们再看文件读写，发起一个read()或者write()系统调用，我们一般会分配一个buff缓冲区，然后会进入内核态，cpu会从页缓存中读取指定的文件缓存。如果发现页缓存中没有，那么这个时候cpu就会让出总线，用DMA的方式，将数据从磁盘拷贝到页缓存中，拷贝完成的时候处理DMA中断。在此之后，因为拷贝的地址是内核地址，cpu需要在内核态，再把页缓存拷贝至用户态的虚拟地址映射的物理地址即（buff对应的缓冲区）。\n\n也就是说，普通文件的读写，会发生两次内存拷贝。\n\n我们再看**mmap**的文件读写：\n\n我们使用mmap的时候，系统会首先分配一段虚拟内存，并且在该过程中建立了vma和映射文件的关联，向上返回虚拟内存的首地址，此时还没有建立和物理内存的映射关系。等到第一次访问虚拟地址时，发生缺页异常，将对应的文件内容读取到页缓存，**并建立虚拟内存和页缓存的映射关系**，如此只有一次将文件数据读取页缓存的过程。\n\n这里有个问题:mmap并不是直接将虚拟内存对应的物理内存和文件建立映射关系，二是内核将数据拷贝至页缓存，然后将虚拟内存直接映射到了页缓存上，从而避免的二次拷贝\n\n这也就是mmap比普通文件读写要快的原因。mmap的其他相关知识可以访问后文的资料链接。\n\n### 数据结构\n\n每个unixFile关联了一个unixShm结构体，这个结构体用来描述一个已打开的共享文件。\n```c\nstruct unixShm {\n  unixShmNode *pShmNode;     /* The underlying unixShmNode object */\n  unixShm *pNext;            /* Next unixShm with the same unixShmNode */\n  u8 hasMutex;               /* True if holding the unixShmNode->pShmMutex */\n  u8 id;                     /* Id of this connection within its unixShmNode */\n  u16 sharedMask;            /* Mask of shared locks held */\n  u16 exclMask;              /* Mask of exclusive locks held */\n};\n```\n\n而从注释上也可以看出来，每一个unixShm还有一个unixShmNode。而指向同一个unixShmNode的unixShm都通过pNext关联在一个链表内。使用同一个unixShmNode的shm链表被存储在unixShmNode的pfirst指针中。同一个数据库文件的不同的数据库连接（假设使用了WAL mode），包含的是不同的unixShm，但是是同一个unixShmNode。\n\nunixShmNode从某种意义上来说是可以与unixInodeInfo关联在一起的，但是开发者可能不想让所有不使用shm（WAL mode）的数据连接也持有这些没有意义的数据，所以才做了分离，只做了unixInodeInfo内的pShmNode指针和unixShmNode的pInode指针的相互指向(绑定)。\n\n```c\nstruct unixShmNode {\n  unixInodeInfo *pInode;     /* unixInodeInfo that owns this SHM node */\n  sqlite3_mutex *pShmMutex;  /* Mutex to access this object */\n  char *zFilename;           /* Name of the mmapped file */\n  int hShm;                  /* Open file descriptor */\n  int szRegion;              /* Size of shared-memory regions */\n  u16 nRegion;               /* Size of array apRegion */\n  u8 isReadonly;             /* True if read-only */\n  u8 isUnlocked;             /* True if no DMS lock held */\n  char **apRegion;           /* Array of mapped shared-memory regions */\n  int nRef;                  /* Number of unixShm objects pointing to this */\n  unixShm *pFirst;           /* All unixShm objects pointing to this */\n};\n```\n\n下面我们分别看Sqlite的这4个接口函数\n\n### sqlite3OsShmMap\n下面是shmMap原始的函数签名。\n```c\nstatic int unixShmMap(\n  sqlite3_file *fd,               /* Handle open on database file */\n  int iRegion,                    /* Region to retrieve */\n  int szRegion,                   /* Size of regions */\n  int bExtend,                    /* True to extend file if necessary */\n  void volatile **pp              /* OUT: Mapped memory */\n)\n```\n\n在sqlite中，每一个文件的映射是由一个一个region组合起来的(unixShmNode中的apRegion就是region指针的数组,nRegion就是这个数组的大小)。而unixShmMap这个函数就是获取第iRegion区域的mmap指针。其中每一个region的size是szRegion。(这个值从第一次调用之后就**不可以**在变了，会被存储在unixShmNode中的szRegion内)\n\n第一个参数就是需要打开shm的数据库文件对象，第二个iRegion是需要获取的区域下标，szRegion是每一个区域的大小，bExtend表示是否可以扩展文件大小，最后是返回的mmap的地址指针。\n\nsqlite设定了一个最小region size是32kb。根据上文说的，mmap是按照page size来映射文件的。一般情况下page size 在32位机器下是4k。所以，mmap一次映射最小（nShmPerMap）是1个region，但如果page size是64k，那么一次最小（nShmPerMap）就需要2个region了。\n\n函数过程：\n1. 如果当前数据库连接的文件对象内共享文件没有打开，先打开文件。如果unixNodeInfo的pShmNode也是空的，那么将创建unixShmNode与unixNodeInfo绑定。在shm文件打开完成之后，会在shm的128个字节处加读锁。（在加读锁之前会判断是否是第一个打开该文件的进程，如果是，那么会把文件裁剪为3个字节，之所以是3个，一是出于调试的目的，二是3个字节小于shm文件的header大小，也不会影响业务逻辑）\n2. 根据最小region，计算出iRegion需要映射的region数量nReqRegion。判断是否已经映射（nReqRegion<unixShmNode.nRegion）,如果还没有映射，那么执行第3步，否则执行第5步\n3. 判断映射文件的大小是否需要扩展，如果需要扩展，那么在扩展的文件空间对应的内存分页写入最后一个字节（下面会解释这个操作的原因）。\n4. 文件扩展完成之后，按照已有的mmap的region个数（unixShmNode.nRegion）和请求的nReqRegion个数来扩展apRegion。其中考虑到一次最少分配nShmPerMap个region，再把nShmPerMap个region拆分到apRegion中\n5. 返回unixShmNode.apRegion中第iRegion个region对应的mmap地址。\n\n**解释一下第三步，为什么扩展mmap文件的时候，需要在每一个分页最后写入一个字节？**\nSqlite的解释是：从技术上来说，扩展一个文件，我们只需要在文件的最后的最后一个字节，写入一个字节就可以直接扩展文件的大小了。在扩展的空间的每一个内存分页大小的最后写入一个字节，可以减少之后mmap映射区间的时候SIGBUS的概率。\n\n详细可以看 [认真分析mmap：是什么 为什么 怎么用 - 胡潇 - 博客园](https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label5) 这篇文章最后的情景二，文件大小不是页的整倍数的情况。\n\n再加上我们上文说到的页缓存的逻辑，大致可以猜测，因为只有在真正读写文件的时候，才会触发页缓存的cache查询。而在文件的每一个分页的最后写入一个字节，会使得页缓存未命中，而触发内核从磁盘读取以及在页缓存中映射这一页对应的文件。这样就会减少在mmap系统调用之后，用户每次访问文件映射的虚拟内存引起的缺页异常，即把耗时操作集中放在了创建的时候。\n\n### sqlite3OsShmUnmap\n\n下面是函数的原型：\n```c\nstatic int unixShmUnmap(\n  sqlite3_file *fd,               /* The underlying database file */\n  int deleteFlag                  /* Delete shared-memory if true */\n)\n```\n顾名思义，Unmap函数的操作结果是取消映射文件，如果deleteFlag是1的话还会清空共享缓存。\n\n函数过程：\n1. 从unixInodeInfo中找到unixShmNode，遍历unixShmNode的first指针链表，找到当前sqlite_file的unixShm，并且从链表中断开。\n2. 减少unixShmNode的引用计数，如果计数到0了，那么就清空共享缓存（第三步）。\n3. 按照nShmPerMap的大小调用osMunmap方法，直到释放所有的mmap缓存。\n\n### sqlite3OsShmLock\n\n下面是函数原型：\n```c\nstatic int unixShmLock(\n  sqlite3_file *fd,          /* Database file holding the shared memory */\n  int ofst,                  /* First lock to acquire or release */\n  int n,                     /* Number of locks to acquire or release */\n  int flags                  /* What to do with the lock */\n)\n```\n\n```\n#define SQLITE_SHM_UNLOCK       1\n#define SQLITE_SHM_LOCK         2\n#define SQLITE_SHM_SHARED       4\n#define SQLITE_SHM_EXCLUSIVE    8\n```\n上面是shm锁的类型，也就是第4个参数flags的参数来源。UNLOCK、LOCK 和 SHARED、EXCLUSIVE分别组合，即4种组合。（其实只有unlock、shared、exclusive三种）\n**与数据库文件锁不太一样，shm的锁不能由excl<->shared，只能有unlock到任一锁或者任一锁到unlock。**\n\n与数据库文件锁一样的是，posix文件锁的特性。\n上文中 unixShm 的数据结构中还有两个变量，分别是sharedMask和exclMask，分别表示当前这个数据库连接持有的对应shm的mmap文件锁类型。\n\n1. 请求的锁是SQLITE_SHM_UNLOCK\n遍历使用当前unixShmNode的unixShm链表，如果已经没有其他unixShm加锁了，就调用unixShmSystemLock真正的移除文件锁，并且移除sharedMask和exclMask的标记位。否则就只是移除标记位。\n\n2. 请求的锁是SQLITE_SHM_SHARED\n遍历使用当前unixShmNode的unixShm链表，如果有exclusive锁，返回SQLITE_BUSY。如果当前进程内没有任何锁，就调用unixShmSystemLock在文件上加读锁，并把unixShm上的sharedMask置1。否则就只是置位。\n\n3. 请求的锁是SQLITE_SHM_EXCLUSIVE\n遍历使用当前unixShmNode的unixShm链表，如果有其他任何在锁状态，返回SQLITE_BUSY。否则就调用unixShmSystemLock在文件上加写锁，并且在exclMask上置1。\n\n### sqlite3OsShmBarrier\n\n通过调用`__sync_synchronize()`函数实现的内存屏障。所有在屏障之前的代码必定会在屏障之后的代码执行之前完成执行。具体可以看后文的内存屏障相关文章。\n\n>参考\nmmap相关\n[各种缓存（一） - ccxikka - 博客园](https://www.cnblogs.com/ccxikka/p/10527056.html)\n[认真分析mmap：是什么 为什么 怎么用 - 胡潇 - 博客园](https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label5)\n[彻底理解mmap()](https://blog.csdn.net/Holy_666/article/details/86532671)\n内存屏障\n[一文解决内存屏障 - 简书](https://www.jianshu.com/p/64240319ed60)","source":"_posts/13.sqlite-os-shm.md","raw":"---\ntitle: SQLite--OS【共享内存】\ndate: 2020-03-18\ntags: [sqlite3,os,shm]\ntop: 300\ncategories: sqlite3\n---\n\n>在开启sqlite wal功能的时候，会在db文件的同级目录下多出一个，与db同名的，后缀为-shm的文件，这个文件就是本文需要讨论的shared-memory（shm）。文章只讨论sqlite在os层中shm的实现，而不关注shm中存储的内容和数据结构。\n\n<!-- more -->\n\n## Shm-共享内存\nshm-shared memory 是在开启wal的时候被用来存储wal-index(这个不是本层考虑的)。所以在没有定义`SQLITE_OMIT_WAL`这个宏的时候，sqlite os层提供了shm的能力。\n\n从暴露的接口上来开一共只有4个接口函数，分别是：\n```c\nint sqlite3OsShmMap(sqlite3_file *,int,int,int,void volatile **);//映射文件\nint sqlite3OsShmLock(sqlite3_file *id, int, int, int);//mmap锁\nvoid sqlite3OsShmBarrier(sqlite3_file *id);//内存屏障\nint sqlite3OsShmUnmap(sqlite3_file *id, int);//取消映射文件\n```\n\n暂先不看代码，需要先从mmap开始说起...\n\n### 关于mmap\n\n这也是在看源码的时候，发现知识盲区了...然后去查了大量关于mmap的资料。这样虽然效率低了一点，但是还是便于之后的代码理解的。\n\nmmap其实之前也有遇到用过，它的两个特性印象比较深刻，一个是mmap是内存文件映射，可以用读写内存的方式读写文件内容，二是在应用crash的时候或者系统掉电的时候可以把内存中数据的flush到文件中。但这些似乎不太够...\n\n首先看**普通**的文件读写：\n\n在此之前，再了解一个**页缓存**，页缓存是内核的一个重要的磁盘高速缓存，**以页为单位进行缓存**。可以简单的把它理解为...memory cache。读数据的时候会优先的从页缓存中读，而写数据的时候，也是优先写入页缓存，并且不会立刻回写文件，而是标记dirty，延迟一段时间或者手动调用sync的时候才会回写。\n\n这时候我们再看文件读写，发起一个read()或者write()系统调用，我们一般会分配一个buff缓冲区，然后会进入内核态，cpu会从页缓存中读取指定的文件缓存。如果发现页缓存中没有，那么这个时候cpu就会让出总线，用DMA的方式，将数据从磁盘拷贝到页缓存中，拷贝完成的时候处理DMA中断。在此之后，因为拷贝的地址是内核地址，cpu需要在内核态，再把页缓存拷贝至用户态的虚拟地址映射的物理地址即（buff对应的缓冲区）。\n\n也就是说，普通文件的读写，会发生两次内存拷贝。\n\n我们再看**mmap**的文件读写：\n\n我们使用mmap的时候，系统会首先分配一段虚拟内存，并且在该过程中建立了vma和映射文件的关联，向上返回虚拟内存的首地址，此时还没有建立和物理内存的映射关系。等到第一次访问虚拟地址时，发生缺页异常，将对应的文件内容读取到页缓存，**并建立虚拟内存和页缓存的映射关系**，如此只有一次将文件数据读取页缓存的过程。\n\n这里有个问题:mmap并不是直接将虚拟内存对应的物理内存和文件建立映射关系，二是内核将数据拷贝至页缓存，然后将虚拟内存直接映射到了页缓存上，从而避免的二次拷贝\n\n这也就是mmap比普通文件读写要快的原因。mmap的其他相关知识可以访问后文的资料链接。\n\n### 数据结构\n\n每个unixFile关联了一个unixShm结构体，这个结构体用来描述一个已打开的共享文件。\n```c\nstruct unixShm {\n  unixShmNode *pShmNode;     /* The underlying unixShmNode object */\n  unixShm *pNext;            /* Next unixShm with the same unixShmNode */\n  u8 hasMutex;               /* True if holding the unixShmNode->pShmMutex */\n  u8 id;                     /* Id of this connection within its unixShmNode */\n  u16 sharedMask;            /* Mask of shared locks held */\n  u16 exclMask;              /* Mask of exclusive locks held */\n};\n```\n\n而从注释上也可以看出来，每一个unixShm还有一个unixShmNode。而指向同一个unixShmNode的unixShm都通过pNext关联在一个链表内。使用同一个unixShmNode的shm链表被存储在unixShmNode的pfirst指针中。同一个数据库文件的不同的数据库连接（假设使用了WAL mode），包含的是不同的unixShm，但是是同一个unixShmNode。\n\nunixShmNode从某种意义上来说是可以与unixInodeInfo关联在一起的，但是开发者可能不想让所有不使用shm（WAL mode）的数据连接也持有这些没有意义的数据，所以才做了分离，只做了unixInodeInfo内的pShmNode指针和unixShmNode的pInode指针的相互指向(绑定)。\n\n```c\nstruct unixShmNode {\n  unixInodeInfo *pInode;     /* unixInodeInfo that owns this SHM node */\n  sqlite3_mutex *pShmMutex;  /* Mutex to access this object */\n  char *zFilename;           /* Name of the mmapped file */\n  int hShm;                  /* Open file descriptor */\n  int szRegion;              /* Size of shared-memory regions */\n  u16 nRegion;               /* Size of array apRegion */\n  u8 isReadonly;             /* True if read-only */\n  u8 isUnlocked;             /* True if no DMS lock held */\n  char **apRegion;           /* Array of mapped shared-memory regions */\n  int nRef;                  /* Number of unixShm objects pointing to this */\n  unixShm *pFirst;           /* All unixShm objects pointing to this */\n};\n```\n\n下面我们分别看Sqlite的这4个接口函数\n\n### sqlite3OsShmMap\n下面是shmMap原始的函数签名。\n```c\nstatic int unixShmMap(\n  sqlite3_file *fd,               /* Handle open on database file */\n  int iRegion,                    /* Region to retrieve */\n  int szRegion,                   /* Size of regions */\n  int bExtend,                    /* True to extend file if necessary */\n  void volatile **pp              /* OUT: Mapped memory */\n)\n```\n\n在sqlite中，每一个文件的映射是由一个一个region组合起来的(unixShmNode中的apRegion就是region指针的数组,nRegion就是这个数组的大小)。而unixShmMap这个函数就是获取第iRegion区域的mmap指针。其中每一个region的size是szRegion。(这个值从第一次调用之后就**不可以**在变了，会被存储在unixShmNode中的szRegion内)\n\n第一个参数就是需要打开shm的数据库文件对象，第二个iRegion是需要获取的区域下标，szRegion是每一个区域的大小，bExtend表示是否可以扩展文件大小，最后是返回的mmap的地址指针。\n\nsqlite设定了一个最小region size是32kb。根据上文说的，mmap是按照page size来映射文件的。一般情况下page size 在32位机器下是4k。所以，mmap一次映射最小（nShmPerMap）是1个region，但如果page size是64k，那么一次最小（nShmPerMap）就需要2个region了。\n\n函数过程：\n1. 如果当前数据库连接的文件对象内共享文件没有打开，先打开文件。如果unixNodeInfo的pShmNode也是空的，那么将创建unixShmNode与unixNodeInfo绑定。在shm文件打开完成之后，会在shm的128个字节处加读锁。（在加读锁之前会判断是否是第一个打开该文件的进程，如果是，那么会把文件裁剪为3个字节，之所以是3个，一是出于调试的目的，二是3个字节小于shm文件的header大小，也不会影响业务逻辑）\n2. 根据最小region，计算出iRegion需要映射的region数量nReqRegion。判断是否已经映射（nReqRegion<unixShmNode.nRegion）,如果还没有映射，那么执行第3步，否则执行第5步\n3. 判断映射文件的大小是否需要扩展，如果需要扩展，那么在扩展的文件空间对应的内存分页写入最后一个字节（下面会解释这个操作的原因）。\n4. 文件扩展完成之后，按照已有的mmap的region个数（unixShmNode.nRegion）和请求的nReqRegion个数来扩展apRegion。其中考虑到一次最少分配nShmPerMap个region，再把nShmPerMap个region拆分到apRegion中\n5. 返回unixShmNode.apRegion中第iRegion个region对应的mmap地址。\n\n**解释一下第三步，为什么扩展mmap文件的时候，需要在每一个分页最后写入一个字节？**\nSqlite的解释是：从技术上来说，扩展一个文件，我们只需要在文件的最后的最后一个字节，写入一个字节就可以直接扩展文件的大小了。在扩展的空间的每一个内存分页大小的最后写入一个字节，可以减少之后mmap映射区间的时候SIGBUS的概率。\n\n详细可以看 [认真分析mmap：是什么 为什么 怎么用 - 胡潇 - 博客园](https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label5) 这篇文章最后的情景二，文件大小不是页的整倍数的情况。\n\n再加上我们上文说到的页缓存的逻辑，大致可以猜测，因为只有在真正读写文件的时候，才会触发页缓存的cache查询。而在文件的每一个分页的最后写入一个字节，会使得页缓存未命中，而触发内核从磁盘读取以及在页缓存中映射这一页对应的文件。这样就会减少在mmap系统调用之后，用户每次访问文件映射的虚拟内存引起的缺页异常，即把耗时操作集中放在了创建的时候。\n\n### sqlite3OsShmUnmap\n\n下面是函数的原型：\n```c\nstatic int unixShmUnmap(\n  sqlite3_file *fd,               /* The underlying database file */\n  int deleteFlag                  /* Delete shared-memory if true */\n)\n```\n顾名思义，Unmap函数的操作结果是取消映射文件，如果deleteFlag是1的话还会清空共享缓存。\n\n函数过程：\n1. 从unixInodeInfo中找到unixShmNode，遍历unixShmNode的first指针链表，找到当前sqlite_file的unixShm，并且从链表中断开。\n2. 减少unixShmNode的引用计数，如果计数到0了，那么就清空共享缓存（第三步）。\n3. 按照nShmPerMap的大小调用osMunmap方法，直到释放所有的mmap缓存。\n\n### sqlite3OsShmLock\n\n下面是函数原型：\n```c\nstatic int unixShmLock(\n  sqlite3_file *fd,          /* Database file holding the shared memory */\n  int ofst,                  /* First lock to acquire or release */\n  int n,                     /* Number of locks to acquire or release */\n  int flags                  /* What to do with the lock */\n)\n```\n\n```\n#define SQLITE_SHM_UNLOCK       1\n#define SQLITE_SHM_LOCK         2\n#define SQLITE_SHM_SHARED       4\n#define SQLITE_SHM_EXCLUSIVE    8\n```\n上面是shm锁的类型，也就是第4个参数flags的参数来源。UNLOCK、LOCK 和 SHARED、EXCLUSIVE分别组合，即4种组合。（其实只有unlock、shared、exclusive三种）\n**与数据库文件锁不太一样，shm的锁不能由excl<->shared，只能有unlock到任一锁或者任一锁到unlock。**\n\n与数据库文件锁一样的是，posix文件锁的特性。\n上文中 unixShm 的数据结构中还有两个变量，分别是sharedMask和exclMask，分别表示当前这个数据库连接持有的对应shm的mmap文件锁类型。\n\n1. 请求的锁是SQLITE_SHM_UNLOCK\n遍历使用当前unixShmNode的unixShm链表，如果已经没有其他unixShm加锁了，就调用unixShmSystemLock真正的移除文件锁，并且移除sharedMask和exclMask的标记位。否则就只是移除标记位。\n\n2. 请求的锁是SQLITE_SHM_SHARED\n遍历使用当前unixShmNode的unixShm链表，如果有exclusive锁，返回SQLITE_BUSY。如果当前进程内没有任何锁，就调用unixShmSystemLock在文件上加读锁，并把unixShm上的sharedMask置1。否则就只是置位。\n\n3. 请求的锁是SQLITE_SHM_EXCLUSIVE\n遍历使用当前unixShmNode的unixShm链表，如果有其他任何在锁状态，返回SQLITE_BUSY。否则就调用unixShmSystemLock在文件上加写锁，并且在exclMask上置1。\n\n### sqlite3OsShmBarrier\n\n通过调用`__sync_synchronize()`函数实现的内存屏障。所有在屏障之前的代码必定会在屏障之后的代码执行之前完成执行。具体可以看后文的内存屏障相关文章。\n\n>参考\nmmap相关\n[各种缓存（一） - ccxikka - 博客园](https://www.cnblogs.com/ccxikka/p/10527056.html)\n[认真分析mmap：是什么 为什么 怎么用 - 胡潇 - 博客园](https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label5)\n[彻底理解mmap()](https://blog.csdn.net/Holy_666/article/details/86532671)\n内存屏障\n[一文解决内存屏障 - 简书](https://www.jianshu.com/p/64240319ed60)","slug":"13.sqlite-os-shm","published":1,"updated":"2022-07-28T13:38:40.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwo3000hp9c950810gyr","content":"<blockquote>\n<p>在开启sqlite wal功能的时候，会在db文件的同级目录下多出一个，与db同名的，后缀为-shm的文件，这个文件就是本文需要讨论的shared-memory（shm）。文章只讨论sqlite在os层中shm的实现，而不关注shm中存储的内容和数据结构。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"Shm-共享内存\"><a href=\"#Shm-共享内存\" class=\"headerlink\" title=\"Shm-共享内存\"></a>Shm-共享内存</h2><p>shm-shared memory 是在开启wal的时候被用来存储wal-index(这个不是本层考虑的)。所以在没有定义<code>SQLITE_OMIT_WAL</code>这个宏的时候，sqlite os层提供了shm的能力。</p>\n<p>从暴露的接口上来开一共只有4个接口函数，分别是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3OsShmMap</span><span class=\"params\">(sqlite3_file *,<span class=\"type\">int</span>,<span class=\"type\">int</span>,<span class=\"type\">int</span>,<span class=\"type\">void</span> <span class=\"keyword\">volatile</span> **)</span>;<span class=\"comment\">//映射文件</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3OsShmLock</span><span class=\"params\">(sqlite3_file *id, <span class=\"type\">int</span>, <span class=\"type\">int</span>, <span class=\"type\">int</span>)</span>;<span class=\"comment\">//mmap锁</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sqlite3OsShmBarrier</span><span class=\"params\">(sqlite3_file *id)</span>;<span class=\"comment\">//内存屏障</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3OsShmUnmap</span><span class=\"params\">(sqlite3_file *id, <span class=\"type\">int</span>)</span>;<span class=\"comment\">//取消映射文件</span></span><br></pre></td></tr></table></figure>\n\n<p>暂先不看代码，需要先从mmap开始说起…</p>\n<h3 id=\"关于mmap\"><a href=\"#关于mmap\" class=\"headerlink\" title=\"关于mmap\"></a>关于mmap</h3><p>这也是在看源码的时候，发现知识盲区了…然后去查了大量关于mmap的资料。这样虽然效率低了一点，但是还是便于之后的代码理解的。</p>\n<p>mmap其实之前也有遇到用过，它的两个特性印象比较深刻，一个是mmap是内存文件映射，可以用读写内存的方式读写文件内容，二是在应用crash的时候或者系统掉电的时候可以把内存中数据的flush到文件中。但这些似乎不太够…</p>\n<p>首先看<strong>普通</strong>的文件读写：</p>\n<p>在此之前，再了解一个<strong>页缓存</strong>，页缓存是内核的一个重要的磁盘高速缓存，<strong>以页为单位进行缓存</strong>。可以简单的把它理解为…memory cache。读数据的时候会优先的从页缓存中读，而写数据的时候，也是优先写入页缓存，并且不会立刻回写文件，而是标记dirty，延迟一段时间或者手动调用sync的时候才会回写。</p>\n<p>这时候我们再看文件读写，发起一个read()或者write()系统调用，我们一般会分配一个buff缓冲区，然后会进入内核态，cpu会从页缓存中读取指定的文件缓存。如果发现页缓存中没有，那么这个时候cpu就会让出总线，用DMA的方式，将数据从磁盘拷贝到页缓存中，拷贝完成的时候处理DMA中断。在此之后，因为拷贝的地址是内核地址，cpu需要在内核态，再把页缓存拷贝至用户态的虚拟地址映射的物理地址即（buff对应的缓冲区）。</p>\n<p>也就是说，普通文件的读写，会发生两次内存拷贝。</p>\n<p>我们再看<strong>mmap</strong>的文件读写：</p>\n<p>我们使用mmap的时候，系统会首先分配一段虚拟内存，并且在该过程中建立了vma和映射文件的关联，向上返回虚拟内存的首地址，此时还没有建立和物理内存的映射关系。等到第一次访问虚拟地址时，发生缺页异常，将对应的文件内容读取到页缓存，<strong>并建立虚拟内存和页缓存的映射关系</strong>，如此只有一次将文件数据读取页缓存的过程。</p>\n<p>这里有个问题:mmap并不是直接将虚拟内存对应的物理内存和文件建立映射关系，二是内核将数据拷贝至页缓存，然后将虚拟内存直接映射到了页缓存上，从而避免的二次拷贝</p>\n<p>这也就是mmap比普通文件读写要快的原因。mmap的其他相关知识可以访问后文的资料链接。</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>每个unixFile关联了一个unixShm结构体，这个结构体用来描述一个已打开的共享文件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">unixShm</span> &#123;</span></span><br><span class=\"line\">  unixShmNode *pShmNode;     <span class=\"comment\">/* The underlying unixShmNode object */</span></span><br><span class=\"line\">  unixShm *pNext;            <span class=\"comment\">/* Next unixShm with the same unixShmNode */</span></span><br><span class=\"line\">  u8 hasMutex;               <span class=\"comment\">/* True if holding the unixShmNode-&gt;pShmMutex */</span></span><br><span class=\"line\">  u8 id;                     <span class=\"comment\">/* Id of this connection within its unixShmNode */</span></span><br><span class=\"line\">  u16 sharedMask;            <span class=\"comment\">/* Mask of shared locks held */</span></span><br><span class=\"line\">  u16 exclMask;              <span class=\"comment\">/* Mask of exclusive locks held */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>而从注释上也可以看出来，每一个unixShm还有一个unixShmNode。而指向同一个unixShmNode的unixShm都通过pNext关联在一个链表内。使用同一个unixShmNode的shm链表被存储在unixShmNode的pfirst指针中。同一个数据库文件的不同的数据库连接（假设使用了WAL mode），包含的是不同的unixShm，但是是同一个unixShmNode。</p>\n<p>unixShmNode从某种意义上来说是可以与unixInodeInfo关联在一起的，但是开发者可能不想让所有不使用shm（WAL mode）的数据连接也持有这些没有意义的数据，所以才做了分离，只做了unixInodeInfo内的pShmNode指针和unixShmNode的pInode指针的相互指向(绑定)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">unixShmNode</span> &#123;</span></span><br><span class=\"line\">  unixInodeInfo *pInode;     <span class=\"comment\">/* unixInodeInfo that owns this SHM node */</span></span><br><span class=\"line\">  sqlite3_mutex *pShmMutex;  <span class=\"comment\">/* Mutex to access this object */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *zFilename;           <span class=\"comment\">/* Name of the mmapped file */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> hShm;                  <span class=\"comment\">/* Open file descriptor */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> szRegion;              <span class=\"comment\">/* Size of shared-memory regions */</span></span><br><span class=\"line\">  u16 nRegion;               <span class=\"comment\">/* Size of array apRegion */</span></span><br><span class=\"line\">  u8 isReadonly;             <span class=\"comment\">/* True if read-only */</span></span><br><span class=\"line\">  u8 isUnlocked;             <span class=\"comment\">/* True if no DMS lock held */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> **apRegion;           <span class=\"comment\">/* Array of mapped shared-memory regions */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nRef;                  <span class=\"comment\">/* Number of unixShm objects pointing to this */</span></span><br><span class=\"line\">  unixShm *pFirst;           <span class=\"comment\">/* All unixShm objects pointing to this */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们分别看Sqlite的这4个接口函数</p>\n<h3 id=\"sqlite3OsShmMap\"><a href=\"#sqlite3OsShmMap\" class=\"headerlink\" title=\"sqlite3OsShmMap\"></a>sqlite3OsShmMap</h3><p>下面是shmMap原始的函数签名。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">unixShmMap</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  sqlite3_file *fd,               <span class=\"comment\">/* Handle open on database file */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> iRegion,                    <span class=\"comment\">/* Region to retrieve */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> szRegion,                   <span class=\"comment\">/* Size of regions */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> bExtend,                    <span class=\"comment\">/* True to extend file if necessary */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">void</span> <span class=\"keyword\">volatile</span> **pp              <span class=\"comment\">/* OUT: Mapped memory */</span></span></span><br><span class=\"line\"><span class=\"params\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>在sqlite中，每一个文件的映射是由一个一个region组合起来的(unixShmNode中的apRegion就是region指针的数组,nRegion就是这个数组的大小)。而unixShmMap这个函数就是获取第iRegion区域的mmap指针。其中每一个region的size是szRegion。(这个值从第一次调用之后就<strong>不可以</strong>在变了，会被存储在unixShmNode中的szRegion内)</p>\n<p>第一个参数就是需要打开shm的数据库文件对象，第二个iRegion是需要获取的区域下标，szRegion是每一个区域的大小，bExtend表示是否可以扩展文件大小，最后是返回的mmap的地址指针。</p>\n<p>sqlite设定了一个最小region size是32kb。根据上文说的，mmap是按照page size来映射文件的。一般情况下page size 在32位机器下是4k。所以，mmap一次映射最小（nShmPerMap）是1个region，但如果page size是64k，那么一次最小（nShmPerMap）就需要2个region了。</p>\n<p>函数过程：</p>\n<ol>\n<li>如果当前数据库连接的文件对象内共享文件没有打开，先打开文件。如果unixNodeInfo的pShmNode也是空的，那么将创建unixShmNode与unixNodeInfo绑定。在shm文件打开完成之后，会在shm的128个字节处加读锁。（在加读锁之前会判断是否是第一个打开该文件的进程，如果是，那么会把文件裁剪为3个字节，之所以是3个，一是出于调试的目的，二是3个字节小于shm文件的header大小，也不会影响业务逻辑）</li>\n<li>根据最小region，计算出iRegion需要映射的region数量nReqRegion。判断是否已经映射（nReqRegion&lt;unixShmNode.nRegion）,如果还没有映射，那么执行第3步，否则执行第5步</li>\n<li>判断映射文件的大小是否需要扩展，如果需要扩展，那么在扩展的文件空间对应的内存分页写入最后一个字节（下面会解释这个操作的原因）。</li>\n<li>文件扩展完成之后，按照已有的mmap的region个数（unixShmNode.nRegion）和请求的nReqRegion个数来扩展apRegion。其中考虑到一次最少分配nShmPerMap个region，再把nShmPerMap个region拆分到apRegion中</li>\n<li>返回unixShmNode.apRegion中第iRegion个region对应的mmap地址。</li>\n</ol>\n<p><strong>解释一下第三步，为什么扩展mmap文件的时候，需要在每一个分页最后写入一个字节？</strong><br>Sqlite的解释是：从技术上来说，扩展一个文件，我们只需要在文件的最后的最后一个字节，写入一个字节就可以直接扩展文件的大小了。在扩展的空间的每一个内存分页大小的最后写入一个字节，可以减少之后mmap映射区间的时候SIGBUS的概率。</p>\n<p>详细可以看 <a href=\"https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label5\">认真分析mmap：是什么 为什么 怎么用 - 胡潇 - 博客园</a> 这篇文章最后的情景二，文件大小不是页的整倍数的情况。</p>\n<p>再加上我们上文说到的页缓存的逻辑，大致可以猜测，因为只有在真正读写文件的时候，才会触发页缓存的cache查询。而在文件的每一个分页的最后写入一个字节，会使得页缓存未命中，而触发内核从磁盘读取以及在页缓存中映射这一页对应的文件。这样就会减少在mmap系统调用之后，用户每次访问文件映射的虚拟内存引起的缺页异常，即把耗时操作集中放在了创建的时候。</p>\n<h3 id=\"sqlite3OsShmUnmap\"><a href=\"#sqlite3OsShmUnmap\" class=\"headerlink\" title=\"sqlite3OsShmUnmap\"></a>sqlite3OsShmUnmap</h3><p>下面是函数的原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">unixShmUnmap</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  sqlite3_file *fd,               <span class=\"comment\">/* The underlying database file */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> deleteFlag                  <span class=\"comment\">/* Delete shared-memory if true */</span></span></span><br><span class=\"line\"><span class=\"params\">)</span></span><br></pre></td></tr></table></figure>\n<p>顾名思义，Unmap函数的操作结果是取消映射文件，如果deleteFlag是1的话还会清空共享缓存。</p>\n<p>函数过程：</p>\n<ol>\n<li>从unixInodeInfo中找到unixShmNode，遍历unixShmNode的first指针链表，找到当前sqlite_file的unixShm，并且从链表中断开。</li>\n<li>减少unixShmNode的引用计数，如果计数到0了，那么就清空共享缓存（第三步）。</li>\n<li>按照nShmPerMap的大小调用osMunmap方法，直到释放所有的mmap缓存。</li>\n</ol>\n<h3 id=\"sqlite3OsShmLock\"><a href=\"#sqlite3OsShmLock\" class=\"headerlink\" title=\"sqlite3OsShmLock\"></a>sqlite3OsShmLock</h3><p>下面是函数原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">unixShmLock</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  sqlite3_file *fd,          <span class=\"comment\">/* Database file holding the shared memory */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> ofst,                  <span class=\"comment\">/* First lock to acquire or release */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> n,                     <span class=\"comment\">/* Number of locks to acquire or release */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> flags                  <span class=\"comment\">/* What to do with the lock */</span></span></span><br><span class=\"line\"><span class=\"params\">)</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define SQLITE_SHM_UNLOCK       1</span><br><span class=\"line\">#define SQLITE_SHM_LOCK         2</span><br><span class=\"line\">#define SQLITE_SHM_SHARED       4</span><br><span class=\"line\">#define SQLITE_SHM_EXCLUSIVE    8</span><br></pre></td></tr></table></figure>\n<p>上面是shm锁的类型，也就是第4个参数flags的参数来源。UNLOCK、LOCK 和 SHARED、EXCLUSIVE分别组合，即4种组合。（其实只有unlock、shared、exclusive三种）<br><strong>与数据库文件锁不太一样，shm的锁不能由excl&lt;-&gt;shared，只能有unlock到任一锁或者任一锁到unlock。</strong></p>\n<p>与数据库文件锁一样的是，posix文件锁的特性。<br>上文中 unixShm 的数据结构中还有两个变量，分别是sharedMask和exclMask，分别表示当前这个数据库连接持有的对应shm的mmap文件锁类型。</p>\n<ol>\n<li><p>请求的锁是SQLITE_SHM_UNLOCK<br>遍历使用当前unixShmNode的unixShm链表，如果已经没有其他unixShm加锁了，就调用unixShmSystemLock真正的移除文件锁，并且移除sharedMask和exclMask的标记位。否则就只是移除标记位。</p>\n</li>\n<li><p>请求的锁是SQLITE_SHM_SHARED<br>遍历使用当前unixShmNode的unixShm链表，如果有exclusive锁，返回SQLITE_BUSY。如果当前进程内没有任何锁，就调用unixShmSystemLock在文件上加读锁，并把unixShm上的sharedMask置1。否则就只是置位。</p>\n</li>\n<li><p>请求的锁是SQLITE_SHM_EXCLUSIVE<br>遍历使用当前unixShmNode的unixShm链表，如果有其他任何在锁状态，返回SQLITE_BUSY。否则就调用unixShmSystemLock在文件上加写锁，并且在exclMask上置1。</p>\n</li>\n</ol>\n<h3 id=\"sqlite3OsShmBarrier\"><a href=\"#sqlite3OsShmBarrier\" class=\"headerlink\" title=\"sqlite3OsShmBarrier\"></a>sqlite3OsShmBarrier</h3><p>通过调用<code>__sync_synchronize()</code>函数实现的内存屏障。所有在屏障之前的代码必定会在屏障之后的代码执行之前完成执行。具体可以看后文的内存屏障相关文章。</p>\n<blockquote>\n<p>参考<br>mmap相关<br><a href=\"https://www.cnblogs.com/ccxikka/p/10527056.html\">各种缓存（一） - ccxikka - 博客园</a><br><a href=\"https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label5\">认真分析mmap：是什么 为什么 怎么用 - 胡潇 - 博客园</a><br><a href=\"https://blog.csdn.net/Holy_666/article/details/86532671\">彻底理解mmap()</a><br>内存屏障<br><a href=\"https://www.jianshu.com/p/64240319ed60\">一文解决内存屏障 - 简书</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在开启sqlite wal功能的时候，会在db文件的同级目录下多出一个，与db同名的，后缀为-shm的文件，这个文件就是本文需要讨论的shared-memory（shm）。文章只讨论sqlite在os层中shm的实现，而不关注shm中存储的内容和数据结构。</p>\n</blockquote>","more":"<h2 id=\"Shm-共享内存\"><a href=\"#Shm-共享内存\" class=\"headerlink\" title=\"Shm-共享内存\"></a>Shm-共享内存</h2><p>shm-shared memory 是在开启wal的时候被用来存储wal-index(这个不是本层考虑的)。所以在没有定义<code>SQLITE_OMIT_WAL</code>这个宏的时候，sqlite os层提供了shm的能力。</p>\n<p>从暴露的接口上来开一共只有4个接口函数，分别是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3OsShmMap</span><span class=\"params\">(sqlite3_file *,<span class=\"type\">int</span>,<span class=\"type\">int</span>,<span class=\"type\">int</span>,<span class=\"type\">void</span> <span class=\"keyword\">volatile</span> **)</span>;<span class=\"comment\">//映射文件</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3OsShmLock</span><span class=\"params\">(sqlite3_file *id, <span class=\"type\">int</span>, <span class=\"type\">int</span>, <span class=\"type\">int</span>)</span>;<span class=\"comment\">//mmap锁</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sqlite3OsShmBarrier</span><span class=\"params\">(sqlite3_file *id)</span>;<span class=\"comment\">//内存屏障</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3OsShmUnmap</span><span class=\"params\">(sqlite3_file *id, <span class=\"type\">int</span>)</span>;<span class=\"comment\">//取消映射文件</span></span><br></pre></td></tr></table></figure>\n\n<p>暂先不看代码，需要先从mmap开始说起…</p>\n<h3 id=\"关于mmap\"><a href=\"#关于mmap\" class=\"headerlink\" title=\"关于mmap\"></a>关于mmap</h3><p>这也是在看源码的时候，发现知识盲区了…然后去查了大量关于mmap的资料。这样虽然效率低了一点，但是还是便于之后的代码理解的。</p>\n<p>mmap其实之前也有遇到用过，它的两个特性印象比较深刻，一个是mmap是内存文件映射，可以用读写内存的方式读写文件内容，二是在应用crash的时候或者系统掉电的时候可以把内存中数据的flush到文件中。但这些似乎不太够…</p>\n<p>首先看<strong>普通</strong>的文件读写：</p>\n<p>在此之前，再了解一个<strong>页缓存</strong>，页缓存是内核的一个重要的磁盘高速缓存，<strong>以页为单位进行缓存</strong>。可以简单的把它理解为…memory cache。读数据的时候会优先的从页缓存中读，而写数据的时候，也是优先写入页缓存，并且不会立刻回写文件，而是标记dirty，延迟一段时间或者手动调用sync的时候才会回写。</p>\n<p>这时候我们再看文件读写，发起一个read()或者write()系统调用，我们一般会分配一个buff缓冲区，然后会进入内核态，cpu会从页缓存中读取指定的文件缓存。如果发现页缓存中没有，那么这个时候cpu就会让出总线，用DMA的方式，将数据从磁盘拷贝到页缓存中，拷贝完成的时候处理DMA中断。在此之后，因为拷贝的地址是内核地址，cpu需要在内核态，再把页缓存拷贝至用户态的虚拟地址映射的物理地址即（buff对应的缓冲区）。</p>\n<p>也就是说，普通文件的读写，会发生两次内存拷贝。</p>\n<p>我们再看<strong>mmap</strong>的文件读写：</p>\n<p>我们使用mmap的时候，系统会首先分配一段虚拟内存，并且在该过程中建立了vma和映射文件的关联，向上返回虚拟内存的首地址，此时还没有建立和物理内存的映射关系。等到第一次访问虚拟地址时，发生缺页异常，将对应的文件内容读取到页缓存，<strong>并建立虚拟内存和页缓存的映射关系</strong>，如此只有一次将文件数据读取页缓存的过程。</p>\n<p>这里有个问题:mmap并不是直接将虚拟内存对应的物理内存和文件建立映射关系，二是内核将数据拷贝至页缓存，然后将虚拟内存直接映射到了页缓存上，从而避免的二次拷贝</p>\n<p>这也就是mmap比普通文件读写要快的原因。mmap的其他相关知识可以访问后文的资料链接。</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>每个unixFile关联了一个unixShm结构体，这个结构体用来描述一个已打开的共享文件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">unixShm</span> &#123;</span></span><br><span class=\"line\">  unixShmNode *pShmNode;     <span class=\"comment\">/* The underlying unixShmNode object */</span></span><br><span class=\"line\">  unixShm *pNext;            <span class=\"comment\">/* Next unixShm with the same unixShmNode */</span></span><br><span class=\"line\">  u8 hasMutex;               <span class=\"comment\">/* True if holding the unixShmNode-&gt;pShmMutex */</span></span><br><span class=\"line\">  u8 id;                     <span class=\"comment\">/* Id of this connection within its unixShmNode */</span></span><br><span class=\"line\">  u16 sharedMask;            <span class=\"comment\">/* Mask of shared locks held */</span></span><br><span class=\"line\">  u16 exclMask;              <span class=\"comment\">/* Mask of exclusive locks held */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>而从注释上也可以看出来，每一个unixShm还有一个unixShmNode。而指向同一个unixShmNode的unixShm都通过pNext关联在一个链表内。使用同一个unixShmNode的shm链表被存储在unixShmNode的pfirst指针中。同一个数据库文件的不同的数据库连接（假设使用了WAL mode），包含的是不同的unixShm，但是是同一个unixShmNode。</p>\n<p>unixShmNode从某种意义上来说是可以与unixInodeInfo关联在一起的，但是开发者可能不想让所有不使用shm（WAL mode）的数据连接也持有这些没有意义的数据，所以才做了分离，只做了unixInodeInfo内的pShmNode指针和unixShmNode的pInode指针的相互指向(绑定)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">unixShmNode</span> &#123;</span></span><br><span class=\"line\">  unixInodeInfo *pInode;     <span class=\"comment\">/* unixInodeInfo that owns this SHM node */</span></span><br><span class=\"line\">  sqlite3_mutex *pShmMutex;  <span class=\"comment\">/* Mutex to access this object */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *zFilename;           <span class=\"comment\">/* Name of the mmapped file */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> hShm;                  <span class=\"comment\">/* Open file descriptor */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> szRegion;              <span class=\"comment\">/* Size of shared-memory regions */</span></span><br><span class=\"line\">  u16 nRegion;               <span class=\"comment\">/* Size of array apRegion */</span></span><br><span class=\"line\">  u8 isReadonly;             <span class=\"comment\">/* True if read-only */</span></span><br><span class=\"line\">  u8 isUnlocked;             <span class=\"comment\">/* True if no DMS lock held */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> **apRegion;           <span class=\"comment\">/* Array of mapped shared-memory regions */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nRef;                  <span class=\"comment\">/* Number of unixShm objects pointing to this */</span></span><br><span class=\"line\">  unixShm *pFirst;           <span class=\"comment\">/* All unixShm objects pointing to this */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们分别看Sqlite的这4个接口函数</p>\n<h3 id=\"sqlite3OsShmMap\"><a href=\"#sqlite3OsShmMap\" class=\"headerlink\" title=\"sqlite3OsShmMap\"></a>sqlite3OsShmMap</h3><p>下面是shmMap原始的函数签名。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">unixShmMap</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  sqlite3_file *fd,               <span class=\"comment\">/* Handle open on database file */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> iRegion,                    <span class=\"comment\">/* Region to retrieve */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> szRegion,                   <span class=\"comment\">/* Size of regions */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> bExtend,                    <span class=\"comment\">/* True to extend file if necessary */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">void</span> <span class=\"keyword\">volatile</span> **pp              <span class=\"comment\">/* OUT: Mapped memory */</span></span></span><br><span class=\"line\"><span class=\"params\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>在sqlite中，每一个文件的映射是由一个一个region组合起来的(unixShmNode中的apRegion就是region指针的数组,nRegion就是这个数组的大小)。而unixShmMap这个函数就是获取第iRegion区域的mmap指针。其中每一个region的size是szRegion。(这个值从第一次调用之后就<strong>不可以</strong>在变了，会被存储在unixShmNode中的szRegion内)</p>\n<p>第一个参数就是需要打开shm的数据库文件对象，第二个iRegion是需要获取的区域下标，szRegion是每一个区域的大小，bExtend表示是否可以扩展文件大小，最后是返回的mmap的地址指针。</p>\n<p>sqlite设定了一个最小region size是32kb。根据上文说的，mmap是按照page size来映射文件的。一般情况下page size 在32位机器下是4k。所以，mmap一次映射最小（nShmPerMap）是1个region，但如果page size是64k，那么一次最小（nShmPerMap）就需要2个region了。</p>\n<p>函数过程：</p>\n<ol>\n<li>如果当前数据库连接的文件对象内共享文件没有打开，先打开文件。如果unixNodeInfo的pShmNode也是空的，那么将创建unixShmNode与unixNodeInfo绑定。在shm文件打开完成之后，会在shm的128个字节处加读锁。（在加读锁之前会判断是否是第一个打开该文件的进程，如果是，那么会把文件裁剪为3个字节，之所以是3个，一是出于调试的目的，二是3个字节小于shm文件的header大小，也不会影响业务逻辑）</li>\n<li>根据最小region，计算出iRegion需要映射的region数量nReqRegion。判断是否已经映射（nReqRegion&lt;unixShmNode.nRegion）,如果还没有映射，那么执行第3步，否则执行第5步</li>\n<li>判断映射文件的大小是否需要扩展，如果需要扩展，那么在扩展的文件空间对应的内存分页写入最后一个字节（下面会解释这个操作的原因）。</li>\n<li>文件扩展完成之后，按照已有的mmap的region个数（unixShmNode.nRegion）和请求的nReqRegion个数来扩展apRegion。其中考虑到一次最少分配nShmPerMap个region，再把nShmPerMap个region拆分到apRegion中</li>\n<li>返回unixShmNode.apRegion中第iRegion个region对应的mmap地址。</li>\n</ol>\n<p><strong>解释一下第三步，为什么扩展mmap文件的时候，需要在每一个分页最后写入一个字节？</strong><br>Sqlite的解释是：从技术上来说，扩展一个文件，我们只需要在文件的最后的最后一个字节，写入一个字节就可以直接扩展文件的大小了。在扩展的空间的每一个内存分页大小的最后写入一个字节，可以减少之后mmap映射区间的时候SIGBUS的概率。</p>\n<p>详细可以看 <a href=\"https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label5\">认真分析mmap：是什么 为什么 怎么用 - 胡潇 - 博客园</a> 这篇文章最后的情景二，文件大小不是页的整倍数的情况。</p>\n<p>再加上我们上文说到的页缓存的逻辑，大致可以猜测，因为只有在真正读写文件的时候，才会触发页缓存的cache查询。而在文件的每一个分页的最后写入一个字节，会使得页缓存未命中，而触发内核从磁盘读取以及在页缓存中映射这一页对应的文件。这样就会减少在mmap系统调用之后，用户每次访问文件映射的虚拟内存引起的缺页异常，即把耗时操作集中放在了创建的时候。</p>\n<h3 id=\"sqlite3OsShmUnmap\"><a href=\"#sqlite3OsShmUnmap\" class=\"headerlink\" title=\"sqlite3OsShmUnmap\"></a>sqlite3OsShmUnmap</h3><p>下面是函数的原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">unixShmUnmap</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  sqlite3_file *fd,               <span class=\"comment\">/* The underlying database file */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> deleteFlag                  <span class=\"comment\">/* Delete shared-memory if true */</span></span></span><br><span class=\"line\"><span class=\"params\">)</span></span><br></pre></td></tr></table></figure>\n<p>顾名思义，Unmap函数的操作结果是取消映射文件，如果deleteFlag是1的话还会清空共享缓存。</p>\n<p>函数过程：</p>\n<ol>\n<li>从unixInodeInfo中找到unixShmNode，遍历unixShmNode的first指针链表，找到当前sqlite_file的unixShm，并且从链表中断开。</li>\n<li>减少unixShmNode的引用计数，如果计数到0了，那么就清空共享缓存（第三步）。</li>\n<li>按照nShmPerMap的大小调用osMunmap方法，直到释放所有的mmap缓存。</li>\n</ol>\n<h3 id=\"sqlite3OsShmLock\"><a href=\"#sqlite3OsShmLock\" class=\"headerlink\" title=\"sqlite3OsShmLock\"></a>sqlite3OsShmLock</h3><p>下面是函数原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">unixShmLock</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  sqlite3_file *fd,          <span class=\"comment\">/* Database file holding the shared memory */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> ofst,                  <span class=\"comment\">/* First lock to acquire or release */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> n,                     <span class=\"comment\">/* Number of locks to acquire or release */</span></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">int</span> flags                  <span class=\"comment\">/* What to do with the lock */</span></span></span><br><span class=\"line\"><span class=\"params\">)</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define SQLITE_SHM_UNLOCK       1</span><br><span class=\"line\">#define SQLITE_SHM_LOCK         2</span><br><span class=\"line\">#define SQLITE_SHM_SHARED       4</span><br><span class=\"line\">#define SQLITE_SHM_EXCLUSIVE    8</span><br></pre></td></tr></table></figure>\n<p>上面是shm锁的类型，也就是第4个参数flags的参数来源。UNLOCK、LOCK 和 SHARED、EXCLUSIVE分别组合，即4种组合。（其实只有unlock、shared、exclusive三种）<br><strong>与数据库文件锁不太一样，shm的锁不能由excl&lt;-&gt;shared，只能有unlock到任一锁或者任一锁到unlock。</strong></p>\n<p>与数据库文件锁一样的是，posix文件锁的特性。<br>上文中 unixShm 的数据结构中还有两个变量，分别是sharedMask和exclMask，分别表示当前这个数据库连接持有的对应shm的mmap文件锁类型。</p>\n<ol>\n<li><p>请求的锁是SQLITE_SHM_UNLOCK<br>遍历使用当前unixShmNode的unixShm链表，如果已经没有其他unixShm加锁了，就调用unixShmSystemLock真正的移除文件锁，并且移除sharedMask和exclMask的标记位。否则就只是移除标记位。</p>\n</li>\n<li><p>请求的锁是SQLITE_SHM_SHARED<br>遍历使用当前unixShmNode的unixShm链表，如果有exclusive锁，返回SQLITE_BUSY。如果当前进程内没有任何锁，就调用unixShmSystemLock在文件上加读锁，并把unixShm上的sharedMask置1。否则就只是置位。</p>\n</li>\n<li><p>请求的锁是SQLITE_SHM_EXCLUSIVE<br>遍历使用当前unixShmNode的unixShm链表，如果有其他任何在锁状态，返回SQLITE_BUSY。否则就调用unixShmSystemLock在文件上加写锁，并且在exclMask上置1。</p>\n</li>\n</ol>\n<h3 id=\"sqlite3OsShmBarrier\"><a href=\"#sqlite3OsShmBarrier\" class=\"headerlink\" title=\"sqlite3OsShmBarrier\"></a>sqlite3OsShmBarrier</h3><p>通过调用<code>__sync_synchronize()</code>函数实现的内存屏障。所有在屏障之前的代码必定会在屏障之后的代码执行之前完成执行。具体可以看后文的内存屏障相关文章。</p>\n<blockquote>\n<p>参考<br>mmap相关<br><a href=\"https://www.cnblogs.com/ccxikka/p/10527056.html\">各种缓存（一） - ccxikka - 博客园</a><br><a href=\"https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label5\">认真分析mmap：是什么 为什么 怎么用 - 胡潇 - 博客园</a><br><a href=\"https://blog.csdn.net/Holy_666/article/details/86532671\">彻底理解mmap()</a><br>内存屏障<br><a href=\"https://www.jianshu.com/p/64240319ed60\">一文解决内存屏障 - 简书</a></p>\n</blockquote>"},{"title":"当编译优化遇上AutoRelease优化","date":"2020-03-14T16:00:00.000Z","top":400,"_content":"\n最近在复习自动释放池，在ARC下runtime有一个优化`objc_autoreleaseReturnValue`和`objc_retainAutoreleaseReturnValue`，但是优化遇上编译器优化，似乎有点问题...不知道算不算苹果自己给自己挖的坑。\n\n<!-- more -->\n\n## 背景\n现讲述一下大致的背景:（如果很了解autorelease及其优化原理可以直接跳过这一节）\n**MRC：**\n\n在MRC下，本着谁分配谁释放的原则，在方法返回方法内部创建的某个对象的时候，其实是需要释放掉对象的（因为当前方法栈已经结束）。但是矛盾的是如果释放了，那这个方法如果返回这个对象给调用者，调用者又如何取到？\n\n所以，在返回对象的时候，不释放对象，而是把对象加入到 自动释放池 内（其实这里可以理解为，把对象的所有权交给了自动释放池），此时自动释放池持有了这个对象（引用计数为1）。调用者依旧可以拿到这个对象地址，对象依旧有效。\n\n当然调用者自己是否需要持有它，那是调用者的逻辑了，持有与释放相互匹配。\n\n**ARC：**\n\n在ARC下，需要依旧保持MRC下的“谁分配谁释放”的原则。但是ARC下编译器不允许调用autorelease方法。编译器会给代码的返回值后自动插入autorelease。\n\n\n**runtime优化：**\n\n在MRC下，如果调用者和被调用者都是模块内自己调用，那么其实可以忽略掉自动释放池这一个步骤。换句话说，如果可以保证调用者有变量在接收返回值，那么被调用者可以不用加入自动释放池，直接把对象的所有权转移给函数接受者。\n\nps:当然这样会有风险，前提是模块内调用，如果是模块间调用，没有变量接收返回值的话，那么就会造成内存泄漏了。\n\n那么在ARC下如何优化呢？\n\nruntime结合编译器自动实现了这个过程。其实runtime的优化思路和上面MRC环境下开发者的优化思路是一样的，只不过把这个过程转换为了代码。\n\n在被调用方使用`__builtin_return_address(int depth)`这个函数判断调用方的接受者是否使用了这个优化函数`objc_retainAutoreleaseReturnValue`（有两种情况不使用，一种是MRC，一种是没有接受者），如果使用了优化那么被调用方`objc_autoreleaseReturnValue`就会把某个标记位flag设置到TLS。\n\n如果调用方不使用优化，那么就是走自动释放池的逻辑；如果调用方使用了优化函数`objc_retainAutoreleaseReturnValue`，那么先去TLS看有没有这个标记位（防止被调用方没有优化），如果有，直接使用返回的值，无需再调用retain了。\n\n简单总结：\n\n如果双方都使用优化，那么就直接用返回的对象，被调用方不释放，调用方不持有。实际就是对象拥有者直接转移。\n\n调用者通过TLS的flag判断被调用者是否使用了优化。\n\n被调用者通过`__builtin_return_address(int depth)`这个函数判断调用者是否使用优化。\n\n## 问题\n在理解的过程中，我一直以为这个在ARC下的实验结果应该没有悬念的...但现实却给了我狠狠的一巴掌。\n\n我在Xcode里新建了一个 Mac 应用程序的Demo，ARC，方法返回的值始终在自动释放池内。\n\n下面是测试代码，测试代码来自网络..\n\n```objective-c\nextern void _objc_autoreleasePoolPrint(void);\n\nint main(int argc, const char * argv[]) {\n    ///////////////////////////////////////////////////////////////////////////////////////////// 1.\n        id obj0;\n        {\n            id obj1 = [NSMutableArray array];\n            obj0 = obj1;\n            _objc_autoreleasePoolPrint();\n        }\n        NSLog(@\"obj0-%@\", obj0);\n        \n    ///////////////////////////////////////////////////////////////////////////////////////////// 2.\n        id __weak obj2;\n        {\n            id obj3 = [NSMutableArray array];\n            obj2 = obj3;\n            _objc_autoreleasePoolPrint();\n        }\n        NSLog(@\"obj2-%@\", obj2);\n        \n    ///////////////////////////////////////////////////////////////////////////////////////////// 3.\n        id __weak obj4;\n        @autoreleasepool {\n            id obj5 = [NSMutableArray array];\n            obj4 = obj5;\n            _objc_autoreleasePoolPrint();\n        }\n        NSLog(@\"obj4-%@\", obj4);\n    return 0;\n}\n```\n\n上面这3段代码，区别在于后两者插入了一个__weak指针的赋值，但是实际结果却是三个数组都在自动释放池内。\n\n于是我找到了这篇 [文章](https://www.jianshu.com/p/e920d1ff570c)....\n\n然后我又在真机上调试了一下，确实，第一个没有进自动释放池，后两个都进了。\n\n文章作者最后给的解释比较模糊（后面两个没有调用retain），于是我只能自己再找原因。\n\n## 解决\nRuntime其实已经有源码可寻，。关键在于调用者的那个优化函数的指令地址。\n\n那么就看看汇编代码，到底有什么区别...\n下面是ARM（真机）的汇编代码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/843978e4d9ad66e0db24562ace0f0f61.png)\n\n在runtime的实现里会直接比较调用者下一个函数在代码内的地址与`objc_retainAutoreleasedReturnValue`的函数地址。很明显，第一个之所以不在池内是因为后面紧跟着`objc_retainAutoreleasedReturnValue`，而第二个就不是。\n\n第二个和第一个的区别只有一个weak指针的赋值，于是我把赋值也去掉了。\n```objective-c\n\t\t id __weak obj2;\n        {\n            id obj3 = [NSMutableArray array];\n            _objc_autoreleasePoolPrint();\n        }\n        NSLog(@\"obj2-%@\", obj2);\n```\n\n结果依旧如此....\n\n？？？？？？\n\n我第一反应就想到了编译器的优化。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/3f92e902bb664855cef64c063158c7d4.png)\n\n默认情况下，Debug的优化级别为`None`，Release的是`Fastest,Smallest[-Os]`。我把Debug改为和Release一样...\n\n结果......就和预期一样，三个都不会在自动释放池内，也就是说在真机上运行是符合预期的。\n\n编译器不优化会导致 `objc_retainAutoreleasedReturnValue`和返回函数之间被插入代码，优化了反而不会被插入...\n\n对编译器不了解，这里没有任何发言权，本文也只是一些实验和猜测...\n\n另外x86的iOS模拟器和mac程序，调整优化level也只能部分达到预期...","source":"_posts/12.compiler-autorelease-opt.md","raw":"---\ntitle: 当编译优化遇上AutoRelease优化\ndate: 2020-03-15\ntags: [object-c]\ntop: 400\ncategories: object-c\n---\n\n最近在复习自动释放池，在ARC下runtime有一个优化`objc_autoreleaseReturnValue`和`objc_retainAutoreleaseReturnValue`，但是优化遇上编译器优化，似乎有点问题...不知道算不算苹果自己给自己挖的坑。\n\n<!-- more -->\n\n## 背景\n现讲述一下大致的背景:（如果很了解autorelease及其优化原理可以直接跳过这一节）\n**MRC：**\n\n在MRC下，本着谁分配谁释放的原则，在方法返回方法内部创建的某个对象的时候，其实是需要释放掉对象的（因为当前方法栈已经结束）。但是矛盾的是如果释放了，那这个方法如果返回这个对象给调用者，调用者又如何取到？\n\n所以，在返回对象的时候，不释放对象，而是把对象加入到 自动释放池 内（其实这里可以理解为，把对象的所有权交给了自动释放池），此时自动释放池持有了这个对象（引用计数为1）。调用者依旧可以拿到这个对象地址，对象依旧有效。\n\n当然调用者自己是否需要持有它，那是调用者的逻辑了，持有与释放相互匹配。\n\n**ARC：**\n\n在ARC下，需要依旧保持MRC下的“谁分配谁释放”的原则。但是ARC下编译器不允许调用autorelease方法。编译器会给代码的返回值后自动插入autorelease。\n\n\n**runtime优化：**\n\n在MRC下，如果调用者和被调用者都是模块内自己调用，那么其实可以忽略掉自动释放池这一个步骤。换句话说，如果可以保证调用者有变量在接收返回值，那么被调用者可以不用加入自动释放池，直接把对象的所有权转移给函数接受者。\n\nps:当然这样会有风险，前提是模块内调用，如果是模块间调用，没有变量接收返回值的话，那么就会造成内存泄漏了。\n\n那么在ARC下如何优化呢？\n\nruntime结合编译器自动实现了这个过程。其实runtime的优化思路和上面MRC环境下开发者的优化思路是一样的，只不过把这个过程转换为了代码。\n\n在被调用方使用`__builtin_return_address(int depth)`这个函数判断调用方的接受者是否使用了这个优化函数`objc_retainAutoreleaseReturnValue`（有两种情况不使用，一种是MRC，一种是没有接受者），如果使用了优化那么被调用方`objc_autoreleaseReturnValue`就会把某个标记位flag设置到TLS。\n\n如果调用方不使用优化，那么就是走自动释放池的逻辑；如果调用方使用了优化函数`objc_retainAutoreleaseReturnValue`，那么先去TLS看有没有这个标记位（防止被调用方没有优化），如果有，直接使用返回的值，无需再调用retain了。\n\n简单总结：\n\n如果双方都使用优化，那么就直接用返回的对象，被调用方不释放，调用方不持有。实际就是对象拥有者直接转移。\n\n调用者通过TLS的flag判断被调用者是否使用了优化。\n\n被调用者通过`__builtin_return_address(int depth)`这个函数判断调用者是否使用优化。\n\n## 问题\n在理解的过程中，我一直以为这个在ARC下的实验结果应该没有悬念的...但现实却给了我狠狠的一巴掌。\n\n我在Xcode里新建了一个 Mac 应用程序的Demo，ARC，方法返回的值始终在自动释放池内。\n\n下面是测试代码，测试代码来自网络..\n\n```objective-c\nextern void _objc_autoreleasePoolPrint(void);\n\nint main(int argc, const char * argv[]) {\n    ///////////////////////////////////////////////////////////////////////////////////////////// 1.\n        id obj0;\n        {\n            id obj1 = [NSMutableArray array];\n            obj0 = obj1;\n            _objc_autoreleasePoolPrint();\n        }\n        NSLog(@\"obj0-%@\", obj0);\n        \n    ///////////////////////////////////////////////////////////////////////////////////////////// 2.\n        id __weak obj2;\n        {\n            id obj3 = [NSMutableArray array];\n            obj2 = obj3;\n            _objc_autoreleasePoolPrint();\n        }\n        NSLog(@\"obj2-%@\", obj2);\n        \n    ///////////////////////////////////////////////////////////////////////////////////////////// 3.\n        id __weak obj4;\n        @autoreleasepool {\n            id obj5 = [NSMutableArray array];\n            obj4 = obj5;\n            _objc_autoreleasePoolPrint();\n        }\n        NSLog(@\"obj4-%@\", obj4);\n    return 0;\n}\n```\n\n上面这3段代码，区别在于后两者插入了一个__weak指针的赋值，但是实际结果却是三个数组都在自动释放池内。\n\n于是我找到了这篇 [文章](https://www.jianshu.com/p/e920d1ff570c)....\n\n然后我又在真机上调试了一下，确实，第一个没有进自动释放池，后两个都进了。\n\n文章作者最后给的解释比较模糊（后面两个没有调用retain），于是我只能自己再找原因。\n\n## 解决\nRuntime其实已经有源码可寻，。关键在于调用者的那个优化函数的指令地址。\n\n那么就看看汇编代码，到底有什么区别...\n下面是ARM（真机）的汇编代码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/843978e4d9ad66e0db24562ace0f0f61.png)\n\n在runtime的实现里会直接比较调用者下一个函数在代码内的地址与`objc_retainAutoreleasedReturnValue`的函数地址。很明显，第一个之所以不在池内是因为后面紧跟着`objc_retainAutoreleasedReturnValue`，而第二个就不是。\n\n第二个和第一个的区别只有一个weak指针的赋值，于是我把赋值也去掉了。\n```objective-c\n\t\t id __weak obj2;\n        {\n            id obj3 = [NSMutableArray array];\n            _objc_autoreleasePoolPrint();\n        }\n        NSLog(@\"obj2-%@\", obj2);\n```\n\n结果依旧如此....\n\n？？？？？？\n\n我第一反应就想到了编译器的优化。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/3f92e902bb664855cef64c063158c7d4.png)\n\n默认情况下，Debug的优化级别为`None`，Release的是`Fastest,Smallest[-Os]`。我把Debug改为和Release一样...\n\n结果......就和预期一样，三个都不会在自动释放池内，也就是说在真机上运行是符合预期的。\n\n编译器不优化会导致 `objc_retainAutoreleasedReturnValue`和返回函数之间被插入代码，优化了反而不会被插入...\n\n对编译器不了解，这里没有任何发言权，本文也只是一些实验和猜测...\n\n另外x86的iOS模拟器和mac程序，调整优化level也只能部分达到预期...","slug":"12.compiler-autorelease-opt","published":1,"updated":"2022-07-28T13:38:40.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwo4000jp9c92cvhffsh","content":"<p>最近在复习自动释放池，在ARC下runtime有一个优化<code>objc_autoreleaseReturnValue</code>和<code>objc_retainAutoreleaseReturnValue</code>，但是优化遇上编译器优化，似乎有点问题…不知道算不算苹果自己给自己挖的坑。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>现讲述一下大致的背景:（如果很了解autorelease及其优化原理可以直接跳过这一节）<br><strong>MRC：</strong></p>\n<p>在MRC下，本着谁分配谁释放的原则，在方法返回方法内部创建的某个对象的时候，其实是需要释放掉对象的（因为当前方法栈已经结束）。但是矛盾的是如果释放了，那这个方法如果返回这个对象给调用者，调用者又如何取到？</p>\n<p>所以，在返回对象的时候，不释放对象，而是把对象加入到 自动释放池 内（其实这里可以理解为，把对象的所有权交给了自动释放池），此时自动释放池持有了这个对象（引用计数为1）。调用者依旧可以拿到这个对象地址，对象依旧有效。</p>\n<p>当然调用者自己是否需要持有它，那是调用者的逻辑了，持有与释放相互匹配。</p>\n<p><strong>ARC：</strong></p>\n<p>在ARC下，需要依旧保持MRC下的“谁分配谁释放”的原则。但是ARC下编译器不允许调用autorelease方法。编译器会给代码的返回值后自动插入autorelease。</p>\n<p><strong>runtime优化：</strong></p>\n<p>在MRC下，如果调用者和被调用者都是模块内自己调用，那么其实可以忽略掉自动释放池这一个步骤。换句话说，如果可以保证调用者有变量在接收返回值，那么被调用者可以不用加入自动释放池，直接把对象的所有权转移给函数接受者。</p>\n<p>ps:当然这样会有风险，前提是模块内调用，如果是模块间调用，没有变量接收返回值的话，那么就会造成内存泄漏了。</p>\n<p>那么在ARC下如何优化呢？</p>\n<p>runtime结合编译器自动实现了这个过程。其实runtime的优化思路和上面MRC环境下开发者的优化思路是一样的，只不过把这个过程转换为了代码。</p>\n<p>在被调用方使用<code>__builtin_return_address(int depth)</code>这个函数判断调用方的接受者是否使用了这个优化函数<code>objc_retainAutoreleaseReturnValue</code>（有两种情况不使用，一种是MRC，一种是没有接受者），如果使用了优化那么被调用方<code>objc_autoreleaseReturnValue</code>就会把某个标记位flag设置到TLS。</p>\n<p>如果调用方不使用优化，那么就是走自动释放池的逻辑；如果调用方使用了优化函数<code>objc_retainAutoreleaseReturnValue</code>，那么先去TLS看有没有这个标记位（防止被调用方没有优化），如果有，直接使用返回的值，无需再调用retain了。</p>\n<p>简单总结：</p>\n<p>如果双方都使用优化，那么就直接用返回的对象，被调用方不释放，调用方不持有。实际就是对象拥有者直接转移。</p>\n<p>调用者通过TLS的flag判断被调用者是否使用了优化。</p>\n<p>被调用者通过<code>__builtin_return_address(int depth)</code>这个函数判断调用者是否使用优化。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在理解的过程中，我一直以为这个在ARC下的实验结果应该没有悬念的…但现实却给了我狠狠的一巴掌。</p>\n<p>我在Xcode里新建了一个 Mac 应用程序的Demo，ARC，方法返回的值始终在自动释放池内。</p>\n<p>下面是测试代码，测试代码来自网络..</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern void _objc_autoreleasePoolPrint(void);</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    ///////////////////////////////////////////////////////////////////////////////////////////// 1.</span><br><span class=\"line\">        id obj0;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            id obj1 = [NSMutableArray array];</span><br><span class=\"line\">            obj0 = obj1;</span><br><span class=\"line\">            _objc_autoreleasePoolPrint();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        NSLog(@&quot;obj0-%@&quot;, obj0);</span><br><span class=\"line\">        </span><br><span class=\"line\">    ///////////////////////////////////////////////////////////////////////////////////////////// 2.</span><br><span class=\"line\">        id __weak obj2;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            id obj3 = [NSMutableArray array];</span><br><span class=\"line\">            obj2 = obj3;</span><br><span class=\"line\">            _objc_autoreleasePoolPrint();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        NSLog(@&quot;obj2-%@&quot;, obj2);</span><br><span class=\"line\">        </span><br><span class=\"line\">    ///////////////////////////////////////////////////////////////////////////////////////////// 3.</span><br><span class=\"line\">        id __weak obj4;</span><br><span class=\"line\">        @autoreleasepool &#123;</span><br><span class=\"line\">            id obj5 = [NSMutableArray array];</span><br><span class=\"line\">            obj4 = obj5;</span><br><span class=\"line\">            _objc_autoreleasePoolPrint();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        NSLog(@&quot;obj4-%@&quot;, obj4);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这3段代码，区别在于后两者插入了一个__weak指针的赋值，但是实际结果却是三个数组都在自动释放池内。</p>\n<p>于是我找到了这篇 <a href=\"https://www.jianshu.com/p/e920d1ff570c\">文章</a>….</p>\n<p>然后我又在真机上调试了一下，确实，第一个没有进自动释放池，后两个都进了。</p>\n<p>文章作者最后给的解释比较模糊（后面两个没有调用retain），于是我只能自己再找原因。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>Runtime其实已经有源码可寻，。关键在于调用者的那个优化函数的指令地址。</p>\n<p>那么就看看汇编代码，到底有什么区别…<br>下面是ARM（真机）的汇编代码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/843978e4d9ad66e0db24562ace0f0f61.png\"></p>\n<p>在runtime的实现里会直接比较调用者下一个函数在代码内的地址与<code>objc_retainAutoreleasedReturnValue</code>的函数地址。很明显，第一个之所以不在池内是因为后面紧跟着<code>objc_retainAutoreleasedReturnValue</code>，而第二个就不是。</p>\n<p>第二个和第一个的区别只有一个weak指针的赋值，于是我把赋值也去掉了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id __weak obj2;</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         id obj3 = [NSMutableArray array];</span><br><span class=\"line\">         _objc_autoreleasePoolPrint();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     NSLog(@&quot;obj2-%@&quot;, obj2);</span><br></pre></td></tr></table></figure>\n\n<p>结果依旧如此….</p>\n<p>？？？？？？</p>\n<p>我第一反应就想到了编译器的优化。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/3f92e902bb664855cef64c063158c7d4.png\"></p>\n<p>默认情况下，Debug的优化级别为<code>None</code>，Release的是<code>Fastest,Smallest[-Os]</code>。我把Debug改为和Release一样…</p>\n<p>结果……就和预期一样，三个都不会在自动释放池内，也就是说在真机上运行是符合预期的。</p>\n<p>编译器不优化会导致 <code>objc_retainAutoreleasedReturnValue</code>和返回函数之间被插入代码，优化了反而不会被插入…</p>\n<p>对编译器不了解，这里没有任何发言权，本文也只是一些实验和猜测…</p>\n<p>另外x86的iOS模拟器和mac程序，调整优化level也只能部分达到预期…</p>\n","site":{"data":{}},"excerpt":"<p>最近在复习自动释放池，在ARC下runtime有一个优化<code>objc_autoreleaseReturnValue</code>和<code>objc_retainAutoreleaseReturnValue</code>，但是优化遇上编译器优化，似乎有点问题…不知道算不算苹果自己给自己挖的坑。</p>","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>现讲述一下大致的背景:（如果很了解autorelease及其优化原理可以直接跳过这一节）<br><strong>MRC：</strong></p>\n<p>在MRC下，本着谁分配谁释放的原则，在方法返回方法内部创建的某个对象的时候，其实是需要释放掉对象的（因为当前方法栈已经结束）。但是矛盾的是如果释放了，那这个方法如果返回这个对象给调用者，调用者又如何取到？</p>\n<p>所以，在返回对象的时候，不释放对象，而是把对象加入到 自动释放池 内（其实这里可以理解为，把对象的所有权交给了自动释放池），此时自动释放池持有了这个对象（引用计数为1）。调用者依旧可以拿到这个对象地址，对象依旧有效。</p>\n<p>当然调用者自己是否需要持有它，那是调用者的逻辑了，持有与释放相互匹配。</p>\n<p><strong>ARC：</strong></p>\n<p>在ARC下，需要依旧保持MRC下的“谁分配谁释放”的原则。但是ARC下编译器不允许调用autorelease方法。编译器会给代码的返回值后自动插入autorelease。</p>\n<p><strong>runtime优化：</strong></p>\n<p>在MRC下，如果调用者和被调用者都是模块内自己调用，那么其实可以忽略掉自动释放池这一个步骤。换句话说，如果可以保证调用者有变量在接收返回值，那么被调用者可以不用加入自动释放池，直接把对象的所有权转移给函数接受者。</p>\n<p>ps:当然这样会有风险，前提是模块内调用，如果是模块间调用，没有变量接收返回值的话，那么就会造成内存泄漏了。</p>\n<p>那么在ARC下如何优化呢？</p>\n<p>runtime结合编译器自动实现了这个过程。其实runtime的优化思路和上面MRC环境下开发者的优化思路是一样的，只不过把这个过程转换为了代码。</p>\n<p>在被调用方使用<code>__builtin_return_address(int depth)</code>这个函数判断调用方的接受者是否使用了这个优化函数<code>objc_retainAutoreleaseReturnValue</code>（有两种情况不使用，一种是MRC，一种是没有接受者），如果使用了优化那么被调用方<code>objc_autoreleaseReturnValue</code>就会把某个标记位flag设置到TLS。</p>\n<p>如果调用方不使用优化，那么就是走自动释放池的逻辑；如果调用方使用了优化函数<code>objc_retainAutoreleaseReturnValue</code>，那么先去TLS看有没有这个标记位（防止被调用方没有优化），如果有，直接使用返回的值，无需再调用retain了。</p>\n<p>简单总结：</p>\n<p>如果双方都使用优化，那么就直接用返回的对象，被调用方不释放，调用方不持有。实际就是对象拥有者直接转移。</p>\n<p>调用者通过TLS的flag判断被调用者是否使用了优化。</p>\n<p>被调用者通过<code>__builtin_return_address(int depth)</code>这个函数判断调用者是否使用优化。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在理解的过程中，我一直以为这个在ARC下的实验结果应该没有悬念的…但现实却给了我狠狠的一巴掌。</p>\n<p>我在Xcode里新建了一个 Mac 应用程序的Demo，ARC，方法返回的值始终在自动释放池内。</p>\n<p>下面是测试代码，测试代码来自网络..</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern void _objc_autoreleasePoolPrint(void);</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    ///////////////////////////////////////////////////////////////////////////////////////////// 1.</span><br><span class=\"line\">        id obj0;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            id obj1 = [NSMutableArray array];</span><br><span class=\"line\">            obj0 = obj1;</span><br><span class=\"line\">            _objc_autoreleasePoolPrint();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        NSLog(@&quot;obj0-%@&quot;, obj0);</span><br><span class=\"line\">        </span><br><span class=\"line\">    ///////////////////////////////////////////////////////////////////////////////////////////// 2.</span><br><span class=\"line\">        id __weak obj2;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            id obj3 = [NSMutableArray array];</span><br><span class=\"line\">            obj2 = obj3;</span><br><span class=\"line\">            _objc_autoreleasePoolPrint();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        NSLog(@&quot;obj2-%@&quot;, obj2);</span><br><span class=\"line\">        </span><br><span class=\"line\">    ///////////////////////////////////////////////////////////////////////////////////////////// 3.</span><br><span class=\"line\">        id __weak obj4;</span><br><span class=\"line\">        @autoreleasepool &#123;</span><br><span class=\"line\">            id obj5 = [NSMutableArray array];</span><br><span class=\"line\">            obj4 = obj5;</span><br><span class=\"line\">            _objc_autoreleasePoolPrint();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        NSLog(@&quot;obj4-%@&quot;, obj4);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这3段代码，区别在于后两者插入了一个__weak指针的赋值，但是实际结果却是三个数组都在自动释放池内。</p>\n<p>于是我找到了这篇 <a href=\"https://www.jianshu.com/p/e920d1ff570c\">文章</a>….</p>\n<p>然后我又在真机上调试了一下，确实，第一个没有进自动释放池，后两个都进了。</p>\n<p>文章作者最后给的解释比较模糊（后面两个没有调用retain），于是我只能自己再找原因。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>Runtime其实已经有源码可寻，。关键在于调用者的那个优化函数的指令地址。</p>\n<p>那么就看看汇编代码，到底有什么区别…<br>下面是ARM（真机）的汇编代码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/843978e4d9ad66e0db24562ace0f0f61.png\"></p>\n<p>在runtime的实现里会直接比较调用者下一个函数在代码内的地址与<code>objc_retainAutoreleasedReturnValue</code>的函数地址。很明显，第一个之所以不在池内是因为后面紧跟着<code>objc_retainAutoreleasedReturnValue</code>，而第二个就不是。</p>\n<p>第二个和第一个的区别只有一个weak指针的赋值，于是我把赋值也去掉了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id __weak obj2;</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         id obj3 = [NSMutableArray array];</span><br><span class=\"line\">         _objc_autoreleasePoolPrint();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     NSLog(@&quot;obj2-%@&quot;, obj2);</span><br></pre></td></tr></table></figure>\n\n<p>结果依旧如此….</p>\n<p>？？？？？？</p>\n<p>我第一反应就想到了编译器的优化。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/3f92e902bb664855cef64c063158c7d4.png\"></p>\n<p>默认情况下，Debug的优化级别为<code>None</code>，Release的是<code>Fastest,Smallest[-Os]</code>。我把Debug改为和Release一样…</p>\n<p>结果……就和预期一样，三个都不会在自动释放池内，也就是说在真机上运行是符合预期的。</p>\n<p>编译器不优化会导致 <code>objc_retainAutoreleasedReturnValue</code>和返回函数之间被插入代码，优化了反而不会被插入…</p>\n<p>对编译器不了解，这里没有任何发言权，本文也只是一些实验和猜测…</p>\n<p>另外x86的iOS模拟器和mac程序，调整优化level也只能部分达到预期…</p>"},{"title":"解析GoMobile生成的\"胶水代码\"","date":"2020-03-31T16:00:00.000Z","top":51,"_content":"\n> 标题要唬人...在做Golang跨平台的时候，使用gomobile bind -target=ios xxx 就可以生成对应平台的framework。\n\n本文讨论的内容是Golang是如何实现了OC和Go的数据通讯与接口调用，以及如何做到让开发者无感知的从OC对象的引用计数切换到Golang的垃圾回收机制。\n\n其实Go的语言层面的通讯实际上是由bind生成的中间层的代码来实现的，什么是中间层的代码？我们简单做实验…\n\n<!-- more -->\n\n写一个Go的例子，以下所有方法就是我们本文需要讨论的所有内容了\n```\npackage g_mb_test\n\ntype GMBInterface interface {\n\tInterfaceTest()\n}\ntype GMBTest struct {\n}\n\nfunc (t *GMBTest) GMBTestOne(value int32) {\n\n}\n\nfunc (t *GMBTest) GMBTestSecond(data []byte, str string) {\n\n}\n\nfunc (t *GMBTest) GMBTest3() string {\n    return “”\n}\n\nfunc (t *GMBTest) GMBTest4() []byte {\n    return nil\n}\n\nfunc (t *GMBTest) GMBTest5() GMBInterface {\n    return nil\n}\n\nfunc (t *GMBTest) GMBTest6() *GMBTest {\n    return nil\n}\n\nfunc (t *GMBTest) GMBTest7(i GMBInterface) {\n}\n```\n\n1. Go 导出的对象在OC中是怎么获取到的？\n2. OC是怎么调用Golang的对象方法的？\n3. OC是怎么传递给Golang参数的？不同的类型是否一样（NSData -> []byte, NSString -> string, interface(OC) -> interface）？\n4. OC传递给Golang 的参数Golang怎么释放（或者OC怎么释放）？\n5. 相反Golang是怎么返回值的？不同的类型是否一样（[]byte -> NSData, string -> NSString, interface -> interface(OC)）?\n6. Golang 如果返回的是一个被导出的类型，又是什么样的？\n\n\n首先Golang本身是由C来实现的，所以Golang可以\"无压力\"和C进行双向通讯(cgo)。其次，OC的本质其实也是C，OC也是可以和C无缝进行双向通讯。在这两个条件下我们可以假想，OC和Golang 的双向通讯是不是也可以用C？\n\n\n实验开始，我们使用命令行`gomobile bind -target=ios/amd64 -work Caio/g_mb_test`来保留工作目录。\n\n找到控制台输出的临时目录，生成了如下的结构。go-buildxxx下是生成的中间产物。而src下就是gomobile自动生成的中间代码。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d4bb5b927cdeb09f7ba32e3925bfb1c4.png)\n\n### 先从对象的初始化开始…\n```\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        __ref = go_seq_from_refnum(new_g_mb_test_GMBTest());\n    }\n    return self;\n}\n```\n\nnew_g_mb_test_GMBTest 实际是由 go在静态库中实现的方法，可以从g_mb_test-amd64.h头文件中找到它的声明。对应了src中的go_g_mb_testmain.go文件中的new_g_mb_test_GMBTest()方法。这个go文件是gomobile在编译go之前自动生成的代码。\n\n可以理解为在iOS中引入了一个”静态 framework”，这个静态库实现了new_g_mb_test_GMBTest()。只不过这个framework是由Go语言实现的。\n\n可以看到 new_g_mb_test_GMBTest()返回了一个 int32值，而这个值最后传递给了go_seq_from_refnum()，这个方法是在seq_darwin.m中。\n```\nGoSeqRef *go_seq_from_refnum(int32_t refnum) {\n  if (refnum == NULL_REFNUM) {\n    return nil;\n  }\n  if (IS_FROM_GO(refnum)) {\n    return [[GoSeqRef alloc] initWithRefnum:refnum obj:NULL];\n  }\n  return [[GoSeqRef alloc] initWithRefnum:refnum obj:go_seq_objc_from_refnum(refnum)];\n}\n```\n\n通过”字面”意思看，是返回了一个GoSeqRef，通过IS_FROM_GO判断传入的refnum（也就是上面提到的new_g_mb_test_GMBTest()返回的值是不是Go生成的），来决定GoSeqRef中的obj是否为NULL。如果不是Go生成的那么就返回go_seq_objc_from_refnum()转换refnum为obj，这个分支我们之后再讲。\n\n那么我们看看这个所谓的”静态库”是怎么生成这个int32值的。\n*注：以下运行的代码已经在Go中了*\n\n```\n*go_g_mb_testmain.go*\n//export new_g_mb_test_GMBTest\nfunc new_g_mb_test_GMBTest() C.int32_t {\n    return C.int32_t(_seq.ToRefNum(new(g_mb_test.GMBTest)))\n}\n```\n\n可以看到 new_g_mb_test_GMBTest()返回了一个 int32，而这个int32值还是由_seq.ToRefNum()方法返回的。这个方法是由golang.org/x/mobile/bind/seq/ref.go 下的bind提供的。方法参数就是一个go struct对象。\n\n```\n*golang.org/x/mobile/bind/seq/ref.go*\n// ToRefNum increments the reference count for an object and\n// returns its refnum.\nfunc ToRefNum(obj interface{}) int32 {\n    // We don’t track foreign objects, so if obj is a proxy\n    // return its refnum.\n    if r, ok := obj.(proxy); ok {\n        refnum := r.Bind_proxy_refnum__()\n        if refnum <= 0 {\n            panic(fmt.Errorf(\"seq: proxy contained invalid Go refnum: %d\", refnum))\n        }\n        return refnum\n    }\n    refs.Lock()\n    num := refs.refs[obj]\n    if num != 0 {\n        s := refs.objs[num]\n        refs.objs[num] = countedObj{s.obj, s.cnt + 1}\n    } else {\n        num = refs.next\n        refs.next--\n        if refs.next > 0 {\n            panic(“refs.next underflow”)\n        }\n        refs.refs[obj] = num\n        refs.objs[num] = countedObj{obj, 1}\n    }\n    refs.Unlock()\n\n    return int32(num)\n}\n```\n\n关于proxy那块的代码，我们稍等之后再看。后面的代码也不急着读，先看后面提到的refs对象：\n```\n// refs stores Go objects that have been passed to another language.\nvar refs struct {\n    sync.Mutex\n    next int32 // next reference number to use for Go object, always negative\n    refs map[interface{}]int32\n    objs map[int32]countedObj\n}\n```\n\n注释写的很明确了，refs存储了从Golang传递给其他语言的对象。\n\n结构体中有两个map成员变量，一个是refs，一个是objs。refs的key是对象，value就是上面提到的refnum，objs的key是refnum，value是这个Go对象的引用计数对象。还有一个变量是next，next是下一个Go对象的refnum，而且永远是负数。\n\n那么上面的后半段代码也就很容易看懂了。从ref取出obj对应的num，计数加一。如果没有的话，next-1作为下一个refnum，把对象存进map。\n\n**所以：**\n1. 在Go中有一个全局变量，维护了所有外部正在使用的Go对象。\n2. 从Go生成的对象，想要被外部使用，都是通过一个refnum的值在这个全局变量中索引的。\n3. 并且还维护了一个引用计数，每次取这个对象都会+1。\n4. 另外，从Go导出的refnum都是负数。\n\n到这里，我们其实可以小*总结*一下了：\n从上面的代码可以知道 Go中的对象在 oc 中的体现是:\n\nOC对象持有一个GoSeqRef，GoSeqRef 持有一个 refnum，refnum在Go中的refs的objs和refs中存储了真正的Go对象和引用计数值。\n\n#### 再看一个OC方法的基本调用\n既然已经生成Golang的对象了，我们看一下 gmbTestOne 这个基本调用。\n\n```\n- (void)gmbTestOne:(int32_t)value {\n    int32_t refnum = go_seq_go_to_refnum(self._ref);\n    int32_t _value = (int32_t)value;\n    proxyg_mb_test_GMBTest_GMBTestOne(refnum, _value);\n}\n\n```\ngo_seq_go_to_refnum()是在Seq_darwin.m中实现的。\n```\n- (int32_t)incNum {\n  IncGoRef(_refnum);\n  return _refnum;\n}\n```\n可以看到最终是返回了_refnum。但是在此之前，还有一个IncGoRef(_refnum);\n可以看ref.go的实现，方法实现是增加Go对象的引用计数。\n*思考：*从OC ARC的对象回收的角度来看，似乎”言之有理”。”int32_t refnum “虽然是个int，但是得要持有这个对象，不然会有可能在调用过程中被释放。那么猜想一样，它会在方法域结束的时候释放？我们接着看…\n\n然后和上面的逻辑一样，proxyg_mb_test_GMBTest_GMBTestOne() 是framework实现的方法，第一个参数是refnum，第二个参数是value的值。\n\n猜想它的实现应该是，通过 refnum找到Go中的对象，然后调用对应的方法。我们来看Go的实现：\n*注：以下运行的代码已经在Go中了*\n```\n//export proxyg_mb_test_GMBTest_GMBTestOne\nfunc proxyg_mb_test_GMBTest_GMBTestOne(refnum C.int32_t, param_value C.int32_t) {\n    ref := _seq.FromRefNum(int32(refnum))\n    v := ref.Get().(*g_mb_test.GMBTest)\n    _param_value := int32(param_value)\n    v.GMBTestOne(_param_value)\n}\n```\n\n```\n// FromRefNum returns the Ref for a refnum. If the refnum specifies a\n// foreign object, a finalizer is set to track its lifetime.\nfunc FromRefNum(num int32) *Ref {\n    if num == NullRefNum {\n        return nil\n    }\n    ref := &Ref{num}\n    if num > 0 {\n        // This is a foreign object reference.\n        // Track its lifetime with a finalizer.\n        runtime.SetFinalizer(ref, FinalizeRef)\n    }\n\n    return ref\n}\n```\n和OC中一样，在Go中也有一个Ref对象，这个对象包裹的就是一个refnum。\nnum > 0是指代外部传入的对象，我们先不看\n\n```\n// Get returns the underlying object.\nfunc (r *Ref) Get() interface{} {\n    refnum := r.Bind_Num\n    refs.Lock()\n    o, ok := refs.objs[refnum]\n    refs.Unlock()\n    if !ok {\n        panic(fmt.Sprintf(“unknown ref %d”, refnum))\n    }\n    // This is a Go reference and its refnum was incremented\n    // before crossing the language barrier.\n    Delete(refnum)\n    return o.obj\n}\n```\n前半段印证了我们的猜想，取出对象并且返回。Delete的实现是引用计数-1，如果到0了，那就从map中删除。\n\n*印证我们上面思考中的猜想！*Golang对象并不是在结束的时候才释放，在Golang中 v := ref.Get().(*g_mb_test.GMBTest) 已经持有，其实不必再持有了，等Golang的方法结束的时候自然会通过Golang的垃圾回收释放。\n\n最后代码就是一个Go的方法调用了，把int参数传入。\n\n**总结一下：**\nOC调用Golang的方法，实际是，在OC中调用方法的时候，先用self.ref 获取 refnum。这个步骤会增加Go中对象的引用计数。然后调入Go的方法，把refnum传入，取出Golang对象，减小引用计数。然后调用具体实现的方法。\n\n#### Golang返回对象\nGolang的方法返回对象其实和上面的初始化方法大同小异，只是结合了基本方法调用。注：Go返回的对象类型必须是Go导出的类型，非Go导出的类型Go不识别或者OC不识别（除了NSData，NSString等基本类型）。\n\n```\n- (G_mb_testGMBTest*)gmbTest6 {\n    int32_t refnum = go_seq_go_to_refnum(self._ref);\n    int32_t r0 = proxyg_mb_test_GMBTest_GMBTest6(refnum);\n    G_mb_testGMBTest* _ret0_ = nil;\n    GoSeqRef* _ret0__ref = go_seq_from_refnum(r0);\n    if (_ret0__ref != NULL) {\n        _ret0_ = _ret0__ref.obj;\n        if (_ret0_ == nil) {\n            _ret0_ = [[G_mb_testGMBTest alloc] initWithRef:_ret0__ref];\n        }\n    }\n    return _ret0_;\n}\n```\nproxyg_mb_test_GMBTest_GMBTest6()方法返回了一个int值，这个值必然是对应的Golang的对象。\n```\n//export proxyg_mb_test_GMBTest_GMBTest6\nfunc proxyg_mb_test_GMBTest_GMBTest6(refnum C.int32_t) C.int32_t {\n    ref := _seq.FromRefNum(int32(refnum))\n    v := ref.Get().(*g_mb_test.GMBTest)\n    res_0 := v.GMBTest6()\n    var _res_0 C.int32_t = _seq.NullRefNum\n    if res_0 != nil {\n        _res_0 = C.int32_t(_seq.ToRefNum(res_0))\n    }\n    return _res_0\n}\n```\n\n方法调用的地方我们不再详述，返回的res_0如果是nil，则会返回_seq.NullRefNum = 41。即用一个特定的值来表示null。\n返回后OC同样的会在go_seq_from_refnum()中判断41这个值。\n\n**总结一下：**\nGo返回对象实际是返回一个refnum值，OC使用GoSeqRef来存储这个值。（返回的对象始终是Go已导出的对象类型）\n\n#### Golang返回接口类型\n实际上Go和其他语言通讯大部分都会使用接口类型\n\n```\n- (id<G_mb_testGMBInterface>)gmbTest5 {\n    int32_t refnum = go_seq_go_to_refnum(self._ref);\n    int32_t r0 = proxyg_mb_test_GMBTest_GMBTest5(refnum);\n    G_mb_testGMBInterface* _ret0_ = nil;\n    GoSeqRef* _ret0__ref = go_seq_from_refnum(r0);\n    if (_ret0__ref != NULL) {\n        _ret0_ = _ret0__ref.obj;\n        if (_ret0_ == nil) {\n            _ret0_ = [[G_mb_testGMBInterface alloc] initWithRef:_ret0__ref];\n        }\n    }\n    return _ret0_;\n}\n```\nproxyg_mb_test_GMBTest_GMBTest5()和上面的proxyg_mb_test_GMBTest_GMBTest6()返回对象没有什么差别，主要差别在于处理返回的值变成go中的refnum。\n\n```\n@implementation G_mb_testGMBInterface {\n}\n\n- (instancetype)initWithRef:(id)ref {\n    self = [super init];\n    if (self) { __ref = ref; }\n    return self;\n}\n\n- (void)interfaceTest {\n    int32_t refnum = go_seq_go_to_refnum(self._ref);\n    proxyg_mb_test_GMBInterface_InterfaceTest(refnum);\n}\n\n@end\n```\n\n在g_mb_test_darwin.m中自动生成了一个G_mb_testGMBInterface类，而这个类实现了G_mb_testGMBInterface，也就是我们定义的接口，并且存储了GO返回的refnum。而接口的实现内调用了proxyg_mb_test_GMBInterface_InterfaceTest()函数。这个函数实际就是通过返回的refnum来获取Go中的对象，调用Go中实现的接口。\n\n**总结：**\nGo返回的接口类型，在OC上还是一个refnum。胶水代码自动生成了一个实现这个接口的类，并且保存了这个GoSeqRef。在调用接口的时候，实际上是调用的这个自动生成的类的方法。最终还是通过存储的GoSeqRef找到Go中的对象，来调用具体方法。\n\n至此，Go方法返回数据都已经讲完了（NSData和NSString我们放在单独的环节）。接下来我们看一下从OC传对象至Go\n\n#### OC传递对象至Go\n这一节我们将补充讲完之前跳过的环节。\n\n```\n- (void)gmbTest7:(id<G_mb_testGMBInterface>)i {\n    int32_t refnum = go_seq_go_to_refnum(self._ref);\n    int32_t _i;\n    if ([i conformsToProtocol:@protocol(goSeqRefInterface)]) {\n        id<goSeqRefInterface> i_proxy = (id<goSeqRefInterface>)(i);\n        _i = go_seq_go_to_refnum(i_proxy._ref);\n    } else {\n        _i = go_seq_to_refnum(i);\n    }\n    proxyg_mb_test_GMBTest_GMBTest7(refnum, _i);\n}\n```\ngoSeqRefInterface接口表示的是Go传出的对象（因为有GoSeqRef)。\n如果是Go的对象，则增加引用计数。\n如果不是Go的对象，即OC new出来的对象，调用go_seq_to_refnum()\n\n方法内部实际是调用的全局变量tracker。\n看到这里其实已经明白了，在OC里实现了一个和Go中refs一样的结构。用来标识从OC传入Go的对象的引用计数。\nGo在OC里的引用计数是，每次在调用Go对象之前持有一次，在Go由refnum找到对应对象之后，再释放一次。那么OC的对象呢？\n\n继续看到下一个方法proxyg_mb_test_GMBTest_GMBTest7()的参数传递。\n```\n//export proxyg_mb_test_GMBTest_GMBTest7\nfunc proxyg_mb_test_GMBTest_GMBTest7(refnum C.int32_t, param_i C.int32_t) {\n    ref := _seq.FromRefNum(int32(refnum))\n    v := ref.Get().(*g_mb_test.GMBTest)\n    var _param_i g_mb_test.GMBInterface\n    _param_i_ref := _seq.FromRefNum(int32(param_i))\n    if _param_i_ref != nil {\n        if param_i < 0 { // go object\n            _param_i = _param_i_ref.Get().(g_mb_test.GMBInterface)\n        } else { // foreign object\n            _param_i = (*proxyg_mb_test_GMBInterface)(_param_i_ref)\n        }\n    }\n    v.GMBTest7(_param_i)\n}\n```\n\n之前提到过，_seq.FromRefNum只判断null（41），否则返回一个Ref指针。如果传入的参数是Go生成的，那么就直接使用。否则，如果是外部传入的，直接把_param_i_ref强转为了proxyg_mb_test_GMBInterface类型。\n\n看到后面还有一个对proxyg_mb_test_GMBInterface 的定义\n```\ntype proxyg_mb_test_GMBInterface _seq.Ref\n\nfunc (p *proxyg_mb_test_GMBInterface) Bind_proxy_refnum__() int32 { return (*_seq.Ref)(p).Bind_IncNum() }\n\nfunc (p *proxyg_mb_test_GMBInterface) InterfaceTest() {\n    C.cproxyg_mb_test_GMBInterface_InterfaceTest(C.int32_t(p.Bind_proxy_refnum__()))\n}\n```\n两个方法：\nBind_proxy_refnum__()调用了Ref的Bind_IncNum(),看名字和注释的意思是增加外部变量的引用。\n```\nfunc init() {\n    _seq.FinalizeRef = func(ref *_seq.Ref) {\n        refnum := ref.Bind_Num\n        if refnum < 0 {\n            panic(fmt.Sprintf(“not a foreign ref: %d”, refnum))\n        }\n        C.go_seq_dec_ref(C.int32_t(refnum))\n    }\n    _seq.IncForeignRef = func(refnum int32) {\n        if refnum < 0 {\n            panic(fmt.Sprintf(\"not a foreign ref: %d\", refnum))\n        }\n        C.go_seq_inc_ref(C.int32_t(refnum))\n    }\n}\n```\n在初始化的时候，会给seq设置两个全局函数，一个是释放，另一个就是刚刚Bind_IncNum()函数内调用的_seq.IncForeignRef()，\nC.cproxyg_mb_test_GMBInterface_InterfaceTest()，这个两个方法内实际调用了Cgo_seq_inc_ref()和C.go_seq_dec_ref(),这个是链接静态库的实现的符号。\n\n```\nvoid go_seq_dec_ref(int32_t refnum) {\n  @autoreleasepool {\n    [tracker dec:refnum];\n  }\n}\n\nvoid go_seq_inc_ref(int32_t refnum) {\n  @autoreleasepool {\n    [tracker inc:refnum];\n  }\n}\n\n```\nseq_darwin.m中可以看到，确实是增加和减少引用计数。\n\n在上面讲到FromRefNum的时候，如果是外部传入的对象，则会给GoRef设置一个析构函数。\n也就是说，在GoRef这个结构体的生命周期内，持有外部的对象。GoRef 映射的就是外部对象。\n\n继续回到上面，InterfaceTest()是接口的另一个方法\n```\nvoid cproxyg_mb_test_GMBInterface_InterfaceTest(int32_t refnum) {\n    @autoreleasepool {\n        G_mb_testGMBInterface* o = go_seq_objc_from_refnum(refnum);\n        [o interfaceTest];\n    }\n}\n```\n和_seq.FinalizeRef一样，调用到了oc。而OC的go_seq_objc_from_refnum（）方法在拿到oc对象之后，调用了[tracker dec:refnum];\n这样，在OC层完成了这个对象的释放\n\n**总结：**\nOC的接口对象传递至Go的时候（非Go导出对象），Go肯定也是以一个接口对象存在。OC在传入之前计数+1（计数为1），传入之后，Go对生成的GoRef增加析构函数，析构函数内对计数 -1。\n在Go内调用GoRef重定义的接口函数时候，会先增加引用计数，调回OC之后，在OC取到对应的OC对象后，OC会主动对计数-1。这一点和Go传出对象很类似。\n\n另外，刚刚我们跳过了go_seq_from_refnum()以及ToRefNum()的代码，都是考虑的特殊情况。我们刚刚讨论的都是OC创建的对象传递至Go，Go创建的对象传递至OC。但是还有OC传递至Go后，Go在把同一个对象返回给OC。相反也有Go给OC后，OC把同一个对象给了Go。（这个同一个对象，在OC内是指GoSeqRef，在Go内是指GoRef，两侧都是镜像的。）对于这种情况，两侧都是不需要转换的，OC内直接从GoSeqRef取出obj调用，Go内直接找到refnum对应的对象调用。\n\n## 总结\n1. Go导出的静态库实际是一个C实现的静态库，还会生成OC的代码（胶水代码）来包裹这个库，以达到导出OC类、方法和接口\n2. Go的对象和OC对象在对方侧，都一个int32(refnum)作为对象参数，来对应每一个传递过去的对象。如果refnum>0表示OC对象，<0表示Go对象。\n3. Go的对象和OC对象在对方侧，分别有一个存储了refnum的GoRef struct和GoSeqRef class来表示对方侧的对象。\n4. Go和OC侧都有全局变量来维护已经传入至对方侧的对象，以及引用计数。\n5. 不论是OC还是Go，如果refnum表示的是本侧的对象，那么就直接从全局变量中取出对象使用。\n6. OC调用Go对象方法，实际是调用Go的C函数，通过传递refnum告知Go具体的Go对象。\n7. Go调用OC对象方法，实际是通过声明式，调用C函数，由.m实现。同理通过传递refnum来告知OC具体的OC对象。\n8. OC调用Go的接口对象，实际是生成了实现接口的类的胶水代码，接口对象持有了GoSeqRef，接口方法实际也是通过传递refnum调用Go\n9. Go调用OC的接口对象，实际是通过声明式，调用C函数，由.m实现。通过重定义GoRef，实现OC的接口方法。接口方法内通过传递refnum调用.m即OC\n10. Go传递至OC的对象，Go在new或者函数返回之前会调用_seq.ToRefNum()，存储在全局变量中，并计数为1。OC存储的GoSeqRef在dealloc的时候通过DestroyRef()将计数-1。\n11. OC传递至Go的对象，OC在传递给Go之前会调用assignRefnumAndIncRefcount:存储在全局变量中，并计数为1。Go在生成GoRef的时候会设置该对象的析构回调，在回调内，通过调用go_seq_dec_ref()将计数-1\n12. Go对象方法被OC调用之前，OC会使用go_seq_go_to_refnum()将计数+1，Go在将refnum转换为go obj之后，又会将计数-1\n13. OC对象方法被Go调用之前，Go会使用Bind_IncNum()将计数+1，OC在将refnum转换为oc obj 之后，又会将计数-1。\n\n以上的总结已经完全可以解答文章开始时候的提问了。\n\n//最后这里回头补充一个图解\n\n## 后记\n还有两个特殊的地方 NSString 和 NSData。这两个对象在Go <—> OC gomobile 是默认支持这两种数据类型的互转的。\n```\ntypedef struct nstring {\n  void *ptr;\n  int len;\n} nstring;\n\ntypedef struct nbyteslice {\n  void *ptr;\n  int len;\n} nbyteslice;\ntypedef int nint;\n```\n这两个数据类型在传递的时候，都会被转换为定义好的C语言的struct类型。\n\n### String\n```\n// encodeString copies a Go string and returns it as a nstring.\nfunc encodeString(s string) C.nstring {\n    n := C.int(len(s))\n    if n == 0 {\n        return C.nstring{}\n    }\n    ptr := C.malloc(C.size_t(n))\n    if ptr == nil {\n        panic(\"encodeString: malloc failed\")\n    }\n    copy((*[1<<31 - 1]byte)(ptr)[:n], s)\n    return C.nstring{ptr: ptr, len: n}\n}\n\n// decodeString converts a nstring to a Go string. The\n// data in str is freed after use.\nfunc decodeString(str C.nstring) string {\n    if str.ptr == nil {\n        return \"\"\n    }\n    s := C.GoStringN((*C.char)(str.ptr), str.len)\n    C.free(str.ptr)\n    return s\n}\n```\n\nGo 侧 string 通过encode和decode方法，在cstring和go string之间互转，*每次转换都会copy*。\n\n```\nNSString *go_seq_to_objc_string(nstring str) {\n  if (str.len == 0) {  // empty string.\n    return @“”;\n  }\n  NSString * res = [[NSString alloc] initWithBytesNoCopy:str.ptr\n                                                  length:str.len\n                                                encoding:NSUTF8StringEncoding\n                                            freeWhenDone:YES];\n  return res;\n}\n\nnstring go_seq_from_objc_string(NSString *s) {\n  nstring res = {NULL, 0};\n  int len = [s lengthOfBytesUsingEncoding:NSUTF8StringEncoding];\n\n  if (len == 0) {\n    if (s.length > 0) {\n      LOG_INFO(@“unable to encode an NSString into UTF-8”);\n    }\n    return res;\n  }\n\n  char *buf = (char *)malloc(len);\n  if (buf == NULL) {\n    LOG_FATAL(@\"malloc failed\");\n  }\n  NSUInteger used;\n  [s getBytes:buf\n           maxLength:len\n          usedLength:&used\n            encoding:NSUTF8StringEncoding\n             options:0\n               range:NSMakeRange(0, [s length])\n      remainingRange:NULL];\n  res.ptr = buf;\n  res.len = used;\n  return res;\n}\n```\n\nOC 侧 NSString 通过go_seq_to_objc_string和go_seq_from_objc_string方法，在cstring和nsstring之间互转，*每次转换都会copy*。\n\n且对方侧生成的cstring由己方释放。\n\n### Bytes\n```\n\n// fromSlice converts a slice to a nbyteslice.\n// If cpy is set, a malloc’ed copy of the data is returned.\nfunc fromSlice(s []byte, cpy bool) C.nbyteslice {\n    if s == nil || len(s) == 0 {\n        return C.nbyteslice{}\n    }\n    ptr, n := unsafe.Pointer(&s[0]), C.int(len(s))\n    if cpy {\n        nptr := C.malloc(C.size_t(n))\n        if nptr == nil {\n            panic(\"fromSlice: malloc failed\")\n        }\n        copy((*[1<<31 - 1]byte)(nptr)[:n], (*[1<<31 - 1]byte)(ptr)[:n])\n        ptr = nptr\n    }\n    return C.nbyteslice{ptr: ptr, len: n}\n}\n\n// toSlice takes a nbyteslice and returns a byte slice with the data. If cpy is\n// set, the slice contains a copy of the data. If not, the generated Go code\n// calls releaseByteSlice after use.\nfunc toSlice(s C.nbyteslice, cpy bool) []byte {\n    if s.ptr == nil || s.len == 0 {\n        return nil\n    }\n    var b []byte\n    if cpy {\n        b = C.GoBytes(s.ptr, C.int(s.len))\n        C.free(s.ptr)\n    } else {\n        b = (*[1<<31 - 1]byte)(unsafe.Pointer(s.ptr))[:s.len:s.len]\n    }\n    return b\n}\n```\n\nGo 侧 nbyteslice 通过fromSlice和toSlice方法，在nbyteslice和go slice之间互转。\n\nOC -> Go 如果对方（OC）copy == true，Go也会拷贝，拷贝完就会释放nbyteslice，否则只是使用。\nGo -> OC  (copy 才会拷贝，go->OC copy=true)。\n\n```\nNSData *go_seq_to_objc_bytearray(nbyteslice s, int copy) {\n  if (s.ptr == NULL) {\n    return NULL;\n  }\n  BOOL freeWhenDone = copy ? YES : NO;\n  return [NSData dataWithBytesNoCopy:s.ptr length:s.len freeWhenDone:freeWhenDone];\n}\n\nnbyteslice go_seq_from_objc_bytearray(NSData *data, int copy) {\n  struct nbyteslice res = {NULL, 0};\n  int sz = data.length;\n  if (sz == 0) {\n    return res;\n  }\n  void *ptr;\n  // If the argument was not a NSMutableData, copy the data so that\n  // the NSData is not changed from Go. The corresponding free is called\n  // by releaseByteSlice.\n  if (copy || ![data isKindOfClass:[NSMutableData class]]) {\n    void *arr_copy = malloc(sz);\n    if (arr_copy == NULL) {\n      LOG_FATAL(@\"malloc failed\");\n    }\n    memcpy(arr_copy, [data bytes], sz);\n    ptr = arr_copy;\n  } else {\n    ptr = (void *)[data bytes];\n  }\n  res.ptr = ptr;\n  res.len = sz;\n  return res;\n}\n\n```\n\nOC 侧 NSData 通过go_seq_to_objc_bytearray和go_seq_from_objc_bytearray方法，在nbyteslice和NSData之间互转。\n\nOC -> Go (NSMutableData && !copy 才不会拷贝，OC->Go copy = false，即NSData拷贝，NSMutableData不拷贝)，*并且方法调用结束就会释放bytes*。（如果在Go内使用slice的时候切协程了，有大概率读取到的bytes是被释放了）\nGo -> OC  OC不拷贝从Go返回的bytes，OC在释放NSData的时候会释放nbyteslice.\n\n*总之一个宗旨，一侧指定了copy，就由另一侧释放。没有指定copy，就由本侧释放，即谁创建谁释放的原则。（NSData是指定了false，但是执行拷贝了，还是由本侧释放）*\n\n---\n\n2020-3-18 记\n[用 Dart 来写 Objective-C 代码](http://yulingtianxia.com/blog/2019/10/27/Write-Objective-C-Code-using-Dart/)\n\n这篇文章讲述的是在Dart中写OC，与GoMobile的原理相比有些许相似...","source":"_posts/14.gomobile-bind.md","raw":"---\ntitle: 解析GoMobile生成的\"胶水代码\"\ndate: 2020-04-01\ntags: [GoMobile]\ntop: 51\ncategories: GoMobile\n---\n\n> 标题要唬人...在做Golang跨平台的时候，使用gomobile bind -target=ios xxx 就可以生成对应平台的framework。\n\n本文讨论的内容是Golang是如何实现了OC和Go的数据通讯与接口调用，以及如何做到让开发者无感知的从OC对象的引用计数切换到Golang的垃圾回收机制。\n\n其实Go的语言层面的通讯实际上是由bind生成的中间层的代码来实现的，什么是中间层的代码？我们简单做实验…\n\n<!-- more -->\n\n写一个Go的例子，以下所有方法就是我们本文需要讨论的所有内容了\n```\npackage g_mb_test\n\ntype GMBInterface interface {\n\tInterfaceTest()\n}\ntype GMBTest struct {\n}\n\nfunc (t *GMBTest) GMBTestOne(value int32) {\n\n}\n\nfunc (t *GMBTest) GMBTestSecond(data []byte, str string) {\n\n}\n\nfunc (t *GMBTest) GMBTest3() string {\n    return “”\n}\n\nfunc (t *GMBTest) GMBTest4() []byte {\n    return nil\n}\n\nfunc (t *GMBTest) GMBTest5() GMBInterface {\n    return nil\n}\n\nfunc (t *GMBTest) GMBTest6() *GMBTest {\n    return nil\n}\n\nfunc (t *GMBTest) GMBTest7(i GMBInterface) {\n}\n```\n\n1. Go 导出的对象在OC中是怎么获取到的？\n2. OC是怎么调用Golang的对象方法的？\n3. OC是怎么传递给Golang参数的？不同的类型是否一样（NSData -> []byte, NSString -> string, interface(OC) -> interface）？\n4. OC传递给Golang 的参数Golang怎么释放（或者OC怎么释放）？\n5. 相反Golang是怎么返回值的？不同的类型是否一样（[]byte -> NSData, string -> NSString, interface -> interface(OC)）?\n6. Golang 如果返回的是一个被导出的类型，又是什么样的？\n\n\n首先Golang本身是由C来实现的，所以Golang可以\"无压力\"和C进行双向通讯(cgo)。其次，OC的本质其实也是C，OC也是可以和C无缝进行双向通讯。在这两个条件下我们可以假想，OC和Golang 的双向通讯是不是也可以用C？\n\n\n实验开始，我们使用命令行`gomobile bind -target=ios/amd64 -work Caio/g_mb_test`来保留工作目录。\n\n找到控制台输出的临时目录，生成了如下的结构。go-buildxxx下是生成的中间产物。而src下就是gomobile自动生成的中间代码。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d4bb5b927cdeb09f7ba32e3925bfb1c4.png)\n\n### 先从对象的初始化开始…\n```\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        __ref = go_seq_from_refnum(new_g_mb_test_GMBTest());\n    }\n    return self;\n}\n```\n\nnew_g_mb_test_GMBTest 实际是由 go在静态库中实现的方法，可以从g_mb_test-amd64.h头文件中找到它的声明。对应了src中的go_g_mb_testmain.go文件中的new_g_mb_test_GMBTest()方法。这个go文件是gomobile在编译go之前自动生成的代码。\n\n可以理解为在iOS中引入了一个”静态 framework”，这个静态库实现了new_g_mb_test_GMBTest()。只不过这个framework是由Go语言实现的。\n\n可以看到 new_g_mb_test_GMBTest()返回了一个 int32值，而这个值最后传递给了go_seq_from_refnum()，这个方法是在seq_darwin.m中。\n```\nGoSeqRef *go_seq_from_refnum(int32_t refnum) {\n  if (refnum == NULL_REFNUM) {\n    return nil;\n  }\n  if (IS_FROM_GO(refnum)) {\n    return [[GoSeqRef alloc] initWithRefnum:refnum obj:NULL];\n  }\n  return [[GoSeqRef alloc] initWithRefnum:refnum obj:go_seq_objc_from_refnum(refnum)];\n}\n```\n\n通过”字面”意思看，是返回了一个GoSeqRef，通过IS_FROM_GO判断传入的refnum（也就是上面提到的new_g_mb_test_GMBTest()返回的值是不是Go生成的），来决定GoSeqRef中的obj是否为NULL。如果不是Go生成的那么就返回go_seq_objc_from_refnum()转换refnum为obj，这个分支我们之后再讲。\n\n那么我们看看这个所谓的”静态库”是怎么生成这个int32值的。\n*注：以下运行的代码已经在Go中了*\n\n```\n*go_g_mb_testmain.go*\n//export new_g_mb_test_GMBTest\nfunc new_g_mb_test_GMBTest() C.int32_t {\n    return C.int32_t(_seq.ToRefNum(new(g_mb_test.GMBTest)))\n}\n```\n\n可以看到 new_g_mb_test_GMBTest()返回了一个 int32，而这个int32值还是由_seq.ToRefNum()方法返回的。这个方法是由golang.org/x/mobile/bind/seq/ref.go 下的bind提供的。方法参数就是一个go struct对象。\n\n```\n*golang.org/x/mobile/bind/seq/ref.go*\n// ToRefNum increments the reference count for an object and\n// returns its refnum.\nfunc ToRefNum(obj interface{}) int32 {\n    // We don’t track foreign objects, so if obj is a proxy\n    // return its refnum.\n    if r, ok := obj.(proxy); ok {\n        refnum := r.Bind_proxy_refnum__()\n        if refnum <= 0 {\n            panic(fmt.Errorf(\"seq: proxy contained invalid Go refnum: %d\", refnum))\n        }\n        return refnum\n    }\n    refs.Lock()\n    num := refs.refs[obj]\n    if num != 0 {\n        s := refs.objs[num]\n        refs.objs[num] = countedObj{s.obj, s.cnt + 1}\n    } else {\n        num = refs.next\n        refs.next--\n        if refs.next > 0 {\n            panic(“refs.next underflow”)\n        }\n        refs.refs[obj] = num\n        refs.objs[num] = countedObj{obj, 1}\n    }\n    refs.Unlock()\n\n    return int32(num)\n}\n```\n\n关于proxy那块的代码，我们稍等之后再看。后面的代码也不急着读，先看后面提到的refs对象：\n```\n// refs stores Go objects that have been passed to another language.\nvar refs struct {\n    sync.Mutex\n    next int32 // next reference number to use for Go object, always negative\n    refs map[interface{}]int32\n    objs map[int32]countedObj\n}\n```\n\n注释写的很明确了，refs存储了从Golang传递给其他语言的对象。\n\n结构体中有两个map成员变量，一个是refs，一个是objs。refs的key是对象，value就是上面提到的refnum，objs的key是refnum，value是这个Go对象的引用计数对象。还有一个变量是next，next是下一个Go对象的refnum，而且永远是负数。\n\n那么上面的后半段代码也就很容易看懂了。从ref取出obj对应的num，计数加一。如果没有的话，next-1作为下一个refnum，把对象存进map。\n\n**所以：**\n1. 在Go中有一个全局变量，维护了所有外部正在使用的Go对象。\n2. 从Go生成的对象，想要被外部使用，都是通过一个refnum的值在这个全局变量中索引的。\n3. 并且还维护了一个引用计数，每次取这个对象都会+1。\n4. 另外，从Go导出的refnum都是负数。\n\n到这里，我们其实可以小*总结*一下了：\n从上面的代码可以知道 Go中的对象在 oc 中的体现是:\n\nOC对象持有一个GoSeqRef，GoSeqRef 持有一个 refnum，refnum在Go中的refs的objs和refs中存储了真正的Go对象和引用计数值。\n\n#### 再看一个OC方法的基本调用\n既然已经生成Golang的对象了，我们看一下 gmbTestOne 这个基本调用。\n\n```\n- (void)gmbTestOne:(int32_t)value {\n    int32_t refnum = go_seq_go_to_refnum(self._ref);\n    int32_t _value = (int32_t)value;\n    proxyg_mb_test_GMBTest_GMBTestOne(refnum, _value);\n}\n\n```\ngo_seq_go_to_refnum()是在Seq_darwin.m中实现的。\n```\n- (int32_t)incNum {\n  IncGoRef(_refnum);\n  return _refnum;\n}\n```\n可以看到最终是返回了_refnum。但是在此之前，还有一个IncGoRef(_refnum);\n可以看ref.go的实现，方法实现是增加Go对象的引用计数。\n*思考：*从OC ARC的对象回收的角度来看，似乎”言之有理”。”int32_t refnum “虽然是个int，但是得要持有这个对象，不然会有可能在调用过程中被释放。那么猜想一样，它会在方法域结束的时候释放？我们接着看…\n\n然后和上面的逻辑一样，proxyg_mb_test_GMBTest_GMBTestOne() 是framework实现的方法，第一个参数是refnum，第二个参数是value的值。\n\n猜想它的实现应该是，通过 refnum找到Go中的对象，然后调用对应的方法。我们来看Go的实现：\n*注：以下运行的代码已经在Go中了*\n```\n//export proxyg_mb_test_GMBTest_GMBTestOne\nfunc proxyg_mb_test_GMBTest_GMBTestOne(refnum C.int32_t, param_value C.int32_t) {\n    ref := _seq.FromRefNum(int32(refnum))\n    v := ref.Get().(*g_mb_test.GMBTest)\n    _param_value := int32(param_value)\n    v.GMBTestOne(_param_value)\n}\n```\n\n```\n// FromRefNum returns the Ref for a refnum. If the refnum specifies a\n// foreign object, a finalizer is set to track its lifetime.\nfunc FromRefNum(num int32) *Ref {\n    if num == NullRefNum {\n        return nil\n    }\n    ref := &Ref{num}\n    if num > 0 {\n        // This is a foreign object reference.\n        // Track its lifetime with a finalizer.\n        runtime.SetFinalizer(ref, FinalizeRef)\n    }\n\n    return ref\n}\n```\n和OC中一样，在Go中也有一个Ref对象，这个对象包裹的就是一个refnum。\nnum > 0是指代外部传入的对象，我们先不看\n\n```\n// Get returns the underlying object.\nfunc (r *Ref) Get() interface{} {\n    refnum := r.Bind_Num\n    refs.Lock()\n    o, ok := refs.objs[refnum]\n    refs.Unlock()\n    if !ok {\n        panic(fmt.Sprintf(“unknown ref %d”, refnum))\n    }\n    // This is a Go reference and its refnum was incremented\n    // before crossing the language barrier.\n    Delete(refnum)\n    return o.obj\n}\n```\n前半段印证了我们的猜想，取出对象并且返回。Delete的实现是引用计数-1，如果到0了，那就从map中删除。\n\n*印证我们上面思考中的猜想！*Golang对象并不是在结束的时候才释放，在Golang中 v := ref.Get().(*g_mb_test.GMBTest) 已经持有，其实不必再持有了，等Golang的方法结束的时候自然会通过Golang的垃圾回收释放。\n\n最后代码就是一个Go的方法调用了，把int参数传入。\n\n**总结一下：**\nOC调用Golang的方法，实际是，在OC中调用方法的时候，先用self.ref 获取 refnum。这个步骤会增加Go中对象的引用计数。然后调入Go的方法，把refnum传入，取出Golang对象，减小引用计数。然后调用具体实现的方法。\n\n#### Golang返回对象\nGolang的方法返回对象其实和上面的初始化方法大同小异，只是结合了基本方法调用。注：Go返回的对象类型必须是Go导出的类型，非Go导出的类型Go不识别或者OC不识别（除了NSData，NSString等基本类型）。\n\n```\n- (G_mb_testGMBTest*)gmbTest6 {\n    int32_t refnum = go_seq_go_to_refnum(self._ref);\n    int32_t r0 = proxyg_mb_test_GMBTest_GMBTest6(refnum);\n    G_mb_testGMBTest* _ret0_ = nil;\n    GoSeqRef* _ret0__ref = go_seq_from_refnum(r0);\n    if (_ret0__ref != NULL) {\n        _ret0_ = _ret0__ref.obj;\n        if (_ret0_ == nil) {\n            _ret0_ = [[G_mb_testGMBTest alloc] initWithRef:_ret0__ref];\n        }\n    }\n    return _ret0_;\n}\n```\nproxyg_mb_test_GMBTest_GMBTest6()方法返回了一个int值，这个值必然是对应的Golang的对象。\n```\n//export proxyg_mb_test_GMBTest_GMBTest6\nfunc proxyg_mb_test_GMBTest_GMBTest6(refnum C.int32_t) C.int32_t {\n    ref := _seq.FromRefNum(int32(refnum))\n    v := ref.Get().(*g_mb_test.GMBTest)\n    res_0 := v.GMBTest6()\n    var _res_0 C.int32_t = _seq.NullRefNum\n    if res_0 != nil {\n        _res_0 = C.int32_t(_seq.ToRefNum(res_0))\n    }\n    return _res_0\n}\n```\n\n方法调用的地方我们不再详述，返回的res_0如果是nil，则会返回_seq.NullRefNum = 41。即用一个特定的值来表示null。\n返回后OC同样的会在go_seq_from_refnum()中判断41这个值。\n\n**总结一下：**\nGo返回对象实际是返回一个refnum值，OC使用GoSeqRef来存储这个值。（返回的对象始终是Go已导出的对象类型）\n\n#### Golang返回接口类型\n实际上Go和其他语言通讯大部分都会使用接口类型\n\n```\n- (id<G_mb_testGMBInterface>)gmbTest5 {\n    int32_t refnum = go_seq_go_to_refnum(self._ref);\n    int32_t r0 = proxyg_mb_test_GMBTest_GMBTest5(refnum);\n    G_mb_testGMBInterface* _ret0_ = nil;\n    GoSeqRef* _ret0__ref = go_seq_from_refnum(r0);\n    if (_ret0__ref != NULL) {\n        _ret0_ = _ret0__ref.obj;\n        if (_ret0_ == nil) {\n            _ret0_ = [[G_mb_testGMBInterface alloc] initWithRef:_ret0__ref];\n        }\n    }\n    return _ret0_;\n}\n```\nproxyg_mb_test_GMBTest_GMBTest5()和上面的proxyg_mb_test_GMBTest_GMBTest6()返回对象没有什么差别，主要差别在于处理返回的值变成go中的refnum。\n\n```\n@implementation G_mb_testGMBInterface {\n}\n\n- (instancetype)initWithRef:(id)ref {\n    self = [super init];\n    if (self) { __ref = ref; }\n    return self;\n}\n\n- (void)interfaceTest {\n    int32_t refnum = go_seq_go_to_refnum(self._ref);\n    proxyg_mb_test_GMBInterface_InterfaceTest(refnum);\n}\n\n@end\n```\n\n在g_mb_test_darwin.m中自动生成了一个G_mb_testGMBInterface类，而这个类实现了G_mb_testGMBInterface，也就是我们定义的接口，并且存储了GO返回的refnum。而接口的实现内调用了proxyg_mb_test_GMBInterface_InterfaceTest()函数。这个函数实际就是通过返回的refnum来获取Go中的对象，调用Go中实现的接口。\n\n**总结：**\nGo返回的接口类型，在OC上还是一个refnum。胶水代码自动生成了一个实现这个接口的类，并且保存了这个GoSeqRef。在调用接口的时候，实际上是调用的这个自动生成的类的方法。最终还是通过存储的GoSeqRef找到Go中的对象，来调用具体方法。\n\n至此，Go方法返回数据都已经讲完了（NSData和NSString我们放在单独的环节）。接下来我们看一下从OC传对象至Go\n\n#### OC传递对象至Go\n这一节我们将补充讲完之前跳过的环节。\n\n```\n- (void)gmbTest7:(id<G_mb_testGMBInterface>)i {\n    int32_t refnum = go_seq_go_to_refnum(self._ref);\n    int32_t _i;\n    if ([i conformsToProtocol:@protocol(goSeqRefInterface)]) {\n        id<goSeqRefInterface> i_proxy = (id<goSeqRefInterface>)(i);\n        _i = go_seq_go_to_refnum(i_proxy._ref);\n    } else {\n        _i = go_seq_to_refnum(i);\n    }\n    proxyg_mb_test_GMBTest_GMBTest7(refnum, _i);\n}\n```\ngoSeqRefInterface接口表示的是Go传出的对象（因为有GoSeqRef)。\n如果是Go的对象，则增加引用计数。\n如果不是Go的对象，即OC new出来的对象，调用go_seq_to_refnum()\n\n方法内部实际是调用的全局变量tracker。\n看到这里其实已经明白了，在OC里实现了一个和Go中refs一样的结构。用来标识从OC传入Go的对象的引用计数。\nGo在OC里的引用计数是，每次在调用Go对象之前持有一次，在Go由refnum找到对应对象之后，再释放一次。那么OC的对象呢？\n\n继续看到下一个方法proxyg_mb_test_GMBTest_GMBTest7()的参数传递。\n```\n//export proxyg_mb_test_GMBTest_GMBTest7\nfunc proxyg_mb_test_GMBTest_GMBTest7(refnum C.int32_t, param_i C.int32_t) {\n    ref := _seq.FromRefNum(int32(refnum))\n    v := ref.Get().(*g_mb_test.GMBTest)\n    var _param_i g_mb_test.GMBInterface\n    _param_i_ref := _seq.FromRefNum(int32(param_i))\n    if _param_i_ref != nil {\n        if param_i < 0 { // go object\n            _param_i = _param_i_ref.Get().(g_mb_test.GMBInterface)\n        } else { // foreign object\n            _param_i = (*proxyg_mb_test_GMBInterface)(_param_i_ref)\n        }\n    }\n    v.GMBTest7(_param_i)\n}\n```\n\n之前提到过，_seq.FromRefNum只判断null（41），否则返回一个Ref指针。如果传入的参数是Go生成的，那么就直接使用。否则，如果是外部传入的，直接把_param_i_ref强转为了proxyg_mb_test_GMBInterface类型。\n\n看到后面还有一个对proxyg_mb_test_GMBInterface 的定义\n```\ntype proxyg_mb_test_GMBInterface _seq.Ref\n\nfunc (p *proxyg_mb_test_GMBInterface) Bind_proxy_refnum__() int32 { return (*_seq.Ref)(p).Bind_IncNum() }\n\nfunc (p *proxyg_mb_test_GMBInterface) InterfaceTest() {\n    C.cproxyg_mb_test_GMBInterface_InterfaceTest(C.int32_t(p.Bind_proxy_refnum__()))\n}\n```\n两个方法：\nBind_proxy_refnum__()调用了Ref的Bind_IncNum(),看名字和注释的意思是增加外部变量的引用。\n```\nfunc init() {\n    _seq.FinalizeRef = func(ref *_seq.Ref) {\n        refnum := ref.Bind_Num\n        if refnum < 0 {\n            panic(fmt.Sprintf(“not a foreign ref: %d”, refnum))\n        }\n        C.go_seq_dec_ref(C.int32_t(refnum))\n    }\n    _seq.IncForeignRef = func(refnum int32) {\n        if refnum < 0 {\n            panic(fmt.Sprintf(\"not a foreign ref: %d\", refnum))\n        }\n        C.go_seq_inc_ref(C.int32_t(refnum))\n    }\n}\n```\n在初始化的时候，会给seq设置两个全局函数，一个是释放，另一个就是刚刚Bind_IncNum()函数内调用的_seq.IncForeignRef()，\nC.cproxyg_mb_test_GMBInterface_InterfaceTest()，这个两个方法内实际调用了Cgo_seq_inc_ref()和C.go_seq_dec_ref(),这个是链接静态库的实现的符号。\n\n```\nvoid go_seq_dec_ref(int32_t refnum) {\n  @autoreleasepool {\n    [tracker dec:refnum];\n  }\n}\n\nvoid go_seq_inc_ref(int32_t refnum) {\n  @autoreleasepool {\n    [tracker inc:refnum];\n  }\n}\n\n```\nseq_darwin.m中可以看到，确实是增加和减少引用计数。\n\n在上面讲到FromRefNum的时候，如果是外部传入的对象，则会给GoRef设置一个析构函数。\n也就是说，在GoRef这个结构体的生命周期内，持有外部的对象。GoRef 映射的就是外部对象。\n\n继续回到上面，InterfaceTest()是接口的另一个方法\n```\nvoid cproxyg_mb_test_GMBInterface_InterfaceTest(int32_t refnum) {\n    @autoreleasepool {\n        G_mb_testGMBInterface* o = go_seq_objc_from_refnum(refnum);\n        [o interfaceTest];\n    }\n}\n```\n和_seq.FinalizeRef一样，调用到了oc。而OC的go_seq_objc_from_refnum（）方法在拿到oc对象之后，调用了[tracker dec:refnum];\n这样，在OC层完成了这个对象的释放\n\n**总结：**\nOC的接口对象传递至Go的时候（非Go导出对象），Go肯定也是以一个接口对象存在。OC在传入之前计数+1（计数为1），传入之后，Go对生成的GoRef增加析构函数，析构函数内对计数 -1。\n在Go内调用GoRef重定义的接口函数时候，会先增加引用计数，调回OC之后，在OC取到对应的OC对象后，OC会主动对计数-1。这一点和Go传出对象很类似。\n\n另外，刚刚我们跳过了go_seq_from_refnum()以及ToRefNum()的代码，都是考虑的特殊情况。我们刚刚讨论的都是OC创建的对象传递至Go，Go创建的对象传递至OC。但是还有OC传递至Go后，Go在把同一个对象返回给OC。相反也有Go给OC后，OC把同一个对象给了Go。（这个同一个对象，在OC内是指GoSeqRef，在Go内是指GoRef，两侧都是镜像的。）对于这种情况，两侧都是不需要转换的，OC内直接从GoSeqRef取出obj调用，Go内直接找到refnum对应的对象调用。\n\n## 总结\n1. Go导出的静态库实际是一个C实现的静态库，还会生成OC的代码（胶水代码）来包裹这个库，以达到导出OC类、方法和接口\n2. Go的对象和OC对象在对方侧，都一个int32(refnum)作为对象参数，来对应每一个传递过去的对象。如果refnum>0表示OC对象，<0表示Go对象。\n3. Go的对象和OC对象在对方侧，分别有一个存储了refnum的GoRef struct和GoSeqRef class来表示对方侧的对象。\n4. Go和OC侧都有全局变量来维护已经传入至对方侧的对象，以及引用计数。\n5. 不论是OC还是Go，如果refnum表示的是本侧的对象，那么就直接从全局变量中取出对象使用。\n6. OC调用Go对象方法，实际是调用Go的C函数，通过传递refnum告知Go具体的Go对象。\n7. Go调用OC对象方法，实际是通过声明式，调用C函数，由.m实现。同理通过传递refnum来告知OC具体的OC对象。\n8. OC调用Go的接口对象，实际是生成了实现接口的类的胶水代码，接口对象持有了GoSeqRef，接口方法实际也是通过传递refnum调用Go\n9. Go调用OC的接口对象，实际是通过声明式，调用C函数，由.m实现。通过重定义GoRef，实现OC的接口方法。接口方法内通过传递refnum调用.m即OC\n10. Go传递至OC的对象，Go在new或者函数返回之前会调用_seq.ToRefNum()，存储在全局变量中，并计数为1。OC存储的GoSeqRef在dealloc的时候通过DestroyRef()将计数-1。\n11. OC传递至Go的对象，OC在传递给Go之前会调用assignRefnumAndIncRefcount:存储在全局变量中，并计数为1。Go在生成GoRef的时候会设置该对象的析构回调，在回调内，通过调用go_seq_dec_ref()将计数-1\n12. Go对象方法被OC调用之前，OC会使用go_seq_go_to_refnum()将计数+1，Go在将refnum转换为go obj之后，又会将计数-1\n13. OC对象方法被Go调用之前，Go会使用Bind_IncNum()将计数+1，OC在将refnum转换为oc obj 之后，又会将计数-1。\n\n以上的总结已经完全可以解答文章开始时候的提问了。\n\n//最后这里回头补充一个图解\n\n## 后记\n还有两个特殊的地方 NSString 和 NSData。这两个对象在Go <—> OC gomobile 是默认支持这两种数据类型的互转的。\n```\ntypedef struct nstring {\n  void *ptr;\n  int len;\n} nstring;\n\ntypedef struct nbyteslice {\n  void *ptr;\n  int len;\n} nbyteslice;\ntypedef int nint;\n```\n这两个数据类型在传递的时候，都会被转换为定义好的C语言的struct类型。\n\n### String\n```\n// encodeString copies a Go string and returns it as a nstring.\nfunc encodeString(s string) C.nstring {\n    n := C.int(len(s))\n    if n == 0 {\n        return C.nstring{}\n    }\n    ptr := C.malloc(C.size_t(n))\n    if ptr == nil {\n        panic(\"encodeString: malloc failed\")\n    }\n    copy((*[1<<31 - 1]byte)(ptr)[:n], s)\n    return C.nstring{ptr: ptr, len: n}\n}\n\n// decodeString converts a nstring to a Go string. The\n// data in str is freed after use.\nfunc decodeString(str C.nstring) string {\n    if str.ptr == nil {\n        return \"\"\n    }\n    s := C.GoStringN((*C.char)(str.ptr), str.len)\n    C.free(str.ptr)\n    return s\n}\n```\n\nGo 侧 string 通过encode和decode方法，在cstring和go string之间互转，*每次转换都会copy*。\n\n```\nNSString *go_seq_to_objc_string(nstring str) {\n  if (str.len == 0) {  // empty string.\n    return @“”;\n  }\n  NSString * res = [[NSString alloc] initWithBytesNoCopy:str.ptr\n                                                  length:str.len\n                                                encoding:NSUTF8StringEncoding\n                                            freeWhenDone:YES];\n  return res;\n}\n\nnstring go_seq_from_objc_string(NSString *s) {\n  nstring res = {NULL, 0};\n  int len = [s lengthOfBytesUsingEncoding:NSUTF8StringEncoding];\n\n  if (len == 0) {\n    if (s.length > 0) {\n      LOG_INFO(@“unable to encode an NSString into UTF-8”);\n    }\n    return res;\n  }\n\n  char *buf = (char *)malloc(len);\n  if (buf == NULL) {\n    LOG_FATAL(@\"malloc failed\");\n  }\n  NSUInteger used;\n  [s getBytes:buf\n           maxLength:len\n          usedLength:&used\n            encoding:NSUTF8StringEncoding\n             options:0\n               range:NSMakeRange(0, [s length])\n      remainingRange:NULL];\n  res.ptr = buf;\n  res.len = used;\n  return res;\n}\n```\n\nOC 侧 NSString 通过go_seq_to_objc_string和go_seq_from_objc_string方法，在cstring和nsstring之间互转，*每次转换都会copy*。\n\n且对方侧生成的cstring由己方释放。\n\n### Bytes\n```\n\n// fromSlice converts a slice to a nbyteslice.\n// If cpy is set, a malloc’ed copy of the data is returned.\nfunc fromSlice(s []byte, cpy bool) C.nbyteslice {\n    if s == nil || len(s) == 0 {\n        return C.nbyteslice{}\n    }\n    ptr, n := unsafe.Pointer(&s[0]), C.int(len(s))\n    if cpy {\n        nptr := C.malloc(C.size_t(n))\n        if nptr == nil {\n            panic(\"fromSlice: malloc failed\")\n        }\n        copy((*[1<<31 - 1]byte)(nptr)[:n], (*[1<<31 - 1]byte)(ptr)[:n])\n        ptr = nptr\n    }\n    return C.nbyteslice{ptr: ptr, len: n}\n}\n\n// toSlice takes a nbyteslice and returns a byte slice with the data. If cpy is\n// set, the slice contains a copy of the data. If not, the generated Go code\n// calls releaseByteSlice after use.\nfunc toSlice(s C.nbyteslice, cpy bool) []byte {\n    if s.ptr == nil || s.len == 0 {\n        return nil\n    }\n    var b []byte\n    if cpy {\n        b = C.GoBytes(s.ptr, C.int(s.len))\n        C.free(s.ptr)\n    } else {\n        b = (*[1<<31 - 1]byte)(unsafe.Pointer(s.ptr))[:s.len:s.len]\n    }\n    return b\n}\n```\n\nGo 侧 nbyteslice 通过fromSlice和toSlice方法，在nbyteslice和go slice之间互转。\n\nOC -> Go 如果对方（OC）copy == true，Go也会拷贝，拷贝完就会释放nbyteslice，否则只是使用。\nGo -> OC  (copy 才会拷贝，go->OC copy=true)。\n\n```\nNSData *go_seq_to_objc_bytearray(nbyteslice s, int copy) {\n  if (s.ptr == NULL) {\n    return NULL;\n  }\n  BOOL freeWhenDone = copy ? YES : NO;\n  return [NSData dataWithBytesNoCopy:s.ptr length:s.len freeWhenDone:freeWhenDone];\n}\n\nnbyteslice go_seq_from_objc_bytearray(NSData *data, int copy) {\n  struct nbyteslice res = {NULL, 0};\n  int sz = data.length;\n  if (sz == 0) {\n    return res;\n  }\n  void *ptr;\n  // If the argument was not a NSMutableData, copy the data so that\n  // the NSData is not changed from Go. The corresponding free is called\n  // by releaseByteSlice.\n  if (copy || ![data isKindOfClass:[NSMutableData class]]) {\n    void *arr_copy = malloc(sz);\n    if (arr_copy == NULL) {\n      LOG_FATAL(@\"malloc failed\");\n    }\n    memcpy(arr_copy, [data bytes], sz);\n    ptr = arr_copy;\n  } else {\n    ptr = (void *)[data bytes];\n  }\n  res.ptr = ptr;\n  res.len = sz;\n  return res;\n}\n\n```\n\nOC 侧 NSData 通过go_seq_to_objc_bytearray和go_seq_from_objc_bytearray方法，在nbyteslice和NSData之间互转。\n\nOC -> Go (NSMutableData && !copy 才不会拷贝，OC->Go copy = false，即NSData拷贝，NSMutableData不拷贝)，*并且方法调用结束就会释放bytes*。（如果在Go内使用slice的时候切协程了，有大概率读取到的bytes是被释放了）\nGo -> OC  OC不拷贝从Go返回的bytes，OC在释放NSData的时候会释放nbyteslice.\n\n*总之一个宗旨，一侧指定了copy，就由另一侧释放。没有指定copy，就由本侧释放，即谁创建谁释放的原则。（NSData是指定了false，但是执行拷贝了，还是由本侧释放）*\n\n---\n\n2020-3-18 记\n[用 Dart 来写 Objective-C 代码](http://yulingtianxia.com/blog/2019/10/27/Write-Objective-C-Code-using-Dart/)\n\n这篇文章讲述的是在Dart中写OC，与GoMobile的原理相比有些许相似...","slug":"14.gomobile-bind","published":1,"updated":"2022-07-28T13:38:40.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwo5000np9c92lag7t6e","content":"<blockquote>\n<p>标题要唬人…在做Golang跨平台的时候，使用gomobile bind -target&#x3D;ios xxx 就可以生成对应平台的framework。</p>\n</blockquote>\n<p>本文讨论的内容是Golang是如何实现了OC和Go的数据通讯与接口调用，以及如何做到让开发者无感知的从OC对象的引用计数切换到Golang的垃圾回收机制。</p>\n<p>其实Go的语言层面的通讯实际上是由bind生成的中间层的代码来实现的，什么是中间层的代码？我们简单做实验…</p>\n<span id=\"more\"></span>\n\n<p>写一个Go的例子，以下所有方法就是我们本文需要讨论的所有内容了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package g_mb_test</span><br><span class=\"line\"></span><br><span class=\"line\">type GMBInterface interface &#123;</span><br><span class=\"line\">\tInterfaceTest()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type GMBTest struct &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTestOne(value int32) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTestSecond(data []byte, str string) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTest3() string &#123;</span><br><span class=\"line\">    return “”</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTest4() []byte &#123;</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTest5() GMBInterface &#123;</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTest6() *GMBTest &#123;</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTest7(i GMBInterface) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Go 导出的对象在OC中是怎么获取到的？</li>\n<li>OC是怎么调用Golang的对象方法的？</li>\n<li>OC是怎么传递给Golang参数的？不同的类型是否一样（NSData -&gt; []byte, NSString -&gt; string, interface(OC) -&gt; interface）？</li>\n<li>OC传递给Golang 的参数Golang怎么释放（或者OC怎么释放）？</li>\n<li>相反Golang是怎么返回值的？不同的类型是否一样（[]byte -&gt; NSData, string -&gt; NSString, interface -&gt; interface(OC)）?</li>\n<li>Golang 如果返回的是一个被导出的类型，又是什么样的？</li>\n</ol>\n<p>首先Golang本身是由C来实现的，所以Golang可以”无压力”和C进行双向通讯(cgo)。其次，OC的本质其实也是C，OC也是可以和C无缝进行双向通讯。在这两个条件下我们可以假想，OC和Golang 的双向通讯是不是也可以用C？</p>\n<p>实验开始，我们使用命令行<code>gomobile bind -target=ios/amd64 -work Caio/g_mb_test</code>来保留工作目录。</p>\n<p>找到控制台输出的临时目录，生成了如下的结构。go-buildxxx下是生成的中间产物。而src下就是gomobile自动生成的中间代码。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d4bb5b927cdeb09f7ba32e3925bfb1c4.png\"></p>\n<h3 id=\"先从对象的初始化开始…\"><a href=\"#先从对象的初始化开始…\" class=\"headerlink\" title=\"先从对象的初始化开始…\"></a>先从对象的初始化开始…</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)init &#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    if (self) &#123;</span><br><span class=\"line\">        __ref = go_seq_from_refnum(new_g_mb_test_GMBTest());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>new_g_mb_test_GMBTest 实际是由 go在静态库中实现的方法，可以从g_mb_test-amd64.h头文件中找到它的声明。对应了src中的go_g_mb_testmain.go文件中的new_g_mb_test_GMBTest()方法。这个go文件是gomobile在编译go之前自动生成的代码。</p>\n<p>可以理解为在iOS中引入了一个”静态 framework”，这个静态库实现了new_g_mb_test_GMBTest()。只不过这个framework是由Go语言实现的。</p>\n<p>可以看到 new_g_mb_test_GMBTest()返回了一个 int32值，而这个值最后传递给了go_seq_from_refnum()，这个方法是在seq_darwin.m中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GoSeqRef *go_seq_from_refnum(int32_t refnum) &#123;</span><br><span class=\"line\">  if (refnum == NULL_REFNUM) &#123;</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (IS_FROM_GO(refnum)) &#123;</span><br><span class=\"line\">    return [[GoSeqRef alloc] initWithRefnum:refnum obj:NULL];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return [[GoSeqRef alloc] initWithRefnum:refnum obj:go_seq_objc_from_refnum(refnum)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过”字面”意思看，是返回了一个GoSeqRef，通过IS_FROM_GO判断传入的refnum（也就是上面提到的new_g_mb_test_GMBTest()返回的值是不是Go生成的），来决定GoSeqRef中的obj是否为NULL。如果不是Go生成的那么就返回go_seq_objc_from_refnum()转换refnum为obj，这个分支我们之后再讲。</p>\n<p>那么我们看看这个所谓的”静态库”是怎么生成这个int32值的。<br><em>注：以下运行的代码已经在Go中了</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*go_g_mb_testmain.go*</span><br><span class=\"line\">//export new_g_mb_test_GMBTest</span><br><span class=\"line\">func new_g_mb_test_GMBTest() C.int32_t &#123;</span><br><span class=\"line\">    return C.int32_t(_seq.ToRefNum(new(g_mb_test.GMBTest)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 new_g_mb_test_GMBTest()返回了一个 int32，而这个int32值还是由_seq.ToRefNum()方法返回的。这个方法是由golang.org&#x2F;x&#x2F;mobile&#x2F;bind&#x2F;seq&#x2F;ref.go 下的bind提供的。方法参数就是一个go struct对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*golang.org/x/mobile/bind/seq/ref.go*</span><br><span class=\"line\">// ToRefNum increments the reference count for an object and</span><br><span class=\"line\">// returns its refnum.</span><br><span class=\"line\">func ToRefNum(obj interface&#123;&#125;) int32 &#123;</span><br><span class=\"line\">    // We don’t track foreign objects, so if obj is a proxy</span><br><span class=\"line\">    // return its refnum.</span><br><span class=\"line\">    if r, ok := obj.(proxy); ok &#123;</span><br><span class=\"line\">        refnum := r.Bind_proxy_refnum__()</span><br><span class=\"line\">        if refnum &lt;= 0 &#123;</span><br><span class=\"line\">            panic(fmt.Errorf(&quot;seq: proxy contained invalid Go refnum: %d&quot;, refnum))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return refnum</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs.Lock()</span><br><span class=\"line\">    num := refs.refs[obj]</span><br><span class=\"line\">    if num != 0 &#123;</span><br><span class=\"line\">        s := refs.objs[num]</span><br><span class=\"line\">        refs.objs[num] = countedObj&#123;s.obj, s.cnt + 1&#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        num = refs.next</span><br><span class=\"line\">        refs.next--</span><br><span class=\"line\">        if refs.next &gt; 0 &#123;</span><br><span class=\"line\">            panic(“refs.next underflow”)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        refs.refs[obj] = num</span><br><span class=\"line\">        refs.objs[num] = countedObj&#123;obj, 1&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    return int32(num)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于proxy那块的代码，我们稍等之后再看。后面的代码也不急着读，先看后面提到的refs对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// refs stores Go objects that have been passed to another language.</span><br><span class=\"line\">var refs struct &#123;</span><br><span class=\"line\">    sync.Mutex</span><br><span class=\"line\">    next int32 // next reference number to use for Go object, always negative</span><br><span class=\"line\">    refs map[interface&#123;&#125;]int32</span><br><span class=\"line\">    objs map[int32]countedObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释写的很明确了，refs存储了从Golang传递给其他语言的对象。</p>\n<p>结构体中有两个map成员变量，一个是refs，一个是objs。refs的key是对象，value就是上面提到的refnum，objs的key是refnum，value是这个Go对象的引用计数对象。还有一个变量是next，next是下一个Go对象的refnum，而且永远是负数。</p>\n<p>那么上面的后半段代码也就很容易看懂了。从ref取出obj对应的num，计数加一。如果没有的话，next-1作为下一个refnum，把对象存进map。</p>\n<p><strong>所以：</strong></p>\n<ol>\n<li>在Go中有一个全局变量，维护了所有外部正在使用的Go对象。</li>\n<li>从Go生成的对象，想要被外部使用，都是通过一个refnum的值在这个全局变量中索引的。</li>\n<li>并且还维护了一个引用计数，每次取这个对象都会+1。</li>\n<li>另外，从Go导出的refnum都是负数。</li>\n</ol>\n<p>到这里，我们其实可以小<em>总结</em>一下了：<br>从上面的代码可以知道 Go中的对象在 oc 中的体现是:</p>\n<p>OC对象持有一个GoSeqRef，GoSeqRef 持有一个 refnum，refnum在Go中的refs的objs和refs中存储了真正的Go对象和引用计数值。</p>\n<h4 id=\"再看一个OC方法的基本调用\"><a href=\"#再看一个OC方法的基本调用\" class=\"headerlink\" title=\"再看一个OC方法的基本调用\"></a>再看一个OC方法的基本调用</h4><p>既然已经生成Golang的对象了，我们看一下 gmbTestOne 这个基本调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)gmbTestOne:(int32_t)value &#123;</span><br><span class=\"line\">    int32_t refnum = go_seq_go_to_refnum(self._ref);</span><br><span class=\"line\">    int32_t _value = (int32_t)value;</span><br><span class=\"line\">    proxyg_mb_test_GMBTest_GMBTestOne(refnum, _value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>go_seq_go_to_refnum()是在Seq_darwin.m中实现的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (int32_t)incNum &#123;</span><br><span class=\"line\">  IncGoRef(_refnum);</span><br><span class=\"line\">  return _refnum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到最终是返回了_refnum。但是在此之前，还有一个IncGoRef(_refnum);<br>可以看ref.go的实现，方法实现是增加Go对象的引用计数。<br><em>思考：</em>从OC ARC的对象回收的角度来看，似乎”言之有理”。”int32_t refnum “虽然是个int，但是得要持有这个对象，不然会有可能在调用过程中被释放。那么猜想一样，它会在方法域结束的时候释放？我们接着看…</p>\n<p>然后和上面的逻辑一样，proxyg_mb_test_GMBTest_GMBTestOne() 是framework实现的方法，第一个参数是refnum，第二个参数是value的值。</p>\n<p>猜想它的实现应该是，通过 refnum找到Go中的对象，然后调用对应的方法。我们来看Go的实现：<br><em>注：以下运行的代码已经在Go中了</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//export proxyg_mb_test_GMBTest_GMBTestOne</span><br><span class=\"line\">func proxyg_mb_test_GMBTest_GMBTestOne(refnum C.int32_t, param_value C.int32_t) &#123;</span><br><span class=\"line\">    ref := _seq.FromRefNum(int32(refnum))</span><br><span class=\"line\">    v := ref.Get().(*g_mb_test.GMBTest)</span><br><span class=\"line\">    _param_value := int32(param_value)</span><br><span class=\"line\">    v.GMBTestOne(_param_value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// FromRefNum returns the Ref for a refnum. If the refnum specifies a</span><br><span class=\"line\">// foreign object, a finalizer is set to track its lifetime.</span><br><span class=\"line\">func FromRefNum(num int32) *Ref &#123;</span><br><span class=\"line\">    if num == NullRefNum &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ref := &amp;Ref&#123;num&#125;</span><br><span class=\"line\">    if num &gt; 0 &#123;</span><br><span class=\"line\">        // This is a foreign object reference.</span><br><span class=\"line\">        // Track its lifetime with a finalizer.</span><br><span class=\"line\">        runtime.SetFinalizer(ref, FinalizeRef)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return ref</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和OC中一样，在Go中也有一个Ref对象，这个对象包裹的就是一个refnum。<br>num &gt; 0是指代外部传入的对象，我们先不看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Get returns the underlying object.</span><br><span class=\"line\">func (r *Ref) Get() interface&#123;&#125; &#123;</span><br><span class=\"line\">    refnum := r.Bind_Num</span><br><span class=\"line\">    refs.Lock()</span><br><span class=\"line\">    o, ok := refs.objs[refnum]</span><br><span class=\"line\">    refs.Unlock()</span><br><span class=\"line\">    if !ok &#123;</span><br><span class=\"line\">        panic(fmt.Sprintf(“unknown ref %d”, refnum))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // This is a Go reference and its refnum was incremented</span><br><span class=\"line\">    // before crossing the language barrier.</span><br><span class=\"line\">    Delete(refnum)</span><br><span class=\"line\">    return o.obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前半段印证了我们的猜想，取出对象并且返回。Delete的实现是引用计数-1，如果到0了，那就从map中删除。</p>\n<p><em>印证我们上面思考中的猜想！</em>Golang对象并不是在结束的时候才释放，在Golang中 v :&#x3D; ref.Get().(*g_mb_test.GMBTest) 已经持有，其实不必再持有了，等Golang的方法结束的时候自然会通过Golang的垃圾回收释放。</p>\n<p>最后代码就是一个Go的方法调用了，把int参数传入。</p>\n<p><strong>总结一下：</strong><br>OC调用Golang的方法，实际是，在OC中调用方法的时候，先用self.ref 获取 refnum。这个步骤会增加Go中对象的引用计数。然后调入Go的方法，把refnum传入，取出Golang对象，减小引用计数。然后调用具体实现的方法。</p>\n<h4 id=\"Golang返回对象\"><a href=\"#Golang返回对象\" class=\"headerlink\" title=\"Golang返回对象\"></a>Golang返回对象</h4><p>Golang的方法返回对象其实和上面的初始化方法大同小异，只是结合了基本方法调用。注：Go返回的对象类型必须是Go导出的类型，非Go导出的类型Go不识别或者OC不识别（除了NSData，NSString等基本类型）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (G_mb_testGMBTest*)gmbTest6 &#123;</span><br><span class=\"line\">    int32_t refnum = go_seq_go_to_refnum(self._ref);</span><br><span class=\"line\">    int32_t r0 = proxyg_mb_test_GMBTest_GMBTest6(refnum);</span><br><span class=\"line\">    G_mb_testGMBTest* _ret0_ = nil;</span><br><span class=\"line\">    GoSeqRef* _ret0__ref = go_seq_from_refnum(r0);</span><br><span class=\"line\">    if (_ret0__ref != NULL) &#123;</span><br><span class=\"line\">        _ret0_ = _ret0__ref.obj;</span><br><span class=\"line\">        if (_ret0_ == nil) &#123;</span><br><span class=\"line\">            _ret0_ = [[G_mb_testGMBTest alloc] initWithRef:_ret0__ref];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _ret0_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>proxyg_mb_test_GMBTest_GMBTest6()方法返回了一个int值，这个值必然是对应的Golang的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//export proxyg_mb_test_GMBTest_GMBTest6</span><br><span class=\"line\">func proxyg_mb_test_GMBTest_GMBTest6(refnum C.int32_t) C.int32_t &#123;</span><br><span class=\"line\">    ref := _seq.FromRefNum(int32(refnum))</span><br><span class=\"line\">    v := ref.Get().(*g_mb_test.GMBTest)</span><br><span class=\"line\">    res_0 := v.GMBTest6()</span><br><span class=\"line\">    var _res_0 C.int32_t = _seq.NullRefNum</span><br><span class=\"line\">    if res_0 != nil &#123;</span><br><span class=\"line\">        _res_0 = C.int32_t(_seq.ToRefNum(res_0))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _res_0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法调用的地方我们不再详述，返回的res_0如果是nil，则会返回_seq.NullRefNum &#x3D; 41。即用一个特定的值来表示null。<br>返回后OC同样的会在go_seq_from_refnum()中判断41这个值。</p>\n<p><strong>总结一下：</strong><br>Go返回对象实际是返回一个refnum值，OC使用GoSeqRef来存储这个值。（返回的对象始终是Go已导出的对象类型）</p>\n<h4 id=\"Golang返回接口类型\"><a href=\"#Golang返回接口类型\" class=\"headerlink\" title=\"Golang返回接口类型\"></a>Golang返回接口类型</h4><p>实际上Go和其他语言通讯大部分都会使用接口类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (id&lt;G_mb_testGMBInterface&gt;)gmbTest5 &#123;</span><br><span class=\"line\">    int32_t refnum = go_seq_go_to_refnum(self._ref);</span><br><span class=\"line\">    int32_t r0 = proxyg_mb_test_GMBTest_GMBTest5(refnum);</span><br><span class=\"line\">    G_mb_testGMBInterface* _ret0_ = nil;</span><br><span class=\"line\">    GoSeqRef* _ret0__ref = go_seq_from_refnum(r0);</span><br><span class=\"line\">    if (_ret0__ref != NULL) &#123;</span><br><span class=\"line\">        _ret0_ = _ret0__ref.obj;</span><br><span class=\"line\">        if (_ret0_ == nil) &#123;</span><br><span class=\"line\">            _ret0_ = [[G_mb_testGMBInterface alloc] initWithRef:_ret0__ref];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _ret0_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>proxyg_mb_test_GMBTest_GMBTest5()和上面的proxyg_mb_test_GMBTest_GMBTest6()返回对象没有什么差别，主要差别在于处理返回的值变成go中的refnum。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation G_mb_testGMBInterface &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithRef:(id)ref &#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    if (self) &#123; __ref = ref; &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)interfaceTest &#123;</span><br><span class=\"line\">    int32_t refnum = go_seq_go_to_refnum(self._ref);</span><br><span class=\"line\">    proxyg_mb_test_GMBInterface_InterfaceTest(refnum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>在g_mb_test_darwin.m中自动生成了一个G_mb_testGMBInterface类，而这个类实现了G_mb_testGMBInterface，也就是我们定义的接口，并且存储了GO返回的refnum。而接口的实现内调用了proxyg_mb_test_GMBInterface_InterfaceTest()函数。这个函数实际就是通过返回的refnum来获取Go中的对象，调用Go中实现的接口。</p>\n<p><strong>总结：</strong><br>Go返回的接口类型，在OC上还是一个refnum。胶水代码自动生成了一个实现这个接口的类，并且保存了这个GoSeqRef。在调用接口的时候，实际上是调用的这个自动生成的类的方法。最终还是通过存储的GoSeqRef找到Go中的对象，来调用具体方法。</p>\n<p>至此，Go方法返回数据都已经讲完了（NSData和NSString我们放在单独的环节）。接下来我们看一下从OC传对象至Go</p>\n<h4 id=\"OC传递对象至Go\"><a href=\"#OC传递对象至Go\" class=\"headerlink\" title=\"OC传递对象至Go\"></a>OC传递对象至Go</h4><p>这一节我们将补充讲完之前跳过的环节。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)gmbTest7:(id&lt;G_mb_testGMBInterface&gt;)i &#123;</span><br><span class=\"line\">    int32_t refnum = go_seq_go_to_refnum(self._ref);</span><br><span class=\"line\">    int32_t _i;</span><br><span class=\"line\">    if ([i conformsToProtocol:@protocol(goSeqRefInterface)]) &#123;</span><br><span class=\"line\">        id&lt;goSeqRefInterface&gt; i_proxy = (id&lt;goSeqRefInterface&gt;)(i);</span><br><span class=\"line\">        _i = go_seq_go_to_refnum(i_proxy._ref);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        _i = go_seq_to_refnum(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    proxyg_mb_test_GMBTest_GMBTest7(refnum, _i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>goSeqRefInterface接口表示的是Go传出的对象（因为有GoSeqRef)。<br>如果是Go的对象，则增加引用计数。<br>如果不是Go的对象，即OC new出来的对象，调用go_seq_to_refnum()</p>\n<p>方法内部实际是调用的全局变量tracker。<br>看到这里其实已经明白了，在OC里实现了一个和Go中refs一样的结构。用来标识从OC传入Go的对象的引用计数。<br>Go在OC里的引用计数是，每次在调用Go对象之前持有一次，在Go由refnum找到对应对象之后，再释放一次。那么OC的对象呢？</p>\n<p>继续看到下一个方法proxyg_mb_test_GMBTest_GMBTest7()的参数传递。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//export proxyg_mb_test_GMBTest_GMBTest7</span><br><span class=\"line\">func proxyg_mb_test_GMBTest_GMBTest7(refnum C.int32_t, param_i C.int32_t) &#123;</span><br><span class=\"line\">    ref := _seq.FromRefNum(int32(refnum))</span><br><span class=\"line\">    v := ref.Get().(*g_mb_test.GMBTest)</span><br><span class=\"line\">    var _param_i g_mb_test.GMBInterface</span><br><span class=\"line\">    _param_i_ref := _seq.FromRefNum(int32(param_i))</span><br><span class=\"line\">    if _param_i_ref != nil &#123;</span><br><span class=\"line\">        if param_i &lt; 0 &#123; // go object</span><br><span class=\"line\">            _param_i = _param_i_ref.Get().(g_mb_test.GMBInterface)</span><br><span class=\"line\">        &#125; else &#123; // foreign object</span><br><span class=\"line\">            _param_i = (*proxyg_mb_test_GMBInterface)(_param_i_ref)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    v.GMBTest7(_param_i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前提到过，_seq.FromRefNum只判断null（41），否则返回一个Ref指针。如果传入的参数是Go生成的，那么就直接使用。否则，如果是外部传入的，直接把_param_i_ref强转为了proxyg_mb_test_GMBInterface类型。</p>\n<p>看到后面还有一个对proxyg_mb_test_GMBInterface 的定义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type proxyg_mb_test_GMBInterface _seq.Ref</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *proxyg_mb_test_GMBInterface) Bind_proxy_refnum__() int32 &#123; return (*_seq.Ref)(p).Bind_IncNum() &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *proxyg_mb_test_GMBInterface) InterfaceTest() &#123;</span><br><span class=\"line\">    C.cproxyg_mb_test_GMBInterface_InterfaceTest(C.int32_t(p.Bind_proxy_refnum__()))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两个方法：<br>Bind_proxy_refnum__()调用了Ref的Bind_IncNum(),看名字和注释的意思是增加外部变量的引用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func init() &#123;</span><br><span class=\"line\">    _seq.FinalizeRef = func(ref *_seq.Ref) &#123;</span><br><span class=\"line\">        refnum := ref.Bind_Num</span><br><span class=\"line\">        if refnum &lt; 0 &#123;</span><br><span class=\"line\">            panic(fmt.Sprintf(“not a foreign ref: %d”, refnum))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        C.go_seq_dec_ref(C.int32_t(refnum))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _seq.IncForeignRef = func(refnum int32) &#123;</span><br><span class=\"line\">        if refnum &lt; 0 &#123;</span><br><span class=\"line\">            panic(fmt.Sprintf(&quot;not a foreign ref: %d&quot;, refnum))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        C.go_seq_inc_ref(C.int32_t(refnum))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在初始化的时候，会给seq设置两个全局函数，一个是释放，另一个就是刚刚Bind_IncNum()函数内调用的_seq.IncForeignRef()，<br>C.cproxyg_mb_test_GMBInterface_InterfaceTest()，这个两个方法内实际调用了Cgo_seq_inc_ref()和C.go_seq_dec_ref(),这个是链接静态库的实现的符号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void go_seq_dec_ref(int32_t refnum) &#123;</span><br><span class=\"line\">  @autoreleasepool &#123;</span><br><span class=\"line\">    [tracker dec:refnum];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void go_seq_inc_ref(int32_t refnum) &#123;</span><br><span class=\"line\">  @autoreleasepool &#123;</span><br><span class=\"line\">    [tracker inc:refnum];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>seq_darwin.m中可以看到，确实是增加和减少引用计数。</p>\n<p>在上面讲到FromRefNum的时候，如果是外部传入的对象，则会给GoRef设置一个析构函数。<br>也就是说，在GoRef这个结构体的生命周期内，持有外部的对象。GoRef 映射的就是外部对象。</p>\n<p>继续回到上面，InterfaceTest()是接口的另一个方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cproxyg_mb_test_GMBInterface_InterfaceTest(int32_t refnum) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        G_mb_testGMBInterface* o = go_seq_objc_from_refnum(refnum);</span><br><span class=\"line\">        [o interfaceTest];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和_seq.FinalizeRef一样，调用到了oc。而OC的go_seq_objc_from_refnum（）方法在拿到oc对象之后，调用了[tracker dec:refnum];<br>这样，在OC层完成了这个对象的释放</p>\n<p><strong>总结：</strong><br>OC的接口对象传递至Go的时候（非Go导出对象），Go肯定也是以一个接口对象存在。OC在传入之前计数+1（计数为1），传入之后，Go对生成的GoRef增加析构函数，析构函数内对计数 -1。<br>在Go内调用GoRef重定义的接口函数时候，会先增加引用计数，调回OC之后，在OC取到对应的OC对象后，OC会主动对计数-1。这一点和Go传出对象很类似。</p>\n<p>另外，刚刚我们跳过了go_seq_from_refnum()以及ToRefNum()的代码，都是考虑的特殊情况。我们刚刚讨论的都是OC创建的对象传递至Go，Go创建的对象传递至OC。但是还有OC传递至Go后，Go在把同一个对象返回给OC。相反也有Go给OC后，OC把同一个对象给了Go。（这个同一个对象，在OC内是指GoSeqRef，在Go内是指GoRef，两侧都是镜像的。）对于这种情况，两侧都是不需要转换的，OC内直接从GoSeqRef取出obj调用，Go内直接找到refnum对应的对象调用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>Go导出的静态库实际是一个C实现的静态库，还会生成OC的代码（胶水代码）来包裹这个库，以达到导出OC类、方法和接口</li>\n<li>Go的对象和OC对象在对方侧，都一个int32(refnum)作为对象参数，来对应每一个传递过去的对象。如果refnum&gt;0表示OC对象，&lt;0表示Go对象。</li>\n<li>Go的对象和OC对象在对方侧，分别有一个存储了refnum的GoRef struct和GoSeqRef class来表示对方侧的对象。</li>\n<li>Go和OC侧都有全局变量来维护已经传入至对方侧的对象，以及引用计数。</li>\n<li>不论是OC还是Go，如果refnum表示的是本侧的对象，那么就直接从全局变量中取出对象使用。</li>\n<li>OC调用Go对象方法，实际是调用Go的C函数，通过传递refnum告知Go具体的Go对象。</li>\n<li>Go调用OC对象方法，实际是通过声明式，调用C函数，由.m实现。同理通过传递refnum来告知OC具体的OC对象。</li>\n<li>OC调用Go的接口对象，实际是生成了实现接口的类的胶水代码，接口对象持有了GoSeqRef，接口方法实际也是通过传递refnum调用Go</li>\n<li>Go调用OC的接口对象，实际是通过声明式，调用C函数，由.m实现。通过重定义GoRef，实现OC的接口方法。接口方法内通过传递refnum调用.m即OC</li>\n<li>Go传递至OC的对象，Go在new或者函数返回之前会调用_seq.ToRefNum()，存储在全局变量中，并计数为1。OC存储的GoSeqRef在dealloc的时候通过DestroyRef()将计数-1。</li>\n<li>OC传递至Go的对象，OC在传递给Go之前会调用assignRefnumAndIncRefcount:存储在全局变量中，并计数为1。Go在生成GoRef的时候会设置该对象的析构回调，在回调内，通过调用go_seq_dec_ref()将计数-1</li>\n<li>Go对象方法被OC调用之前，OC会使用go_seq_go_to_refnum()将计数+1，Go在将refnum转换为go obj之后，又会将计数-1</li>\n<li>OC对象方法被Go调用之前，Go会使用Bind_IncNum()将计数+1，OC在将refnum转换为oc obj 之后，又会将计数-1。</li>\n</ol>\n<p>以上的总结已经完全可以解答文章开始时候的提问了。</p>\n<p>&#x2F;&#x2F;最后这里回头补充一个图解</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>还有两个特殊的地方 NSString 和 NSData。这两个对象在Go &lt;—&gt; OC gomobile 是默认支持这两种数据类型的互转的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct nstring &#123;</span><br><span class=\"line\">  void *ptr;</span><br><span class=\"line\">  int len;</span><br><span class=\"line\">&#125; nstring;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct nbyteslice &#123;</span><br><span class=\"line\">  void *ptr;</span><br><span class=\"line\">  int len;</span><br><span class=\"line\">&#125; nbyteslice;</span><br><span class=\"line\">typedef int nint;</span><br></pre></td></tr></table></figure>\n<p>这两个数据类型在传递的时候，都会被转换为定义好的C语言的struct类型。</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// encodeString copies a Go string and returns it as a nstring.</span><br><span class=\"line\">func encodeString(s string) C.nstring &#123;</span><br><span class=\"line\">    n := C.int(len(s))</span><br><span class=\"line\">    if n == 0 &#123;</span><br><span class=\"line\">        return C.nstring&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ptr := C.malloc(C.size_t(n))</span><br><span class=\"line\">    if ptr == nil &#123;</span><br><span class=\"line\">        panic(&quot;encodeString: malloc failed&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    copy((*[1&lt;&lt;31 - 1]byte)(ptr)[:n], s)</span><br><span class=\"line\">    return C.nstring&#123;ptr: ptr, len: n&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// decodeString converts a nstring to a Go string. The</span><br><span class=\"line\">// data in str is freed after use.</span><br><span class=\"line\">func decodeString(str C.nstring) string &#123;</span><br><span class=\"line\">    if str.ptr == nil &#123;</span><br><span class=\"line\">        return &quot;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s := C.GoStringN((*C.char)(str.ptr), str.len)</span><br><span class=\"line\">    C.free(str.ptr)</span><br><span class=\"line\">    return s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go 侧 string 通过encode和decode方法，在cstring和go string之间互转，<em>每次转换都会copy</em>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString *go_seq_to_objc_string(nstring str) &#123;</span><br><span class=\"line\">  if (str.len == 0) &#123;  // empty string.</span><br><span class=\"line\">    return @“”;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  NSString * res = [[NSString alloc] initWithBytesNoCopy:str.ptr</span><br><span class=\"line\">                                                  length:str.len</span><br><span class=\"line\">                                                encoding:NSUTF8StringEncoding</span><br><span class=\"line\">                                            freeWhenDone:YES];</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">nstring go_seq_from_objc_string(NSString *s) &#123;</span><br><span class=\"line\">  nstring res = &#123;NULL, 0&#125;;</span><br><span class=\"line\">  int len = [s lengthOfBytesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\"></span><br><span class=\"line\">  if (len == 0) &#123;</span><br><span class=\"line\">    if (s.length &gt; 0) &#123;</span><br><span class=\"line\">      LOG_INFO(@“unable to encode an NSString into UTF-8”);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  char *buf = (char *)malloc(len);</span><br><span class=\"line\">  if (buf == NULL) &#123;</span><br><span class=\"line\">    LOG_FATAL(@&quot;malloc failed&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  NSUInteger used;</span><br><span class=\"line\">  [s getBytes:buf</span><br><span class=\"line\">           maxLength:len</span><br><span class=\"line\">          usedLength:&amp;used</span><br><span class=\"line\">            encoding:NSUTF8StringEncoding</span><br><span class=\"line\">             options:0</span><br><span class=\"line\">               range:NSMakeRange(0, [s length])</span><br><span class=\"line\">      remainingRange:NULL];</span><br><span class=\"line\">  res.ptr = buf;</span><br><span class=\"line\">  res.len = used;</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OC 侧 NSString 通过go_seq_to_objc_string和go_seq_from_objc_string方法，在cstring和nsstring之间互转，<em>每次转换都会copy</em>。</p>\n<p>且对方侧生成的cstring由己方释放。</p>\n<h3 id=\"Bytes\"><a href=\"#Bytes\" class=\"headerlink\" title=\"Bytes\"></a>Bytes</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// fromSlice converts a slice to a nbyteslice.</span><br><span class=\"line\">// If cpy is set, a malloc’ed copy of the data is returned.</span><br><span class=\"line\">func fromSlice(s []byte, cpy bool) C.nbyteslice &#123;</span><br><span class=\"line\">    if s == nil || len(s) == 0 &#123;</span><br><span class=\"line\">        return C.nbyteslice&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ptr, n := unsafe.Pointer(&amp;s[0]), C.int(len(s))</span><br><span class=\"line\">    if cpy &#123;</span><br><span class=\"line\">        nptr := C.malloc(C.size_t(n))</span><br><span class=\"line\">        if nptr == nil &#123;</span><br><span class=\"line\">            panic(&quot;fromSlice: malloc failed&quot;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        copy((*[1&lt;&lt;31 - 1]byte)(nptr)[:n], (*[1&lt;&lt;31 - 1]byte)(ptr)[:n])</span><br><span class=\"line\">        ptr = nptr</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return C.nbyteslice&#123;ptr: ptr, len: n&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// toSlice takes a nbyteslice and returns a byte slice with the data. If cpy is</span><br><span class=\"line\">// set, the slice contains a copy of the data. If not, the generated Go code</span><br><span class=\"line\">// calls releaseByteSlice after use.</span><br><span class=\"line\">func toSlice(s C.nbyteslice, cpy bool) []byte &#123;</span><br><span class=\"line\">    if s.ptr == nil || s.len == 0 &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var b []byte</span><br><span class=\"line\">    if cpy &#123;</span><br><span class=\"line\">        b = C.GoBytes(s.ptr, C.int(s.len))</span><br><span class=\"line\">        C.free(s.ptr)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        b = (*[1&lt;&lt;31 - 1]byte)(unsafe.Pointer(s.ptr))[:s.len:s.len]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go 侧 nbyteslice 通过fromSlice和toSlice方法，在nbyteslice和go slice之间互转。</p>\n<p>OC -&gt; Go 如果对方（OC）copy &#x3D;&#x3D; true，Go也会拷贝，拷贝完就会释放nbyteslice，否则只是使用。<br>Go -&gt; OC  (copy 才会拷贝，go-&gt;OC copy&#x3D;true)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSData *go_seq_to_objc_bytearray(nbyteslice s, int copy) &#123;</span><br><span class=\"line\">  if (s.ptr == NULL) &#123;</span><br><span class=\"line\">    return NULL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  BOOL freeWhenDone = copy ? YES : NO;</span><br><span class=\"line\">  return [NSData dataWithBytesNoCopy:s.ptr length:s.len freeWhenDone:freeWhenDone];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">nbyteslice go_seq_from_objc_bytearray(NSData *data, int copy) &#123;</span><br><span class=\"line\">  struct nbyteslice res = &#123;NULL, 0&#125;;</span><br><span class=\"line\">  int sz = data.length;</span><br><span class=\"line\">  if (sz == 0) &#123;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void *ptr;</span><br><span class=\"line\">  // If the argument was not a NSMutableData, copy the data so that</span><br><span class=\"line\">  // the NSData is not changed from Go. The corresponding free is called</span><br><span class=\"line\">  // by releaseByteSlice.</span><br><span class=\"line\">  if (copy || ![data isKindOfClass:[NSMutableData class]]) &#123;</span><br><span class=\"line\">    void *arr_copy = malloc(sz);</span><br><span class=\"line\">    if (arr_copy == NULL) &#123;</span><br><span class=\"line\">      LOG_FATAL(@&quot;malloc failed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    memcpy(arr_copy, [data bytes], sz);</span><br><span class=\"line\">    ptr = arr_copy;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    ptr = (void *)[data bytes];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  res.ptr = ptr;</span><br><span class=\"line\">  res.len = sz;</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>OC 侧 NSData 通过go_seq_to_objc_bytearray和go_seq_from_objc_bytearray方法，在nbyteslice和NSData之间互转。</p>\n<p>OC -&gt; Go (NSMutableData &amp;&amp; !copy 才不会拷贝，OC-&gt;Go copy &#x3D; false，即NSData拷贝，NSMutableData不拷贝)，<em>并且方法调用结束就会释放bytes</em>。（如果在Go内使用slice的时候切协程了，有大概率读取到的bytes是被释放了）<br>Go -&gt; OC  OC不拷贝从Go返回的bytes，OC在释放NSData的时候会释放nbyteslice.</p>\n<p><em>总之一个宗旨，一侧指定了copy，就由另一侧释放。没有指定copy，就由本侧释放，即谁创建谁释放的原则。（NSData是指定了false，但是执行拷贝了，还是由本侧释放）</em></p>\n<hr>\n<p>2020-3-18 记<br><a href=\"http://yulingtianxia.com/blog/2019/10/27/Write-Objective-C-Code-using-Dart/\">用 Dart 来写 Objective-C 代码</a></p>\n<p>这篇文章讲述的是在Dart中写OC，与GoMobile的原理相比有些许相似…</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>标题要唬人…在做Golang跨平台的时候，使用gomobile bind -target&#x3D;ios xxx 就可以生成对应平台的framework。</p>\n</blockquote>\n<p>本文讨论的内容是Golang是如何实现了OC和Go的数据通讯与接口调用，以及如何做到让开发者无感知的从OC对象的引用计数切换到Golang的垃圾回收机制。</p>\n<p>其实Go的语言层面的通讯实际上是由bind生成的中间层的代码来实现的，什么是中间层的代码？我们简单做实验…</p>","more":"<p>写一个Go的例子，以下所有方法就是我们本文需要讨论的所有内容了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package g_mb_test</span><br><span class=\"line\"></span><br><span class=\"line\">type GMBInterface interface &#123;</span><br><span class=\"line\">\tInterfaceTest()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type GMBTest struct &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTestOne(value int32) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTestSecond(data []byte, str string) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTest3() string &#123;</span><br><span class=\"line\">    return “”</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTest4() []byte &#123;</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTest5() GMBInterface &#123;</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTest6() *GMBTest &#123;</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (t *GMBTest) GMBTest7(i GMBInterface) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Go 导出的对象在OC中是怎么获取到的？</li>\n<li>OC是怎么调用Golang的对象方法的？</li>\n<li>OC是怎么传递给Golang参数的？不同的类型是否一样（NSData -&gt; []byte, NSString -&gt; string, interface(OC) -&gt; interface）？</li>\n<li>OC传递给Golang 的参数Golang怎么释放（或者OC怎么释放）？</li>\n<li>相反Golang是怎么返回值的？不同的类型是否一样（[]byte -&gt; NSData, string -&gt; NSString, interface -&gt; interface(OC)）?</li>\n<li>Golang 如果返回的是一个被导出的类型，又是什么样的？</li>\n</ol>\n<p>首先Golang本身是由C来实现的，所以Golang可以”无压力”和C进行双向通讯(cgo)。其次，OC的本质其实也是C，OC也是可以和C无缝进行双向通讯。在这两个条件下我们可以假想，OC和Golang 的双向通讯是不是也可以用C？</p>\n<p>实验开始，我们使用命令行<code>gomobile bind -target=ios/amd64 -work Caio/g_mb_test</code>来保留工作目录。</p>\n<p>找到控制台输出的临时目录，生成了如下的结构。go-buildxxx下是生成的中间产物。而src下就是gomobile自动生成的中间代码。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d4bb5b927cdeb09f7ba32e3925bfb1c4.png\"></p>\n<h3 id=\"先从对象的初始化开始…\"><a href=\"#先从对象的初始化开始…\" class=\"headerlink\" title=\"先从对象的初始化开始…\"></a>先从对象的初始化开始…</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)init &#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    if (self) &#123;</span><br><span class=\"line\">        __ref = go_seq_from_refnum(new_g_mb_test_GMBTest());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>new_g_mb_test_GMBTest 实际是由 go在静态库中实现的方法，可以从g_mb_test-amd64.h头文件中找到它的声明。对应了src中的go_g_mb_testmain.go文件中的new_g_mb_test_GMBTest()方法。这个go文件是gomobile在编译go之前自动生成的代码。</p>\n<p>可以理解为在iOS中引入了一个”静态 framework”，这个静态库实现了new_g_mb_test_GMBTest()。只不过这个framework是由Go语言实现的。</p>\n<p>可以看到 new_g_mb_test_GMBTest()返回了一个 int32值，而这个值最后传递给了go_seq_from_refnum()，这个方法是在seq_darwin.m中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GoSeqRef *go_seq_from_refnum(int32_t refnum) &#123;</span><br><span class=\"line\">  if (refnum == NULL_REFNUM) &#123;</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (IS_FROM_GO(refnum)) &#123;</span><br><span class=\"line\">    return [[GoSeqRef alloc] initWithRefnum:refnum obj:NULL];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return [[GoSeqRef alloc] initWithRefnum:refnum obj:go_seq_objc_from_refnum(refnum)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过”字面”意思看，是返回了一个GoSeqRef，通过IS_FROM_GO判断传入的refnum（也就是上面提到的new_g_mb_test_GMBTest()返回的值是不是Go生成的），来决定GoSeqRef中的obj是否为NULL。如果不是Go生成的那么就返回go_seq_objc_from_refnum()转换refnum为obj，这个分支我们之后再讲。</p>\n<p>那么我们看看这个所谓的”静态库”是怎么生成这个int32值的。<br><em>注：以下运行的代码已经在Go中了</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*go_g_mb_testmain.go*</span><br><span class=\"line\">//export new_g_mb_test_GMBTest</span><br><span class=\"line\">func new_g_mb_test_GMBTest() C.int32_t &#123;</span><br><span class=\"line\">    return C.int32_t(_seq.ToRefNum(new(g_mb_test.GMBTest)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 new_g_mb_test_GMBTest()返回了一个 int32，而这个int32值还是由_seq.ToRefNum()方法返回的。这个方法是由golang.org&#x2F;x&#x2F;mobile&#x2F;bind&#x2F;seq&#x2F;ref.go 下的bind提供的。方法参数就是一个go struct对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*golang.org/x/mobile/bind/seq/ref.go*</span><br><span class=\"line\">// ToRefNum increments the reference count for an object and</span><br><span class=\"line\">// returns its refnum.</span><br><span class=\"line\">func ToRefNum(obj interface&#123;&#125;) int32 &#123;</span><br><span class=\"line\">    // We don’t track foreign objects, so if obj is a proxy</span><br><span class=\"line\">    // return its refnum.</span><br><span class=\"line\">    if r, ok := obj.(proxy); ok &#123;</span><br><span class=\"line\">        refnum := r.Bind_proxy_refnum__()</span><br><span class=\"line\">        if refnum &lt;= 0 &#123;</span><br><span class=\"line\">            panic(fmt.Errorf(&quot;seq: proxy contained invalid Go refnum: %d&quot;, refnum))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return refnum</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs.Lock()</span><br><span class=\"line\">    num := refs.refs[obj]</span><br><span class=\"line\">    if num != 0 &#123;</span><br><span class=\"line\">        s := refs.objs[num]</span><br><span class=\"line\">        refs.objs[num] = countedObj&#123;s.obj, s.cnt + 1&#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        num = refs.next</span><br><span class=\"line\">        refs.next--</span><br><span class=\"line\">        if refs.next &gt; 0 &#123;</span><br><span class=\"line\">            panic(“refs.next underflow”)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        refs.refs[obj] = num</span><br><span class=\"line\">        refs.objs[num] = countedObj&#123;obj, 1&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    refs.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    return int32(num)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于proxy那块的代码，我们稍等之后再看。后面的代码也不急着读，先看后面提到的refs对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// refs stores Go objects that have been passed to another language.</span><br><span class=\"line\">var refs struct &#123;</span><br><span class=\"line\">    sync.Mutex</span><br><span class=\"line\">    next int32 // next reference number to use for Go object, always negative</span><br><span class=\"line\">    refs map[interface&#123;&#125;]int32</span><br><span class=\"line\">    objs map[int32]countedObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释写的很明确了，refs存储了从Golang传递给其他语言的对象。</p>\n<p>结构体中有两个map成员变量，一个是refs，一个是objs。refs的key是对象，value就是上面提到的refnum，objs的key是refnum，value是这个Go对象的引用计数对象。还有一个变量是next，next是下一个Go对象的refnum，而且永远是负数。</p>\n<p>那么上面的后半段代码也就很容易看懂了。从ref取出obj对应的num，计数加一。如果没有的话，next-1作为下一个refnum，把对象存进map。</p>\n<p><strong>所以：</strong></p>\n<ol>\n<li>在Go中有一个全局变量，维护了所有外部正在使用的Go对象。</li>\n<li>从Go生成的对象，想要被外部使用，都是通过一个refnum的值在这个全局变量中索引的。</li>\n<li>并且还维护了一个引用计数，每次取这个对象都会+1。</li>\n<li>另外，从Go导出的refnum都是负数。</li>\n</ol>\n<p>到这里，我们其实可以小<em>总结</em>一下了：<br>从上面的代码可以知道 Go中的对象在 oc 中的体现是:</p>\n<p>OC对象持有一个GoSeqRef，GoSeqRef 持有一个 refnum，refnum在Go中的refs的objs和refs中存储了真正的Go对象和引用计数值。</p>\n<h4 id=\"再看一个OC方法的基本调用\"><a href=\"#再看一个OC方法的基本调用\" class=\"headerlink\" title=\"再看一个OC方法的基本调用\"></a>再看一个OC方法的基本调用</h4><p>既然已经生成Golang的对象了，我们看一下 gmbTestOne 这个基本调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)gmbTestOne:(int32_t)value &#123;</span><br><span class=\"line\">    int32_t refnum = go_seq_go_to_refnum(self._ref);</span><br><span class=\"line\">    int32_t _value = (int32_t)value;</span><br><span class=\"line\">    proxyg_mb_test_GMBTest_GMBTestOne(refnum, _value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>go_seq_go_to_refnum()是在Seq_darwin.m中实现的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (int32_t)incNum &#123;</span><br><span class=\"line\">  IncGoRef(_refnum);</span><br><span class=\"line\">  return _refnum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到最终是返回了_refnum。但是在此之前，还有一个IncGoRef(_refnum);<br>可以看ref.go的实现，方法实现是增加Go对象的引用计数。<br><em>思考：</em>从OC ARC的对象回收的角度来看，似乎”言之有理”。”int32_t refnum “虽然是个int，但是得要持有这个对象，不然会有可能在调用过程中被释放。那么猜想一样，它会在方法域结束的时候释放？我们接着看…</p>\n<p>然后和上面的逻辑一样，proxyg_mb_test_GMBTest_GMBTestOne() 是framework实现的方法，第一个参数是refnum，第二个参数是value的值。</p>\n<p>猜想它的实现应该是，通过 refnum找到Go中的对象，然后调用对应的方法。我们来看Go的实现：<br><em>注：以下运行的代码已经在Go中了</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//export proxyg_mb_test_GMBTest_GMBTestOne</span><br><span class=\"line\">func proxyg_mb_test_GMBTest_GMBTestOne(refnum C.int32_t, param_value C.int32_t) &#123;</span><br><span class=\"line\">    ref := _seq.FromRefNum(int32(refnum))</span><br><span class=\"line\">    v := ref.Get().(*g_mb_test.GMBTest)</span><br><span class=\"line\">    _param_value := int32(param_value)</span><br><span class=\"line\">    v.GMBTestOne(_param_value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// FromRefNum returns the Ref for a refnum. If the refnum specifies a</span><br><span class=\"line\">// foreign object, a finalizer is set to track its lifetime.</span><br><span class=\"line\">func FromRefNum(num int32) *Ref &#123;</span><br><span class=\"line\">    if num == NullRefNum &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ref := &amp;Ref&#123;num&#125;</span><br><span class=\"line\">    if num &gt; 0 &#123;</span><br><span class=\"line\">        // This is a foreign object reference.</span><br><span class=\"line\">        // Track its lifetime with a finalizer.</span><br><span class=\"line\">        runtime.SetFinalizer(ref, FinalizeRef)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return ref</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和OC中一样，在Go中也有一个Ref对象，这个对象包裹的就是一个refnum。<br>num &gt; 0是指代外部传入的对象，我们先不看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Get returns the underlying object.</span><br><span class=\"line\">func (r *Ref) Get() interface&#123;&#125; &#123;</span><br><span class=\"line\">    refnum := r.Bind_Num</span><br><span class=\"line\">    refs.Lock()</span><br><span class=\"line\">    o, ok := refs.objs[refnum]</span><br><span class=\"line\">    refs.Unlock()</span><br><span class=\"line\">    if !ok &#123;</span><br><span class=\"line\">        panic(fmt.Sprintf(“unknown ref %d”, refnum))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // This is a Go reference and its refnum was incremented</span><br><span class=\"line\">    // before crossing the language barrier.</span><br><span class=\"line\">    Delete(refnum)</span><br><span class=\"line\">    return o.obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前半段印证了我们的猜想，取出对象并且返回。Delete的实现是引用计数-1，如果到0了，那就从map中删除。</p>\n<p><em>印证我们上面思考中的猜想！</em>Golang对象并不是在结束的时候才释放，在Golang中 v :&#x3D; ref.Get().(*g_mb_test.GMBTest) 已经持有，其实不必再持有了，等Golang的方法结束的时候自然会通过Golang的垃圾回收释放。</p>\n<p>最后代码就是一个Go的方法调用了，把int参数传入。</p>\n<p><strong>总结一下：</strong><br>OC调用Golang的方法，实际是，在OC中调用方法的时候，先用self.ref 获取 refnum。这个步骤会增加Go中对象的引用计数。然后调入Go的方法，把refnum传入，取出Golang对象，减小引用计数。然后调用具体实现的方法。</p>\n<h4 id=\"Golang返回对象\"><a href=\"#Golang返回对象\" class=\"headerlink\" title=\"Golang返回对象\"></a>Golang返回对象</h4><p>Golang的方法返回对象其实和上面的初始化方法大同小异，只是结合了基本方法调用。注：Go返回的对象类型必须是Go导出的类型，非Go导出的类型Go不识别或者OC不识别（除了NSData，NSString等基本类型）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (G_mb_testGMBTest*)gmbTest6 &#123;</span><br><span class=\"line\">    int32_t refnum = go_seq_go_to_refnum(self._ref);</span><br><span class=\"line\">    int32_t r0 = proxyg_mb_test_GMBTest_GMBTest6(refnum);</span><br><span class=\"line\">    G_mb_testGMBTest* _ret0_ = nil;</span><br><span class=\"line\">    GoSeqRef* _ret0__ref = go_seq_from_refnum(r0);</span><br><span class=\"line\">    if (_ret0__ref != NULL) &#123;</span><br><span class=\"line\">        _ret0_ = _ret0__ref.obj;</span><br><span class=\"line\">        if (_ret0_ == nil) &#123;</span><br><span class=\"line\">            _ret0_ = [[G_mb_testGMBTest alloc] initWithRef:_ret0__ref];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _ret0_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>proxyg_mb_test_GMBTest_GMBTest6()方法返回了一个int值，这个值必然是对应的Golang的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//export proxyg_mb_test_GMBTest_GMBTest6</span><br><span class=\"line\">func proxyg_mb_test_GMBTest_GMBTest6(refnum C.int32_t) C.int32_t &#123;</span><br><span class=\"line\">    ref := _seq.FromRefNum(int32(refnum))</span><br><span class=\"line\">    v := ref.Get().(*g_mb_test.GMBTest)</span><br><span class=\"line\">    res_0 := v.GMBTest6()</span><br><span class=\"line\">    var _res_0 C.int32_t = _seq.NullRefNum</span><br><span class=\"line\">    if res_0 != nil &#123;</span><br><span class=\"line\">        _res_0 = C.int32_t(_seq.ToRefNum(res_0))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _res_0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法调用的地方我们不再详述，返回的res_0如果是nil，则会返回_seq.NullRefNum &#x3D; 41。即用一个特定的值来表示null。<br>返回后OC同样的会在go_seq_from_refnum()中判断41这个值。</p>\n<p><strong>总结一下：</strong><br>Go返回对象实际是返回一个refnum值，OC使用GoSeqRef来存储这个值。（返回的对象始终是Go已导出的对象类型）</p>\n<h4 id=\"Golang返回接口类型\"><a href=\"#Golang返回接口类型\" class=\"headerlink\" title=\"Golang返回接口类型\"></a>Golang返回接口类型</h4><p>实际上Go和其他语言通讯大部分都会使用接口类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (id&lt;G_mb_testGMBInterface&gt;)gmbTest5 &#123;</span><br><span class=\"line\">    int32_t refnum = go_seq_go_to_refnum(self._ref);</span><br><span class=\"line\">    int32_t r0 = proxyg_mb_test_GMBTest_GMBTest5(refnum);</span><br><span class=\"line\">    G_mb_testGMBInterface* _ret0_ = nil;</span><br><span class=\"line\">    GoSeqRef* _ret0__ref = go_seq_from_refnum(r0);</span><br><span class=\"line\">    if (_ret0__ref != NULL) &#123;</span><br><span class=\"line\">        _ret0_ = _ret0__ref.obj;</span><br><span class=\"line\">        if (_ret0_ == nil) &#123;</span><br><span class=\"line\">            _ret0_ = [[G_mb_testGMBInterface alloc] initWithRef:_ret0__ref];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _ret0_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>proxyg_mb_test_GMBTest_GMBTest5()和上面的proxyg_mb_test_GMBTest_GMBTest6()返回对象没有什么差别，主要差别在于处理返回的值变成go中的refnum。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation G_mb_testGMBInterface &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithRef:(id)ref &#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    if (self) &#123; __ref = ref; &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)interfaceTest &#123;</span><br><span class=\"line\">    int32_t refnum = go_seq_go_to_refnum(self._ref);</span><br><span class=\"line\">    proxyg_mb_test_GMBInterface_InterfaceTest(refnum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>在g_mb_test_darwin.m中自动生成了一个G_mb_testGMBInterface类，而这个类实现了G_mb_testGMBInterface，也就是我们定义的接口，并且存储了GO返回的refnum。而接口的实现内调用了proxyg_mb_test_GMBInterface_InterfaceTest()函数。这个函数实际就是通过返回的refnum来获取Go中的对象，调用Go中实现的接口。</p>\n<p><strong>总结：</strong><br>Go返回的接口类型，在OC上还是一个refnum。胶水代码自动生成了一个实现这个接口的类，并且保存了这个GoSeqRef。在调用接口的时候，实际上是调用的这个自动生成的类的方法。最终还是通过存储的GoSeqRef找到Go中的对象，来调用具体方法。</p>\n<p>至此，Go方法返回数据都已经讲完了（NSData和NSString我们放在单独的环节）。接下来我们看一下从OC传对象至Go</p>\n<h4 id=\"OC传递对象至Go\"><a href=\"#OC传递对象至Go\" class=\"headerlink\" title=\"OC传递对象至Go\"></a>OC传递对象至Go</h4><p>这一节我们将补充讲完之前跳过的环节。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)gmbTest7:(id&lt;G_mb_testGMBInterface&gt;)i &#123;</span><br><span class=\"line\">    int32_t refnum = go_seq_go_to_refnum(self._ref);</span><br><span class=\"line\">    int32_t _i;</span><br><span class=\"line\">    if ([i conformsToProtocol:@protocol(goSeqRefInterface)]) &#123;</span><br><span class=\"line\">        id&lt;goSeqRefInterface&gt; i_proxy = (id&lt;goSeqRefInterface&gt;)(i);</span><br><span class=\"line\">        _i = go_seq_go_to_refnum(i_proxy._ref);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        _i = go_seq_to_refnum(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    proxyg_mb_test_GMBTest_GMBTest7(refnum, _i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>goSeqRefInterface接口表示的是Go传出的对象（因为有GoSeqRef)。<br>如果是Go的对象，则增加引用计数。<br>如果不是Go的对象，即OC new出来的对象，调用go_seq_to_refnum()</p>\n<p>方法内部实际是调用的全局变量tracker。<br>看到这里其实已经明白了，在OC里实现了一个和Go中refs一样的结构。用来标识从OC传入Go的对象的引用计数。<br>Go在OC里的引用计数是，每次在调用Go对象之前持有一次，在Go由refnum找到对应对象之后，再释放一次。那么OC的对象呢？</p>\n<p>继续看到下一个方法proxyg_mb_test_GMBTest_GMBTest7()的参数传递。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//export proxyg_mb_test_GMBTest_GMBTest7</span><br><span class=\"line\">func proxyg_mb_test_GMBTest_GMBTest7(refnum C.int32_t, param_i C.int32_t) &#123;</span><br><span class=\"line\">    ref := _seq.FromRefNum(int32(refnum))</span><br><span class=\"line\">    v := ref.Get().(*g_mb_test.GMBTest)</span><br><span class=\"line\">    var _param_i g_mb_test.GMBInterface</span><br><span class=\"line\">    _param_i_ref := _seq.FromRefNum(int32(param_i))</span><br><span class=\"line\">    if _param_i_ref != nil &#123;</span><br><span class=\"line\">        if param_i &lt; 0 &#123; // go object</span><br><span class=\"line\">            _param_i = _param_i_ref.Get().(g_mb_test.GMBInterface)</span><br><span class=\"line\">        &#125; else &#123; // foreign object</span><br><span class=\"line\">            _param_i = (*proxyg_mb_test_GMBInterface)(_param_i_ref)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    v.GMBTest7(_param_i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前提到过，_seq.FromRefNum只判断null（41），否则返回一个Ref指针。如果传入的参数是Go生成的，那么就直接使用。否则，如果是外部传入的，直接把_param_i_ref强转为了proxyg_mb_test_GMBInterface类型。</p>\n<p>看到后面还有一个对proxyg_mb_test_GMBInterface 的定义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type proxyg_mb_test_GMBInterface _seq.Ref</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *proxyg_mb_test_GMBInterface) Bind_proxy_refnum__() int32 &#123; return (*_seq.Ref)(p).Bind_IncNum() &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *proxyg_mb_test_GMBInterface) InterfaceTest() &#123;</span><br><span class=\"line\">    C.cproxyg_mb_test_GMBInterface_InterfaceTest(C.int32_t(p.Bind_proxy_refnum__()))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两个方法：<br>Bind_proxy_refnum__()调用了Ref的Bind_IncNum(),看名字和注释的意思是增加外部变量的引用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func init() &#123;</span><br><span class=\"line\">    _seq.FinalizeRef = func(ref *_seq.Ref) &#123;</span><br><span class=\"line\">        refnum := ref.Bind_Num</span><br><span class=\"line\">        if refnum &lt; 0 &#123;</span><br><span class=\"line\">            panic(fmt.Sprintf(“not a foreign ref: %d”, refnum))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        C.go_seq_dec_ref(C.int32_t(refnum))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _seq.IncForeignRef = func(refnum int32) &#123;</span><br><span class=\"line\">        if refnum &lt; 0 &#123;</span><br><span class=\"line\">            panic(fmt.Sprintf(&quot;not a foreign ref: %d&quot;, refnum))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        C.go_seq_inc_ref(C.int32_t(refnum))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在初始化的时候，会给seq设置两个全局函数，一个是释放，另一个就是刚刚Bind_IncNum()函数内调用的_seq.IncForeignRef()，<br>C.cproxyg_mb_test_GMBInterface_InterfaceTest()，这个两个方法内实际调用了Cgo_seq_inc_ref()和C.go_seq_dec_ref(),这个是链接静态库的实现的符号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void go_seq_dec_ref(int32_t refnum) &#123;</span><br><span class=\"line\">  @autoreleasepool &#123;</span><br><span class=\"line\">    [tracker dec:refnum];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void go_seq_inc_ref(int32_t refnum) &#123;</span><br><span class=\"line\">  @autoreleasepool &#123;</span><br><span class=\"line\">    [tracker inc:refnum];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>seq_darwin.m中可以看到，确实是增加和减少引用计数。</p>\n<p>在上面讲到FromRefNum的时候，如果是外部传入的对象，则会给GoRef设置一个析构函数。<br>也就是说，在GoRef这个结构体的生命周期内，持有外部的对象。GoRef 映射的就是外部对象。</p>\n<p>继续回到上面，InterfaceTest()是接口的另一个方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cproxyg_mb_test_GMBInterface_InterfaceTest(int32_t refnum) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        G_mb_testGMBInterface* o = go_seq_objc_from_refnum(refnum);</span><br><span class=\"line\">        [o interfaceTest];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和_seq.FinalizeRef一样，调用到了oc。而OC的go_seq_objc_from_refnum（）方法在拿到oc对象之后，调用了[tracker dec:refnum];<br>这样，在OC层完成了这个对象的释放</p>\n<p><strong>总结：</strong><br>OC的接口对象传递至Go的时候（非Go导出对象），Go肯定也是以一个接口对象存在。OC在传入之前计数+1（计数为1），传入之后，Go对生成的GoRef增加析构函数，析构函数内对计数 -1。<br>在Go内调用GoRef重定义的接口函数时候，会先增加引用计数，调回OC之后，在OC取到对应的OC对象后，OC会主动对计数-1。这一点和Go传出对象很类似。</p>\n<p>另外，刚刚我们跳过了go_seq_from_refnum()以及ToRefNum()的代码，都是考虑的特殊情况。我们刚刚讨论的都是OC创建的对象传递至Go，Go创建的对象传递至OC。但是还有OC传递至Go后，Go在把同一个对象返回给OC。相反也有Go给OC后，OC把同一个对象给了Go。（这个同一个对象，在OC内是指GoSeqRef，在Go内是指GoRef，两侧都是镜像的。）对于这种情况，两侧都是不需要转换的，OC内直接从GoSeqRef取出obj调用，Go内直接找到refnum对应的对象调用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>Go导出的静态库实际是一个C实现的静态库，还会生成OC的代码（胶水代码）来包裹这个库，以达到导出OC类、方法和接口</li>\n<li>Go的对象和OC对象在对方侧，都一个int32(refnum)作为对象参数，来对应每一个传递过去的对象。如果refnum&gt;0表示OC对象，&lt;0表示Go对象。</li>\n<li>Go的对象和OC对象在对方侧，分别有一个存储了refnum的GoRef struct和GoSeqRef class来表示对方侧的对象。</li>\n<li>Go和OC侧都有全局变量来维护已经传入至对方侧的对象，以及引用计数。</li>\n<li>不论是OC还是Go，如果refnum表示的是本侧的对象，那么就直接从全局变量中取出对象使用。</li>\n<li>OC调用Go对象方法，实际是调用Go的C函数，通过传递refnum告知Go具体的Go对象。</li>\n<li>Go调用OC对象方法，实际是通过声明式，调用C函数，由.m实现。同理通过传递refnum来告知OC具体的OC对象。</li>\n<li>OC调用Go的接口对象，实际是生成了实现接口的类的胶水代码，接口对象持有了GoSeqRef，接口方法实际也是通过传递refnum调用Go</li>\n<li>Go调用OC的接口对象，实际是通过声明式，调用C函数，由.m实现。通过重定义GoRef，实现OC的接口方法。接口方法内通过传递refnum调用.m即OC</li>\n<li>Go传递至OC的对象，Go在new或者函数返回之前会调用_seq.ToRefNum()，存储在全局变量中，并计数为1。OC存储的GoSeqRef在dealloc的时候通过DestroyRef()将计数-1。</li>\n<li>OC传递至Go的对象，OC在传递给Go之前会调用assignRefnumAndIncRefcount:存储在全局变量中，并计数为1。Go在生成GoRef的时候会设置该对象的析构回调，在回调内，通过调用go_seq_dec_ref()将计数-1</li>\n<li>Go对象方法被OC调用之前，OC会使用go_seq_go_to_refnum()将计数+1，Go在将refnum转换为go obj之后，又会将计数-1</li>\n<li>OC对象方法被Go调用之前，Go会使用Bind_IncNum()将计数+1，OC在将refnum转换为oc obj 之后，又会将计数-1。</li>\n</ol>\n<p>以上的总结已经完全可以解答文章开始时候的提问了。</p>\n<p>&#x2F;&#x2F;最后这里回头补充一个图解</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>还有两个特殊的地方 NSString 和 NSData。这两个对象在Go &lt;—&gt; OC gomobile 是默认支持这两种数据类型的互转的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct nstring &#123;</span><br><span class=\"line\">  void *ptr;</span><br><span class=\"line\">  int len;</span><br><span class=\"line\">&#125; nstring;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct nbyteslice &#123;</span><br><span class=\"line\">  void *ptr;</span><br><span class=\"line\">  int len;</span><br><span class=\"line\">&#125; nbyteslice;</span><br><span class=\"line\">typedef int nint;</span><br></pre></td></tr></table></figure>\n<p>这两个数据类型在传递的时候，都会被转换为定义好的C语言的struct类型。</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// encodeString copies a Go string and returns it as a nstring.</span><br><span class=\"line\">func encodeString(s string) C.nstring &#123;</span><br><span class=\"line\">    n := C.int(len(s))</span><br><span class=\"line\">    if n == 0 &#123;</span><br><span class=\"line\">        return C.nstring&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ptr := C.malloc(C.size_t(n))</span><br><span class=\"line\">    if ptr == nil &#123;</span><br><span class=\"line\">        panic(&quot;encodeString: malloc failed&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    copy((*[1&lt;&lt;31 - 1]byte)(ptr)[:n], s)</span><br><span class=\"line\">    return C.nstring&#123;ptr: ptr, len: n&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// decodeString converts a nstring to a Go string. The</span><br><span class=\"line\">// data in str is freed after use.</span><br><span class=\"line\">func decodeString(str C.nstring) string &#123;</span><br><span class=\"line\">    if str.ptr == nil &#123;</span><br><span class=\"line\">        return &quot;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s := C.GoStringN((*C.char)(str.ptr), str.len)</span><br><span class=\"line\">    C.free(str.ptr)</span><br><span class=\"line\">    return s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go 侧 string 通过encode和decode方法，在cstring和go string之间互转，<em>每次转换都会copy</em>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString *go_seq_to_objc_string(nstring str) &#123;</span><br><span class=\"line\">  if (str.len == 0) &#123;  // empty string.</span><br><span class=\"line\">    return @“”;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  NSString * res = [[NSString alloc] initWithBytesNoCopy:str.ptr</span><br><span class=\"line\">                                                  length:str.len</span><br><span class=\"line\">                                                encoding:NSUTF8StringEncoding</span><br><span class=\"line\">                                            freeWhenDone:YES];</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">nstring go_seq_from_objc_string(NSString *s) &#123;</span><br><span class=\"line\">  nstring res = &#123;NULL, 0&#125;;</span><br><span class=\"line\">  int len = [s lengthOfBytesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\"></span><br><span class=\"line\">  if (len == 0) &#123;</span><br><span class=\"line\">    if (s.length &gt; 0) &#123;</span><br><span class=\"line\">      LOG_INFO(@“unable to encode an NSString into UTF-8”);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  char *buf = (char *)malloc(len);</span><br><span class=\"line\">  if (buf == NULL) &#123;</span><br><span class=\"line\">    LOG_FATAL(@&quot;malloc failed&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  NSUInteger used;</span><br><span class=\"line\">  [s getBytes:buf</span><br><span class=\"line\">           maxLength:len</span><br><span class=\"line\">          usedLength:&amp;used</span><br><span class=\"line\">            encoding:NSUTF8StringEncoding</span><br><span class=\"line\">             options:0</span><br><span class=\"line\">               range:NSMakeRange(0, [s length])</span><br><span class=\"line\">      remainingRange:NULL];</span><br><span class=\"line\">  res.ptr = buf;</span><br><span class=\"line\">  res.len = used;</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OC 侧 NSString 通过go_seq_to_objc_string和go_seq_from_objc_string方法，在cstring和nsstring之间互转，<em>每次转换都会copy</em>。</p>\n<p>且对方侧生成的cstring由己方释放。</p>\n<h3 id=\"Bytes\"><a href=\"#Bytes\" class=\"headerlink\" title=\"Bytes\"></a>Bytes</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// fromSlice converts a slice to a nbyteslice.</span><br><span class=\"line\">// If cpy is set, a malloc’ed copy of the data is returned.</span><br><span class=\"line\">func fromSlice(s []byte, cpy bool) C.nbyteslice &#123;</span><br><span class=\"line\">    if s == nil || len(s) == 0 &#123;</span><br><span class=\"line\">        return C.nbyteslice&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ptr, n := unsafe.Pointer(&amp;s[0]), C.int(len(s))</span><br><span class=\"line\">    if cpy &#123;</span><br><span class=\"line\">        nptr := C.malloc(C.size_t(n))</span><br><span class=\"line\">        if nptr == nil &#123;</span><br><span class=\"line\">            panic(&quot;fromSlice: malloc failed&quot;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        copy((*[1&lt;&lt;31 - 1]byte)(nptr)[:n], (*[1&lt;&lt;31 - 1]byte)(ptr)[:n])</span><br><span class=\"line\">        ptr = nptr</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return C.nbyteslice&#123;ptr: ptr, len: n&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// toSlice takes a nbyteslice and returns a byte slice with the data. If cpy is</span><br><span class=\"line\">// set, the slice contains a copy of the data. If not, the generated Go code</span><br><span class=\"line\">// calls releaseByteSlice after use.</span><br><span class=\"line\">func toSlice(s C.nbyteslice, cpy bool) []byte &#123;</span><br><span class=\"line\">    if s.ptr == nil || s.len == 0 &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var b []byte</span><br><span class=\"line\">    if cpy &#123;</span><br><span class=\"line\">        b = C.GoBytes(s.ptr, C.int(s.len))</span><br><span class=\"line\">        C.free(s.ptr)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        b = (*[1&lt;&lt;31 - 1]byte)(unsafe.Pointer(s.ptr))[:s.len:s.len]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go 侧 nbyteslice 通过fromSlice和toSlice方法，在nbyteslice和go slice之间互转。</p>\n<p>OC -&gt; Go 如果对方（OC）copy &#x3D;&#x3D; true，Go也会拷贝，拷贝完就会释放nbyteslice，否则只是使用。<br>Go -&gt; OC  (copy 才会拷贝，go-&gt;OC copy&#x3D;true)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSData *go_seq_to_objc_bytearray(nbyteslice s, int copy) &#123;</span><br><span class=\"line\">  if (s.ptr == NULL) &#123;</span><br><span class=\"line\">    return NULL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  BOOL freeWhenDone = copy ? YES : NO;</span><br><span class=\"line\">  return [NSData dataWithBytesNoCopy:s.ptr length:s.len freeWhenDone:freeWhenDone];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">nbyteslice go_seq_from_objc_bytearray(NSData *data, int copy) &#123;</span><br><span class=\"line\">  struct nbyteslice res = &#123;NULL, 0&#125;;</span><br><span class=\"line\">  int sz = data.length;</span><br><span class=\"line\">  if (sz == 0) &#123;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void *ptr;</span><br><span class=\"line\">  // If the argument was not a NSMutableData, copy the data so that</span><br><span class=\"line\">  // the NSData is not changed from Go. The corresponding free is called</span><br><span class=\"line\">  // by releaseByteSlice.</span><br><span class=\"line\">  if (copy || ![data isKindOfClass:[NSMutableData class]]) &#123;</span><br><span class=\"line\">    void *arr_copy = malloc(sz);</span><br><span class=\"line\">    if (arr_copy == NULL) &#123;</span><br><span class=\"line\">      LOG_FATAL(@&quot;malloc failed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    memcpy(arr_copy, [data bytes], sz);</span><br><span class=\"line\">    ptr = arr_copy;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    ptr = (void *)[data bytes];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  res.ptr = ptr;</span><br><span class=\"line\">  res.len = sz;</span><br><span class=\"line\">  return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>OC 侧 NSData 通过go_seq_to_objc_bytearray和go_seq_from_objc_bytearray方法，在nbyteslice和NSData之间互转。</p>\n<p>OC -&gt; Go (NSMutableData &amp;&amp; !copy 才不会拷贝，OC-&gt;Go copy &#x3D; false，即NSData拷贝，NSMutableData不拷贝)，<em>并且方法调用结束就会释放bytes</em>。（如果在Go内使用slice的时候切协程了，有大概率读取到的bytes是被释放了）<br>Go -&gt; OC  OC不拷贝从Go返回的bytes，OC在释放NSData的时候会释放nbyteslice.</p>\n<p><em>总之一个宗旨，一侧指定了copy，就由另一侧释放。没有指定copy，就由本侧释放，即谁创建谁释放的原则。（NSData是指定了false，但是执行拷贝了，还是由本侧释放）</em></p>\n<hr>\n<p>2020-3-18 记<br><a href=\"http://yulingtianxia.com/blog/2019/10/27/Write-Objective-C-Code-using-Dart/\">用 Dart 来写 Objective-C 代码</a></p>\n<p>这篇文章讲述的是在Dart中写OC，与GoMobile的原理相比有些许相似…</p>"},{"title":"SQLite--OS","date":"2020-04-18T16:00:00.000Z","top":300,"_content":"\n>自底向上看sqlite的时候发现自己欠缺和遗忘了好多知识（尤其是操作系统）。如果能把这个sqlite的系列都写完的话，在操作系统上，尤其是文件和内存管理上能有不少的知识复习和提升 :)。\n\n<!-- more -->\n\n## 简述\n\n本文主要讲述Sqlite的最底下那层，也就是OS-Interface(后面我们统一叫os层)的原理和实现。\n\n从接口上来看，OS层主要是对上层屏蔽了不同操作系统下的文件操作实现。OS层提供了统一的以`sqlite3Os`为前缀的接口方法给上层，实现了包括文件读写，文件创建/删除，sqlite文件锁，以及一些与系统实现相关的`Util`类操作，例如`sqlite3OsSleep`、`sqlite3OsCurrentTimeInt64`等等。这些接口方法都在`os.h`的头文件中声明了。\n\nOS层主要实现了文件操作，锁，以及共享内存，三大块的内容。[共享内存](https://caio.ink/sqlite-os-shm/)可以看这篇文章。本文就从另外两个角度去看OS是如何提供平台无关的接口。而其中 锁 是本层的一个核心功能，SQLite的多线程乃至跨进程的并发读写很大程度上就是依赖了这个锁的实现。\n\n> 一般在移动设备上（尤其是iOS）多进程读写文件在操作系统层面上就被禁止了，所以有些框架（WCDB）为了减少一些文件锁带来的读写性能开销，直接把文件锁禁用了，打开即独占。\n\n## 初始化\n\nos层还有一个别的名字，叫vfs（virtual file system）。sqlite在很多地方都使用了插件化和模块化的设计，例如cache，extension...还有就是这里的vfs。\n\n在sqlite最早初始化的时候会调用`sqlite3_os_init()`方法，这个方法除了测试一下malloc方法之外，剩下的就是初始化vfs了。\n\n函数原型\n```c\nint sqlite3_os_init(void);\n```\n\n> sqlite是跨平台组件，实现大体上都差不太多，这里我们只看unix的实现，如果不同平台实现差别较大的地方，我们再另外提及。\n\n## 文件\n\n### 文件结构\n\nSqlite从OS层向外暴露的是*sqlite3_file*这个数据结构，标识了一个数据库文件。而这个*sqlite3_file*更多的可以理解为一个接口，它抽象出了很多vfs的方法。而不同平台下的vfs会有不同的文件数据结构，例如*unixFile*就是在Unix系统下的一个vfs实现。\n\n在*unixFile*这个数据结构内存储了很多这个文件当前的属性。*UnixFile*，*sqlite3_file* 这些数据结构是相对于连接而言的，也就是说，不同的连接持有的是不同的file对象，可以对应到操作系统中的文件描述符。\n\n### 文件inode\n\n在Unix中，对于同一个数据库文件或者是同一个数据库文件的不同连接（软连接或硬连接），在sqlite3中可以多次打开，他们也是不同的file对象。对于这个情况，Unix的vfs针对file node也做了管理。\n\n每个打开的文件都会有一个文件描述符与之对应，但是在操作系统中，文件的实际索引是由inode来决定的。同一个文件或者文件链接打开多次，会有不同的文件描述符，但是文件的实际索引不变。\n\n*unixInodeInfo*这个数据结构描述了unix中一个文件的实际索引信息。*unixFile*和*unixInodeInfo*是多对一的关系。*unixInodeInfo*中会有一个nRef变量来记录当前还有多少个文件描述符(*unixFile*)，在持有这个文件索引。每打开一次文件nRef++，关闭一次nRef--。另外在关闭一个已打开的文件描述符的时候，Sqlite不会立即关闭。在*unixInodeInfo*中用一个链表`UnixUnusedFd`描述了当前文件索引下，不再使用的文件描述符。以便再次打开该数据库。当nRef降至0时，Sqlite才会真正关闭数据库文件。\n\n数据结构\n```c\n/*\n * 标识UNIX的文件索引,对所有持有这个InodeInfo的UnixFile做了引用计数\n */\nstruct unixInodeInfo {\n  struct unixFileId fileId;       /* The lookup key */\n  sqlite3_mutex *pLockMutex;      /* Hold this mutex for... */\n  int nShared;                      /* Number of SHARED locks held */\n  int nLock;                        /* Number of outstanding file locks */\n  unsigned char eFileLock;          /* One of SHARED_LOCK, RESERVED_LOCK etc. */\n  unsigned char bProcessLock;       /* An exclusive process lock is held */\n  UnixUnusedFd *pUnused;            /* Unused file descriptors to close */\n  int nRef;                       /* Number of pointers to this structure */\n  unixShmNode *pShmNode;          /* Shared memory associated with this inode */\n  unixInodeInfo *pNext;           /* List of all unixInodeInfo objects */\n  unixInodeInfo *pPrev;           /*    .... doubly linked */\n};\n```\n\n在Sqlite中有一个全局变量 `static unixInodeInfo *inodeList = 0;` 用一个双向链表记录了，当前进程内打开的所有文件索引。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/52e0629643e32cd4700b2ccf86cf96fb.png)\n\n## 锁\n\nPOSIX设计的锁做不到在同一个进程内不同线程之间互斥。因为按照POSIX的设计，文件锁的最小粒度是进程，所以只要\n在同一个进程内，不同线程的锁，是可以相互覆盖的。\n\n> 举个例子，如果线程AB在同一个进程内，线程A先请求了某个文件某个区域的写锁，这个时候，线程B如果再去请求同一个区域的写锁的时候，是可以成功的。因为锁分配的最小单位是进程。\n\n另外，对于不同的文件描述符，但是是同一个文件索引，操作系统在对文件加锁的时候，是会对实际的文件（文件索引）加锁，而不是硬链接或者软链接。\n\n> 举个例子，如果一个文件有两个软链接，在同一个进程内分别对这两个软链接指向的文件进行锁操作的时候，操作的实际是同一个文件。\n\n1. 根据上面的问题描述，那么Sqlite 如果想要实现多线程操作一个文件，必然需要实现多线程下的文件锁互斥。也就是说Sqlite需要在进程内，把锁的粒度控制在线程上。\n2. 当关闭文件的时候，操作系统会释放掉当前进程在改文件上的所有锁。所以还需要管理进程内对每个文件的锁，所有线程都释放锁的时候，才会真正释放进程对文件的锁。\n\n### Sqlite 锁的设计\n\n与简单的读写锁不同，Sqlite内部有5种锁状态：`UNLOCKED`,`SHARED`,`RESERVED`,`PENDING`,`EXCLUSIVE`。这5个锁的状态是存储在*inode*的eFileLock上。\n\n- UNLOCKED:这个没有什么疑问，就是没有加锁的状态，任何文件初始状态都是这个。\n- SHARED:共享锁，也叫读锁，如果想要读一个文件，那么这个文件的锁级别必须至少是SHARED。同一个文件上的共享锁可以存在多个。共享锁是所有锁的第一步，想要获取任何高级别的锁，必须要先获取共享锁。\n- RESERVED:保留锁，保留锁是用来过渡想要从共享锁提升到高级锁的一个暂度期。在这个锁的状态下，可以继续有新的共享锁出现。\n- PENDING:未决锁，这个锁表示，当前连接马上要写数据库了。但是也不能把所有读锁都剥夺，这样会有问题。所以在这个级别的锁下，可以保持现有的锁。但是不能有新的共享锁了。\n- EXCLUSIVE:排它锁，在排它锁下，只有当前这个连接可以读写数据库。这个锁的级别最高。\n\n在os层有5个类型的锁，但是os暴露出来的只有4个类型。其中的PENDING，是os的内部锁。\n\n接下来我们详细看下锁升降级的两个函数，理解Sqlite是如何设计锁的。\n\n### 锁的结构\n\n简单画了一张图，描述了单个文件下的不同文件锁状态。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/f847a348f6011bf85c71903fc41e03de.png)\n\n解释一下图，绿色表示读锁，红色表示写锁。\n\n从上到下，依次是:Shared锁，Shared->Reserved锁，Shared->Reserved->Pending锁 ，Shared->Pending锁，Shared->Reserved->Pending->Exclusive锁，Shared->Pending->Exclusive锁。这些锁的转换下文会细说。\n\n- 1GB:\n\t因为在Windows上锁是强制性的，加锁区间不能存储数据。所以这个区间必然不能被分配为一个page。page的大小是[512,32768]，为了让这个锁的区间可以在一个page内，所以整个锁的区间大小为512 bytes。\n\t\n- SharedBytes:\n\t在Win95/98/ME上，操作系统没有提供读写锁，因此，在shared byte上写并行会存在问题。sqlite把这块区域放大到510字节，每次加读锁的时候，从510个字节中随机取一个。有概率会失败，但毕竟这也算是一个曲线救国的方案吧。\n\t\n- 图中描述的是文件锁，文件锁的状态实际是存储在file的inode中（unixInodeInfo）。\n\n### 锁的升级\n\n```c\n//os.h 中声明了这个方法，用来给外部调用，第一个参数是抽象文件对象，第二个参数是锁的级别，即上面提到4种锁的枚举值。\nint sqlite3OsLock(sqlite3_file*, int);\n```\n\n锁的状态转换：\n- UNLOCKED -> SHARED\n\t从未加锁状态转换到 共享锁 读锁：\n\t\n\t如果当前文件描述符对应的文件索引已经持有了共享锁或者保留锁，那么就只需要在InodeInfo上增加nShared、nLock的计数，并修改文件描述符内文件的锁状态即可。否则就会走下面的加锁流程：\n\t1. 在pending byte位上加读锁\n\t2. 在所有的SHARED_BYTES上加读锁\n\t3. 移除掉pending byte位上的读锁\n\t\n- SHARED -> RESERVED\n\t从共享读锁升级到保留锁：\n\t1. 当前已经持有共享锁，直接在保留锁位上加写锁\n\t\n- SHARED -> (PENDING) -> EXCLUSIVE\n\t从共享读锁直接升级到排他锁：\n\t1. 如果当前InodeInfo持有的锁不是Pending，那么先在pending上加写锁\n\t2. 如果InodeInfo上还有其他共享读锁（nShared>1），那么直接返回SQLITE_BUSY。此时InodeInfo和unixFile持有的都是Pending锁，不会回滚Pending锁。\n\t3. 把所有的SHARED_BYTES上加写锁。\n\t\n- RESERVED -> (PENDING) -> EXCLUSIVE\n\t从保留锁升级到排他锁：\n\t1. 与上一个步骤一样。\n\t\n- PENDING -> EXCLUSIVE\n\t从未决锁升级到排他锁：\n\t1. 直接尝试 *SHARED -> (PENDING) -> EXCLUSIVE*的步骤 3\n\n其他说明：\n1. unlocked状态只能升级到shared状态，也就是说，锁状态必须从共享读锁开始向上升级。\n2. Sqlite不接受直接请求pending锁，也就是Pending锁只是内部使用。\n3. SQLITE_BUSY:\n\t当前文件描述符持有的锁与文件索引实际持有的状态不一致时（即文件实际锁状态级别高于文件描述符的锁的状态，即文件实际锁状态至少为共享锁）\n\ta. Inode 实际锁 >= pending时，即表示有其他线程等待写入文件，当前文件描述符请求任何锁失败（因为pending的时候不允许有shared）。\n\tb. Inode 实际锁 < pending时，请求的锁 > shared时（即保留锁和排它锁），请求锁返回失败。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/b04697cfc5624e7286657b74d3096fa7.png)\n\n>对于面向OS接口而言，没有PENDING->EXCLUSIVE这个升级过程，因为PENDING锁是不会以一个独立的锁的状态存在。而是在一个文件因为还有正在读的进程，而尝试加写锁失败的时候，此时*unixFile*才会停滞于Pending锁状态，等待下一次的加锁重试。\n\n### 锁的降级\n\n```c\n// 降低锁的级别\nint sqlite3OsUnlock(sqlite3_file*, int);\n```\n\n其中第二个参数只能是 SHARE_LOCK 或者 NO_LOCK...换句话说，文件描述符持有的锁只能降低为读锁或者无锁。\n\n分两种情况讨论：\n\n- 降级为无锁：\n\t1. 将pending + reserved + shared_size 全部降为 UNLOCK\n\t2. 文件索引Inode上的 nShared-- 以及 nLock--\n\t\n- 降级为共享读锁：\n\n\t降级到读锁的时候稍微麻烦一点。理论上来说和无锁应该一样，把pending+reserved全部降为UNLOCK，shared_size降为读锁即可。但是，在某些BSD 的NFS上会出现某个区间写锁降到读锁的时候会出现失败的bug。\n\t\n\tSqlite针对上面的情况，做了兼容：在此类操作系统上，先把(shared_size - 1)个bytes降为无锁，然后再把这些bytes升级为读锁，最后把剩下的最后一个byte降为无锁。这样避免了在从写锁降到读锁的时候，出现竞争条件的问题。\n","source":"_posts/15.Sqlite-OS.md","raw":"---\ntitle: SQLite--OS\ndate: 2020-04-19\ntags: [sqlite3,os]\ntop: 300\ncategories: sqlite3\n---\n\n>自底向上看sqlite的时候发现自己欠缺和遗忘了好多知识（尤其是操作系统）。如果能把这个sqlite的系列都写完的话，在操作系统上，尤其是文件和内存管理上能有不少的知识复习和提升 :)。\n\n<!-- more -->\n\n## 简述\n\n本文主要讲述Sqlite的最底下那层，也就是OS-Interface(后面我们统一叫os层)的原理和实现。\n\n从接口上来看，OS层主要是对上层屏蔽了不同操作系统下的文件操作实现。OS层提供了统一的以`sqlite3Os`为前缀的接口方法给上层，实现了包括文件读写，文件创建/删除，sqlite文件锁，以及一些与系统实现相关的`Util`类操作，例如`sqlite3OsSleep`、`sqlite3OsCurrentTimeInt64`等等。这些接口方法都在`os.h`的头文件中声明了。\n\nOS层主要实现了文件操作，锁，以及共享内存，三大块的内容。[共享内存](https://caio.ink/sqlite-os-shm/)可以看这篇文章。本文就从另外两个角度去看OS是如何提供平台无关的接口。而其中 锁 是本层的一个核心功能，SQLite的多线程乃至跨进程的并发读写很大程度上就是依赖了这个锁的实现。\n\n> 一般在移动设备上（尤其是iOS）多进程读写文件在操作系统层面上就被禁止了，所以有些框架（WCDB）为了减少一些文件锁带来的读写性能开销，直接把文件锁禁用了，打开即独占。\n\n## 初始化\n\nos层还有一个别的名字，叫vfs（virtual file system）。sqlite在很多地方都使用了插件化和模块化的设计，例如cache，extension...还有就是这里的vfs。\n\n在sqlite最早初始化的时候会调用`sqlite3_os_init()`方法，这个方法除了测试一下malloc方法之外，剩下的就是初始化vfs了。\n\n函数原型\n```c\nint sqlite3_os_init(void);\n```\n\n> sqlite是跨平台组件，实现大体上都差不太多，这里我们只看unix的实现，如果不同平台实现差别较大的地方，我们再另外提及。\n\n## 文件\n\n### 文件结构\n\nSqlite从OS层向外暴露的是*sqlite3_file*这个数据结构，标识了一个数据库文件。而这个*sqlite3_file*更多的可以理解为一个接口，它抽象出了很多vfs的方法。而不同平台下的vfs会有不同的文件数据结构，例如*unixFile*就是在Unix系统下的一个vfs实现。\n\n在*unixFile*这个数据结构内存储了很多这个文件当前的属性。*UnixFile*，*sqlite3_file* 这些数据结构是相对于连接而言的，也就是说，不同的连接持有的是不同的file对象，可以对应到操作系统中的文件描述符。\n\n### 文件inode\n\n在Unix中，对于同一个数据库文件或者是同一个数据库文件的不同连接（软连接或硬连接），在sqlite3中可以多次打开，他们也是不同的file对象。对于这个情况，Unix的vfs针对file node也做了管理。\n\n每个打开的文件都会有一个文件描述符与之对应，但是在操作系统中，文件的实际索引是由inode来决定的。同一个文件或者文件链接打开多次，会有不同的文件描述符，但是文件的实际索引不变。\n\n*unixInodeInfo*这个数据结构描述了unix中一个文件的实际索引信息。*unixFile*和*unixInodeInfo*是多对一的关系。*unixInodeInfo*中会有一个nRef变量来记录当前还有多少个文件描述符(*unixFile*)，在持有这个文件索引。每打开一次文件nRef++，关闭一次nRef--。另外在关闭一个已打开的文件描述符的时候，Sqlite不会立即关闭。在*unixInodeInfo*中用一个链表`UnixUnusedFd`描述了当前文件索引下，不再使用的文件描述符。以便再次打开该数据库。当nRef降至0时，Sqlite才会真正关闭数据库文件。\n\n数据结构\n```c\n/*\n * 标识UNIX的文件索引,对所有持有这个InodeInfo的UnixFile做了引用计数\n */\nstruct unixInodeInfo {\n  struct unixFileId fileId;       /* The lookup key */\n  sqlite3_mutex *pLockMutex;      /* Hold this mutex for... */\n  int nShared;                      /* Number of SHARED locks held */\n  int nLock;                        /* Number of outstanding file locks */\n  unsigned char eFileLock;          /* One of SHARED_LOCK, RESERVED_LOCK etc. */\n  unsigned char bProcessLock;       /* An exclusive process lock is held */\n  UnixUnusedFd *pUnused;            /* Unused file descriptors to close */\n  int nRef;                       /* Number of pointers to this structure */\n  unixShmNode *pShmNode;          /* Shared memory associated with this inode */\n  unixInodeInfo *pNext;           /* List of all unixInodeInfo objects */\n  unixInodeInfo *pPrev;           /*    .... doubly linked */\n};\n```\n\n在Sqlite中有一个全局变量 `static unixInodeInfo *inodeList = 0;` 用一个双向链表记录了，当前进程内打开的所有文件索引。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/52e0629643e32cd4700b2ccf86cf96fb.png)\n\n## 锁\n\nPOSIX设计的锁做不到在同一个进程内不同线程之间互斥。因为按照POSIX的设计，文件锁的最小粒度是进程，所以只要\n在同一个进程内，不同线程的锁，是可以相互覆盖的。\n\n> 举个例子，如果线程AB在同一个进程内，线程A先请求了某个文件某个区域的写锁，这个时候，线程B如果再去请求同一个区域的写锁的时候，是可以成功的。因为锁分配的最小单位是进程。\n\n另外，对于不同的文件描述符，但是是同一个文件索引，操作系统在对文件加锁的时候，是会对实际的文件（文件索引）加锁，而不是硬链接或者软链接。\n\n> 举个例子，如果一个文件有两个软链接，在同一个进程内分别对这两个软链接指向的文件进行锁操作的时候，操作的实际是同一个文件。\n\n1. 根据上面的问题描述，那么Sqlite 如果想要实现多线程操作一个文件，必然需要实现多线程下的文件锁互斥。也就是说Sqlite需要在进程内，把锁的粒度控制在线程上。\n2. 当关闭文件的时候，操作系统会释放掉当前进程在改文件上的所有锁。所以还需要管理进程内对每个文件的锁，所有线程都释放锁的时候，才会真正释放进程对文件的锁。\n\n### Sqlite 锁的设计\n\n与简单的读写锁不同，Sqlite内部有5种锁状态：`UNLOCKED`,`SHARED`,`RESERVED`,`PENDING`,`EXCLUSIVE`。这5个锁的状态是存储在*inode*的eFileLock上。\n\n- UNLOCKED:这个没有什么疑问，就是没有加锁的状态，任何文件初始状态都是这个。\n- SHARED:共享锁，也叫读锁，如果想要读一个文件，那么这个文件的锁级别必须至少是SHARED。同一个文件上的共享锁可以存在多个。共享锁是所有锁的第一步，想要获取任何高级别的锁，必须要先获取共享锁。\n- RESERVED:保留锁，保留锁是用来过渡想要从共享锁提升到高级锁的一个暂度期。在这个锁的状态下，可以继续有新的共享锁出现。\n- PENDING:未决锁，这个锁表示，当前连接马上要写数据库了。但是也不能把所有读锁都剥夺，这样会有问题。所以在这个级别的锁下，可以保持现有的锁。但是不能有新的共享锁了。\n- EXCLUSIVE:排它锁，在排它锁下，只有当前这个连接可以读写数据库。这个锁的级别最高。\n\n在os层有5个类型的锁，但是os暴露出来的只有4个类型。其中的PENDING，是os的内部锁。\n\n接下来我们详细看下锁升降级的两个函数，理解Sqlite是如何设计锁的。\n\n### 锁的结构\n\n简单画了一张图，描述了单个文件下的不同文件锁状态。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/f847a348f6011bf85c71903fc41e03de.png)\n\n解释一下图，绿色表示读锁，红色表示写锁。\n\n从上到下，依次是:Shared锁，Shared->Reserved锁，Shared->Reserved->Pending锁 ，Shared->Pending锁，Shared->Reserved->Pending->Exclusive锁，Shared->Pending->Exclusive锁。这些锁的转换下文会细说。\n\n- 1GB:\n\t因为在Windows上锁是强制性的，加锁区间不能存储数据。所以这个区间必然不能被分配为一个page。page的大小是[512,32768]，为了让这个锁的区间可以在一个page内，所以整个锁的区间大小为512 bytes。\n\t\n- SharedBytes:\n\t在Win95/98/ME上，操作系统没有提供读写锁，因此，在shared byte上写并行会存在问题。sqlite把这块区域放大到510字节，每次加读锁的时候，从510个字节中随机取一个。有概率会失败，但毕竟这也算是一个曲线救国的方案吧。\n\t\n- 图中描述的是文件锁，文件锁的状态实际是存储在file的inode中（unixInodeInfo）。\n\n### 锁的升级\n\n```c\n//os.h 中声明了这个方法，用来给外部调用，第一个参数是抽象文件对象，第二个参数是锁的级别，即上面提到4种锁的枚举值。\nint sqlite3OsLock(sqlite3_file*, int);\n```\n\n锁的状态转换：\n- UNLOCKED -> SHARED\n\t从未加锁状态转换到 共享锁 读锁：\n\t\n\t如果当前文件描述符对应的文件索引已经持有了共享锁或者保留锁，那么就只需要在InodeInfo上增加nShared、nLock的计数，并修改文件描述符内文件的锁状态即可。否则就会走下面的加锁流程：\n\t1. 在pending byte位上加读锁\n\t2. 在所有的SHARED_BYTES上加读锁\n\t3. 移除掉pending byte位上的读锁\n\t\n- SHARED -> RESERVED\n\t从共享读锁升级到保留锁：\n\t1. 当前已经持有共享锁，直接在保留锁位上加写锁\n\t\n- SHARED -> (PENDING) -> EXCLUSIVE\n\t从共享读锁直接升级到排他锁：\n\t1. 如果当前InodeInfo持有的锁不是Pending，那么先在pending上加写锁\n\t2. 如果InodeInfo上还有其他共享读锁（nShared>1），那么直接返回SQLITE_BUSY。此时InodeInfo和unixFile持有的都是Pending锁，不会回滚Pending锁。\n\t3. 把所有的SHARED_BYTES上加写锁。\n\t\n- RESERVED -> (PENDING) -> EXCLUSIVE\n\t从保留锁升级到排他锁：\n\t1. 与上一个步骤一样。\n\t\n- PENDING -> EXCLUSIVE\n\t从未决锁升级到排他锁：\n\t1. 直接尝试 *SHARED -> (PENDING) -> EXCLUSIVE*的步骤 3\n\n其他说明：\n1. unlocked状态只能升级到shared状态，也就是说，锁状态必须从共享读锁开始向上升级。\n2. Sqlite不接受直接请求pending锁，也就是Pending锁只是内部使用。\n3. SQLITE_BUSY:\n\t当前文件描述符持有的锁与文件索引实际持有的状态不一致时（即文件实际锁状态级别高于文件描述符的锁的状态，即文件实际锁状态至少为共享锁）\n\ta. Inode 实际锁 >= pending时，即表示有其他线程等待写入文件，当前文件描述符请求任何锁失败（因为pending的时候不允许有shared）。\n\tb. Inode 实际锁 < pending时，请求的锁 > shared时（即保留锁和排它锁），请求锁返回失败。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/b04697cfc5624e7286657b74d3096fa7.png)\n\n>对于面向OS接口而言，没有PENDING->EXCLUSIVE这个升级过程，因为PENDING锁是不会以一个独立的锁的状态存在。而是在一个文件因为还有正在读的进程，而尝试加写锁失败的时候，此时*unixFile*才会停滞于Pending锁状态，等待下一次的加锁重试。\n\n### 锁的降级\n\n```c\n// 降低锁的级别\nint sqlite3OsUnlock(sqlite3_file*, int);\n```\n\n其中第二个参数只能是 SHARE_LOCK 或者 NO_LOCK...换句话说，文件描述符持有的锁只能降低为读锁或者无锁。\n\n分两种情况讨论：\n\n- 降级为无锁：\n\t1. 将pending + reserved + shared_size 全部降为 UNLOCK\n\t2. 文件索引Inode上的 nShared-- 以及 nLock--\n\t\n- 降级为共享读锁：\n\n\t降级到读锁的时候稍微麻烦一点。理论上来说和无锁应该一样，把pending+reserved全部降为UNLOCK，shared_size降为读锁即可。但是，在某些BSD 的NFS上会出现某个区间写锁降到读锁的时候会出现失败的bug。\n\t\n\tSqlite针对上面的情况，做了兼容：在此类操作系统上，先把(shared_size - 1)个bytes降为无锁，然后再把这些bytes升级为读锁，最后把剩下的最后一个byte降为无锁。这样避免了在从写锁降到读锁的时候，出现竞争条件的问题。\n","slug":"15.Sqlite-OS","published":1,"updated":"2022-07-28T13:38:40.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwo6000pp9c967jt56rg","content":"<blockquote>\n<p>自底向上看sqlite的时候发现自己欠缺和遗忘了好多知识（尤其是操作系统）。如果能把这个sqlite的系列都写完的话，在操作系统上，尤其是文件和内存管理上能有不少的知识复习和提升 :)。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>本文主要讲述Sqlite的最底下那层，也就是OS-Interface(后面我们统一叫os层)的原理和实现。</p>\n<p>从接口上来看，OS层主要是对上层屏蔽了不同操作系统下的文件操作实现。OS层提供了统一的以<code>sqlite3Os</code>为前缀的接口方法给上层，实现了包括文件读写，文件创建&#x2F;删除，sqlite文件锁，以及一些与系统实现相关的<code>Util</code>类操作，例如<code>sqlite3OsSleep</code>、<code>sqlite3OsCurrentTimeInt64</code>等等。这些接口方法都在<code>os.h</code>的头文件中声明了。</p>\n<p>OS层主要实现了文件操作，锁，以及共享内存，三大块的内容。<a href=\"https://caio.ink/sqlite-os-shm/\">共享内存</a>可以看这篇文章。本文就从另外两个角度去看OS是如何提供平台无关的接口。而其中 锁 是本层的一个核心功能，SQLite的多线程乃至跨进程的并发读写很大程度上就是依赖了这个锁的实现。</p>\n<blockquote>\n<p>一般在移动设备上（尤其是iOS）多进程读写文件在操作系统层面上就被禁止了，所以有些框架（WCDB）为了减少一些文件锁带来的读写性能开销，直接把文件锁禁用了，打开即独占。</p>\n</blockquote>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>os层还有一个别的名字，叫vfs（virtual file system）。sqlite在很多地方都使用了插件化和模块化的设计，例如cache，extension…还有就是这里的vfs。</p>\n<p>在sqlite最早初始化的时候会调用<code>sqlite3_os_init()</code>方法，这个方法除了测试一下malloc方法之外，剩下的就是初始化vfs了。</p>\n<p>函数原型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3_os_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>sqlite是跨平台组件，实现大体上都差不太多，这里我们只看unix的实现，如果不同平台实现差别较大的地方，我们再另外提及。</p>\n</blockquote>\n<h2 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h2><h3 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h3><p>Sqlite从OS层向外暴露的是<em>sqlite3_file</em>这个数据结构，标识了一个数据库文件。而这个<em>sqlite3_file</em>更多的可以理解为一个接口，它抽象出了很多vfs的方法。而不同平台下的vfs会有不同的文件数据结构，例如<em>unixFile</em>就是在Unix系统下的一个vfs实现。</p>\n<p>在<em>unixFile</em>这个数据结构内存储了很多这个文件当前的属性。<em>UnixFile</em>，<em>sqlite3_file</em> 这些数据结构是相对于连接而言的，也就是说，不同的连接持有的是不同的file对象，可以对应到操作系统中的文件描述符。</p>\n<h3 id=\"文件inode\"><a href=\"#文件inode\" class=\"headerlink\" title=\"文件inode\"></a>文件inode</h3><p>在Unix中，对于同一个数据库文件或者是同一个数据库文件的不同连接（软连接或硬连接），在sqlite3中可以多次打开，他们也是不同的file对象。对于这个情况，Unix的vfs针对file node也做了管理。</p>\n<p>每个打开的文件都会有一个文件描述符与之对应，但是在操作系统中，文件的实际索引是由inode来决定的。同一个文件或者文件链接打开多次，会有不同的文件描述符，但是文件的实际索引不变。</p>\n<p><em>unixInodeInfo</em>这个数据结构描述了unix中一个文件的实际索引信息。<em>unixFile</em>和<em>unixInodeInfo</em>是多对一的关系。<em>unixInodeInfo</em>中会有一个nRef变量来记录当前还有多少个文件描述符(<em>unixFile</em>)，在持有这个文件索引。每打开一次文件nRef++，关闭一次nRef–。另外在关闭一个已打开的文件描述符的时候，Sqlite不会立即关闭。在<em>unixInodeInfo</em>中用一个链表<code>UnixUnusedFd</code>描述了当前文件索引下，不再使用的文件描述符。以便再次打开该数据库。当nRef降至0时，Sqlite才会真正关闭数据库文件。</p>\n<p>数据结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 标识UNIX的文件索引,对所有持有这个InodeInfo的UnixFile做了引用计数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">unixInodeInfo</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">unixFileId</span> <span class=\"title\">fileId</span>;</span>       <span class=\"comment\">/* The lookup key */</span></span><br><span class=\"line\">  sqlite3_mutex *pLockMutex;      <span class=\"comment\">/* Hold this mutex for... */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nShared;                      <span class=\"comment\">/* Number of SHARED locks held */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nLock;                        <span class=\"comment\">/* Number of outstanding file locks */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> eFileLock;          <span class=\"comment\">/* One of SHARED_LOCK, RESERVED_LOCK etc. */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> bProcessLock;       <span class=\"comment\">/* An exclusive process lock is held */</span></span><br><span class=\"line\">  UnixUnusedFd *pUnused;            <span class=\"comment\">/* Unused file descriptors to close */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nRef;                       <span class=\"comment\">/* Number of pointers to this structure */</span></span><br><span class=\"line\">  unixShmNode *pShmNode;          <span class=\"comment\">/* Shared memory associated with this inode */</span></span><br><span class=\"line\">  unixInodeInfo *pNext;           <span class=\"comment\">/* List of all unixInodeInfo objects */</span></span><br><span class=\"line\">  unixInodeInfo *pPrev;           <span class=\"comment\">/*    .... doubly linked */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在Sqlite中有一个全局变量 <code>static unixInodeInfo *inodeList = 0;</code> 用一个双向链表记录了，当前进程内打开的所有文件索引。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/52e0629643e32cd4700b2ccf86cf96fb.png\"></p>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><p>POSIX设计的锁做不到在同一个进程内不同线程之间互斥。因为按照POSIX的设计，文件锁的最小粒度是进程，所以只要<br>在同一个进程内，不同线程的锁，是可以相互覆盖的。</p>\n<blockquote>\n<p>举个例子，如果线程AB在同一个进程内，线程A先请求了某个文件某个区域的写锁，这个时候，线程B如果再去请求同一个区域的写锁的时候，是可以成功的。因为锁分配的最小单位是进程。</p>\n</blockquote>\n<p>另外，对于不同的文件描述符，但是是同一个文件索引，操作系统在对文件加锁的时候，是会对实际的文件（文件索引）加锁，而不是硬链接或者软链接。</p>\n<blockquote>\n<p>举个例子，如果一个文件有两个软链接，在同一个进程内分别对这两个软链接指向的文件进行锁操作的时候，操作的实际是同一个文件。</p>\n</blockquote>\n<ol>\n<li>根据上面的问题描述，那么Sqlite 如果想要实现多线程操作一个文件，必然需要实现多线程下的文件锁互斥。也就是说Sqlite需要在进程内，把锁的粒度控制在线程上。</li>\n<li>当关闭文件的时候，操作系统会释放掉当前进程在改文件上的所有锁。所以还需要管理进程内对每个文件的锁，所有线程都释放锁的时候，才会真正释放进程对文件的锁。</li>\n</ol>\n<h3 id=\"Sqlite-锁的设计\"><a href=\"#Sqlite-锁的设计\" class=\"headerlink\" title=\"Sqlite 锁的设计\"></a>Sqlite 锁的设计</h3><p>与简单的读写锁不同，Sqlite内部有5种锁状态：<code>UNLOCKED</code>,<code>SHARED</code>,<code>RESERVED</code>,<code>PENDING</code>,<code>EXCLUSIVE</code>。这5个锁的状态是存储在<em>inode</em>的eFileLock上。</p>\n<ul>\n<li>UNLOCKED:这个没有什么疑问，就是没有加锁的状态，任何文件初始状态都是这个。</li>\n<li>SHARED:共享锁，也叫读锁，如果想要读一个文件，那么这个文件的锁级别必须至少是SHARED。同一个文件上的共享锁可以存在多个。共享锁是所有锁的第一步，想要获取任何高级别的锁，必须要先获取共享锁。</li>\n<li>RESERVED:保留锁，保留锁是用来过渡想要从共享锁提升到高级锁的一个暂度期。在这个锁的状态下，可以继续有新的共享锁出现。</li>\n<li>PENDING:未决锁，这个锁表示，当前连接马上要写数据库了。但是也不能把所有读锁都剥夺，这样会有问题。所以在这个级别的锁下，可以保持现有的锁。但是不能有新的共享锁了。</li>\n<li>EXCLUSIVE:排它锁，在排它锁下，只有当前这个连接可以读写数据库。这个锁的级别最高。</li>\n</ul>\n<p>在os层有5个类型的锁，但是os暴露出来的只有4个类型。其中的PENDING，是os的内部锁。</p>\n<p>接下来我们详细看下锁升降级的两个函数，理解Sqlite是如何设计锁的。</p>\n<h3 id=\"锁的结构\"><a href=\"#锁的结构\" class=\"headerlink\" title=\"锁的结构\"></a>锁的结构</h3><p>简单画了一张图，描述了单个文件下的不同文件锁状态。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/f847a348f6011bf85c71903fc41e03de.png\"></p>\n<p>解释一下图，绿色表示读锁，红色表示写锁。</p>\n<p>从上到下，依次是:Shared锁，Shared-&gt;Reserved锁，Shared-&gt;Reserved-&gt;Pending锁 ，Shared-&gt;Pending锁，Shared-&gt;Reserved-&gt;Pending-&gt;Exclusive锁，Shared-&gt;Pending-&gt;Exclusive锁。这些锁的转换下文会细说。</p>\n<ul>\n<li><p>1GB:<br>  因为在Windows上锁是强制性的，加锁区间不能存储数据。所以这个区间必然不能被分配为一个page。page的大小是[512,32768]，为了让这个锁的区间可以在一个page内，所以整个锁的区间大小为512 bytes。</p>\n</li>\n<li><p>SharedBytes:<br>  在Win95&#x2F;98&#x2F;ME上，操作系统没有提供读写锁，因此，在shared byte上写并行会存在问题。sqlite把这块区域放大到510字节，每次加读锁的时候，从510个字节中随机取一个。有概率会失败，但毕竟这也算是一个曲线救国的方案吧。</p>\n</li>\n<li><p>图中描述的是文件锁，文件锁的状态实际是存储在file的inode中（unixInodeInfo）。</p>\n</li>\n</ul>\n<h3 id=\"锁的升级\"><a href=\"#锁的升级\" class=\"headerlink\" title=\"锁的升级\"></a>锁的升级</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//os.h 中声明了这个方法，用来给外部调用，第一个参数是抽象文件对象，第二个参数是锁的级别，即上面提到4种锁的枚举值。</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3OsLock</span><span class=\"params\">(sqlite3_file*, <span class=\"type\">int</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>锁的状态转换：</p>\n<ul>\n<li><p>UNLOCKED -&gt; SHARED<br>  从未加锁状态转换到 共享锁 读锁：</p>\n<p>  如果当前文件描述符对应的文件索引已经持有了共享锁或者保留锁，那么就只需要在InodeInfo上增加nShared、nLock的计数，并修改文件描述符内文件的锁状态即可。否则就会走下面的加锁流程：</p>\n<ol>\n<li>在pending byte位上加读锁</li>\n<li>在所有的SHARED_BYTES上加读锁</li>\n<li>移除掉pending byte位上的读锁</li>\n</ol>\n</li>\n<li><p>SHARED -&gt; RESERVED<br>  从共享读锁升级到保留锁：</p>\n<ol>\n<li>当前已经持有共享锁，直接在保留锁位上加写锁</li>\n</ol>\n</li>\n<li><p>SHARED -&gt; (PENDING) -&gt; EXCLUSIVE<br>  从共享读锁直接升级到排他锁：</p>\n<ol>\n<li>如果当前InodeInfo持有的锁不是Pending，那么先在pending上加写锁</li>\n<li>如果InodeInfo上还有其他共享读锁（nShared&gt;1），那么直接返回SQLITE_BUSY。此时InodeInfo和unixFile持有的都是Pending锁，不会回滚Pending锁。</li>\n<li>把所有的SHARED_BYTES上加写锁。</li>\n</ol>\n</li>\n<li><p>RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE<br>  从保留锁升级到排他锁：</p>\n<ol>\n<li>与上一个步骤一样。</li>\n</ol>\n</li>\n<li><p>PENDING -&gt; EXCLUSIVE<br>  从未决锁升级到排他锁：</p>\n<ol>\n<li>直接尝试 <em>SHARED -&gt; (PENDING) -&gt; EXCLUSIVE</em>的步骤 3</li>\n</ol>\n</li>\n</ul>\n<p>其他说明：</p>\n<ol>\n<li>unlocked状态只能升级到shared状态，也就是说，锁状态必须从共享读锁开始向上升级。</li>\n<li>Sqlite不接受直接请求pending锁，也就是Pending锁只是内部使用。</li>\n<li>SQLITE_BUSY:<br> 当前文件描述符持有的锁与文件索引实际持有的状态不一致时（即文件实际锁状态级别高于文件描述符的锁的状态，即文件实际锁状态至少为共享锁）<br> a. Inode 实际锁 &gt;&#x3D; pending时，即表示有其他线程等待写入文件，当前文件描述符请求任何锁失败（因为pending的时候不允许有shared）。<br> b. Inode 实际锁 &lt; pending时，请求的锁 &gt; shared时（即保留锁和排它锁），请求锁返回失败。</li>\n</ol>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/b04697cfc5624e7286657b74d3096fa7.png\"></p>\n<blockquote>\n<p>对于面向OS接口而言，没有PENDING-&gt;EXCLUSIVE这个升级过程，因为PENDING锁是不会以一个独立的锁的状态存在。而是在一个文件因为还有正在读的进程，而尝试加写锁失败的时候，此时<em>unixFile</em>才会停滞于Pending锁状态，等待下一次的加锁重试。</p>\n</blockquote>\n<h3 id=\"锁的降级\"><a href=\"#锁的降级\" class=\"headerlink\" title=\"锁的降级\"></a>锁的降级</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 降低锁的级别</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3OsUnlock</span><span class=\"params\">(sqlite3_file*, <span class=\"type\">int</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>其中第二个参数只能是 SHARE_LOCK 或者 NO_LOCK…换句话说，文件描述符持有的锁只能降低为读锁或者无锁。</p>\n<p>分两种情况讨论：</p>\n<ul>\n<li><p>降级为无锁：</p>\n<ol>\n<li>将pending + reserved + shared_size 全部降为 UNLOCK</li>\n<li>文件索引Inode上的 nShared– 以及 nLock–</li>\n</ol>\n</li>\n<li><p>降级为共享读锁：</p>\n<p>  降级到读锁的时候稍微麻烦一点。理论上来说和无锁应该一样，把pending+reserved全部降为UNLOCK，shared_size降为读锁即可。但是，在某些BSD 的NFS上会出现某个区间写锁降到读锁的时候会出现失败的bug。</p>\n<p>  Sqlite针对上面的情况，做了兼容：在此类操作系统上，先把(shared_size - 1)个bytes降为无锁，然后再把这些bytes升级为读锁，最后把剩下的最后一个byte降为无锁。这样避免了在从写锁降到读锁的时候，出现竞争条件的问题。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>自底向上看sqlite的时候发现自己欠缺和遗忘了好多知识（尤其是操作系统）。如果能把这个sqlite的系列都写完的话，在操作系统上，尤其是文件和内存管理上能有不少的知识复习和提升 :)。</p>\n</blockquote>","more":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>本文主要讲述Sqlite的最底下那层，也就是OS-Interface(后面我们统一叫os层)的原理和实现。</p>\n<p>从接口上来看，OS层主要是对上层屏蔽了不同操作系统下的文件操作实现。OS层提供了统一的以<code>sqlite3Os</code>为前缀的接口方法给上层，实现了包括文件读写，文件创建&#x2F;删除，sqlite文件锁，以及一些与系统实现相关的<code>Util</code>类操作，例如<code>sqlite3OsSleep</code>、<code>sqlite3OsCurrentTimeInt64</code>等等。这些接口方法都在<code>os.h</code>的头文件中声明了。</p>\n<p>OS层主要实现了文件操作，锁，以及共享内存，三大块的内容。<a href=\"https://caio.ink/sqlite-os-shm/\">共享内存</a>可以看这篇文章。本文就从另外两个角度去看OS是如何提供平台无关的接口。而其中 锁 是本层的一个核心功能，SQLite的多线程乃至跨进程的并发读写很大程度上就是依赖了这个锁的实现。</p>\n<blockquote>\n<p>一般在移动设备上（尤其是iOS）多进程读写文件在操作系统层面上就被禁止了，所以有些框架（WCDB）为了减少一些文件锁带来的读写性能开销，直接把文件锁禁用了，打开即独占。</p>\n</blockquote>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>os层还有一个别的名字，叫vfs（virtual file system）。sqlite在很多地方都使用了插件化和模块化的设计，例如cache，extension…还有就是这里的vfs。</p>\n<p>在sqlite最早初始化的时候会调用<code>sqlite3_os_init()</code>方法，这个方法除了测试一下malloc方法之外，剩下的就是初始化vfs了。</p>\n<p>函数原型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3_os_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>sqlite是跨平台组件，实现大体上都差不太多，这里我们只看unix的实现，如果不同平台实现差别较大的地方，我们再另外提及。</p>\n</blockquote>\n<h2 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h2><h3 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h3><p>Sqlite从OS层向外暴露的是<em>sqlite3_file</em>这个数据结构，标识了一个数据库文件。而这个<em>sqlite3_file</em>更多的可以理解为一个接口，它抽象出了很多vfs的方法。而不同平台下的vfs会有不同的文件数据结构，例如<em>unixFile</em>就是在Unix系统下的一个vfs实现。</p>\n<p>在<em>unixFile</em>这个数据结构内存储了很多这个文件当前的属性。<em>UnixFile</em>，<em>sqlite3_file</em> 这些数据结构是相对于连接而言的，也就是说，不同的连接持有的是不同的file对象，可以对应到操作系统中的文件描述符。</p>\n<h3 id=\"文件inode\"><a href=\"#文件inode\" class=\"headerlink\" title=\"文件inode\"></a>文件inode</h3><p>在Unix中，对于同一个数据库文件或者是同一个数据库文件的不同连接（软连接或硬连接），在sqlite3中可以多次打开，他们也是不同的file对象。对于这个情况，Unix的vfs针对file node也做了管理。</p>\n<p>每个打开的文件都会有一个文件描述符与之对应，但是在操作系统中，文件的实际索引是由inode来决定的。同一个文件或者文件链接打开多次，会有不同的文件描述符，但是文件的实际索引不变。</p>\n<p><em>unixInodeInfo</em>这个数据结构描述了unix中一个文件的实际索引信息。<em>unixFile</em>和<em>unixInodeInfo</em>是多对一的关系。<em>unixInodeInfo</em>中会有一个nRef变量来记录当前还有多少个文件描述符(<em>unixFile</em>)，在持有这个文件索引。每打开一次文件nRef++，关闭一次nRef–。另外在关闭一个已打开的文件描述符的时候，Sqlite不会立即关闭。在<em>unixInodeInfo</em>中用一个链表<code>UnixUnusedFd</code>描述了当前文件索引下，不再使用的文件描述符。以便再次打开该数据库。当nRef降至0时，Sqlite才会真正关闭数据库文件。</p>\n<p>数据结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 标识UNIX的文件索引,对所有持有这个InodeInfo的UnixFile做了引用计数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">unixInodeInfo</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">unixFileId</span> <span class=\"title\">fileId</span>;</span>       <span class=\"comment\">/* The lookup key */</span></span><br><span class=\"line\">  sqlite3_mutex *pLockMutex;      <span class=\"comment\">/* Hold this mutex for... */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nShared;                      <span class=\"comment\">/* Number of SHARED locks held */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nLock;                        <span class=\"comment\">/* Number of outstanding file locks */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> eFileLock;          <span class=\"comment\">/* One of SHARED_LOCK, RESERVED_LOCK etc. */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> bProcessLock;       <span class=\"comment\">/* An exclusive process lock is held */</span></span><br><span class=\"line\">  UnixUnusedFd *pUnused;            <span class=\"comment\">/* Unused file descriptors to close */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> nRef;                       <span class=\"comment\">/* Number of pointers to this structure */</span></span><br><span class=\"line\">  unixShmNode *pShmNode;          <span class=\"comment\">/* Shared memory associated with this inode */</span></span><br><span class=\"line\">  unixInodeInfo *pNext;           <span class=\"comment\">/* List of all unixInodeInfo objects */</span></span><br><span class=\"line\">  unixInodeInfo *pPrev;           <span class=\"comment\">/*    .... doubly linked */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在Sqlite中有一个全局变量 <code>static unixInodeInfo *inodeList = 0;</code> 用一个双向链表记录了，当前进程内打开的所有文件索引。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/52e0629643e32cd4700b2ccf86cf96fb.png\"></p>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><p>POSIX设计的锁做不到在同一个进程内不同线程之间互斥。因为按照POSIX的设计，文件锁的最小粒度是进程，所以只要<br>在同一个进程内，不同线程的锁，是可以相互覆盖的。</p>\n<blockquote>\n<p>举个例子，如果线程AB在同一个进程内，线程A先请求了某个文件某个区域的写锁，这个时候，线程B如果再去请求同一个区域的写锁的时候，是可以成功的。因为锁分配的最小单位是进程。</p>\n</blockquote>\n<p>另外，对于不同的文件描述符，但是是同一个文件索引，操作系统在对文件加锁的时候，是会对实际的文件（文件索引）加锁，而不是硬链接或者软链接。</p>\n<blockquote>\n<p>举个例子，如果一个文件有两个软链接，在同一个进程内分别对这两个软链接指向的文件进行锁操作的时候，操作的实际是同一个文件。</p>\n</blockquote>\n<ol>\n<li>根据上面的问题描述，那么Sqlite 如果想要实现多线程操作一个文件，必然需要实现多线程下的文件锁互斥。也就是说Sqlite需要在进程内，把锁的粒度控制在线程上。</li>\n<li>当关闭文件的时候，操作系统会释放掉当前进程在改文件上的所有锁。所以还需要管理进程内对每个文件的锁，所有线程都释放锁的时候，才会真正释放进程对文件的锁。</li>\n</ol>\n<h3 id=\"Sqlite-锁的设计\"><a href=\"#Sqlite-锁的设计\" class=\"headerlink\" title=\"Sqlite 锁的设计\"></a>Sqlite 锁的设计</h3><p>与简单的读写锁不同，Sqlite内部有5种锁状态：<code>UNLOCKED</code>,<code>SHARED</code>,<code>RESERVED</code>,<code>PENDING</code>,<code>EXCLUSIVE</code>。这5个锁的状态是存储在<em>inode</em>的eFileLock上。</p>\n<ul>\n<li>UNLOCKED:这个没有什么疑问，就是没有加锁的状态，任何文件初始状态都是这个。</li>\n<li>SHARED:共享锁，也叫读锁，如果想要读一个文件，那么这个文件的锁级别必须至少是SHARED。同一个文件上的共享锁可以存在多个。共享锁是所有锁的第一步，想要获取任何高级别的锁，必须要先获取共享锁。</li>\n<li>RESERVED:保留锁，保留锁是用来过渡想要从共享锁提升到高级锁的一个暂度期。在这个锁的状态下，可以继续有新的共享锁出现。</li>\n<li>PENDING:未决锁，这个锁表示，当前连接马上要写数据库了。但是也不能把所有读锁都剥夺，这样会有问题。所以在这个级别的锁下，可以保持现有的锁。但是不能有新的共享锁了。</li>\n<li>EXCLUSIVE:排它锁，在排它锁下，只有当前这个连接可以读写数据库。这个锁的级别最高。</li>\n</ul>\n<p>在os层有5个类型的锁，但是os暴露出来的只有4个类型。其中的PENDING，是os的内部锁。</p>\n<p>接下来我们详细看下锁升降级的两个函数，理解Sqlite是如何设计锁的。</p>\n<h3 id=\"锁的结构\"><a href=\"#锁的结构\" class=\"headerlink\" title=\"锁的结构\"></a>锁的结构</h3><p>简单画了一张图，描述了单个文件下的不同文件锁状态。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/f847a348f6011bf85c71903fc41e03de.png\"></p>\n<p>解释一下图，绿色表示读锁，红色表示写锁。</p>\n<p>从上到下，依次是:Shared锁，Shared-&gt;Reserved锁，Shared-&gt;Reserved-&gt;Pending锁 ，Shared-&gt;Pending锁，Shared-&gt;Reserved-&gt;Pending-&gt;Exclusive锁，Shared-&gt;Pending-&gt;Exclusive锁。这些锁的转换下文会细说。</p>\n<ul>\n<li><p>1GB:<br>  因为在Windows上锁是强制性的，加锁区间不能存储数据。所以这个区间必然不能被分配为一个page。page的大小是[512,32768]，为了让这个锁的区间可以在一个page内，所以整个锁的区间大小为512 bytes。</p>\n</li>\n<li><p>SharedBytes:<br>  在Win95&#x2F;98&#x2F;ME上，操作系统没有提供读写锁，因此，在shared byte上写并行会存在问题。sqlite把这块区域放大到510字节，每次加读锁的时候，从510个字节中随机取一个。有概率会失败，但毕竟这也算是一个曲线救国的方案吧。</p>\n</li>\n<li><p>图中描述的是文件锁，文件锁的状态实际是存储在file的inode中（unixInodeInfo）。</p>\n</li>\n</ul>\n<h3 id=\"锁的升级\"><a href=\"#锁的升级\" class=\"headerlink\" title=\"锁的升级\"></a>锁的升级</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//os.h 中声明了这个方法，用来给外部调用，第一个参数是抽象文件对象，第二个参数是锁的级别，即上面提到4种锁的枚举值。</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3OsLock</span><span class=\"params\">(sqlite3_file*, <span class=\"type\">int</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>锁的状态转换：</p>\n<ul>\n<li><p>UNLOCKED -&gt; SHARED<br>  从未加锁状态转换到 共享锁 读锁：</p>\n<p>  如果当前文件描述符对应的文件索引已经持有了共享锁或者保留锁，那么就只需要在InodeInfo上增加nShared、nLock的计数，并修改文件描述符内文件的锁状态即可。否则就会走下面的加锁流程：</p>\n<ol>\n<li>在pending byte位上加读锁</li>\n<li>在所有的SHARED_BYTES上加读锁</li>\n<li>移除掉pending byte位上的读锁</li>\n</ol>\n</li>\n<li><p>SHARED -&gt; RESERVED<br>  从共享读锁升级到保留锁：</p>\n<ol>\n<li>当前已经持有共享锁，直接在保留锁位上加写锁</li>\n</ol>\n</li>\n<li><p>SHARED -&gt; (PENDING) -&gt; EXCLUSIVE<br>  从共享读锁直接升级到排他锁：</p>\n<ol>\n<li>如果当前InodeInfo持有的锁不是Pending，那么先在pending上加写锁</li>\n<li>如果InodeInfo上还有其他共享读锁（nShared&gt;1），那么直接返回SQLITE_BUSY。此时InodeInfo和unixFile持有的都是Pending锁，不会回滚Pending锁。</li>\n<li>把所有的SHARED_BYTES上加写锁。</li>\n</ol>\n</li>\n<li><p>RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE<br>  从保留锁升级到排他锁：</p>\n<ol>\n<li>与上一个步骤一样。</li>\n</ol>\n</li>\n<li><p>PENDING -&gt; EXCLUSIVE<br>  从未决锁升级到排他锁：</p>\n<ol>\n<li>直接尝试 <em>SHARED -&gt; (PENDING) -&gt; EXCLUSIVE</em>的步骤 3</li>\n</ol>\n</li>\n</ul>\n<p>其他说明：</p>\n<ol>\n<li>unlocked状态只能升级到shared状态，也就是说，锁状态必须从共享读锁开始向上升级。</li>\n<li>Sqlite不接受直接请求pending锁，也就是Pending锁只是内部使用。</li>\n<li>SQLITE_BUSY:<br> 当前文件描述符持有的锁与文件索引实际持有的状态不一致时（即文件实际锁状态级别高于文件描述符的锁的状态，即文件实际锁状态至少为共享锁）<br> a. Inode 实际锁 &gt;&#x3D; pending时，即表示有其他线程等待写入文件，当前文件描述符请求任何锁失败（因为pending的时候不允许有shared）。<br> b. Inode 实际锁 &lt; pending时，请求的锁 &gt; shared时（即保留锁和排它锁），请求锁返回失败。</li>\n</ol>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/04/b04697cfc5624e7286657b74d3096fa7.png\"></p>\n<blockquote>\n<p>对于面向OS接口而言，没有PENDING-&gt;EXCLUSIVE这个升级过程，因为PENDING锁是不会以一个独立的锁的状态存在。而是在一个文件因为还有正在读的进程，而尝试加写锁失败的时候，此时<em>unixFile</em>才会停滞于Pending锁状态，等待下一次的加锁重试。</p>\n</blockquote>\n<h3 id=\"锁的降级\"><a href=\"#锁的降级\" class=\"headerlink\" title=\"锁的降级\"></a>锁的降级</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 降低锁的级别</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3OsUnlock</span><span class=\"params\">(sqlite3_file*, <span class=\"type\">int</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>其中第二个参数只能是 SHARE_LOCK 或者 NO_LOCK…换句话说，文件描述符持有的锁只能降低为读锁或者无锁。</p>\n<p>分两种情况讨论：</p>\n<ul>\n<li><p>降级为无锁：</p>\n<ol>\n<li>将pending + reserved + shared_size 全部降为 UNLOCK</li>\n<li>文件索引Inode上的 nShared– 以及 nLock–</li>\n</ol>\n</li>\n<li><p>降级为共享读锁：</p>\n<p>  降级到读锁的时候稍微麻烦一点。理论上来说和无锁应该一样，把pending+reserved全部降为UNLOCK，shared_size降为读锁即可。但是，在某些BSD 的NFS上会出现某个区间写锁降到读锁的时候会出现失败的bug。</p>\n<p>  Sqlite针对上面的情况，做了兼容：在此类操作系统上，先把(shared_size - 1)个bytes降为无锁，然后再把这些bytes升级为读锁，最后把剩下的最后一个byte降为无锁。这样避免了在从写锁降到读锁的时候，出现竞争条件的问题。</p>\n</li>\n</ul>"},{"title":"SQLite--KeywordHash","date":"2020-07-15T16:00:00.000Z","top":300,"_content":"\n> SQLite 的关键字有很多个(在3.27.2版本就支持136个)。从用户侧输入一个SQL语句到Tokenize(词法分析器)的时候，SQLite如何快速判断一个单词是否是关键字呢？第一想法肯定是利用哈希表，SQLite也确实是如此。但是如何构建一个查询高效，存储占用低，而且还支持关键字\"裁剪\"的哈希表呢？这里从源码的角度来看，SQLite是如何一步一步的精简优化一个词法分析器的关键字查询表的。\n\n<!-- more -->\n\n## SQLite源码的构成\n\nSQLite本身是可以支持用cmake通过宏来裁剪功能和扩展功能的。在编译源码的过程中，会通过autoconfig生成一个Makefile。而Makefile的依赖中有一个`keywordhash.h`的文件。这个头文件就是用来做哈希表的构建的。可以看下Makefile中这个头文件的依赖与command。\n\n``` c\nkeywordhash.h:\t$(TOP)/tool/mkkeywordhash.c\n\t$(BCC) -o mkkeywordhash $(OPTS) $(TOP)/tool/mkkeywordhash.c\n\t./mkkeywordhash >keywordhash.h\n```\n\n这个文件只依赖`$(TOP)/tool/mkkeywordhash.c`这个文件的变更，并且command为:编译链接这个`mkkeywordhash.c`的源码，并且执行编译后的可执行文件，将输出重定向到`keywordhash.h`。那么到这里可以判断出`keywordhash.h`这个文件是`mkkeywordhash`这个程序生成的。\n\n在`keywordhash.h`文件的开头注释也写的很清楚:\n\n``` c\n** The code in this file has been automatically generated by\n**\n**   sqlite/tool/mkkeywordhash.c\n**\n** The code in this file implements a function that determines whether\n** or not a given identifier is really an SQL keyword.  The same thing\n** might be implemented more directly using a hand-written hash table.\n** But by using this automatically generated code, the size of the code\n** is substantially reduced.  This is important for embedded applications\n** on platforms with limited memory.\n```\n\n注释写到，直接用hand-written(手写)的哈希表也可以达到同一个目的。但是为了达到极致的内存和性能等，SQLite做了更多的优化。\n\n## 为什么要使用mkkeywordhash？\n\n上面提到了，SQLite完全可以通过一个纯手写的哈希表来达到快速查询一个单词是否是SQL关键字的目的。但是，使用SQLite的一般都是移动或者嵌入式设备，那么内存必然是需要考虑的一个因素。136个关键字，加上哈希表的散列，内存消耗还是非常可观的。总结使用`mkkeywordhash`有以下的优点:\n\n1. 支持裁剪。支持使用宏，动态地在编译期就可以决定SQLite支持哪些关键字(因为在编译期就会使用mkkeywordhash来动态生成源码)。\n2. 支持动态关键字压缩。`mkkeywordhash`压缩了所有的关键字，压缩对象为前缀与其他关键字前缀相同的关键字，或者是其他关键字子串的关键字。例:`REINDEX`的后缀和`INDEXED`的前缀一致；`INDEX`是`REINDEX`的子串\n3. 支持动态创建静态的哈希表。这句话怎么理解？静态哈希表可以理解：最终生成的哈希表肯定是静态的，因为SQLite编译后支持的关键字始终是固定的。动态创建是指，可以通过宏来动态决定这个关键字哈希表的大小，内容，以及哈希表的*碰撞率*。\n\n注意这里说的动态，是指在编译期根据不同的需求，*动态*的来定制SQLite，而不是运行期的动态输入输出。\n\n下面来详细看下这个`mkkeywordhash.c`的源码，看看SQLite在编译期间是如何动态生成需要的关键字哈希表的:\n\n## mkkeywordhash.c\n\n### 关键字的数据结构\n\n``` c\n/*\n** All the keywords of the SQL language are stored in a hash\n** table composed of instances of the following structure.\n*/\ntypedef struct Keyword Keyword;\nstruct Keyword {\n  char *zName;         /* The keyword name */\n  char *zTokenType;    /* Token value for this keyword */\n  int mask;            /* Code this keyword if non-zero */\n  int id;              /* Unique ID for this record */\n  int hash;            /* Hash on the keyword */\n  int offset;          /* Offset to start of name string */\n  int len;             /* Length of this keyword, not counting final \\000 */\n  int prefix;          /* Number of characters in prefix */\n  int longestSuffix;   /* Longest suffix that is a prefix on another word */\n  int iNext;           /* Index in aKeywordTable[] of next with same hash */\n  int substrId;        /* Id to another keyword this keyword is embedded in */\n  int substrOffset;    /* Offset into substrId for start of this keyword */\n  char zOrigName[20];  /* Original keyword name before processing */\n};\n```\n\n这里需要说明一下，这个数据结构是用于`mkkeywordhash.c`，用来组织和描述所有需要编译进去的关键字的数据结构。在最后`mkkeywordhash`会根据计算好的所有关键字的`KeyWord`对象来生成最终的`keywordhash.h`文件中的静态哈希表。\n\n* char *zName:           关键字字符串，最终会变成压缩后的关键字字符串。  \n* char *zTokenType:      关键字类型，在tokenize暴露给外层类型。\n* int mask:              不同的关键字可能是属于同一个功能的，宏的控制就通过控制mask的值来开启或者关闭同一类的能力\n* int id:                关键字的id，会以关键字在数组中的索引值作为id，意义不大。\n* int hash:              关键字的哈希值\n* int offset:            关键字在压缩后的字符串表中的起始偏移\n* int len:               关键字的原始长度\n* int prefix:            关键字前缀和其他关键字后缀重叠部分的长度\n* int longestSuffix:     当前关键字后缀和其他关键字前缀重叠部分的最长长度\n* int iNext:             当哈希表发生碰撞的时候，通过链表来存储\n* int substrId:          如果当前关键字是另一个关键字子串的时候，substrId就是另一个关键字的Id\n* int substrOffset:      在substrId不为空的情况下，substrOffset标识子串开始的偏移\n* char zOrigName[20]:    关键字原始字符串\n\n全局静态变量 aKeywordTable 存储了目前支持的所有的关键字。\n\n``` c\nstatic Keyword aKeywordTable[] = {\n  { \"ABORT\",            \"TK_ABORT\",        CONFLICT|TRIGGER       },\n  { \"ACTION\",           \"TK_ACTION\",       FKEY                   },\n  { \"ADD\",              \"TK_ADD\",          ALTER                  },\n  { \"AFTER\",            \"TK_AFTER\",        TRIGGER                },\n  /* ... 136个关键字 ... */\n};\n```\n\n### 基本处理流程\n\n`mkkeywordhash`分成了几个步骤:\n\n### 裁剪不支持的关键字\n\n在`mkkeywordhash` main函数开始的第一步就是裁减掉不使用的关键字，如何裁剪？\n\n在 aKeywordTable 和 `Keyword` 的数据结构里可以看到，每一个关键字都给予了一个mask，这个mask可以理解为关键字的tag，不同的mask值不一样，不同的关键字可以同时具有相同的mask，同一个mask可以具有多个mask。SQLite通过定义mask的值来确定是否需要裁剪。\n\n``` c\n#ifdef SQLITE_OMIT_ALTERTABLE\n#  define ALTER      0\n#else\n#  define ALTER      0x00000001\n#endif\n```\n\n例如，如果定义了`SQLITE_OMIT_ALTERTABLE`宏，那么`ALTER`就会被定义为0，那么只具有`ALTER`mask的关键字的mask值就会被标记为0。\n\n``` c\n/* Remove entries from the list of keywords that have mask==0 */\nfor(i=j=0; i<nKeyword; i++){\n    if( aKeywordTable[i].mask==0 ) continue;\n    if( j<i ){\n      aKeywordTable[j] = aKeywordTable[i];\n    }\n    j++;\n}\nnKeyword = j;\n```\n然后通过遍历 akeywordTable 数组，过滤掉所有关键字mask为0的关键字，遍历的时候使用了快慢指针，分别指向当前遍历索引和存储的索引。\n\n### 数据结构和计算哈希值\n\n``` c\nfor(i=0; i<nKeyword; i++){\n    Keyword *p = &aKeywordTable[i];\n    p->len = (int)strlen(p->zName);\n    assert( p->len<sizeof(p->zOrigName) );\n    memcpy(p->zOrigName, p->zName, p->len+1);\n    totalLen += p->len;\n    p->hash = (charMap(p->zName[0])*4) ^\n              (charMap(p->zName[p->len-1])*3) ^ (p->len*1);\n    p->id = i+1;\n}\n```\n\n在裁剪完成之后，当前aKeywordTable里的nKeyword个关键字就是SQLite本次编译需要支持的所有关键字了。\n\n* 以每一个关键字的索引作为id\n* p->len 存关键字的原始长度\n* p->zOrigName 存储原始字符串，也就是当前 的p->zName 字段\n* 哈希算法:(关键字的第一个字符*4)^(关键字的最后一个字符*3)^(关键字名字的长度)) 大致从aKeywordTable中的关键字看到，首尾字符已经可以获得很少的哈希冲突了。\n\n### 完全子串的关系查找\n\n首先可以压缩的情况就是，A串是B串的子串，这种情况下，我们只需要记录A串是B串子串的这一关系，以及A在B中起始的偏移值既可。\n\n``` c\n/* Sort the table from shortest to longest keyword */\n/* 从关键字字符串长度的最短到最长做排序 */\nqsort(aKeywordTable, nKeyword, sizeof(aKeywordTable[0]), keywordCompare1);\n\n/* Look for short keywords embedded in longer keywords */\n/* 从数组中找到，某些关键字是另一些关键字子串的情况，例如,IN是INDEX的子串，INDEX是INDEXED的子串*/\nfor(i=nKeyword-2; i>=0; i--){//从倒数第二个开始\n    Keyword *p = &aKeywordTable[i];//p: 当前关键字\n    for(j=nKeyword-1; j>i && p->substrId==0; j--){//依次判断当前关键字，是否是其他关键字(其他关键字从最后向前遍历)的子串\n        Keyword *pOther = &aKeywordTable[j];\n        if( pOther->substrId ) continue;\n        if( pOther->len<=p->len ) continue;\n\n        //判断 p 是不是 pOther 关键字的子串\n        for(k=0; k<=pOther->len-p->len; k++){\n            if( memcmp(p->zName, &pOther->zName[k], p->len)==0 ){\n                p->substrId = pOther->id;\n                p->substrOffset = k;\n                break;\n            }\n        }\n    }\n}\n```\n\n* 如果A是B的子串，那么A的长度必然不长于B。所以先按照长度，从短到长排序。\n* 如果A是B的子串，那么A的substrId会被记录为B的Id，A的substrOffset会被记录为子串的起始偏移。\n\n### 前缀、后缀的进一步压缩\n\n``` c\n  /* Compute the longestSuffix value for every word */\n  /* 进步压缩，除了完全包含其他关键字的以外，其他关键字中，\n    每一个关键字的后缀中与其他关键字的前缀相等的最长长度是多少 */\n  for(i=0; i<nKeyword; i++){//遍历所有关键字\n    Keyword *p = &aKeywordTable[i];\n    if( p->substrId ) continue;//忽略已经是其他关键字子串的关键字。\n    for(j=0; j<nKeyword; j++){//双重循环遍历\n      Keyword *pOther;\n      if( j==i ) continue;//不和自己比较\n      pOther = &aKeywordTable[j];\n      if( pOther->substrId ) continue;//同样忽略已经是其他关键字子串的关键字。\n\n      //计算 p 的后缀和 pOther 的前缀最长多少是相同的\n      for(k=p->longestSuffix+1; k<p->len && k<pOther->len; k++){\n        if( memcmp(&p->zName[p->len-k], pOther->zName, k)==0 ){\n          p->longestSuffix = k;\n        }\n      }\n    }\n  }\n\n    /* Sort the table into reverse order by length */\n    /* 从关键字最长后缀相同长度的 最长到最短 做排序 */\n    qsort(aKeywordTable, nKeyword, sizeof(aKeywordTable[0]), keywordCompare2);\n```\n\n除了上面一节中找出的子串关键字以外，剩下的关键字中，找出每一个关键字的后缀与其他关键字前缀相同的最长长度。最后以这个值从大到小做排序。这个步骤看似好像没有什么实际作用，但是这也是关键的一步，后续再分析为什么需要这么做。\n\n### 计算压缩的最后结果\n\n``` c\n  /* Fill in the offset for all entries */\n  nChar = 0;\n  for(i=0; i<nKeyword; i++){\n    Keyword *p = &aKeywordTable[i];\n    if( p->offset>0 || p->substrId ) continue;\n    p->offset = nChar;\n    nChar += p->len;\n    for(k=p->len-1; k>=1; k--){\n      for(j=i+1; j<nKeyword; j++){\n        Keyword *pOther = &aKeywordTable[j];\n        if( pOther->offset>0 || pOther->substrId ) continue;\n        if( pOther->len<=k ) continue;\n        if( memcmp(&p->zName[p->len-k], pOther->zName, k)==0 ){\n          p = pOther;\n          p->offset = nChar - k;\n          nChar = p->offset + p->len;\n          p->zName += k;\n          p->len -= k;\n          p->prefix = k;\n          j = i;\n          k = p->len;\n        }\n      }\n    }\n  }\n\n  for(i=0; i<nKeyword; i++){\n    Keyword *p = &aKeywordTable[i];\n    //处理带subStrId的\n    if( p->substrId ){\n      p->offset = findById(p->substrId)->offset + p->substrOffset;\n    }\n  }\n```\n\n接下来对数组进行最后的压缩: 对数组进行遍历，遍历的目的是为了在当前关键字数组中，找到前缀与这个关键字后缀一样的关键字。并且，将这个关键字拼接在后面。\n\n举个例子:现有关键字`abcde``def``efg`,因为`def`的前缀`de`与`abcde`的后缀相同，所以在记录第二个关键字的时候，只需要记录`f`，与在前一个关键字中后缀偏移3即可。\n\n处理完所有的前后缀相接的字符串之后，再处理子串的问题，子串问题也就相对简单了。\n\n代码中可以注意到下面这几个问题:\n1. 在上一节最后会对关键字排序，排序方法是按照每个关键字的最长相同后缀降序排列。\n2. 在比较关键字的后缀是否一致的时候，从相同长度为(`k=p->len-1`)开始比较。但是找到前缀与之相同的字符串之后并没有立刻break。\n\n\n下面来解释这两个问题：\n\n* 首先SQLite希望，每次都是优先从与其他关键字前缀相同的更长后缀的的关键字中挑选出一个关键字，来拼接到关键字表后面。有点拗口，但是也不难以理解。这也就是为什么上一节中SQLite需要做一个看似“没有意义的”计算和排序。\n* 在找到一个关键字拼接的下一个关键字之后，注意`p = pOther;`当前的关键字p变成了下一个关键字pOther。这一步也不难理解，pOther将会变成下一步中寻找最长后缀的关键字。\n* 一直到所有的关键字都被check或者处理过(i==nKeyword)之后，才可以结束本次压缩。\n\n### 计算和生成最优的哈希表\n\n如何衡量一个哈希表是否是最优的呢？有两个指标，一个是*稀疏程度*，一个是*表的大小*。\n\n越稀疏，肯定会让哈希表的碰撞率越低，但是随之带来的就是size变大。就像时间复杂度和空间复杂度一样，毕竟鱼和熊掌不可兼得。\n\n那么如何去衡量这个哈希表的这两个指标呢？SQLite使用一个bestCount变量，来衡量。可以类似的理解为一个score得分。得分越高，哈希表代价(碰撞率和大小)越大，反之亦然。\n\n如何计算这个得分呢？既然有两个因素，那么必然有权重。如果简单一点设计的话，那就是 碰撞次数 * 权值1+哈希表大小 * 权值2，其中 权值1+权值2=1。SQLite设计的时候也是这个思路，但是不是等比分配权值。它认为，比起哈希表的大小来说，碰撞的代价要高的多的多。也就是说相对来说更加希望用空间来换时间。\n\n于是有了以下的算法：\n\n``` c\n  /* Figure out how big to make the hash table in order to minimize the\n  ** number of collisions */\n  /* 计算一下 最优的哈希表大小*/\n  // SQLite 从 [nKeyword, 2*nKeyword]之间选择一个合适的哈希表大小\n  // 如何选择？选择“碰撞值”最低？如何计算碰撞值？\n  bestSize = nKeyword;\n  bestCount = nKeyword*nKeyword;\n  for(i=nKeyword/2; i<=2*nKeyword; i++){\n    for(j=0; j<i; j++) aKWHash[j] = 0;\n    for(j=0; j<nKeyword; j++){\n      h = aKeywordTable[j].hash % i;\n      aKWHash[h] *= 2;\n      aKWHash[h]++;\n    }\n    for(j=count=0; j<i; j++) count += aKWHash[j];\n    if( count<bestCount ){\n      bestCount = count;\n      bestSize = i;\n    }\n  }\n```\n\n虽然希望查询速度快，但是也不能无限制大小。SQLite希望把哈希表的大小控制在[nKeyword, 2 x nKeyword]之间(毋庸置疑，最好的情况肯定是nKeyword，即所有值的哈希都不一样，一次碰撞都不发生)。在这个范围内计算每一个大小的哈希表的得分，算法为，计算所有关键字的哈希索引(即哈希值模当前的哈希表大小)，每发生一次碰撞的时候，把当前索引对应的值x2 并且加1，然后计算所有的值的总和。bestCount就存储了这个值。\n\n具体计算步骤：\n\n1. aKWHash默认值全部重置为0。\n2. 依次计算关键字中的哈希值，得到每一个关键字在哈希表中的索引。\n3. 将对应索引中的值*2 + 1（第一次命中的时候结果为1，第二次的时候结果为1*2+1=3，第三次的的时候结果为3*2+1=7）\n4. 计算所有aKWHash中值的和，这个和就是当前这个大小的aKWHash的\"score得分\"。\n5. 在哈希表大小为[nKeyword, 2 x nKeyword]的范围内，计算出其中\"score得分最低的\"一个大小。\n\n\n其中 x2 是一个\"放大因子\"，利用 x2 这个指数的增长来放大一次碰撞带来的影响。即碰撞冲突增加的时候，这个\"score\"会以指数级增长。2 就可以理解为哈希表大小和哈希碰撞之间\"权值\"，只不过不是等比关系，而是指数关系。如果希望碰撞的影响再大，那么可以把这个值改成 3，4，5...\n\n在`keywordhash.h`头文件顶部会输出当前哈希表的`Hash score`, 举个例子，在当前版本(3.27.2)下，如果支持所有的关键字，计算以 2 为“放大因子”的最合适的哈希表的`Hash score`为*208*。\n\n### 计算生成哈希表\n\n``` c\n/* Compute the hash */\n  for(i=0; i<bestSize; i++) aKWHash[i] = 0;\n  for(i=0; i<nKeyword; i++) {\n    //头插法..\n    h = aKeywordTable[i].hash % bestSize;\n    aKeywordTable[i].iNext = aKWHash[h];\n    aKWHash[h] = i+1;\n  }\n```\n\n从上一步计算的结果中可以得到，bestSize -> 最优的哈希表大小，bestCount -> 最优的哈希表得分。\n\n依次计算所有的关键字的哈希值，每个命中的哈希值存储的是当前索引+1。一旦发生冲突的时候，使用头插法，在冲突的哈希索引值存储一个链表。`iNext`即为next指针。\n\n到这里为止，整个哈希表的计算已经全部完成了......后面的代码生成也已经很简单了，纯字符串拼接。\n\n`aKeywordTable`是一个对象数组，自动输出代码的时候，将整个数组拆分成了N个数组。\n\n`zKWText`: 也就是`aKeywordTable`中每一个元素`KeyWord`的`zName`变量的拼接，即最终压缩后的所有关键字的字符。\n`aKWHash`: 每一个哈希值(索引)对应的关键字的索引。\n`aKWNext`: 哈希冲突时的链表。每一个索引下存储的值，表示，与该索引对应的关键字具有相同哈希值的下一个关键字的索引。\n`aKWLen` : 表示第i个关键字的字符长度。\n`aKWOffset` : 表示第一个关键字在`zKWText`字符表内的偏移长度。\n`aKWCode` : 返回给`parser`模块的关键字码。\n\n\n## 关键字的查询过程(函数keywordCode)\n\n正向的看函数`keywordCode(const char *z, int n, int *pType)`，也就是上面自动生成的代码，看下是否符合之前设计的预期。\n\n``` c\n/* Check to see if z[0..n-1] is a keyword. If it is, write the\n** parser symbol code for that keyword into *pType.  Always\n** return the integer n (the length of the token). */\nstatic int keywordCode(const char *z, int n, int *pType){\n  int i, j;\n  const char *zKW;\n  if( n>=2 ){\n    i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n) % 127;//计算关键字的散列索引\n    for(i=((int)aKWHash[i])-1; i>=0; i=((int)aKWNext[i])-1){\n      if( aKWLen[i]!=n ) continue;\n      j = 0;\n      zKW = &zKWText[aKWOffset[i]];\n#ifdef SQLITE_ASCII\n      while( j<n && (z[j]&~0x20)==zKW[j] ){ j++; }\n#endif\n#ifdef SQLITE_EBCDIC\n      while( j<n && toupper(z[j])==zKW[j] ){ j++; }\n#endif\n      if( j<n ) continue;\n      testcase( i==0 ); /* REINDEX */\n      testcase( i==1 ); /* INDEXED */\n    //   ......\n      testcase( i==135 ); /* PRIMARY */\n      *pType = aKWCode[i];\n      break;\n    }\n  }\n  return n;\n}\n```\n\n函数传入的有三个参数:第一个是需要判断的关键字的字符串的指针，第二个就是关键字的长度，第三个是函数需要返回的当前关键字的类型(也就是上面所说的，返回给`parser`的关键字码)。函数的返回值始终都是n，也就是关键字的长度。\n\n1. 关键字长度均大于2。\n2. 计算关键字的哈希值，以及哈希索引`i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n) % 127`。127是当前哈希表的大小，在生成代码的时候会自动计算。\n3. 从aKWHash[i]中获取到关键字的索引，遍历当前索引对应的aKWNext的链表。\n4. 先判断关键字的长度与当前参数是否相同。\n5. 从zKWText中获取到当前关键字的字符串，根据不同的编码进行比较。\n6. 重复第3步骤，直到找到字符串与关键字相同。（因为哈希有冲突，所以需要遍历哈希值对应的整个链表）\n","source":"_posts/19.SQLite-KeywordHash.md","raw":"---\ntitle: SQLite--KeywordHash\ndate: 2020-07-16\ntags: [sqlite3]\ntop: 300\ncategories: sqlite3\n---\n\n> SQLite 的关键字有很多个(在3.27.2版本就支持136个)。从用户侧输入一个SQL语句到Tokenize(词法分析器)的时候，SQLite如何快速判断一个单词是否是关键字呢？第一想法肯定是利用哈希表，SQLite也确实是如此。但是如何构建一个查询高效，存储占用低，而且还支持关键字\"裁剪\"的哈希表呢？这里从源码的角度来看，SQLite是如何一步一步的精简优化一个词法分析器的关键字查询表的。\n\n<!-- more -->\n\n## SQLite源码的构成\n\nSQLite本身是可以支持用cmake通过宏来裁剪功能和扩展功能的。在编译源码的过程中，会通过autoconfig生成一个Makefile。而Makefile的依赖中有一个`keywordhash.h`的文件。这个头文件就是用来做哈希表的构建的。可以看下Makefile中这个头文件的依赖与command。\n\n``` c\nkeywordhash.h:\t$(TOP)/tool/mkkeywordhash.c\n\t$(BCC) -o mkkeywordhash $(OPTS) $(TOP)/tool/mkkeywordhash.c\n\t./mkkeywordhash >keywordhash.h\n```\n\n这个文件只依赖`$(TOP)/tool/mkkeywordhash.c`这个文件的变更，并且command为:编译链接这个`mkkeywordhash.c`的源码，并且执行编译后的可执行文件，将输出重定向到`keywordhash.h`。那么到这里可以判断出`keywordhash.h`这个文件是`mkkeywordhash`这个程序生成的。\n\n在`keywordhash.h`文件的开头注释也写的很清楚:\n\n``` c\n** The code in this file has been automatically generated by\n**\n**   sqlite/tool/mkkeywordhash.c\n**\n** The code in this file implements a function that determines whether\n** or not a given identifier is really an SQL keyword.  The same thing\n** might be implemented more directly using a hand-written hash table.\n** But by using this automatically generated code, the size of the code\n** is substantially reduced.  This is important for embedded applications\n** on platforms with limited memory.\n```\n\n注释写到，直接用hand-written(手写)的哈希表也可以达到同一个目的。但是为了达到极致的内存和性能等，SQLite做了更多的优化。\n\n## 为什么要使用mkkeywordhash？\n\n上面提到了，SQLite完全可以通过一个纯手写的哈希表来达到快速查询一个单词是否是SQL关键字的目的。但是，使用SQLite的一般都是移动或者嵌入式设备，那么内存必然是需要考虑的一个因素。136个关键字，加上哈希表的散列，内存消耗还是非常可观的。总结使用`mkkeywordhash`有以下的优点:\n\n1. 支持裁剪。支持使用宏，动态地在编译期就可以决定SQLite支持哪些关键字(因为在编译期就会使用mkkeywordhash来动态生成源码)。\n2. 支持动态关键字压缩。`mkkeywordhash`压缩了所有的关键字，压缩对象为前缀与其他关键字前缀相同的关键字，或者是其他关键字子串的关键字。例:`REINDEX`的后缀和`INDEXED`的前缀一致；`INDEX`是`REINDEX`的子串\n3. 支持动态创建静态的哈希表。这句话怎么理解？静态哈希表可以理解：最终生成的哈希表肯定是静态的，因为SQLite编译后支持的关键字始终是固定的。动态创建是指，可以通过宏来动态决定这个关键字哈希表的大小，内容，以及哈希表的*碰撞率*。\n\n注意这里说的动态，是指在编译期根据不同的需求，*动态*的来定制SQLite，而不是运行期的动态输入输出。\n\n下面来详细看下这个`mkkeywordhash.c`的源码，看看SQLite在编译期间是如何动态生成需要的关键字哈希表的:\n\n## mkkeywordhash.c\n\n### 关键字的数据结构\n\n``` c\n/*\n** All the keywords of the SQL language are stored in a hash\n** table composed of instances of the following structure.\n*/\ntypedef struct Keyword Keyword;\nstruct Keyword {\n  char *zName;         /* The keyword name */\n  char *zTokenType;    /* Token value for this keyword */\n  int mask;            /* Code this keyword if non-zero */\n  int id;              /* Unique ID for this record */\n  int hash;            /* Hash on the keyword */\n  int offset;          /* Offset to start of name string */\n  int len;             /* Length of this keyword, not counting final \\000 */\n  int prefix;          /* Number of characters in prefix */\n  int longestSuffix;   /* Longest suffix that is a prefix on another word */\n  int iNext;           /* Index in aKeywordTable[] of next with same hash */\n  int substrId;        /* Id to another keyword this keyword is embedded in */\n  int substrOffset;    /* Offset into substrId for start of this keyword */\n  char zOrigName[20];  /* Original keyword name before processing */\n};\n```\n\n这里需要说明一下，这个数据结构是用于`mkkeywordhash.c`，用来组织和描述所有需要编译进去的关键字的数据结构。在最后`mkkeywordhash`会根据计算好的所有关键字的`KeyWord`对象来生成最终的`keywordhash.h`文件中的静态哈希表。\n\n* char *zName:           关键字字符串，最终会变成压缩后的关键字字符串。  \n* char *zTokenType:      关键字类型，在tokenize暴露给外层类型。\n* int mask:              不同的关键字可能是属于同一个功能的，宏的控制就通过控制mask的值来开启或者关闭同一类的能力\n* int id:                关键字的id，会以关键字在数组中的索引值作为id，意义不大。\n* int hash:              关键字的哈希值\n* int offset:            关键字在压缩后的字符串表中的起始偏移\n* int len:               关键字的原始长度\n* int prefix:            关键字前缀和其他关键字后缀重叠部分的长度\n* int longestSuffix:     当前关键字后缀和其他关键字前缀重叠部分的最长长度\n* int iNext:             当哈希表发生碰撞的时候，通过链表来存储\n* int substrId:          如果当前关键字是另一个关键字子串的时候，substrId就是另一个关键字的Id\n* int substrOffset:      在substrId不为空的情况下，substrOffset标识子串开始的偏移\n* char zOrigName[20]:    关键字原始字符串\n\n全局静态变量 aKeywordTable 存储了目前支持的所有的关键字。\n\n``` c\nstatic Keyword aKeywordTable[] = {\n  { \"ABORT\",            \"TK_ABORT\",        CONFLICT|TRIGGER       },\n  { \"ACTION\",           \"TK_ACTION\",       FKEY                   },\n  { \"ADD\",              \"TK_ADD\",          ALTER                  },\n  { \"AFTER\",            \"TK_AFTER\",        TRIGGER                },\n  /* ... 136个关键字 ... */\n};\n```\n\n### 基本处理流程\n\n`mkkeywordhash`分成了几个步骤:\n\n### 裁剪不支持的关键字\n\n在`mkkeywordhash` main函数开始的第一步就是裁减掉不使用的关键字，如何裁剪？\n\n在 aKeywordTable 和 `Keyword` 的数据结构里可以看到，每一个关键字都给予了一个mask，这个mask可以理解为关键字的tag，不同的mask值不一样，不同的关键字可以同时具有相同的mask，同一个mask可以具有多个mask。SQLite通过定义mask的值来确定是否需要裁剪。\n\n``` c\n#ifdef SQLITE_OMIT_ALTERTABLE\n#  define ALTER      0\n#else\n#  define ALTER      0x00000001\n#endif\n```\n\n例如，如果定义了`SQLITE_OMIT_ALTERTABLE`宏，那么`ALTER`就会被定义为0，那么只具有`ALTER`mask的关键字的mask值就会被标记为0。\n\n``` c\n/* Remove entries from the list of keywords that have mask==0 */\nfor(i=j=0; i<nKeyword; i++){\n    if( aKeywordTable[i].mask==0 ) continue;\n    if( j<i ){\n      aKeywordTable[j] = aKeywordTable[i];\n    }\n    j++;\n}\nnKeyword = j;\n```\n然后通过遍历 akeywordTable 数组，过滤掉所有关键字mask为0的关键字，遍历的时候使用了快慢指针，分别指向当前遍历索引和存储的索引。\n\n### 数据结构和计算哈希值\n\n``` c\nfor(i=0; i<nKeyword; i++){\n    Keyword *p = &aKeywordTable[i];\n    p->len = (int)strlen(p->zName);\n    assert( p->len<sizeof(p->zOrigName) );\n    memcpy(p->zOrigName, p->zName, p->len+1);\n    totalLen += p->len;\n    p->hash = (charMap(p->zName[0])*4) ^\n              (charMap(p->zName[p->len-1])*3) ^ (p->len*1);\n    p->id = i+1;\n}\n```\n\n在裁剪完成之后，当前aKeywordTable里的nKeyword个关键字就是SQLite本次编译需要支持的所有关键字了。\n\n* 以每一个关键字的索引作为id\n* p->len 存关键字的原始长度\n* p->zOrigName 存储原始字符串，也就是当前 的p->zName 字段\n* 哈希算法:(关键字的第一个字符*4)^(关键字的最后一个字符*3)^(关键字名字的长度)) 大致从aKeywordTable中的关键字看到，首尾字符已经可以获得很少的哈希冲突了。\n\n### 完全子串的关系查找\n\n首先可以压缩的情况就是，A串是B串的子串，这种情况下，我们只需要记录A串是B串子串的这一关系，以及A在B中起始的偏移值既可。\n\n``` c\n/* Sort the table from shortest to longest keyword */\n/* 从关键字字符串长度的最短到最长做排序 */\nqsort(aKeywordTable, nKeyword, sizeof(aKeywordTable[0]), keywordCompare1);\n\n/* Look for short keywords embedded in longer keywords */\n/* 从数组中找到，某些关键字是另一些关键字子串的情况，例如,IN是INDEX的子串，INDEX是INDEXED的子串*/\nfor(i=nKeyword-2; i>=0; i--){//从倒数第二个开始\n    Keyword *p = &aKeywordTable[i];//p: 当前关键字\n    for(j=nKeyword-1; j>i && p->substrId==0; j--){//依次判断当前关键字，是否是其他关键字(其他关键字从最后向前遍历)的子串\n        Keyword *pOther = &aKeywordTable[j];\n        if( pOther->substrId ) continue;\n        if( pOther->len<=p->len ) continue;\n\n        //判断 p 是不是 pOther 关键字的子串\n        for(k=0; k<=pOther->len-p->len; k++){\n            if( memcmp(p->zName, &pOther->zName[k], p->len)==0 ){\n                p->substrId = pOther->id;\n                p->substrOffset = k;\n                break;\n            }\n        }\n    }\n}\n```\n\n* 如果A是B的子串，那么A的长度必然不长于B。所以先按照长度，从短到长排序。\n* 如果A是B的子串，那么A的substrId会被记录为B的Id，A的substrOffset会被记录为子串的起始偏移。\n\n### 前缀、后缀的进一步压缩\n\n``` c\n  /* Compute the longestSuffix value for every word */\n  /* 进步压缩，除了完全包含其他关键字的以外，其他关键字中，\n    每一个关键字的后缀中与其他关键字的前缀相等的最长长度是多少 */\n  for(i=0; i<nKeyword; i++){//遍历所有关键字\n    Keyword *p = &aKeywordTable[i];\n    if( p->substrId ) continue;//忽略已经是其他关键字子串的关键字。\n    for(j=0; j<nKeyword; j++){//双重循环遍历\n      Keyword *pOther;\n      if( j==i ) continue;//不和自己比较\n      pOther = &aKeywordTable[j];\n      if( pOther->substrId ) continue;//同样忽略已经是其他关键字子串的关键字。\n\n      //计算 p 的后缀和 pOther 的前缀最长多少是相同的\n      for(k=p->longestSuffix+1; k<p->len && k<pOther->len; k++){\n        if( memcmp(&p->zName[p->len-k], pOther->zName, k)==0 ){\n          p->longestSuffix = k;\n        }\n      }\n    }\n  }\n\n    /* Sort the table into reverse order by length */\n    /* 从关键字最长后缀相同长度的 最长到最短 做排序 */\n    qsort(aKeywordTable, nKeyword, sizeof(aKeywordTable[0]), keywordCompare2);\n```\n\n除了上面一节中找出的子串关键字以外，剩下的关键字中，找出每一个关键字的后缀与其他关键字前缀相同的最长长度。最后以这个值从大到小做排序。这个步骤看似好像没有什么实际作用，但是这也是关键的一步，后续再分析为什么需要这么做。\n\n### 计算压缩的最后结果\n\n``` c\n  /* Fill in the offset for all entries */\n  nChar = 0;\n  for(i=0; i<nKeyword; i++){\n    Keyword *p = &aKeywordTable[i];\n    if( p->offset>0 || p->substrId ) continue;\n    p->offset = nChar;\n    nChar += p->len;\n    for(k=p->len-1; k>=1; k--){\n      for(j=i+1; j<nKeyword; j++){\n        Keyword *pOther = &aKeywordTable[j];\n        if( pOther->offset>0 || pOther->substrId ) continue;\n        if( pOther->len<=k ) continue;\n        if( memcmp(&p->zName[p->len-k], pOther->zName, k)==0 ){\n          p = pOther;\n          p->offset = nChar - k;\n          nChar = p->offset + p->len;\n          p->zName += k;\n          p->len -= k;\n          p->prefix = k;\n          j = i;\n          k = p->len;\n        }\n      }\n    }\n  }\n\n  for(i=0; i<nKeyword; i++){\n    Keyword *p = &aKeywordTable[i];\n    //处理带subStrId的\n    if( p->substrId ){\n      p->offset = findById(p->substrId)->offset + p->substrOffset;\n    }\n  }\n```\n\n接下来对数组进行最后的压缩: 对数组进行遍历，遍历的目的是为了在当前关键字数组中，找到前缀与这个关键字后缀一样的关键字。并且，将这个关键字拼接在后面。\n\n举个例子:现有关键字`abcde``def``efg`,因为`def`的前缀`de`与`abcde`的后缀相同，所以在记录第二个关键字的时候，只需要记录`f`，与在前一个关键字中后缀偏移3即可。\n\n处理完所有的前后缀相接的字符串之后，再处理子串的问题，子串问题也就相对简单了。\n\n代码中可以注意到下面这几个问题:\n1. 在上一节最后会对关键字排序，排序方法是按照每个关键字的最长相同后缀降序排列。\n2. 在比较关键字的后缀是否一致的时候，从相同长度为(`k=p->len-1`)开始比较。但是找到前缀与之相同的字符串之后并没有立刻break。\n\n\n下面来解释这两个问题：\n\n* 首先SQLite希望，每次都是优先从与其他关键字前缀相同的更长后缀的的关键字中挑选出一个关键字，来拼接到关键字表后面。有点拗口，但是也不难以理解。这也就是为什么上一节中SQLite需要做一个看似“没有意义的”计算和排序。\n* 在找到一个关键字拼接的下一个关键字之后，注意`p = pOther;`当前的关键字p变成了下一个关键字pOther。这一步也不难理解，pOther将会变成下一步中寻找最长后缀的关键字。\n* 一直到所有的关键字都被check或者处理过(i==nKeyword)之后，才可以结束本次压缩。\n\n### 计算和生成最优的哈希表\n\n如何衡量一个哈希表是否是最优的呢？有两个指标，一个是*稀疏程度*，一个是*表的大小*。\n\n越稀疏，肯定会让哈希表的碰撞率越低，但是随之带来的就是size变大。就像时间复杂度和空间复杂度一样，毕竟鱼和熊掌不可兼得。\n\n那么如何去衡量这个哈希表的这两个指标呢？SQLite使用一个bestCount变量，来衡量。可以类似的理解为一个score得分。得分越高，哈希表代价(碰撞率和大小)越大，反之亦然。\n\n如何计算这个得分呢？既然有两个因素，那么必然有权重。如果简单一点设计的话，那就是 碰撞次数 * 权值1+哈希表大小 * 权值2，其中 权值1+权值2=1。SQLite设计的时候也是这个思路，但是不是等比分配权值。它认为，比起哈希表的大小来说，碰撞的代价要高的多的多。也就是说相对来说更加希望用空间来换时间。\n\n于是有了以下的算法：\n\n``` c\n  /* Figure out how big to make the hash table in order to minimize the\n  ** number of collisions */\n  /* 计算一下 最优的哈希表大小*/\n  // SQLite 从 [nKeyword, 2*nKeyword]之间选择一个合适的哈希表大小\n  // 如何选择？选择“碰撞值”最低？如何计算碰撞值？\n  bestSize = nKeyword;\n  bestCount = nKeyword*nKeyword;\n  for(i=nKeyword/2; i<=2*nKeyword; i++){\n    for(j=0; j<i; j++) aKWHash[j] = 0;\n    for(j=0; j<nKeyword; j++){\n      h = aKeywordTable[j].hash % i;\n      aKWHash[h] *= 2;\n      aKWHash[h]++;\n    }\n    for(j=count=0; j<i; j++) count += aKWHash[j];\n    if( count<bestCount ){\n      bestCount = count;\n      bestSize = i;\n    }\n  }\n```\n\n虽然希望查询速度快，但是也不能无限制大小。SQLite希望把哈希表的大小控制在[nKeyword, 2 x nKeyword]之间(毋庸置疑，最好的情况肯定是nKeyword，即所有值的哈希都不一样，一次碰撞都不发生)。在这个范围内计算每一个大小的哈希表的得分，算法为，计算所有关键字的哈希索引(即哈希值模当前的哈希表大小)，每发生一次碰撞的时候，把当前索引对应的值x2 并且加1，然后计算所有的值的总和。bestCount就存储了这个值。\n\n具体计算步骤：\n\n1. aKWHash默认值全部重置为0。\n2. 依次计算关键字中的哈希值，得到每一个关键字在哈希表中的索引。\n3. 将对应索引中的值*2 + 1（第一次命中的时候结果为1，第二次的时候结果为1*2+1=3，第三次的的时候结果为3*2+1=7）\n4. 计算所有aKWHash中值的和，这个和就是当前这个大小的aKWHash的\"score得分\"。\n5. 在哈希表大小为[nKeyword, 2 x nKeyword]的范围内，计算出其中\"score得分最低的\"一个大小。\n\n\n其中 x2 是一个\"放大因子\"，利用 x2 这个指数的增长来放大一次碰撞带来的影响。即碰撞冲突增加的时候，这个\"score\"会以指数级增长。2 就可以理解为哈希表大小和哈希碰撞之间\"权值\"，只不过不是等比关系，而是指数关系。如果希望碰撞的影响再大，那么可以把这个值改成 3，4，5...\n\n在`keywordhash.h`头文件顶部会输出当前哈希表的`Hash score`, 举个例子，在当前版本(3.27.2)下，如果支持所有的关键字，计算以 2 为“放大因子”的最合适的哈希表的`Hash score`为*208*。\n\n### 计算生成哈希表\n\n``` c\n/* Compute the hash */\n  for(i=0; i<bestSize; i++) aKWHash[i] = 0;\n  for(i=0; i<nKeyword; i++) {\n    //头插法..\n    h = aKeywordTable[i].hash % bestSize;\n    aKeywordTable[i].iNext = aKWHash[h];\n    aKWHash[h] = i+1;\n  }\n```\n\n从上一步计算的结果中可以得到，bestSize -> 最优的哈希表大小，bestCount -> 最优的哈希表得分。\n\n依次计算所有的关键字的哈希值，每个命中的哈希值存储的是当前索引+1。一旦发生冲突的时候，使用头插法，在冲突的哈希索引值存储一个链表。`iNext`即为next指针。\n\n到这里为止，整个哈希表的计算已经全部完成了......后面的代码生成也已经很简单了，纯字符串拼接。\n\n`aKeywordTable`是一个对象数组，自动输出代码的时候，将整个数组拆分成了N个数组。\n\n`zKWText`: 也就是`aKeywordTable`中每一个元素`KeyWord`的`zName`变量的拼接，即最终压缩后的所有关键字的字符。\n`aKWHash`: 每一个哈希值(索引)对应的关键字的索引。\n`aKWNext`: 哈希冲突时的链表。每一个索引下存储的值，表示，与该索引对应的关键字具有相同哈希值的下一个关键字的索引。\n`aKWLen` : 表示第i个关键字的字符长度。\n`aKWOffset` : 表示第一个关键字在`zKWText`字符表内的偏移长度。\n`aKWCode` : 返回给`parser`模块的关键字码。\n\n\n## 关键字的查询过程(函数keywordCode)\n\n正向的看函数`keywordCode(const char *z, int n, int *pType)`，也就是上面自动生成的代码，看下是否符合之前设计的预期。\n\n``` c\n/* Check to see if z[0..n-1] is a keyword. If it is, write the\n** parser symbol code for that keyword into *pType.  Always\n** return the integer n (the length of the token). */\nstatic int keywordCode(const char *z, int n, int *pType){\n  int i, j;\n  const char *zKW;\n  if( n>=2 ){\n    i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n) % 127;//计算关键字的散列索引\n    for(i=((int)aKWHash[i])-1; i>=0; i=((int)aKWNext[i])-1){\n      if( aKWLen[i]!=n ) continue;\n      j = 0;\n      zKW = &zKWText[aKWOffset[i]];\n#ifdef SQLITE_ASCII\n      while( j<n && (z[j]&~0x20)==zKW[j] ){ j++; }\n#endif\n#ifdef SQLITE_EBCDIC\n      while( j<n && toupper(z[j])==zKW[j] ){ j++; }\n#endif\n      if( j<n ) continue;\n      testcase( i==0 ); /* REINDEX */\n      testcase( i==1 ); /* INDEXED */\n    //   ......\n      testcase( i==135 ); /* PRIMARY */\n      *pType = aKWCode[i];\n      break;\n    }\n  }\n  return n;\n}\n```\n\n函数传入的有三个参数:第一个是需要判断的关键字的字符串的指针，第二个就是关键字的长度，第三个是函数需要返回的当前关键字的类型(也就是上面所说的，返回给`parser`的关键字码)。函数的返回值始终都是n，也就是关键字的长度。\n\n1. 关键字长度均大于2。\n2. 计算关键字的哈希值，以及哈希索引`i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n) % 127`。127是当前哈希表的大小，在生成代码的时候会自动计算。\n3. 从aKWHash[i]中获取到关键字的索引，遍历当前索引对应的aKWNext的链表。\n4. 先判断关键字的长度与当前参数是否相同。\n5. 从zKWText中获取到当前关键字的字符串，根据不同的编码进行比较。\n6. 重复第3步骤，直到找到字符串与关键字相同。（因为哈希有冲突，所以需要遍历哈希值对应的整个链表）\n","slug":"19.SQLite-KeywordHash","published":1,"updated":"2022-07-28T13:38:40.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwo6000tp9c92z617a4j","content":"<blockquote>\n<p>SQLite 的关键字有很多个(在3.27.2版本就支持136个)。从用户侧输入一个SQL语句到Tokenize(词法分析器)的时候，SQLite如何快速判断一个单词是否是关键字呢？第一想法肯定是利用哈希表，SQLite也确实是如此。但是如何构建一个查询高效，存储占用低，而且还支持关键字”裁剪”的哈希表呢？这里从源码的角度来看，SQLite是如何一步一步的精简优化一个词法分析器的关键字查询表的。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"SQLite源码的构成\"><a href=\"#SQLite源码的构成\" class=\"headerlink\" title=\"SQLite源码的构成\"></a>SQLite源码的构成</h2><p>SQLite本身是可以支持用cmake通过宏来裁剪功能和扩展功能的。在编译源码的过程中，会通过autoconfig生成一个Makefile。而Makefile的依赖中有一个<code>keywordhash.h</code>的文件。这个头文件就是用来做哈希表的构建的。可以看下Makefile中这个头文件的依赖与command。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keywordhash.h:\t$(TOP)/tool/mkkeywordhash.c</span><br><span class=\"line\">\t$(BCC) -o mkkeywordhash $(OPTS) $(TOP)/tool/mkkeywordhash.c</span><br><span class=\"line\">\t./mkkeywordhash &gt;keywordhash.h</span><br></pre></td></tr></table></figure>\n\n<p>这个文件只依赖<code>$(TOP)/tool/mkkeywordhash.c</code>这个文件的变更，并且command为:编译链接这个<code>mkkeywordhash.c</code>的源码，并且执行编译后的可执行文件，将输出重定向到<code>keywordhash.h</code>。那么到这里可以判断出<code>keywordhash.h</code>这个文件是<code>mkkeywordhash</code>这个程序生成的。</p>\n<p>在<code>keywordhash.h</code>文件的开头注释也写的很清楚:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">** The code in this file has been automatically generated by</span><br><span class=\"line\">**</span><br><span class=\"line\">**   sqlite/tool/mkkeywordhash.c</span><br><span class=\"line\">**</span><br><span class=\"line\">** The code in this file implements a function that determines whether</span><br><span class=\"line\">** or not a given identifier is really an SQL keyword.  The same thing</span><br><span class=\"line\">** might be implemented more directly using a hand-written hash table.</span><br><span class=\"line\">** But by using this automatically generated code, the size of the code</span><br><span class=\"line\">** is substantially reduced.  This is important <span class=\"keyword\">for</span> embedded applications</span><br><span class=\"line\">** on platforms with limited memory.</span><br></pre></td></tr></table></figure>\n\n<p>注释写到，直接用hand-written(手写)的哈希表也可以达到同一个目的。但是为了达到极致的内存和性能等，SQLite做了更多的优化。</p>\n<h2 id=\"为什么要使用mkkeywordhash？\"><a href=\"#为什么要使用mkkeywordhash？\" class=\"headerlink\" title=\"为什么要使用mkkeywordhash？\"></a>为什么要使用mkkeywordhash？</h2><p>上面提到了，SQLite完全可以通过一个纯手写的哈希表来达到快速查询一个单词是否是SQL关键字的目的。但是，使用SQLite的一般都是移动或者嵌入式设备，那么内存必然是需要考虑的一个因素。136个关键字，加上哈希表的散列，内存消耗还是非常可观的。总结使用<code>mkkeywordhash</code>有以下的优点:</p>\n<ol>\n<li>支持裁剪。支持使用宏，动态地在编译期就可以决定SQLite支持哪些关键字(因为在编译期就会使用mkkeywordhash来动态生成源码)。</li>\n<li>支持动态关键字压缩。<code>mkkeywordhash</code>压缩了所有的关键字，压缩对象为前缀与其他关键字前缀相同的关键字，或者是其他关键字子串的关键字。例:<code>REINDEX</code>的后缀和<code>INDEXED</code>的前缀一致；<code>INDEX</code>是<code>REINDEX</code>的子串</li>\n<li>支持动态创建静态的哈希表。这句话怎么理解？静态哈希表可以理解：最终生成的哈希表肯定是静态的，因为SQLite编译后支持的关键字始终是固定的。动态创建是指，可以通过宏来动态决定这个关键字哈希表的大小，内容，以及哈希表的<em>碰撞率</em>。</li>\n</ol>\n<p>注意这里说的动态，是指在编译期根据不同的需求，<em>动态</em>的来定制SQLite，而不是运行期的动态输入输出。</p>\n<p>下面来详细看下这个<code>mkkeywordhash.c</code>的源码，看看SQLite在编译期间是如何动态生成需要的关键字哈希表的:</p>\n<h2 id=\"mkkeywordhash-c\"><a href=\"#mkkeywordhash-c\" class=\"headerlink\" title=\"mkkeywordhash.c\"></a>mkkeywordhash.c</h2><h3 id=\"关键字的数据结构\"><a href=\"#关键字的数据结构\" class=\"headerlink\" title=\"关键字的数据结构\"></a>关键字的数据结构</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** All the keywords of the SQL language are stored in a hash</span></span><br><span class=\"line\"><span class=\"comment\">** table composed of instances of the following structure.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Keyword</span> <span class=\"title\">Keyword</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Keyword</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *zName;         <span class=\"comment\">/* The keyword name */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *zTokenType;    <span class=\"comment\">/* Token value for this keyword */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> mask;            <span class=\"comment\">/* Code this keyword if non-zero */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> id;              <span class=\"comment\">/* Unique ID for this record */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> hash;            <span class=\"comment\">/* Hash on the keyword */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> offset;          <span class=\"comment\">/* Offset to start of name string */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> len;             <span class=\"comment\">/* Length of this keyword, not counting final \\000 */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> prefix;          <span class=\"comment\">/* Number of characters in prefix */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> longestSuffix;   <span class=\"comment\">/* Longest suffix that is a prefix on another word */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> iNext;           <span class=\"comment\">/* Index in aKeywordTable[] of next with same hash */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> substrId;        <span class=\"comment\">/* Id to another keyword this keyword is embedded in */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> substrOffset;    <span class=\"comment\">/* Offset into substrId for start of this keyword */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> zOrigName[<span class=\"number\">20</span>];  <span class=\"comment\">/* Original keyword name before processing */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要说明一下，这个数据结构是用于<code>mkkeywordhash.c</code>，用来组织和描述所有需要编译进去的关键字的数据结构。在最后<code>mkkeywordhash</code>会根据计算好的所有关键字的<code>KeyWord</code>对象来生成最终的<code>keywordhash.h</code>文件中的静态哈希表。</p>\n<ul>\n<li>char *zName:           关键字字符串，最终会变成压缩后的关键字字符串。  </li>\n<li>char *zTokenType:      关键字类型，在tokenize暴露给外层类型。</li>\n<li>int mask:              不同的关键字可能是属于同一个功能的，宏的控制就通过控制mask的值来开启或者关闭同一类的能力</li>\n<li>int id:                关键字的id，会以关键字在数组中的索引值作为id，意义不大。</li>\n<li>int hash:              关键字的哈希值</li>\n<li>int offset:            关键字在压缩后的字符串表中的起始偏移</li>\n<li>int len:               关键字的原始长度</li>\n<li>int prefix:            关键字前缀和其他关键字后缀重叠部分的长度</li>\n<li>int longestSuffix:     当前关键字后缀和其他关键字前缀重叠部分的最长长度</li>\n<li>int iNext:             当哈希表发生碰撞的时候，通过链表来存储</li>\n<li>int substrId:          如果当前关键字是另一个关键字子串的时候，substrId就是另一个关键字的Id</li>\n<li>int substrOffset:      在substrId不为空的情况下，substrOffset标识子串开始的偏移</li>\n<li>char zOrigName[20]:    关键字原始字符串</li>\n</ul>\n<p>全局静态变量 aKeywordTable 存储了目前支持的所有的关键字。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> Keyword aKeywordTable[] = &#123;</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;ABORT&quot;</span>,            <span class=\"string\">&quot;TK_ABORT&quot;</span>,        CONFLICT|TRIGGER       &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;ACTION&quot;</span>,           <span class=\"string\">&quot;TK_ACTION&quot;</span>,       FKEY                   &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;ADD&quot;</span>,              <span class=\"string\">&quot;TK_ADD&quot;</span>,          ALTER                  &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;AFTER&quot;</span>,            <span class=\"string\">&quot;TK_AFTER&quot;</span>,        TRIGGER                &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/* ... 136个关键字 ... */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本处理流程\"><a href=\"#基本处理流程\" class=\"headerlink\" title=\"基本处理流程\"></a>基本处理流程</h3><p><code>mkkeywordhash</code>分成了几个步骤:</p>\n<h3 id=\"裁剪不支持的关键字\"><a href=\"#裁剪不支持的关键字\" class=\"headerlink\" title=\"裁剪不支持的关键字\"></a>裁剪不支持的关键字</h3><p>在<code>mkkeywordhash</code> main函数开始的第一步就是裁减掉不使用的关键字，如何裁剪？</p>\n<p>在 aKeywordTable 和 <code>Keyword</code> 的数据结构里可以看到，每一个关键字都给予了一个mask，这个mask可以理解为关键字的tag，不同的mask值不一样，不同的关键字可以同时具有相同的mask，同一个mask可以具有多个mask。SQLite通过定义mask的值来确定是否需要裁剪。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> SQLITE_OMIT_ALTERTABLE</span></span><br><span class=\"line\"><span class=\"meta\">#  <span class=\"keyword\">define</span> ALTER      0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#  <span class=\"keyword\">define</span> ALTER      0x00000001</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>例如，如果定义了<code>SQLITE_OMIT_ALTERTABLE</code>宏，那么<code>ALTER</code>就会被定义为0，那么只具有<code>ALTER</code>mask的关键字的mask值就会被标记为0。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Remove entries from the list of keywords that have mask==0 */</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=j=<span class=\"number\">0</span>; i&lt;nKeyword; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( aKeywordTable[i].mask==<span class=\"number\">0</span> ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( j&lt;i )&#123;</span><br><span class=\"line\">      aKeywordTable[j] = aKeywordTable[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    j++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nKeyword = j;</span><br></pre></td></tr></table></figure>\n<p>然后通过遍历 akeywordTable 数组，过滤掉所有关键字mask为0的关键字，遍历的时候使用了快慢指针，分别指向当前遍历索引和存储的索引。</p>\n<h3 id=\"数据结构和计算哈希值\"><a href=\"#数据结构和计算哈希值\" class=\"headerlink\" title=\"数据结构和计算哈希值\"></a>数据结构和计算哈希值</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;nKeyword; i++)&#123;</span><br><span class=\"line\">    Keyword *p = &amp;aKeywordTable[i];</span><br><span class=\"line\">    p-&gt;len = (<span class=\"type\">int</span>)<span class=\"built_in\">strlen</span>(p-&gt;zName);</span><br><span class=\"line\">    assert( p-&gt;len&lt;<span class=\"keyword\">sizeof</span>(p-&gt;zOrigName) );</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(p-&gt;zOrigName, p-&gt;zName, p-&gt;len+<span class=\"number\">1</span>);</span><br><span class=\"line\">    totalLen += p-&gt;len;</span><br><span class=\"line\">    p-&gt;hash = (charMap(p-&gt;zName[<span class=\"number\">0</span>])*<span class=\"number\">4</span>) ^</span><br><span class=\"line\">              (charMap(p-&gt;zName[p-&gt;len<span class=\"number\">-1</span>])*<span class=\"number\">3</span>) ^ (p-&gt;len*<span class=\"number\">1</span>);</span><br><span class=\"line\">    p-&gt;id = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在裁剪完成之后，当前aKeywordTable里的nKeyword个关键字就是SQLite本次编译需要支持的所有关键字了。</p>\n<ul>\n<li>以每一个关键字的索引作为id</li>\n<li>p-&gt;len 存关键字的原始长度</li>\n<li>p-&gt;zOrigName 存储原始字符串，也就是当前 的p-&gt;zName 字段</li>\n<li>哈希算法:(关键字的第一个字符<em>4)^(关键字的最后一个字符</em>3)^(关键字名字的长度)) 大致从aKeywordTable中的关键字看到，首尾字符已经可以获得很少的哈希冲突了。</li>\n</ul>\n<h3 id=\"完全子串的关系查找\"><a href=\"#完全子串的关系查找\" class=\"headerlink\" title=\"完全子串的关系查找\"></a>完全子串的关系查找</h3><p>首先可以压缩的情况就是，A串是B串的子串，这种情况下，我们只需要记录A串是B串子串的这一关系，以及A在B中起始的偏移值既可。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Sort the table from shortest to longest keyword */</span></span><br><span class=\"line\"><span class=\"comment\">/* 从关键字字符串长度的最短到最长做排序 */</span></span><br><span class=\"line\">qsort(aKeywordTable, nKeyword, <span class=\"keyword\">sizeof</span>(aKeywordTable[<span class=\"number\">0</span>]), keywordCompare1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Look for short keywords embedded in longer keywords */</span></span><br><span class=\"line\"><span class=\"comment\">/* 从数组中找到，某些关键字是另一些关键字子串的情况，例如,IN是INDEX的子串，INDEX是INDEXED的子串*/</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=nKeyword<span class=\"number\">-2</span>; i&gt;=<span class=\"number\">0</span>; i--)&#123;<span class=\"comment\">//从倒数第二个开始</span></span><br><span class=\"line\">    Keyword *p = &amp;aKeywordTable[i];<span class=\"comment\">//p: 当前关键字</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j=nKeyword<span class=\"number\">-1</span>; j&gt;i &amp;&amp; p-&gt;substrId==<span class=\"number\">0</span>; j--)&#123;<span class=\"comment\">//依次判断当前关键字，是否是其他关键字(其他关键字从最后向前遍历)的子串</span></span><br><span class=\"line\">        Keyword *pOther = &amp;aKeywordTable[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( pOther-&gt;substrId ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( pOther-&gt;len&lt;=p-&gt;len ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//判断 p 是不是 pOther 关键字的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(k=<span class=\"number\">0</span>; k&lt;=pOther-&gt;len-p-&gt;len; k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( <span class=\"built_in\">memcmp</span>(p-&gt;zName, &amp;pOther-&gt;zName[k], p-&gt;len)==<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                p-&gt;substrId = pOther-&gt;id;</span><br><span class=\"line\">                p-&gt;substrOffset = k;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果A是B的子串，那么A的长度必然不长于B。所以先按照长度，从短到长排序。</li>\n<li>如果A是B的子串，那么A的substrId会被记录为B的Id，A的substrOffset会被记录为子串的起始偏移。</li>\n</ul>\n<h3 id=\"前缀、后缀的进一步压缩\"><a href=\"#前缀、后缀的进一步压缩\" class=\"headerlink\" title=\"前缀、后缀的进一步压缩\"></a>前缀、后缀的进一步压缩</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Compute the longestSuffix value for every word */</span></span><br><span class=\"line\"><span class=\"comment\">/* 进步压缩，除了完全包含其他关键字的以外，其他关键字中，</span></span><br><span class=\"line\"><span class=\"comment\">  每一个关键字的后缀中与其他关键字的前缀相等的最长长度是多少 */</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;nKeyword; i++)&#123;<span class=\"comment\">//遍历所有关键字</span></span><br><span class=\"line\">  Keyword *p = &amp;aKeywordTable[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( p-&gt;substrId ) <span class=\"keyword\">continue</span>;<span class=\"comment\">//忽略已经是其他关键字子串的关键字。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>; j&lt;nKeyword; j++)&#123;<span class=\"comment\">//双重循环遍历</span></span><br><span class=\"line\">    Keyword *pOther;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( j==i ) <span class=\"keyword\">continue</span>;<span class=\"comment\">//不和自己比较</span></span><br><span class=\"line\">    pOther = &amp;aKeywordTable[j];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( pOther-&gt;substrId ) <span class=\"keyword\">continue</span>;<span class=\"comment\">//同样忽略已经是其他关键字子串的关键字。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//计算 p 的后缀和 pOther 的前缀最长多少是相同的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k=p-&gt;longestSuffix+<span class=\"number\">1</span>; k&lt;p-&gt;len &amp;&amp; k&lt;pOther-&gt;len; k++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( <span class=\"built_in\">memcmp</span>(&amp;p-&gt;zName[p-&gt;len-k], pOther-&gt;zName, k)==<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">        p-&gt;longestSuffix = k;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Sort the table into reverse order by length */</span></span><br><span class=\"line\">  <span class=\"comment\">/* 从关键字最长后缀相同长度的 最长到最短 做排序 */</span></span><br><span class=\"line\">  qsort(aKeywordTable, nKeyword, <span class=\"keyword\">sizeof</span>(aKeywordTable[<span class=\"number\">0</span>]), keywordCompare2);</span><br></pre></td></tr></table></figure>\n\n<p>除了上面一节中找出的子串关键字以外，剩下的关键字中，找出每一个关键字的后缀与其他关键字前缀相同的最长长度。最后以这个值从大到小做排序。这个步骤看似好像没有什么实际作用，但是这也是关键的一步，后续再分析为什么需要这么做。</p>\n<h3 id=\"计算压缩的最后结果\"><a href=\"#计算压缩的最后结果\" class=\"headerlink\" title=\"计算压缩的最后结果\"></a>计算压缩的最后结果</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Fill in the offset for all entries */</span></span><br><span class=\"line\">nChar = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;nKeyword; i++)&#123;</span><br><span class=\"line\">  Keyword *p = &amp;aKeywordTable[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( p-&gt;offset&gt;<span class=\"number\">0</span> || p-&gt;substrId ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  p-&gt;offset = nChar;</span><br><span class=\"line\">  nChar += p-&gt;len;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(k=p-&gt;len<span class=\"number\">-1</span>; k&gt;=<span class=\"number\">1</span>; k--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j=i+<span class=\"number\">1</span>; j&lt;nKeyword; j++)&#123;</span><br><span class=\"line\">      Keyword *pOther = &amp;aKeywordTable[j];</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( pOther-&gt;offset&gt;<span class=\"number\">0</span> || pOther-&gt;substrId ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( pOther-&gt;len&lt;=k ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( <span class=\"built_in\">memcmp</span>(&amp;p-&gt;zName[p-&gt;len-k], pOther-&gt;zName, k)==<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">        p = pOther;</span><br><span class=\"line\">        p-&gt;offset = nChar - k;</span><br><span class=\"line\">        nChar = p-&gt;offset + p-&gt;len;</span><br><span class=\"line\">        p-&gt;zName += k;</span><br><span class=\"line\">        p-&gt;len -= k;</span><br><span class=\"line\">        p-&gt;prefix = k;</span><br><span class=\"line\">        j = i;</span><br><span class=\"line\">        k = p-&gt;len;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;nKeyword; i++)&#123;</span><br><span class=\"line\">  Keyword *p = &amp;aKeywordTable[i];</span><br><span class=\"line\">  <span class=\"comment\">//处理带subStrId的</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>( p-&gt;substrId )&#123;</span><br><span class=\"line\">    p-&gt;offset = findById(p-&gt;substrId)-&gt;offset + p-&gt;substrOffset;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来对数组进行最后的压缩: 对数组进行遍历，遍历的目的是为了在当前关键字数组中，找到前缀与这个关键字后缀一样的关键字。并且，将这个关键字拼接在后面。</p>\n<p>举个例子:现有关键字<code>abcde``def``efg</code>,因为<code>def</code>的前缀<code>de</code>与<code>abcde</code>的后缀相同，所以在记录第二个关键字的时候，只需要记录<code>f</code>，与在前一个关键字中后缀偏移3即可。</p>\n<p>处理完所有的前后缀相接的字符串之后，再处理子串的问题，子串问题也就相对简单了。</p>\n<p>代码中可以注意到下面这几个问题:</p>\n<ol>\n<li>在上一节最后会对关键字排序，排序方法是按照每个关键字的最长相同后缀降序排列。</li>\n<li>在比较关键字的后缀是否一致的时候，从相同长度为(<code>k=p-&gt;len-1</code>)开始比较。但是找到前缀与之相同的字符串之后并没有立刻break。</li>\n</ol>\n<p>下面来解释这两个问题：</p>\n<ul>\n<li>首先SQLite希望，每次都是优先从与其他关键字前缀相同的更长后缀的的关键字中挑选出一个关键字，来拼接到关键字表后面。有点拗口，但是也不难以理解。这也就是为什么上一节中SQLite需要做一个看似“没有意义的”计算和排序。</li>\n<li>在找到一个关键字拼接的下一个关键字之后，注意<code>p = pOther;</code>当前的关键字p变成了下一个关键字pOther。这一步也不难理解，pOther将会变成下一步中寻找最长后缀的关键字。</li>\n<li>一直到所有的关键字都被check或者处理过(i&#x3D;&#x3D;nKeyword)之后，才可以结束本次压缩。</li>\n</ul>\n<h3 id=\"计算和生成最优的哈希表\"><a href=\"#计算和生成最优的哈希表\" class=\"headerlink\" title=\"计算和生成最优的哈希表\"></a>计算和生成最优的哈希表</h3><p>如何衡量一个哈希表是否是最优的呢？有两个指标，一个是<em>稀疏程度</em>，一个是<em>表的大小</em>。</p>\n<p>越稀疏，肯定会让哈希表的碰撞率越低，但是随之带来的就是size变大。就像时间复杂度和空间复杂度一样，毕竟鱼和熊掌不可兼得。</p>\n<p>那么如何去衡量这个哈希表的这两个指标呢？SQLite使用一个bestCount变量，来衡量。可以类似的理解为一个score得分。得分越高，哈希表代价(碰撞率和大小)越大，反之亦然。</p>\n<p>如何计算这个得分呢？既然有两个因素，那么必然有权重。如果简单一点设计的话，那就是 碰撞次数 * 权值1+哈希表大小 * 权值2，其中 权值1+权值2&#x3D;1。SQLite设计的时候也是这个思路，但是不是等比分配权值。它认为，比起哈希表的大小来说，碰撞的代价要高的多的多。也就是说相对来说更加希望用空间来换时间。</p>\n<p>于是有了以下的算法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Figure out how big to make the hash table in order to minimize the</span></span><br><span class=\"line\"><span class=\"comment\">** number of collisions */</span></span><br><span class=\"line\"><span class=\"comment\">/* 计算一下 最优的哈希表大小*/</span></span><br><span class=\"line\"><span class=\"comment\">// SQLite 从 [nKeyword, 2*nKeyword]之间选择一个合适的哈希表大小</span></span><br><span class=\"line\"><span class=\"comment\">// 如何选择？选择“碰撞值”最低？如何计算碰撞值？</span></span><br><span class=\"line\">bestSize = nKeyword;</span><br><span class=\"line\">bestCount = nKeyword*nKeyword;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=nKeyword/<span class=\"number\">2</span>; i&lt;=<span class=\"number\">2</span>*nKeyword; i++)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>; j&lt;i; j++) aKWHash[j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>; j&lt;nKeyword; j++)&#123;</span><br><span class=\"line\">    h = aKeywordTable[j].hash % i;</span><br><span class=\"line\">    aKWHash[h] *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    aKWHash[h]++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(j=count=<span class=\"number\">0</span>; j&lt;i; j++) count += aKWHash[j];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( count&lt;bestCount )&#123;</span><br><span class=\"line\">    bestCount = count;</span><br><span class=\"line\">    bestSize = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然希望查询速度快，但是也不能无限制大小。SQLite希望把哈希表的大小控制在[nKeyword, 2 x nKeyword]之间(毋庸置疑，最好的情况肯定是nKeyword，即所有值的哈希都不一样，一次碰撞都不发生)。在这个范围内计算每一个大小的哈希表的得分，算法为，计算所有关键字的哈希索引(即哈希值模当前的哈希表大小)，每发生一次碰撞的时候，把当前索引对应的值x2 并且加1，然后计算所有的值的总和。bestCount就存储了这个值。</p>\n<p>具体计算步骤：</p>\n<ol>\n<li>aKWHash默认值全部重置为0。</li>\n<li>依次计算关键字中的哈希值，得到每一个关键字在哈希表中的索引。</li>\n<li>将对应索引中的值<em>2 + 1（第一次命中的时候结果为1，第二次的时候结果为1</em>2+1&#x3D;3，第三次的的时候结果为3*2+1&#x3D;7）</li>\n<li>计算所有aKWHash中值的和，这个和就是当前这个大小的aKWHash的”score得分”。</li>\n<li>在哈希表大小为[nKeyword, 2 x nKeyword]的范围内，计算出其中”score得分最低的”一个大小。</li>\n</ol>\n<p>其中 x2 是一个”放大因子”，利用 x2 这个指数的增长来放大一次碰撞带来的影响。即碰撞冲突增加的时候，这个”score”会以指数级增长。2 就可以理解为哈希表大小和哈希碰撞之间”权值”，只不过不是等比关系，而是指数关系。如果希望碰撞的影响再大，那么可以把这个值改成 3，4，5…</p>\n<p>在<code>keywordhash.h</code>头文件顶部会输出当前哈希表的<code>Hash score</code>, 举个例子，在当前版本(3.27.2)下，如果支持所有的关键字，计算以 2 为“放大因子”的最合适的哈希表的<code>Hash score</code>为<em>208</em>。</p>\n<h3 id=\"计算生成哈希表\"><a href=\"#计算生成哈希表\" class=\"headerlink\" title=\"计算生成哈希表\"></a>计算生成哈希表</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Compute the hash */</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;bestSize; i++) aKWHash[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;nKeyword; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//头插法..</span></span><br><span class=\"line\">    h = aKeywordTable[i].hash % bestSize;</span><br><span class=\"line\">    aKeywordTable[i].iNext = aKWHash[h];</span><br><span class=\"line\">    aKWHash[h] = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上一步计算的结果中可以得到，bestSize -&gt; 最优的哈希表大小，bestCount -&gt; 最优的哈希表得分。</p>\n<p>依次计算所有的关键字的哈希值，每个命中的哈希值存储的是当前索引+1。一旦发生冲突的时候，使用头插法，在冲突的哈希索引值存储一个链表。<code>iNext</code>即为next指针。</p>\n<p>到这里为止，整个哈希表的计算已经全部完成了……后面的代码生成也已经很简单了，纯字符串拼接。</p>\n<p><code>aKeywordTable</code>是一个对象数组，自动输出代码的时候，将整个数组拆分成了N个数组。</p>\n<p><code>zKWText</code>: 也就是<code>aKeywordTable</code>中每一个元素<code>KeyWord</code>的<code>zName</code>变量的拼接，即最终压缩后的所有关键字的字符。<br><code>aKWHash</code>: 每一个哈希值(索引)对应的关键字的索引。<br><code>aKWNext</code>: 哈希冲突时的链表。每一个索引下存储的值，表示，与该索引对应的关键字具有相同哈希值的下一个关键字的索引。<br><code>aKWLen</code> : 表示第i个关键字的字符长度。<br><code>aKWOffset</code> : 表示第一个关键字在<code>zKWText</code>字符表内的偏移长度。<br><code>aKWCode</code> : 返回给<code>parser</code>模块的关键字码。</p>\n<h2 id=\"关键字的查询过程-函数keywordCode\"><a href=\"#关键字的查询过程-函数keywordCode\" class=\"headerlink\" title=\"关键字的查询过程(函数keywordCode)\"></a>关键字的查询过程(函数keywordCode)</h2><p>正向的看函数<code>keywordCode(const char *z, int n, int *pType)</code>，也就是上面自动生成的代码，看下是否符合之前设计的预期。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Check to see if z[0..n-1] is a keyword. If it is, write the</span></span><br><span class=\"line\"><span class=\"comment\">** parser symbol code for that keyword into *pType.  Always</span></span><br><span class=\"line\"><span class=\"comment\">** return the integer n (the length of the token). */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">keywordCode</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *z, <span class=\"type\">int</span> n, <span class=\"type\">int</span> *pType)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *zKW;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( n&gt;=<span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">    i = ((charMap(z[<span class=\"number\">0</span>])*<span class=\"number\">4</span>) ^ (charMap(z[n<span class=\"number\">-1</span>])*<span class=\"number\">3</span>) ^ n) % <span class=\"number\">127</span>;<span class=\"comment\">//计算关键字的散列索引</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=((<span class=\"type\">int</span>)aKWHash[i])<span class=\"number\">-1</span>; i&gt;=<span class=\"number\">0</span>; i=((<span class=\"type\">int</span>)aKWNext[i])<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( aKWLen[i]!=n ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      j = <span class=\"number\">0</span>;</span><br><span class=\"line\">      zKW = &amp;zKWText[aKWOffset[i]];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> SQLITE_ASCII</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>( j&lt;n &amp;&amp; (z[j]&amp;~<span class=\"number\">0x20</span>)==zKW[j] )&#123; j++; &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> SQLITE_EBCDIC</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>( j&lt;n &amp;&amp; <span class=\"built_in\">toupper</span>(z[j])==zKW[j] )&#123; j++; &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>( j&lt;n ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      testcase( i==<span class=\"number\">0</span> ); <span class=\"comment\">/* REINDEX */</span></span><br><span class=\"line\">      testcase( i==<span class=\"number\">1</span> ); <span class=\"comment\">/* INDEXED */</span></span><br><span class=\"line\">    <span class=\"comment\">//   ......</span></span><br><span class=\"line\">      testcase( i==<span class=\"number\">135</span> ); <span class=\"comment\">/* PRIMARY */</span></span><br><span class=\"line\">      *pType = aKWCode[i];</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数传入的有三个参数:第一个是需要判断的关键字的字符串的指针，第二个就是关键字的长度，第三个是函数需要返回的当前关键字的类型(也就是上面所说的，返回给<code>parser</code>的关键字码)。函数的返回值始终都是n，也就是关键字的长度。</p>\n<ol>\n<li>关键字长度均大于2。</li>\n<li>计算关键字的哈希值，以及哈希索引<code>i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n) % 127</code>。127是当前哈希表的大小，在生成代码的时候会自动计算。</li>\n<li>从aKWHash[i]中获取到关键字的索引，遍历当前索引对应的aKWNext的链表。</li>\n<li>先判断关键字的长度与当前参数是否相同。</li>\n<li>从zKWText中获取到当前关键字的字符串，根据不同的编码进行比较。</li>\n<li>重复第3步骤，直到找到字符串与关键字相同。（因为哈希有冲突，所以需要遍历哈希值对应的整个链表）</li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>SQLite 的关键字有很多个(在3.27.2版本就支持136个)。从用户侧输入一个SQL语句到Tokenize(词法分析器)的时候，SQLite如何快速判断一个单词是否是关键字呢？第一想法肯定是利用哈希表，SQLite也确实是如此。但是如何构建一个查询高效，存储占用低，而且还支持关键字”裁剪”的哈希表呢？这里从源码的角度来看，SQLite是如何一步一步的精简优化一个词法分析器的关键字查询表的。</p>\n</blockquote>","more":"<h2 id=\"SQLite源码的构成\"><a href=\"#SQLite源码的构成\" class=\"headerlink\" title=\"SQLite源码的构成\"></a>SQLite源码的构成</h2><p>SQLite本身是可以支持用cmake通过宏来裁剪功能和扩展功能的。在编译源码的过程中，会通过autoconfig生成一个Makefile。而Makefile的依赖中有一个<code>keywordhash.h</code>的文件。这个头文件就是用来做哈希表的构建的。可以看下Makefile中这个头文件的依赖与command。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keywordhash.h:\t$(TOP)/tool/mkkeywordhash.c</span><br><span class=\"line\">\t$(BCC) -o mkkeywordhash $(OPTS) $(TOP)/tool/mkkeywordhash.c</span><br><span class=\"line\">\t./mkkeywordhash &gt;keywordhash.h</span><br></pre></td></tr></table></figure>\n\n<p>这个文件只依赖<code>$(TOP)/tool/mkkeywordhash.c</code>这个文件的变更，并且command为:编译链接这个<code>mkkeywordhash.c</code>的源码，并且执行编译后的可执行文件，将输出重定向到<code>keywordhash.h</code>。那么到这里可以判断出<code>keywordhash.h</code>这个文件是<code>mkkeywordhash</code>这个程序生成的。</p>\n<p>在<code>keywordhash.h</code>文件的开头注释也写的很清楚:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">** The code in this file has been automatically generated by</span><br><span class=\"line\">**</span><br><span class=\"line\">**   sqlite/tool/mkkeywordhash.c</span><br><span class=\"line\">**</span><br><span class=\"line\">** The code in this file implements a function that determines whether</span><br><span class=\"line\">** or not a given identifier is really an SQL keyword.  The same thing</span><br><span class=\"line\">** might be implemented more directly using a hand-written hash table.</span><br><span class=\"line\">** But by using this automatically generated code, the size of the code</span><br><span class=\"line\">** is substantially reduced.  This is important <span class=\"keyword\">for</span> embedded applications</span><br><span class=\"line\">** on platforms with limited memory.</span><br></pre></td></tr></table></figure>\n\n<p>注释写到，直接用hand-written(手写)的哈希表也可以达到同一个目的。但是为了达到极致的内存和性能等，SQLite做了更多的优化。</p>\n<h2 id=\"为什么要使用mkkeywordhash？\"><a href=\"#为什么要使用mkkeywordhash？\" class=\"headerlink\" title=\"为什么要使用mkkeywordhash？\"></a>为什么要使用mkkeywordhash？</h2><p>上面提到了，SQLite完全可以通过一个纯手写的哈希表来达到快速查询一个单词是否是SQL关键字的目的。但是，使用SQLite的一般都是移动或者嵌入式设备，那么内存必然是需要考虑的一个因素。136个关键字，加上哈希表的散列，内存消耗还是非常可观的。总结使用<code>mkkeywordhash</code>有以下的优点:</p>\n<ol>\n<li>支持裁剪。支持使用宏，动态地在编译期就可以决定SQLite支持哪些关键字(因为在编译期就会使用mkkeywordhash来动态生成源码)。</li>\n<li>支持动态关键字压缩。<code>mkkeywordhash</code>压缩了所有的关键字，压缩对象为前缀与其他关键字前缀相同的关键字，或者是其他关键字子串的关键字。例:<code>REINDEX</code>的后缀和<code>INDEXED</code>的前缀一致；<code>INDEX</code>是<code>REINDEX</code>的子串</li>\n<li>支持动态创建静态的哈希表。这句话怎么理解？静态哈希表可以理解：最终生成的哈希表肯定是静态的，因为SQLite编译后支持的关键字始终是固定的。动态创建是指，可以通过宏来动态决定这个关键字哈希表的大小，内容，以及哈希表的<em>碰撞率</em>。</li>\n</ol>\n<p>注意这里说的动态，是指在编译期根据不同的需求，<em>动态</em>的来定制SQLite，而不是运行期的动态输入输出。</p>\n<p>下面来详细看下这个<code>mkkeywordhash.c</code>的源码，看看SQLite在编译期间是如何动态生成需要的关键字哈希表的:</p>\n<h2 id=\"mkkeywordhash-c\"><a href=\"#mkkeywordhash-c\" class=\"headerlink\" title=\"mkkeywordhash.c\"></a>mkkeywordhash.c</h2><h3 id=\"关键字的数据结构\"><a href=\"#关键字的数据结构\" class=\"headerlink\" title=\"关键字的数据结构\"></a>关键字的数据结构</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** All the keywords of the SQL language are stored in a hash</span></span><br><span class=\"line\"><span class=\"comment\">** table composed of instances of the following structure.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Keyword</span> <span class=\"title\">Keyword</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Keyword</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *zName;         <span class=\"comment\">/* The keyword name */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *zTokenType;    <span class=\"comment\">/* Token value for this keyword */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> mask;            <span class=\"comment\">/* Code this keyword if non-zero */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> id;              <span class=\"comment\">/* Unique ID for this record */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> hash;            <span class=\"comment\">/* Hash on the keyword */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> offset;          <span class=\"comment\">/* Offset to start of name string */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> len;             <span class=\"comment\">/* Length of this keyword, not counting final \\000 */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> prefix;          <span class=\"comment\">/* Number of characters in prefix */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> longestSuffix;   <span class=\"comment\">/* Longest suffix that is a prefix on another word */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> iNext;           <span class=\"comment\">/* Index in aKeywordTable[] of next with same hash */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> substrId;        <span class=\"comment\">/* Id to another keyword this keyword is embedded in */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> substrOffset;    <span class=\"comment\">/* Offset into substrId for start of this keyword */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> zOrigName[<span class=\"number\">20</span>];  <span class=\"comment\">/* Original keyword name before processing */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要说明一下，这个数据结构是用于<code>mkkeywordhash.c</code>，用来组织和描述所有需要编译进去的关键字的数据结构。在最后<code>mkkeywordhash</code>会根据计算好的所有关键字的<code>KeyWord</code>对象来生成最终的<code>keywordhash.h</code>文件中的静态哈希表。</p>\n<ul>\n<li>char *zName:           关键字字符串，最终会变成压缩后的关键字字符串。  </li>\n<li>char *zTokenType:      关键字类型，在tokenize暴露给外层类型。</li>\n<li>int mask:              不同的关键字可能是属于同一个功能的，宏的控制就通过控制mask的值来开启或者关闭同一类的能力</li>\n<li>int id:                关键字的id，会以关键字在数组中的索引值作为id，意义不大。</li>\n<li>int hash:              关键字的哈希值</li>\n<li>int offset:            关键字在压缩后的字符串表中的起始偏移</li>\n<li>int len:               关键字的原始长度</li>\n<li>int prefix:            关键字前缀和其他关键字后缀重叠部分的长度</li>\n<li>int longestSuffix:     当前关键字后缀和其他关键字前缀重叠部分的最长长度</li>\n<li>int iNext:             当哈希表发生碰撞的时候，通过链表来存储</li>\n<li>int substrId:          如果当前关键字是另一个关键字子串的时候，substrId就是另一个关键字的Id</li>\n<li>int substrOffset:      在substrId不为空的情况下，substrOffset标识子串开始的偏移</li>\n<li>char zOrigName[20]:    关键字原始字符串</li>\n</ul>\n<p>全局静态变量 aKeywordTable 存储了目前支持的所有的关键字。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> Keyword aKeywordTable[] = &#123;</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;ABORT&quot;</span>,            <span class=\"string\">&quot;TK_ABORT&quot;</span>,        CONFLICT|TRIGGER       &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;ACTION&quot;</span>,           <span class=\"string\">&quot;TK_ACTION&quot;</span>,       FKEY                   &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;ADD&quot;</span>,              <span class=\"string\">&quot;TK_ADD&quot;</span>,          ALTER                  &#125;,</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;AFTER&quot;</span>,            <span class=\"string\">&quot;TK_AFTER&quot;</span>,        TRIGGER                &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/* ... 136个关键字 ... */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本处理流程\"><a href=\"#基本处理流程\" class=\"headerlink\" title=\"基本处理流程\"></a>基本处理流程</h3><p><code>mkkeywordhash</code>分成了几个步骤:</p>\n<h3 id=\"裁剪不支持的关键字\"><a href=\"#裁剪不支持的关键字\" class=\"headerlink\" title=\"裁剪不支持的关键字\"></a>裁剪不支持的关键字</h3><p>在<code>mkkeywordhash</code> main函数开始的第一步就是裁减掉不使用的关键字，如何裁剪？</p>\n<p>在 aKeywordTable 和 <code>Keyword</code> 的数据结构里可以看到，每一个关键字都给予了一个mask，这个mask可以理解为关键字的tag，不同的mask值不一样，不同的关键字可以同时具有相同的mask，同一个mask可以具有多个mask。SQLite通过定义mask的值来确定是否需要裁剪。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> SQLITE_OMIT_ALTERTABLE</span></span><br><span class=\"line\"><span class=\"meta\">#  <span class=\"keyword\">define</span> ALTER      0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#  <span class=\"keyword\">define</span> ALTER      0x00000001</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>例如，如果定义了<code>SQLITE_OMIT_ALTERTABLE</code>宏，那么<code>ALTER</code>就会被定义为0，那么只具有<code>ALTER</code>mask的关键字的mask值就会被标记为0。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Remove entries from the list of keywords that have mask==0 */</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=j=<span class=\"number\">0</span>; i&lt;nKeyword; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( aKeywordTable[i].mask==<span class=\"number\">0</span> ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( j&lt;i )&#123;</span><br><span class=\"line\">      aKeywordTable[j] = aKeywordTable[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    j++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nKeyword = j;</span><br></pre></td></tr></table></figure>\n<p>然后通过遍历 akeywordTable 数组，过滤掉所有关键字mask为0的关键字，遍历的时候使用了快慢指针，分别指向当前遍历索引和存储的索引。</p>\n<h3 id=\"数据结构和计算哈希值\"><a href=\"#数据结构和计算哈希值\" class=\"headerlink\" title=\"数据结构和计算哈希值\"></a>数据结构和计算哈希值</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;nKeyword; i++)&#123;</span><br><span class=\"line\">    Keyword *p = &amp;aKeywordTable[i];</span><br><span class=\"line\">    p-&gt;len = (<span class=\"type\">int</span>)<span class=\"built_in\">strlen</span>(p-&gt;zName);</span><br><span class=\"line\">    assert( p-&gt;len&lt;<span class=\"keyword\">sizeof</span>(p-&gt;zOrigName) );</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(p-&gt;zOrigName, p-&gt;zName, p-&gt;len+<span class=\"number\">1</span>);</span><br><span class=\"line\">    totalLen += p-&gt;len;</span><br><span class=\"line\">    p-&gt;hash = (charMap(p-&gt;zName[<span class=\"number\">0</span>])*<span class=\"number\">4</span>) ^</span><br><span class=\"line\">              (charMap(p-&gt;zName[p-&gt;len<span class=\"number\">-1</span>])*<span class=\"number\">3</span>) ^ (p-&gt;len*<span class=\"number\">1</span>);</span><br><span class=\"line\">    p-&gt;id = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在裁剪完成之后，当前aKeywordTable里的nKeyword个关键字就是SQLite本次编译需要支持的所有关键字了。</p>\n<ul>\n<li>以每一个关键字的索引作为id</li>\n<li>p-&gt;len 存关键字的原始长度</li>\n<li>p-&gt;zOrigName 存储原始字符串，也就是当前 的p-&gt;zName 字段</li>\n<li>哈希算法:(关键字的第一个字符<em>4)^(关键字的最后一个字符</em>3)^(关键字名字的长度)) 大致从aKeywordTable中的关键字看到，首尾字符已经可以获得很少的哈希冲突了。</li>\n</ul>\n<h3 id=\"完全子串的关系查找\"><a href=\"#完全子串的关系查找\" class=\"headerlink\" title=\"完全子串的关系查找\"></a>完全子串的关系查找</h3><p>首先可以压缩的情况就是，A串是B串的子串，这种情况下，我们只需要记录A串是B串子串的这一关系，以及A在B中起始的偏移值既可。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Sort the table from shortest to longest keyword */</span></span><br><span class=\"line\"><span class=\"comment\">/* 从关键字字符串长度的最短到最长做排序 */</span></span><br><span class=\"line\">qsort(aKeywordTable, nKeyword, <span class=\"keyword\">sizeof</span>(aKeywordTable[<span class=\"number\">0</span>]), keywordCompare1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Look for short keywords embedded in longer keywords */</span></span><br><span class=\"line\"><span class=\"comment\">/* 从数组中找到，某些关键字是另一些关键字子串的情况，例如,IN是INDEX的子串，INDEX是INDEXED的子串*/</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=nKeyword<span class=\"number\">-2</span>; i&gt;=<span class=\"number\">0</span>; i--)&#123;<span class=\"comment\">//从倒数第二个开始</span></span><br><span class=\"line\">    Keyword *p = &amp;aKeywordTable[i];<span class=\"comment\">//p: 当前关键字</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j=nKeyword<span class=\"number\">-1</span>; j&gt;i &amp;&amp; p-&gt;substrId==<span class=\"number\">0</span>; j--)&#123;<span class=\"comment\">//依次判断当前关键字，是否是其他关键字(其他关键字从最后向前遍历)的子串</span></span><br><span class=\"line\">        Keyword *pOther = &amp;aKeywordTable[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( pOther-&gt;substrId ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( pOther-&gt;len&lt;=p-&gt;len ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//判断 p 是不是 pOther 关键字的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(k=<span class=\"number\">0</span>; k&lt;=pOther-&gt;len-p-&gt;len; k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( <span class=\"built_in\">memcmp</span>(p-&gt;zName, &amp;pOther-&gt;zName[k], p-&gt;len)==<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                p-&gt;substrId = pOther-&gt;id;</span><br><span class=\"line\">                p-&gt;substrOffset = k;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果A是B的子串，那么A的长度必然不长于B。所以先按照长度，从短到长排序。</li>\n<li>如果A是B的子串，那么A的substrId会被记录为B的Id，A的substrOffset会被记录为子串的起始偏移。</li>\n</ul>\n<h3 id=\"前缀、后缀的进一步压缩\"><a href=\"#前缀、后缀的进一步压缩\" class=\"headerlink\" title=\"前缀、后缀的进一步压缩\"></a>前缀、后缀的进一步压缩</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Compute the longestSuffix value for every word */</span></span><br><span class=\"line\"><span class=\"comment\">/* 进步压缩，除了完全包含其他关键字的以外，其他关键字中，</span></span><br><span class=\"line\"><span class=\"comment\">  每一个关键字的后缀中与其他关键字的前缀相等的最长长度是多少 */</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;nKeyword; i++)&#123;<span class=\"comment\">//遍历所有关键字</span></span><br><span class=\"line\">  Keyword *p = &amp;aKeywordTable[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( p-&gt;substrId ) <span class=\"keyword\">continue</span>;<span class=\"comment\">//忽略已经是其他关键字子串的关键字。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>; j&lt;nKeyword; j++)&#123;<span class=\"comment\">//双重循环遍历</span></span><br><span class=\"line\">    Keyword *pOther;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( j==i ) <span class=\"keyword\">continue</span>;<span class=\"comment\">//不和自己比较</span></span><br><span class=\"line\">    pOther = &amp;aKeywordTable[j];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( pOther-&gt;substrId ) <span class=\"keyword\">continue</span>;<span class=\"comment\">//同样忽略已经是其他关键字子串的关键字。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//计算 p 的后缀和 pOther 的前缀最长多少是相同的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k=p-&gt;longestSuffix+<span class=\"number\">1</span>; k&lt;p-&gt;len &amp;&amp; k&lt;pOther-&gt;len; k++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( <span class=\"built_in\">memcmp</span>(&amp;p-&gt;zName[p-&gt;len-k], pOther-&gt;zName, k)==<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">        p-&gt;longestSuffix = k;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Sort the table into reverse order by length */</span></span><br><span class=\"line\">  <span class=\"comment\">/* 从关键字最长后缀相同长度的 最长到最短 做排序 */</span></span><br><span class=\"line\">  qsort(aKeywordTable, nKeyword, <span class=\"keyword\">sizeof</span>(aKeywordTable[<span class=\"number\">0</span>]), keywordCompare2);</span><br></pre></td></tr></table></figure>\n\n<p>除了上面一节中找出的子串关键字以外，剩下的关键字中，找出每一个关键字的后缀与其他关键字前缀相同的最长长度。最后以这个值从大到小做排序。这个步骤看似好像没有什么实际作用，但是这也是关键的一步，后续再分析为什么需要这么做。</p>\n<h3 id=\"计算压缩的最后结果\"><a href=\"#计算压缩的最后结果\" class=\"headerlink\" title=\"计算压缩的最后结果\"></a>计算压缩的最后结果</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Fill in the offset for all entries */</span></span><br><span class=\"line\">nChar = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;nKeyword; i++)&#123;</span><br><span class=\"line\">  Keyword *p = &amp;aKeywordTable[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( p-&gt;offset&gt;<span class=\"number\">0</span> || p-&gt;substrId ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  p-&gt;offset = nChar;</span><br><span class=\"line\">  nChar += p-&gt;len;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(k=p-&gt;len<span class=\"number\">-1</span>; k&gt;=<span class=\"number\">1</span>; k--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j=i+<span class=\"number\">1</span>; j&lt;nKeyword; j++)&#123;</span><br><span class=\"line\">      Keyword *pOther = &amp;aKeywordTable[j];</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( pOther-&gt;offset&gt;<span class=\"number\">0</span> || pOther-&gt;substrId ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( pOther-&gt;len&lt;=k ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( <span class=\"built_in\">memcmp</span>(&amp;p-&gt;zName[p-&gt;len-k], pOther-&gt;zName, k)==<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">        p = pOther;</span><br><span class=\"line\">        p-&gt;offset = nChar - k;</span><br><span class=\"line\">        nChar = p-&gt;offset + p-&gt;len;</span><br><span class=\"line\">        p-&gt;zName += k;</span><br><span class=\"line\">        p-&gt;len -= k;</span><br><span class=\"line\">        p-&gt;prefix = k;</span><br><span class=\"line\">        j = i;</span><br><span class=\"line\">        k = p-&gt;len;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;nKeyword; i++)&#123;</span><br><span class=\"line\">  Keyword *p = &amp;aKeywordTable[i];</span><br><span class=\"line\">  <span class=\"comment\">//处理带subStrId的</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>( p-&gt;substrId )&#123;</span><br><span class=\"line\">    p-&gt;offset = findById(p-&gt;substrId)-&gt;offset + p-&gt;substrOffset;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来对数组进行最后的压缩: 对数组进行遍历，遍历的目的是为了在当前关键字数组中，找到前缀与这个关键字后缀一样的关键字。并且，将这个关键字拼接在后面。</p>\n<p>举个例子:现有关键字<code>abcde``def``efg</code>,因为<code>def</code>的前缀<code>de</code>与<code>abcde</code>的后缀相同，所以在记录第二个关键字的时候，只需要记录<code>f</code>，与在前一个关键字中后缀偏移3即可。</p>\n<p>处理完所有的前后缀相接的字符串之后，再处理子串的问题，子串问题也就相对简单了。</p>\n<p>代码中可以注意到下面这几个问题:</p>\n<ol>\n<li>在上一节最后会对关键字排序，排序方法是按照每个关键字的最长相同后缀降序排列。</li>\n<li>在比较关键字的后缀是否一致的时候，从相同长度为(<code>k=p-&gt;len-1</code>)开始比较。但是找到前缀与之相同的字符串之后并没有立刻break。</li>\n</ol>\n<p>下面来解释这两个问题：</p>\n<ul>\n<li>首先SQLite希望，每次都是优先从与其他关键字前缀相同的更长后缀的的关键字中挑选出一个关键字，来拼接到关键字表后面。有点拗口，但是也不难以理解。这也就是为什么上一节中SQLite需要做一个看似“没有意义的”计算和排序。</li>\n<li>在找到一个关键字拼接的下一个关键字之后，注意<code>p = pOther;</code>当前的关键字p变成了下一个关键字pOther。这一步也不难理解，pOther将会变成下一步中寻找最长后缀的关键字。</li>\n<li>一直到所有的关键字都被check或者处理过(i&#x3D;&#x3D;nKeyword)之后，才可以结束本次压缩。</li>\n</ul>\n<h3 id=\"计算和生成最优的哈希表\"><a href=\"#计算和生成最优的哈希表\" class=\"headerlink\" title=\"计算和生成最优的哈希表\"></a>计算和生成最优的哈希表</h3><p>如何衡量一个哈希表是否是最优的呢？有两个指标，一个是<em>稀疏程度</em>，一个是<em>表的大小</em>。</p>\n<p>越稀疏，肯定会让哈希表的碰撞率越低，但是随之带来的就是size变大。就像时间复杂度和空间复杂度一样，毕竟鱼和熊掌不可兼得。</p>\n<p>那么如何去衡量这个哈希表的这两个指标呢？SQLite使用一个bestCount变量，来衡量。可以类似的理解为一个score得分。得分越高，哈希表代价(碰撞率和大小)越大，反之亦然。</p>\n<p>如何计算这个得分呢？既然有两个因素，那么必然有权重。如果简单一点设计的话，那就是 碰撞次数 * 权值1+哈希表大小 * 权值2，其中 权值1+权值2&#x3D;1。SQLite设计的时候也是这个思路，但是不是等比分配权值。它认为，比起哈希表的大小来说，碰撞的代价要高的多的多。也就是说相对来说更加希望用空间来换时间。</p>\n<p>于是有了以下的算法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Figure out how big to make the hash table in order to minimize the</span></span><br><span class=\"line\"><span class=\"comment\">** number of collisions */</span></span><br><span class=\"line\"><span class=\"comment\">/* 计算一下 最优的哈希表大小*/</span></span><br><span class=\"line\"><span class=\"comment\">// SQLite 从 [nKeyword, 2*nKeyword]之间选择一个合适的哈希表大小</span></span><br><span class=\"line\"><span class=\"comment\">// 如何选择？选择“碰撞值”最低？如何计算碰撞值？</span></span><br><span class=\"line\">bestSize = nKeyword;</span><br><span class=\"line\">bestCount = nKeyword*nKeyword;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=nKeyword/<span class=\"number\">2</span>; i&lt;=<span class=\"number\">2</span>*nKeyword; i++)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>; j&lt;i; j++) aKWHash[j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>; j&lt;nKeyword; j++)&#123;</span><br><span class=\"line\">    h = aKeywordTable[j].hash % i;</span><br><span class=\"line\">    aKWHash[h] *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    aKWHash[h]++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(j=count=<span class=\"number\">0</span>; j&lt;i; j++) count += aKWHash[j];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( count&lt;bestCount )&#123;</span><br><span class=\"line\">    bestCount = count;</span><br><span class=\"line\">    bestSize = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然希望查询速度快，但是也不能无限制大小。SQLite希望把哈希表的大小控制在[nKeyword, 2 x nKeyword]之间(毋庸置疑，最好的情况肯定是nKeyword，即所有值的哈希都不一样，一次碰撞都不发生)。在这个范围内计算每一个大小的哈希表的得分，算法为，计算所有关键字的哈希索引(即哈希值模当前的哈希表大小)，每发生一次碰撞的时候，把当前索引对应的值x2 并且加1，然后计算所有的值的总和。bestCount就存储了这个值。</p>\n<p>具体计算步骤：</p>\n<ol>\n<li>aKWHash默认值全部重置为0。</li>\n<li>依次计算关键字中的哈希值，得到每一个关键字在哈希表中的索引。</li>\n<li>将对应索引中的值<em>2 + 1（第一次命中的时候结果为1，第二次的时候结果为1</em>2+1&#x3D;3，第三次的的时候结果为3*2+1&#x3D;7）</li>\n<li>计算所有aKWHash中值的和，这个和就是当前这个大小的aKWHash的”score得分”。</li>\n<li>在哈希表大小为[nKeyword, 2 x nKeyword]的范围内，计算出其中”score得分最低的”一个大小。</li>\n</ol>\n<p>其中 x2 是一个”放大因子”，利用 x2 这个指数的增长来放大一次碰撞带来的影响。即碰撞冲突增加的时候，这个”score”会以指数级增长。2 就可以理解为哈希表大小和哈希碰撞之间”权值”，只不过不是等比关系，而是指数关系。如果希望碰撞的影响再大，那么可以把这个值改成 3，4，5…</p>\n<p>在<code>keywordhash.h</code>头文件顶部会输出当前哈希表的<code>Hash score</code>, 举个例子，在当前版本(3.27.2)下，如果支持所有的关键字，计算以 2 为“放大因子”的最合适的哈希表的<code>Hash score</code>为<em>208</em>。</p>\n<h3 id=\"计算生成哈希表\"><a href=\"#计算生成哈希表\" class=\"headerlink\" title=\"计算生成哈希表\"></a>计算生成哈希表</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Compute the hash */</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;bestSize; i++) aKWHash[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;nKeyword; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//头插法..</span></span><br><span class=\"line\">    h = aKeywordTable[i].hash % bestSize;</span><br><span class=\"line\">    aKeywordTable[i].iNext = aKWHash[h];</span><br><span class=\"line\">    aKWHash[h] = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上一步计算的结果中可以得到，bestSize -&gt; 最优的哈希表大小，bestCount -&gt; 最优的哈希表得分。</p>\n<p>依次计算所有的关键字的哈希值，每个命中的哈希值存储的是当前索引+1。一旦发生冲突的时候，使用头插法，在冲突的哈希索引值存储一个链表。<code>iNext</code>即为next指针。</p>\n<p>到这里为止，整个哈希表的计算已经全部完成了……后面的代码生成也已经很简单了，纯字符串拼接。</p>\n<p><code>aKeywordTable</code>是一个对象数组，自动输出代码的时候，将整个数组拆分成了N个数组。</p>\n<p><code>zKWText</code>: 也就是<code>aKeywordTable</code>中每一个元素<code>KeyWord</code>的<code>zName</code>变量的拼接，即最终压缩后的所有关键字的字符。<br><code>aKWHash</code>: 每一个哈希值(索引)对应的关键字的索引。<br><code>aKWNext</code>: 哈希冲突时的链表。每一个索引下存储的值，表示，与该索引对应的关键字具有相同哈希值的下一个关键字的索引。<br><code>aKWLen</code> : 表示第i个关键字的字符长度。<br><code>aKWOffset</code> : 表示第一个关键字在<code>zKWText</code>字符表内的偏移长度。<br><code>aKWCode</code> : 返回给<code>parser</code>模块的关键字码。</p>\n<h2 id=\"关键字的查询过程-函数keywordCode\"><a href=\"#关键字的查询过程-函数keywordCode\" class=\"headerlink\" title=\"关键字的查询过程(函数keywordCode)\"></a>关键字的查询过程(函数keywordCode)</h2><p>正向的看函数<code>keywordCode(const char *z, int n, int *pType)</code>，也就是上面自动生成的代码，看下是否符合之前设计的预期。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Check to see if z[0..n-1] is a keyword. If it is, write the</span></span><br><span class=\"line\"><span class=\"comment\">** parser symbol code for that keyword into *pType.  Always</span></span><br><span class=\"line\"><span class=\"comment\">** return the integer n (the length of the token). */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">keywordCode</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *z, <span class=\"type\">int</span> n, <span class=\"type\">int</span> *pType)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *zKW;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( n&gt;=<span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">    i = ((charMap(z[<span class=\"number\">0</span>])*<span class=\"number\">4</span>) ^ (charMap(z[n<span class=\"number\">-1</span>])*<span class=\"number\">3</span>) ^ n) % <span class=\"number\">127</span>;<span class=\"comment\">//计算关键字的散列索引</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=((<span class=\"type\">int</span>)aKWHash[i])<span class=\"number\">-1</span>; i&gt;=<span class=\"number\">0</span>; i=((<span class=\"type\">int</span>)aKWNext[i])<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( aKWLen[i]!=n ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      j = <span class=\"number\">0</span>;</span><br><span class=\"line\">      zKW = &amp;zKWText[aKWOffset[i]];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> SQLITE_ASCII</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>( j&lt;n &amp;&amp; (z[j]&amp;~<span class=\"number\">0x20</span>)==zKW[j] )&#123; j++; &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> SQLITE_EBCDIC</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>( j&lt;n &amp;&amp; <span class=\"built_in\">toupper</span>(z[j])==zKW[j] )&#123; j++; &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>( j&lt;n ) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      testcase( i==<span class=\"number\">0</span> ); <span class=\"comment\">/* REINDEX */</span></span><br><span class=\"line\">      testcase( i==<span class=\"number\">1</span> ); <span class=\"comment\">/* INDEXED */</span></span><br><span class=\"line\">    <span class=\"comment\">//   ......</span></span><br><span class=\"line\">      testcase( i==<span class=\"number\">135</span> ); <span class=\"comment\">/* PRIMARY */</span></span><br><span class=\"line\">      *pType = aKWCode[i];</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数传入的有三个参数:第一个是需要判断的关键字的字符串的指针，第二个就是关键字的长度，第三个是函数需要返回的当前关键字的类型(也就是上面所说的，返回给<code>parser</code>的关键字码)。函数的返回值始终都是n，也就是关键字的长度。</p>\n<ol>\n<li>关键字长度均大于2。</li>\n<li>计算关键字的哈希值，以及哈希索引<code>i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n) % 127</code>。127是当前哈希表的大小，在生成代码的时候会自动计算。</li>\n<li>从aKWHash[i]中获取到关键字的索引，遍历当前索引对应的aKWNext的链表。</li>\n<li>先判断关键字的长度与当前参数是否相同。</li>\n<li>从zKWText中获取到当前关键字的字符串，根据不同的编码进行比较。</li>\n<li>重复第3步骤，直到找到字符串与关键字相同。（因为哈希有冲突，所以需要遍历哈希值对应的整个链表）</li>\n</ol>"},{"title":"SQLite引擎","date":"2020-06-11T16:00:00.000Z","top":300,"_content":"\n> source: inside-sqlite\n\n<!-- more -->\n\n## SQLite 引擎\n\n后端最顶层的模块在SQLite术语中通常被称之为虚拟数据库引擎，或虚拟机（VM）。VM是SQLite的核心，并且是前端和后端之间的接口。在VM中会处理一些核心信息。它在原生的操作系统上层实现了一个抽象的虚拟的机器，并且它可以执行用SQLite内部的字节码程序语言编写的程序。这个程序语言是特地设计用来搜索，读取和修改数据库的。VM接受由前端生成的字节码程序，并且执行这个程序（您可能还记得字节码程序是准备好的语句）。VM使用B+树提供的\"基础能力\"来执行字节码程序，并且输出程序的执行结果。\n\nVM不会做任何的查询语句优化操作。它会无条件地执行字节码程序。这样，它可以将数据从一个格式转换为另一个格式。即时的数据转换，是VM的主要任务。所有事情都会在它所执行的字节码程序的控制之下。\n\n一个内存对象 sqlite3_stmt(内部为Vdbe)封装了一个字节码程序。\n\n一个Vdbe对象包含以下的内部状态：\n* 一个字节码程序\n* 所有结果列的名字和数据类型\n* 绑定到输入参数的值\n* 一个程序计数器\n* 操作对象的执行栈\n* 任意数量的“编号”存储单元\n* 其他运行时的状态信息（例如打开的BTree对象，排序器，列表和集合）\n\n### 1 字节码程序语言\n\nSQLite定义了一种内部的编程语言来准备字节码程序。该语言类似于物理机和虚拟机使用的汇编语言：它定义了字节码指令。一个字节码指令按照如下格式<opcode, P1, P2, P3>, opcode 标识了特定的字节码操作，并且P1, P2, P3是这个操作符的操作数。每一个字节码操作符定义了少量的VM工作。P1操作数是一个32位的有符号整型数。P2 操作数是一个31位的非负整型，在任何一个可能会导致跳转的操作中，P2永远是跳转的目标，当然它也会被用在其他用途。P3操作数是一个指向具有Null终止符的字符串的指针，或者是一个指向不同的结构化的对象或者NULL指针。有些操作符使用三个操作数，一些典型的操作符会忽略一个或者两个操作数，并且很多甚至会忽略三个操作数。\n\n操作符是VM内部的操作名，并且它们不是SQLite接口规范的一部分。所以，它们的操作语义可能会从一个版本更改为另一个版本。SQLite的开发者团队不鼓励SQLite的用户自己去写字节码程序。\n\n[表6-1]()表述了一个等价于 SELECT * FROM t1 的典型的字节码程序。表t1有两列，命名为x和y。除了第一行以外，后面的每一行都是一个字节码指令。\n\n| Address | Opcode | p1 | p2 | p3 |\n| ---- | ---- | ---- | ---- | ---- |\n| 0 | Goto | 0 | 11 |  |\n| 1 | Integer | 0 | 0 |  |\n| 2 | OpenRead | 0 | 2 |  |\n| 3 | SetNumColumn | 0 | 2 | #t1 |\n| 4 | Rewind | 0 | 9 |\n| 5 | Column | 0 | 0 | #x |\n| 6 | Column | 0 | 1 | #y |\n| 7 | Callback | 2 | 0 |\n| 8 | Next | 0 | 5 |\n| 9 | Close | 0 | 0 |\n| 10 | Halt | 0 | 0 |\n| 11 | Transaction | 0 | 0 |\n| 12 | VerifyCookie | 0 | 1 |\n| 13 | Goto | 0 | 1 |\n\n如果说VM是一个解释器，那么下面的就是它的结构:\n\n```c\nfor (; pc < nOp && rc == SQLITE_OK; pc++){ \n    switch (aOp[pc].opcode){\n    case OP_Add:\n        /* Implementation of the ADD operation here */\n        break; \n    case OP_Goto:\n        pc = op[pc].p2-1;\n        break; \n    case OP_Halt:\n        pc = nOp;\n        break;\n    /* other cases for other opcodes */ }\n}\n```\n\n这个解释器是一个包含了一个巨大的Switch语句的循环体。每一个case的语句实现了一个字节码指令（操作码的名字以 OP_ 开头）。在每一次迭代中，VM从程序中拉取下一次的字节码指令。例如：从aOp数组中以pc作为下标索引获取下一个字节码指令。它会解码并且执行指定的指令。VM从指令号0开始执行一个字节码程序。\n\nVM使用游标来访问数据库。在一个数据库上可以有若干个打开的游标。每一个游标都是一个指向单个表或者索引的树。光标可以通过一个指定的key直接检索到一个条目，或者遍历整个树上的条目。VM在光标上的当前条目处插入新条目，检索键/数据或删除条目。\n\nVM使用操作数栈和一个任意大小的内存来保存中间结果。许多操作码都从栈中获取使用操作数。计算结果也保存在栈上。每一个栈或者内存位置都保存一个单个数据值。内存位置通常用于保存作为较大表达式一部分的标量SELECT的结果。\n\nVM会一直执行字节码程序，一直到它处理一个停止指令或者遇到一个错误（在解释程序中，rc变量存储了指令的执行状态），或者程序计数器指向了最后一条指令。当程序终止的时候，它会释放所有已经分配的内存，并且关闭所有的游标。如果执行因为错误而终止了，VM会终止事务或者子事务，并且移除当前事务或者子事务引起的变更。\n\n### 2 记录的格式\n\nVM把数据值以记录(record)的形式存储在B/B+树内。每一条记录包含一个**key项**和**可选的数据项**。VM仅负责维护key和数据的内部结构（尽管B+-tree模块可以在树（叶或内部）和多个溢出页之间拆分单个记录，但是VM是把每一条记录看做一个逻辑上连续的字节串）。VM在表记录和索引记录上使用了两种不同但是类似的记录格式。\n\n有两种格式来格式化data/key记录：固定长度和可变长度。对于固定的长度来说，对于表或者索引的所有记录都是使用了相同大小的空间；在表或者索引的创建的时候就已经知道每一个字段的大小了。对于可变长度的格式来说，每一个字段的空间大小可能根据不同的记录而不一样。SQLite使用可变的变量长度来格式化记录，因为它有几个优势。数据库因为没有空间的浪费而变得更小。同样也会让整个系统跑得更快，因为在内存和磁盘之间需要同步的bytes数量更小。另外，使用可变长度的记录可以允许SQLite可以使用显式类型而不是静态类型。\n\n每一个数据库内存储的或者VM操作的值，都有一个相关联的数据类型。称之为数据值的存储类型。我们可以对数据进行的操作取决于数据的类型。大部分的SQL数据库使用静态类型：一个数据类型与表内的列相关联，只允许将该特定数据类型的值存储在该列中。SQLite通过使用显式类型放宽了此限制。在显式类型中，数据的类型是数据自己本身的一个属性，而不属于存储这个值的列或者变量。SQLite使用显式类型（即使SQL语言规范要求静态类型），即把数据类型作为数据的一部分来存储。SQLite允许用户不用管当前列声明的数据类型，而在该列中存储任何类型的任何数据。（有一个例外是，一个整型类型的主键列只允许存整型。）\n\n表记录的格式\n\n| Header size | Type 1 | Type 2| ... | Data1 | Data2 |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n\n上面给出了一个表记录(row data)的格式。记录有两部分组成：头部和记录内容。头部由一个大小字段开始，后面跟着字段的类型。头部后面跟着记录的数据项。Header size是Data1之前的字节数。这个大小是一个哈夫曼编码的64位的可变长度的integer值，并且它包含了它自身所占用的大小。这个大小也可以被用作Data1项的指针。在header size大小之后紧跟着的是数据类型字段，每一个数据值都按照它在字段中出现的顺序排列。每一个类型字段Type i是一个可变长的无符号整型（最大是2^64），对应编码了数据字段Data i的存储类型。\n\nVM支持5种存储类型：有符号整型，有符号的浮点类型，字符串，字节流和SQL NULL。每一个在内存或者文件中存储的数据必须是以上五种之一。注意到一些数据可能在某个时间有多种含义。举个例子，123可以是一个整型数据，浮点小数，或者一个字符串。字节流和NULL没有其他的含义。所以从一种类型隐式转换为另一种类型也是有必要的。\n\n存储类型取值和它们的含义\n\n| 类型值 | 含义 | 数据长度 |\n| ---- | ---- | ---- |\n| 0 | NULL | 0 |\n| N in {1..4} | 有符号整数 | N |\n| 5 | 有符号整数 | 6 |\n| 6 | 有符号整数 | 8 |\n| 7 | IEEE 浮点 | 8 |\n| 8 | 常数 0 | 0 |\n| 9 | 常数 1 | 0 |\n| 10、11 | 扩展保留 | N/A |\n| N>=12 偶数 | 字节流 | (N-12)/2 |\n| N>=12 奇数 | 纯文本 | (N-13)/2 |\n\nNULL类型代表了SQL的NULL值。对于INTEGER类型，数据值是一个有符号的整型，根据数据大小的不同，存储在1，2，3，4，6或8个字节内。对于REAL类型，数据值是一个浮点小数，按照IEEE浮点数表示标准中的规定，存储在8个字节内。8，9两个数据类型，分别代表了整型常量0和1.对于TEXT类型，数据值就是一个文本字符串，使用默认编码(UTF-8, UTF-16BE, or UTF-16-LE)格式存储文本。对于后两者来说，字节顺序分别是大端或者小端。（每个数据库文件只会用一种UTF编码）对于BLOB类型，数据值是一个字节流，完全和用户输入的字节流一致。\n\n在SQLite中，每一个B+-Tree必须有一个唯一的key。尽管一个定义好的关系型表不包含相同的行，但是实际上用户是可以在关系表中存储重复的行的。但是数据库系统必须有办法来区分这些相同的行。该系统必须能够关联其他信息以实现差异化目的。这也就意味着，系统需要为这个关系提供一个新的唯一的属性。因此，在内部，每个表都有唯一的主键，并且该键由表的创建者或SQLite来定义。\n\n对于每一个SQL表，SQLite指定了一列作为rowid(或oid或_rowid_)，这一列的值唯一标识了在表中的每一行。它是表的隐式主键，表B+树的唯一搜索关键字。如果表内的任何一列被声明为 integer primary key，那么这列就会被当做这个表的rowid（作为别名）。否则的话，SQLite会创建一个独立的名为rowid作为唯一主键列。因此，每一个表不论是否声明了 integer primary key列，都有一个唯一的整型key，命名为rowid。对于后一种情况，rowid本身在内部被视为表的整数主键。无论哪种情况，rowid都是[-2^63, 2^63-1]范围内的有符号整数值\n\n下面的表展示了一个典型的SQL表的内容，这个表由SQL语句:`create table t1(x, y)`创建。rowid列由SQLite新增。rowid值通常由SQLite确定。不过你可以通过`insert into t1(rowid, x, y) values(100, 'hello', 'world')`为rowid插入任何值。\n\n一个典型的SQL表\n\n| rowid | x | y |\n| ---- | ---- | ---- |\n| -5 | abc | xyz |\n| 1 | abc | 12345 |\n| 2 | 456 | def |\n| 100 | hello | world |\n| 54321 | NULL | 987|\n\n**注意**\n\n如果rowid作为一个列的别名出现(例如，声明了 INTEGER PRIMARY KEY)，数据库的用户将要负责对这个列的值的维护。如果rowid是由SQLite添加的，那么SQLite负责这个值的生成，并且它需要保证这个值的唯一性。当一行被插入的时候，如果没有指定一行内的rowid的值，SQLite会访问表的B+树并且为rowid找到一个没有使用过的整型数、\n\n这个rowid的值，如果作为数据记录的一部分存储，那么就会具有一个内部的整型类型。而如果作为key来存储，那么它就是一个可变长度的哈夫曼编码。rowid允许可以使用负数，但是他们通常使用9个字节来存储，所以一般不鼓励这样使用。当rowid由SQLite生成的时候，它们通常是非负的，尽管你可以指定这个rowid为一个负数，上面的表里-5就是一个例子。\n\n在前面的一小节里，你已经看到了，每个表的B+树的key是一个整型，并且数据记录就是表内其中的一行。索引表也保留了这个设计安排。对于一个索引记录来说，键(key)是要存储在索引表中的行的所有索引列的组合值，而数据是行的rowid。要访问具有某些用于索引列的特定值的表行，SQLite首先搜索索引表以找到相应的rowid整数值，然后使用该整数值在表的B+树中查找完整记录。\n\n索引记录的格式\n\n|Header size| Type 1 | Type 2| ··· | Data1 | Data2 | rowid |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n\nSQLite把索引也当做一个表，并且在它自己的B-Tree中存储索引。它将一个搜索的key映射到了一个rowid上。它可以有自己的关键字的比较器，例如，使用排序方法来排序索引条目。每一个索引记录包含了索引列值的拷贝，并且紧跟着被索引的这个行的rowid。上面给出了索引记录的格式。整个记录都当做了B-Tree的key；没有数据部分。索引记录的编码和数据表的记录的一样，除了后面跟了一个rowid，并且rowid的数据类型，没有在记录头部显式声明。因为rowid的类型只能是有符号整数并且是用哈夫曼编码表示的（不是内部的整型类型）。（其它数据的值和数据的类型都从表内拷贝）在x列上的内容索引，如下所示.\n\n| x | rowid |\n| ---- | ----|\n| NULL | 54321 |\n| 456 | 2 |\n| abc | -5 |\n| abc | 1 |\n| hello | 100 |\n\nSQLite也支持多列索引。下表展示了y列和x列的索引内容。索引的条目根据他们的第一列的值排序，后面的列用作子排序。\n\ny列和x列的索引\n\n| y | x | rowid |\n| ---- | ----| ---- |\n| 987 | NULL | 54321 |\n| 12345 | abc | 1 |\n| def | 456 | 2 |\n| xyz | abc | -5 |\n| world | hello | 100 |\n\n索引主要是用来加速数据库查询的。举个例子，思考一下以下查询`SELECT y FROM t1 WHERE x=`。SQLite 在索引`t1(x)`上做一次索引搜索，并且找到所有x=?的rowid；对于每一个rowid，再在表t1的B+树上做一次搜索来获取到y列的值。\n\n### 3 数据类型管理\n\nSQLite的数据处理是发生在VM模块的。VM是数据库内数据存储的唯一操纵者；所有事情都是通过字节码的执行来控制的。它决定了在某个地方存储什么数据，以及在某个地方检索什么数据。给合适的数据分配合适的数据类型，并且做必要的数据转换都是VM的主要任务。有三个数据交换的地方可能会触发数据转换：从应用到引擎，从引擎到应用，从引擎到引擎。对于前两个情况，VM为用户数据分配数据类型，VM会尽可能将用户提供的数据转换为在列上声明的数据类型，反之亦然。对于后一种情况，表达式转换会引起数据转换。在下面三个小节中，我们讨论一下这三种数据转换。\n\n在记录格式那一节中，我们讨论了表和索引记录的存储格式。每一个记录的字段值都有一个存储类型。每一个提交给SQLite的值，不论是否是作为文字嵌入到SQL语句中，亦或是准备语句的时候绑定的值，在语句执行的时候都会被指派一个数据类型。这个类型是用来将这个值实际编码为一个合适的\"物理格式\"。VM通过三个步骤来决定一个值的数据类型：它首先确定输入数据的存储类型，然后确定列的声明的SQL类型，最后，如果需要，它再进行类型转换。在后面章节的讲述中，SQLite可能会在查询期间在数字存储类型（INTEGER和REAL）与TEXT之间转换数据。\n\n#### 3.1.1 输入数据类型\n\nVM根据如下情况，为一个用户数据指派一个初始化的存储类型。一个嵌入在SQL语句中的文字将会被指派以下的几个存储类型中的一个:\n\n* 如果值被单双引号包含，那么指派为TEXT\n* 如果值是不带小数点或指数的，不带引号的数字，那么指派为INTEGER\n* 如果值是带小数点或指数的不带引号的数字，那么指派为REAL\n* 如果值是字符串NULL，且周围没有引号，那么指派为NULL\n* 如果使用X'ABCD'标记指定值，那么指派为BLOB\n\n除这些之外，输入的值会被拒绝，并且查询会失败。使用sqlite3_bind_ * API函数提供的SQL参数值将分配给与函数名绑定最接近的存储类型（例如，sqlite3_bind_blob 绑定一个具有存储类型BLOB的值）。\n\nSQL标量运算符结果的值的存储类型取决于表达式的最外层运算符。用户定义的函数可以返回任何存储类型的值。通常在SQL语句的准备时间阶段无法确定表达式结果的类型。VM在运行时获取值的时候分配存储类型。\n\n#### 3.1.2 列关联性\n\n尽管每个列（整数主键除外）都可以存储任何类型的值，但是该值也是会具有其声明的SQL类型的关联性。其他SQL数据库引擎使用限制性更强的静态类型，其中类型与容器关联，而不与值关联。为了最大程度地提高SQLite与其他数据库引擎之间的兼容性，SQLite支持在列上使用类型关联性的概念。对于该列中存储的值，建议使用列类型相似性：\"建议使用，不是必需的。\"任何列仍可以存储任何类型的数据。只是，某些列（在有选择的情况下）宁愿使用关联的那种类型而不是其他类型。\n\n**注意**\n\nSQLite是无类型的，即没有域约束。它允许在已经声明了数据类型的任何一列内存储任何类型。（除了rowid的这一列，这一列只能存整型，不能存任何其他类型）SQLite可以让你在创建语句中忽略掉SQL类型。例如，`create table T1(a, b, c)`在SQLite中是一个有效的SQL语句。\n\n列的首选类型称为其关联类型。每一列只能分配为以下五个类型之一：TEXT, NUMERIC, INTEGER, REAL, and NONE。（你可能注意到了一些与上文的冲突，\"text,\" \"integer,\"和\"real\"也是用于存储类型的名字。但是，您可以根据上下文确定类型类别）根据`CREATE TABLE`语句中声明的SQL类型，根据以下规则确定列的关联类型（SQLite对SQL类型声明中的拼写错误完全不严格）:\n\n1. 如果SQL类型包含子字符串INT，则该列具有INTEGER关联。\n2. 如果SQL类型包含任何子字符串CHAR，BLOB或TEXT，则该列具有TEXT关联性。 （SQL类型VARCHAR包含字符串CHAR，因此也具有TEXT关联性。）\n3. 如果SQL类型包含子字符串BLOB，或者未指定类型，则列具有NONE关联。\n4. 如果SQL类型包含任何子串REAL，FLOA或DOUB，则列具有REAL关联。\n5. 除此之外, 列具有NUMERIC关联。\n\nVM按照与上述相同的顺序评估规则。模式匹配不区分大小写。例如，如果声明的列的SQL类型为BLOBINT，则关联性为INTEGER，而不是NONE。如果使用`create table table1 as select ...`语句创建了SQL表，则所有列都没有SQL类型，并且它们的关联性为NONE。隐式rowid的类型始终是整数.\n\n#### 3.1.3 类型转换\n在关联类型和存储类型之间有点关系。如果用户为列提供的值不满足该关系，则该值将被拒绝或转换为适当的格式。在将值插入列中时，VM首先分配最合适的存储类型（请参见“输入数据类型”部分），然后尝试将初始存储类型转换为其与列相关联类型的格式（请参见“列关联”部分）。它会按照下面的规则执行：\n\n1. 具有TEXT关联性的列存储所有具有NULL，TEXT或BLOB存储类型的数据。如果将数值（整数或实数）插入列中，则该值将转换为文本形式，并且最终的存储类型为TEXT。\n2. 具有NUMERIC关联性的列可能包含所有五种存储类型的值。将文本值插入NUMERIC列时，将尝试将值转换为整数或实数。如果转换成功，则使用INTEGER或REAL存储类型存储转换后的值。如果无法执行转换，则使用TEXT存储类型存储该值。不会尝试转换NULL或BLOB值。\n3. 具有INTEGER关联性的列的行为与具有NUMERIC关联性的列的行为相同，不同之处在于，如果插入没有浮点分量的实数值（或转换为此类的文本值），则该值将转换为整数并使用INTEGER存储类型。\n4. 具有REAL关联性的列的行为类似于具有NUMERIC关联性的列，不同之处在于它强制将整数值转换为浮点表示形式。（作为一种优化，整数值以整数形式存储在磁-盘上，以占用更少的空间，并且仅当从表中读取该值时才将其转换为浮点数。）\n5. 关联性为NONE的列不会更偏向于哪个存储类型。 VM不会尝试转换任何输入值。\n\n**注意**\n\n所有的SQL数据库引擎都会执行数据转换。它们一般都会拒绝一些无法转换为目标类型的输入数据。区别是在于，当不能格式化数据的时候，SQLite依旧会存储这个值。举个例子，如果你有一个表列，声明了SQL类型为INTEGER，并且尝试插入一个字符串(如：\"123\"或者\"abc\")，VM会鉴别一下这个字符串，看看它是否是像一个数字。如果字符串看起来像是一个数字(例如\"123\")，它就会被转换为一个数字（如果数字没有小数部分，那就会被转换为整型），并且存储为一个REAL或者INTEGER存储类型。但是，如果这个字符串的内容不是一个数字格式的话(如：\"abc\")，它就会被存储为TEXT存储类型。一个具有TEXT关联性的列在存储之前会尝试把数字转换为ASCII码文本。但是BLOBs存储在TEXT列的时候就不会发生转换，因为SQLite无法转换。SQLite允许把字符串的值转换为整型。这是一个特性，不是bug。\n\n#### 3.1.4 一个简单的例子\n\n一个典型的表数据记录\n\n`CREATE TABLE T1(a,b,c);`\n`INSERT INTO T1 VALUES(177,NULL,'hello');`\n\n<table>\n    <tr>\n        <th style=\"color:grey\">Header size</th>\n        <th style=\"color:grey\">Type 1</th>\n        <th style=\"color:grey\">Type 2</th>\n        <th style=\"color:grey\">Type 3</th>\n        <th style=\"color:grey\" colspan=\"2\">Data 1</th>\n        <th style=\"color:grey\">Data 2</th>\n        <th style=\"color:grey\" colspan=\"5\">Data 3</th>\n    </tr>\n    <tr>\n        <th>04</th>\n        <th>02</th>\n        <th>00</th>\n        <th>17</th>\n        <th>00</th>\n        <th>B1</th>\n        <th></th>\n        <th>68</th>\n        <th>65</th>\n        <th>6C</th>\n        <th>6C</th>\n        <th>6F</th>\n    </tr>\n</table>\n\n让我们更清晰的了解一个非常简单的例子。上面的表给出了一个典型的无类型的表记录。a,b,c三列的初始化的输入类型是integer，NULL和TEXT。每一列的关联类型是NONE，VM不会尝试去转换初始化的存储类型。在图表里，这个记录包含了11个字节(header+data)。所有数据都是16进制格式的。\n\n1. Header有4个字节：一个字节是用来标识头部大小，后续的三个数据都有一个字节来标识数据类型。数字4会被编码为单个字节的0x04。\n2. Type 1是被编码为单个字节的2.代表有两个字节的无符号整数\n3. Type 2是被编码为单个字节的0.代表NULL\n4. Type 3是被编码为单个字节的23.代表纯文本，文本长度为(23-13/2=)5个字节。\n5. Data 1是一个2个字节长的00B1,也就是117。这里117是无法编码为单个字节的，因为B1是-79而不是177.\n6. Data 2是NULL，它不会在记录里占据任何的字节大小。\n7. Data 3是5个字节长的字符串68 65 6C 6F。终止符0被忽略了。\n\n`sqlite3_column_*`开头的API方法，在SQLite引擎外读取数据。这些方法会在合适的时候转换数据类型。举个例子，如果内部的类型是FLOAT，但是结果要求是一个字符串(方法 sqlite3_column_text)，那么VM会使用`sprintf()`库方法在返回值给调用者的时候在内部做一次数据转换。下面的表格就是VM将内部数据为上层应用创建输出数据的转换规则。\n\n**数据转换规则**\n\n| 内部类型 | 要求数据类型 | 转换结果 |\n| ---- | ---- | ---- |\n| NULL | INTEGER | 结果是 0 |\n| NULL | FLOAT | 结果是 0 |\n| NULL | TEXT | 结果是NULL指针 |\n| NULL | BLOB | 结果是NULL指针 |\n| INTEGER | FLOAT | 整型转换为浮点型 |\n| INTEGER | TEXT | 整数的ASCII呈现 |\n| INTEGER | BLOB | 和上面一样 |\n| FLOAT | INTEGER | 浮点型转换为整型 |\n| FLOAT | TEXT | 浮点数的ASCII呈现 |\n| FLOAT | BLOB | 和上面一样 |\n| TEXT | INTEGER | 使用atoi() C库函数 |\n| TEXT | FLOAT | 使用atof() C库函数 |\n| TEXT | BLOB | 没有变化 |\n| BLOB | INTEGER | 使用atoi() 转换 |\n| BLOB | FLOAT | 使用atof() 转换 |\n| BLOB | TEXT | 如果有必要的话，增加\\000终止符 |\n\nVM可能会先转换内部数据，然后再与另一个进行比较或评估表达式.它会使用以下规则来转换内部数据.\n\n\n#### 3.2.1 处理NULL值\n\nNULL值可以在任何一个表列使用，除了主键列。NULL值的存储类型是NULL。无论它们的存储类型如何，NULL值与给定列的所有有效值都不同。SQL标准对于如何处理表达式列中的NULL值不是很具体。根据标准尚不清楚在所有情况下应如何正确处理NULL值。例如，我们如何比较NULL和其他值？SQLite以许多其他DBMS一样的方式处理NULL。在SELECT DISTINCT语句，使用UNION操作符的SELECT的组合语句，和GROUP BY语句中NULL是一样的。但是，NULL在UNIQUE列中却是不同的。NULL由SQL标准指定的内置SUM函数处理。对NULL进行算术运算会产生NULL。\n\n\n#### 3.2.2 表达式中的类型\n\nSQLite支持三种比较操作符：\n\n* 二元比较运算符 =, <, <=, >, >= 和 !=\n* 成员运算符 IN\n* 三元比较运算符 BETWEEN\n\n根据以下规则，比较的结果取决于要比较的两个值的存储类型：\n1. 如果运算符左侧的值是NULL，那么这个值一般都会认为比其他的小。（如果其他的值中有NULL，也是这样）\n2. INTEGER或REAL比TEXT或BLOB值小。如果INTEGER或REAL和另一个INTEGER或REAL比较，那么就是常规的数字比较了。\n3. TEXT值比BLOB值小。如果两个TEXT值比较，那么就是使用标准C库的memcmp函数来比较。但是这个函数是可以被用户自定义的函数重写的。\n4. 当两个BLOB比较的时候，始终使用memcmp函数比较。\n\n在应用这些规则之前，VM的首要任务是确定比较运算符的操作数的存储类型。它首先确定操作数的初步存储类型，然后（如有必要）根据它们的相似性在类型之间转换值。最后，它使用以上四个规则进行比较。\n\n如果一个表达式是某列，或者是使用别名指向的某列，或者是一个子查询返回的一个列，或者是rowid，那么这个列的关联性就会被用作这个表达式的关联性。否则，这个表达式没有SQL类型，并且它的关联性是NONE。SQLite会尝试在比较运算之前，在（INTEGER和REAL）和TEXT之间做转换。对于二元比较，会在下列情况下完成。这里说的表达式，是除了列值以外的任何SQL标量表达式或者文字。\n* 当两个列的值比较的时候，如果其中任何一列的值有NUMERIC关联性，那么这两个值会优先使用这个关联性。也就是说，VM尝试在比较之前转换其他列的值。\n* 当将列值与表达式的结果进行比较时，在进行比较之前，将列的关联性同样应用于这个表达式的结果。\n* 比较两个表达式的值时，将不进行任何转换。按照上述四个标准规则比较这些值。例如，如果将字符串与数字进行比较，则数字将始终小于字符串。\n\n在SQLite中表达式`a BETWEEN b AND c`对于`a >= b AND a <= c`是等价的，尽管在两次比较中，a列的关联性会不一样。\n\n对于表达式`a IN (SELECT b ...)`来说，就会使用上面提到的=号的二元操作符的规则来处理(例如,a=b)。举个例子，如果b是一个列的值，a是一个表达式，那么在比较之前b的关联性就会被应用到a上。SQLite处理表达式`a IN (x,y,z)`和处理`a = x OR a = y OR a = z`是一样的，尽管a的关联性是不一样的。\n\n有些简单的例子。假设，你有一个通过`CREATE TABLE t1(a TEXT,b NUMERIC, c BLOB)`语句创建的表。你可以通过执行`INSERT INTO t1 VALUES(‘500’，‘500’，‘500’)`插入一条记录。那么最终，a,b,c三列的存储类型就会变成TEXT，INTEGER，TEXT。\n\n* `SELECT a < 60,a < 40 FROM t1`，会把60和40转换为\"60\"和\"40\"，因为a列具有TEXT关联性，值就会被当做TEXT来比较。并且整个语句返回`1|0`作为输出，因为\"500\"比\"60\"小，但是比\"40\"大。\n* `SELECT b < 60,b < 600 FROM t1`不会转换任何值，会被当做普通的数字比较，那么就会返回`0|1`\n* `SELECT c < 60,c < 600 FROM t1`不会转换值，因为c的关联性是NONE。存储的两个值（存储类类型是NUMERIC）都是小于\"500\"(存储类型是TEXT)，那么就会返回`0|0`\n\n#### 3.2.3 操作符类型\n\n所有的数学运算符(除了 || 串联运算符以外)都将NUMERIC关联到所有的操作数上，并求值。如果所有操作数都无法转换为NUMERIC，那么运算结果为NULL。对于串联运算符来说，TEXT将关联到两个操作数上。如果任何一个操作数都无法转换为TEXT(NULL或者BLOB)，那么串联的结果为NULL。\n\n#### 3.2.4 ORDER BY里的类型\n当值被ORDER BY语句排序的时候，在排序之前不会有存储类型的转换。遵循先前规定的标准比较规则：NULL在最前面，然后是按值大小的INTEGER和REAL，再然后是TEXT，最后是BLOB，后面两个通常是memcmp()排序顺序。同样的文本排序方法可以被用户定义的函数重写。\n\n#### 3.2.5 GROUP BY里的类型\n当值被GROUP BY语句分组的时候，在分组之前不会有存储类型的转换。具有不同存储类型的值被认为是不同的，但INTEGER和REAL值除外，如果它们在数值上相等，则被视为相等。\n\n#### 3.2.6 复合SELECT里的类型\n复合SELECT操作符(UNION，INTERSECT和EXCEPT)，在值之间进行隐式比较。在执行这些比较之前，可以将关联性应用于每个值。相同的关联性（如果有的话）将应用于可能在复合SELECT结果集的单个列中返回的所有值。所应用的关联性是最左边的SELECT返回的列的关联性，该组件在该位置具有列值（而不是其他某种表达式）","source":"_posts/17.inside-sqlite-chapter-6.md","raw":"---\ntitle: SQLite引擎\ndate: 2020-06-12\ntags: [sqlite3]\ntop: 300\ncategories: sqlite3\n---\n\n> source: inside-sqlite\n\n<!-- more -->\n\n## SQLite 引擎\n\n后端最顶层的模块在SQLite术语中通常被称之为虚拟数据库引擎，或虚拟机（VM）。VM是SQLite的核心，并且是前端和后端之间的接口。在VM中会处理一些核心信息。它在原生的操作系统上层实现了一个抽象的虚拟的机器，并且它可以执行用SQLite内部的字节码程序语言编写的程序。这个程序语言是特地设计用来搜索，读取和修改数据库的。VM接受由前端生成的字节码程序，并且执行这个程序（您可能还记得字节码程序是准备好的语句）。VM使用B+树提供的\"基础能力\"来执行字节码程序，并且输出程序的执行结果。\n\nVM不会做任何的查询语句优化操作。它会无条件地执行字节码程序。这样，它可以将数据从一个格式转换为另一个格式。即时的数据转换，是VM的主要任务。所有事情都会在它所执行的字节码程序的控制之下。\n\n一个内存对象 sqlite3_stmt(内部为Vdbe)封装了一个字节码程序。\n\n一个Vdbe对象包含以下的内部状态：\n* 一个字节码程序\n* 所有结果列的名字和数据类型\n* 绑定到输入参数的值\n* 一个程序计数器\n* 操作对象的执行栈\n* 任意数量的“编号”存储单元\n* 其他运行时的状态信息（例如打开的BTree对象，排序器，列表和集合）\n\n### 1 字节码程序语言\n\nSQLite定义了一种内部的编程语言来准备字节码程序。该语言类似于物理机和虚拟机使用的汇编语言：它定义了字节码指令。一个字节码指令按照如下格式<opcode, P1, P2, P3>, opcode 标识了特定的字节码操作，并且P1, P2, P3是这个操作符的操作数。每一个字节码操作符定义了少量的VM工作。P1操作数是一个32位的有符号整型数。P2 操作数是一个31位的非负整型，在任何一个可能会导致跳转的操作中，P2永远是跳转的目标，当然它也会被用在其他用途。P3操作数是一个指向具有Null终止符的字符串的指针，或者是一个指向不同的结构化的对象或者NULL指针。有些操作符使用三个操作数，一些典型的操作符会忽略一个或者两个操作数，并且很多甚至会忽略三个操作数。\n\n操作符是VM内部的操作名，并且它们不是SQLite接口规范的一部分。所以，它们的操作语义可能会从一个版本更改为另一个版本。SQLite的开发者团队不鼓励SQLite的用户自己去写字节码程序。\n\n[表6-1]()表述了一个等价于 SELECT * FROM t1 的典型的字节码程序。表t1有两列，命名为x和y。除了第一行以外，后面的每一行都是一个字节码指令。\n\n| Address | Opcode | p1 | p2 | p3 |\n| ---- | ---- | ---- | ---- | ---- |\n| 0 | Goto | 0 | 11 |  |\n| 1 | Integer | 0 | 0 |  |\n| 2 | OpenRead | 0 | 2 |  |\n| 3 | SetNumColumn | 0 | 2 | #t1 |\n| 4 | Rewind | 0 | 9 |\n| 5 | Column | 0 | 0 | #x |\n| 6 | Column | 0 | 1 | #y |\n| 7 | Callback | 2 | 0 |\n| 8 | Next | 0 | 5 |\n| 9 | Close | 0 | 0 |\n| 10 | Halt | 0 | 0 |\n| 11 | Transaction | 0 | 0 |\n| 12 | VerifyCookie | 0 | 1 |\n| 13 | Goto | 0 | 1 |\n\n如果说VM是一个解释器，那么下面的就是它的结构:\n\n```c\nfor (; pc < nOp && rc == SQLITE_OK; pc++){ \n    switch (aOp[pc].opcode){\n    case OP_Add:\n        /* Implementation of the ADD operation here */\n        break; \n    case OP_Goto:\n        pc = op[pc].p2-1;\n        break; \n    case OP_Halt:\n        pc = nOp;\n        break;\n    /* other cases for other opcodes */ }\n}\n```\n\n这个解释器是一个包含了一个巨大的Switch语句的循环体。每一个case的语句实现了一个字节码指令（操作码的名字以 OP_ 开头）。在每一次迭代中，VM从程序中拉取下一次的字节码指令。例如：从aOp数组中以pc作为下标索引获取下一个字节码指令。它会解码并且执行指定的指令。VM从指令号0开始执行一个字节码程序。\n\nVM使用游标来访问数据库。在一个数据库上可以有若干个打开的游标。每一个游标都是一个指向单个表或者索引的树。光标可以通过一个指定的key直接检索到一个条目，或者遍历整个树上的条目。VM在光标上的当前条目处插入新条目，检索键/数据或删除条目。\n\nVM使用操作数栈和一个任意大小的内存来保存中间结果。许多操作码都从栈中获取使用操作数。计算结果也保存在栈上。每一个栈或者内存位置都保存一个单个数据值。内存位置通常用于保存作为较大表达式一部分的标量SELECT的结果。\n\nVM会一直执行字节码程序，一直到它处理一个停止指令或者遇到一个错误（在解释程序中，rc变量存储了指令的执行状态），或者程序计数器指向了最后一条指令。当程序终止的时候，它会释放所有已经分配的内存，并且关闭所有的游标。如果执行因为错误而终止了，VM会终止事务或者子事务，并且移除当前事务或者子事务引起的变更。\n\n### 2 记录的格式\n\nVM把数据值以记录(record)的形式存储在B/B+树内。每一条记录包含一个**key项**和**可选的数据项**。VM仅负责维护key和数据的内部结构（尽管B+-tree模块可以在树（叶或内部）和多个溢出页之间拆分单个记录，但是VM是把每一条记录看做一个逻辑上连续的字节串）。VM在表记录和索引记录上使用了两种不同但是类似的记录格式。\n\n有两种格式来格式化data/key记录：固定长度和可变长度。对于固定的长度来说，对于表或者索引的所有记录都是使用了相同大小的空间；在表或者索引的创建的时候就已经知道每一个字段的大小了。对于可变长度的格式来说，每一个字段的空间大小可能根据不同的记录而不一样。SQLite使用可变的变量长度来格式化记录，因为它有几个优势。数据库因为没有空间的浪费而变得更小。同样也会让整个系统跑得更快，因为在内存和磁盘之间需要同步的bytes数量更小。另外，使用可变长度的记录可以允许SQLite可以使用显式类型而不是静态类型。\n\n每一个数据库内存储的或者VM操作的值，都有一个相关联的数据类型。称之为数据值的存储类型。我们可以对数据进行的操作取决于数据的类型。大部分的SQL数据库使用静态类型：一个数据类型与表内的列相关联，只允许将该特定数据类型的值存储在该列中。SQLite通过使用显式类型放宽了此限制。在显式类型中，数据的类型是数据自己本身的一个属性，而不属于存储这个值的列或者变量。SQLite使用显式类型（即使SQL语言规范要求静态类型），即把数据类型作为数据的一部分来存储。SQLite允许用户不用管当前列声明的数据类型，而在该列中存储任何类型的任何数据。（有一个例外是，一个整型类型的主键列只允许存整型。）\n\n表记录的格式\n\n| Header size | Type 1 | Type 2| ... | Data1 | Data2 |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n\n上面给出了一个表记录(row data)的格式。记录有两部分组成：头部和记录内容。头部由一个大小字段开始，后面跟着字段的类型。头部后面跟着记录的数据项。Header size是Data1之前的字节数。这个大小是一个哈夫曼编码的64位的可变长度的integer值，并且它包含了它自身所占用的大小。这个大小也可以被用作Data1项的指针。在header size大小之后紧跟着的是数据类型字段，每一个数据值都按照它在字段中出现的顺序排列。每一个类型字段Type i是一个可变长的无符号整型（最大是2^64），对应编码了数据字段Data i的存储类型。\n\nVM支持5种存储类型：有符号整型，有符号的浮点类型，字符串，字节流和SQL NULL。每一个在内存或者文件中存储的数据必须是以上五种之一。注意到一些数据可能在某个时间有多种含义。举个例子，123可以是一个整型数据，浮点小数，或者一个字符串。字节流和NULL没有其他的含义。所以从一种类型隐式转换为另一种类型也是有必要的。\n\n存储类型取值和它们的含义\n\n| 类型值 | 含义 | 数据长度 |\n| ---- | ---- | ---- |\n| 0 | NULL | 0 |\n| N in {1..4} | 有符号整数 | N |\n| 5 | 有符号整数 | 6 |\n| 6 | 有符号整数 | 8 |\n| 7 | IEEE 浮点 | 8 |\n| 8 | 常数 0 | 0 |\n| 9 | 常数 1 | 0 |\n| 10、11 | 扩展保留 | N/A |\n| N>=12 偶数 | 字节流 | (N-12)/2 |\n| N>=12 奇数 | 纯文本 | (N-13)/2 |\n\nNULL类型代表了SQL的NULL值。对于INTEGER类型，数据值是一个有符号的整型，根据数据大小的不同，存储在1，2，3，4，6或8个字节内。对于REAL类型，数据值是一个浮点小数，按照IEEE浮点数表示标准中的规定，存储在8个字节内。8，9两个数据类型，分别代表了整型常量0和1.对于TEXT类型，数据值就是一个文本字符串，使用默认编码(UTF-8, UTF-16BE, or UTF-16-LE)格式存储文本。对于后两者来说，字节顺序分别是大端或者小端。（每个数据库文件只会用一种UTF编码）对于BLOB类型，数据值是一个字节流，完全和用户输入的字节流一致。\n\n在SQLite中，每一个B+-Tree必须有一个唯一的key。尽管一个定义好的关系型表不包含相同的行，但是实际上用户是可以在关系表中存储重复的行的。但是数据库系统必须有办法来区分这些相同的行。该系统必须能够关联其他信息以实现差异化目的。这也就意味着，系统需要为这个关系提供一个新的唯一的属性。因此，在内部，每个表都有唯一的主键，并且该键由表的创建者或SQLite来定义。\n\n对于每一个SQL表，SQLite指定了一列作为rowid(或oid或_rowid_)，这一列的值唯一标识了在表中的每一行。它是表的隐式主键，表B+树的唯一搜索关键字。如果表内的任何一列被声明为 integer primary key，那么这列就会被当做这个表的rowid（作为别名）。否则的话，SQLite会创建一个独立的名为rowid作为唯一主键列。因此，每一个表不论是否声明了 integer primary key列，都有一个唯一的整型key，命名为rowid。对于后一种情况，rowid本身在内部被视为表的整数主键。无论哪种情况，rowid都是[-2^63, 2^63-1]范围内的有符号整数值\n\n下面的表展示了一个典型的SQL表的内容，这个表由SQL语句:`create table t1(x, y)`创建。rowid列由SQLite新增。rowid值通常由SQLite确定。不过你可以通过`insert into t1(rowid, x, y) values(100, 'hello', 'world')`为rowid插入任何值。\n\n一个典型的SQL表\n\n| rowid | x | y |\n| ---- | ---- | ---- |\n| -5 | abc | xyz |\n| 1 | abc | 12345 |\n| 2 | 456 | def |\n| 100 | hello | world |\n| 54321 | NULL | 987|\n\n**注意**\n\n如果rowid作为一个列的别名出现(例如，声明了 INTEGER PRIMARY KEY)，数据库的用户将要负责对这个列的值的维护。如果rowid是由SQLite添加的，那么SQLite负责这个值的生成，并且它需要保证这个值的唯一性。当一行被插入的时候，如果没有指定一行内的rowid的值，SQLite会访问表的B+树并且为rowid找到一个没有使用过的整型数、\n\n这个rowid的值，如果作为数据记录的一部分存储，那么就会具有一个内部的整型类型。而如果作为key来存储，那么它就是一个可变长度的哈夫曼编码。rowid允许可以使用负数，但是他们通常使用9个字节来存储，所以一般不鼓励这样使用。当rowid由SQLite生成的时候，它们通常是非负的，尽管你可以指定这个rowid为一个负数，上面的表里-5就是一个例子。\n\n在前面的一小节里，你已经看到了，每个表的B+树的key是一个整型，并且数据记录就是表内其中的一行。索引表也保留了这个设计安排。对于一个索引记录来说，键(key)是要存储在索引表中的行的所有索引列的组合值，而数据是行的rowid。要访问具有某些用于索引列的特定值的表行，SQLite首先搜索索引表以找到相应的rowid整数值，然后使用该整数值在表的B+树中查找完整记录。\n\n索引记录的格式\n\n|Header size| Type 1 | Type 2| ··· | Data1 | Data2 | rowid |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n\nSQLite把索引也当做一个表，并且在它自己的B-Tree中存储索引。它将一个搜索的key映射到了一个rowid上。它可以有自己的关键字的比较器，例如，使用排序方法来排序索引条目。每一个索引记录包含了索引列值的拷贝，并且紧跟着被索引的这个行的rowid。上面给出了索引记录的格式。整个记录都当做了B-Tree的key；没有数据部分。索引记录的编码和数据表的记录的一样，除了后面跟了一个rowid，并且rowid的数据类型，没有在记录头部显式声明。因为rowid的类型只能是有符号整数并且是用哈夫曼编码表示的（不是内部的整型类型）。（其它数据的值和数据的类型都从表内拷贝）在x列上的内容索引，如下所示.\n\n| x | rowid |\n| ---- | ----|\n| NULL | 54321 |\n| 456 | 2 |\n| abc | -5 |\n| abc | 1 |\n| hello | 100 |\n\nSQLite也支持多列索引。下表展示了y列和x列的索引内容。索引的条目根据他们的第一列的值排序，后面的列用作子排序。\n\ny列和x列的索引\n\n| y | x | rowid |\n| ---- | ----| ---- |\n| 987 | NULL | 54321 |\n| 12345 | abc | 1 |\n| def | 456 | 2 |\n| xyz | abc | -5 |\n| world | hello | 100 |\n\n索引主要是用来加速数据库查询的。举个例子，思考一下以下查询`SELECT y FROM t1 WHERE x=`。SQLite 在索引`t1(x)`上做一次索引搜索，并且找到所有x=?的rowid；对于每一个rowid，再在表t1的B+树上做一次搜索来获取到y列的值。\n\n### 3 数据类型管理\n\nSQLite的数据处理是发生在VM模块的。VM是数据库内数据存储的唯一操纵者；所有事情都是通过字节码的执行来控制的。它决定了在某个地方存储什么数据，以及在某个地方检索什么数据。给合适的数据分配合适的数据类型，并且做必要的数据转换都是VM的主要任务。有三个数据交换的地方可能会触发数据转换：从应用到引擎，从引擎到应用，从引擎到引擎。对于前两个情况，VM为用户数据分配数据类型，VM会尽可能将用户提供的数据转换为在列上声明的数据类型，反之亦然。对于后一种情况，表达式转换会引起数据转换。在下面三个小节中，我们讨论一下这三种数据转换。\n\n在记录格式那一节中，我们讨论了表和索引记录的存储格式。每一个记录的字段值都有一个存储类型。每一个提交给SQLite的值，不论是否是作为文字嵌入到SQL语句中，亦或是准备语句的时候绑定的值，在语句执行的时候都会被指派一个数据类型。这个类型是用来将这个值实际编码为一个合适的\"物理格式\"。VM通过三个步骤来决定一个值的数据类型：它首先确定输入数据的存储类型，然后确定列的声明的SQL类型，最后，如果需要，它再进行类型转换。在后面章节的讲述中，SQLite可能会在查询期间在数字存储类型（INTEGER和REAL）与TEXT之间转换数据。\n\n#### 3.1.1 输入数据类型\n\nVM根据如下情况，为一个用户数据指派一个初始化的存储类型。一个嵌入在SQL语句中的文字将会被指派以下的几个存储类型中的一个:\n\n* 如果值被单双引号包含，那么指派为TEXT\n* 如果值是不带小数点或指数的，不带引号的数字，那么指派为INTEGER\n* 如果值是带小数点或指数的不带引号的数字，那么指派为REAL\n* 如果值是字符串NULL，且周围没有引号，那么指派为NULL\n* 如果使用X'ABCD'标记指定值，那么指派为BLOB\n\n除这些之外，输入的值会被拒绝，并且查询会失败。使用sqlite3_bind_ * API函数提供的SQL参数值将分配给与函数名绑定最接近的存储类型（例如，sqlite3_bind_blob 绑定一个具有存储类型BLOB的值）。\n\nSQL标量运算符结果的值的存储类型取决于表达式的最外层运算符。用户定义的函数可以返回任何存储类型的值。通常在SQL语句的准备时间阶段无法确定表达式结果的类型。VM在运行时获取值的时候分配存储类型。\n\n#### 3.1.2 列关联性\n\n尽管每个列（整数主键除外）都可以存储任何类型的值，但是该值也是会具有其声明的SQL类型的关联性。其他SQL数据库引擎使用限制性更强的静态类型，其中类型与容器关联，而不与值关联。为了最大程度地提高SQLite与其他数据库引擎之间的兼容性，SQLite支持在列上使用类型关联性的概念。对于该列中存储的值，建议使用列类型相似性：\"建议使用，不是必需的。\"任何列仍可以存储任何类型的数据。只是，某些列（在有选择的情况下）宁愿使用关联的那种类型而不是其他类型。\n\n**注意**\n\nSQLite是无类型的，即没有域约束。它允许在已经声明了数据类型的任何一列内存储任何类型。（除了rowid的这一列，这一列只能存整型，不能存任何其他类型）SQLite可以让你在创建语句中忽略掉SQL类型。例如，`create table T1(a, b, c)`在SQLite中是一个有效的SQL语句。\n\n列的首选类型称为其关联类型。每一列只能分配为以下五个类型之一：TEXT, NUMERIC, INTEGER, REAL, and NONE。（你可能注意到了一些与上文的冲突，\"text,\" \"integer,\"和\"real\"也是用于存储类型的名字。但是，您可以根据上下文确定类型类别）根据`CREATE TABLE`语句中声明的SQL类型，根据以下规则确定列的关联类型（SQLite对SQL类型声明中的拼写错误完全不严格）:\n\n1. 如果SQL类型包含子字符串INT，则该列具有INTEGER关联。\n2. 如果SQL类型包含任何子字符串CHAR，BLOB或TEXT，则该列具有TEXT关联性。 （SQL类型VARCHAR包含字符串CHAR，因此也具有TEXT关联性。）\n3. 如果SQL类型包含子字符串BLOB，或者未指定类型，则列具有NONE关联。\n4. 如果SQL类型包含任何子串REAL，FLOA或DOUB，则列具有REAL关联。\n5. 除此之外, 列具有NUMERIC关联。\n\nVM按照与上述相同的顺序评估规则。模式匹配不区分大小写。例如，如果声明的列的SQL类型为BLOBINT，则关联性为INTEGER，而不是NONE。如果使用`create table table1 as select ...`语句创建了SQL表，则所有列都没有SQL类型，并且它们的关联性为NONE。隐式rowid的类型始终是整数.\n\n#### 3.1.3 类型转换\n在关联类型和存储类型之间有点关系。如果用户为列提供的值不满足该关系，则该值将被拒绝或转换为适当的格式。在将值插入列中时，VM首先分配最合适的存储类型（请参见“输入数据类型”部分），然后尝试将初始存储类型转换为其与列相关联类型的格式（请参见“列关联”部分）。它会按照下面的规则执行：\n\n1. 具有TEXT关联性的列存储所有具有NULL，TEXT或BLOB存储类型的数据。如果将数值（整数或实数）插入列中，则该值将转换为文本形式，并且最终的存储类型为TEXT。\n2. 具有NUMERIC关联性的列可能包含所有五种存储类型的值。将文本值插入NUMERIC列时，将尝试将值转换为整数或实数。如果转换成功，则使用INTEGER或REAL存储类型存储转换后的值。如果无法执行转换，则使用TEXT存储类型存储该值。不会尝试转换NULL或BLOB值。\n3. 具有INTEGER关联性的列的行为与具有NUMERIC关联性的列的行为相同，不同之处在于，如果插入没有浮点分量的实数值（或转换为此类的文本值），则该值将转换为整数并使用INTEGER存储类型。\n4. 具有REAL关联性的列的行为类似于具有NUMERIC关联性的列，不同之处在于它强制将整数值转换为浮点表示形式。（作为一种优化，整数值以整数形式存储在磁-盘上，以占用更少的空间，并且仅当从表中读取该值时才将其转换为浮点数。）\n5. 关联性为NONE的列不会更偏向于哪个存储类型。 VM不会尝试转换任何输入值。\n\n**注意**\n\n所有的SQL数据库引擎都会执行数据转换。它们一般都会拒绝一些无法转换为目标类型的输入数据。区别是在于，当不能格式化数据的时候，SQLite依旧会存储这个值。举个例子，如果你有一个表列，声明了SQL类型为INTEGER，并且尝试插入一个字符串(如：\"123\"或者\"abc\")，VM会鉴别一下这个字符串，看看它是否是像一个数字。如果字符串看起来像是一个数字(例如\"123\")，它就会被转换为一个数字（如果数字没有小数部分，那就会被转换为整型），并且存储为一个REAL或者INTEGER存储类型。但是，如果这个字符串的内容不是一个数字格式的话(如：\"abc\")，它就会被存储为TEXT存储类型。一个具有TEXT关联性的列在存储之前会尝试把数字转换为ASCII码文本。但是BLOBs存储在TEXT列的时候就不会发生转换，因为SQLite无法转换。SQLite允许把字符串的值转换为整型。这是一个特性，不是bug。\n\n#### 3.1.4 一个简单的例子\n\n一个典型的表数据记录\n\n`CREATE TABLE T1(a,b,c);`\n`INSERT INTO T1 VALUES(177,NULL,'hello');`\n\n<table>\n    <tr>\n        <th style=\"color:grey\">Header size</th>\n        <th style=\"color:grey\">Type 1</th>\n        <th style=\"color:grey\">Type 2</th>\n        <th style=\"color:grey\">Type 3</th>\n        <th style=\"color:grey\" colspan=\"2\">Data 1</th>\n        <th style=\"color:grey\">Data 2</th>\n        <th style=\"color:grey\" colspan=\"5\">Data 3</th>\n    </tr>\n    <tr>\n        <th>04</th>\n        <th>02</th>\n        <th>00</th>\n        <th>17</th>\n        <th>00</th>\n        <th>B1</th>\n        <th></th>\n        <th>68</th>\n        <th>65</th>\n        <th>6C</th>\n        <th>6C</th>\n        <th>6F</th>\n    </tr>\n</table>\n\n让我们更清晰的了解一个非常简单的例子。上面的表给出了一个典型的无类型的表记录。a,b,c三列的初始化的输入类型是integer，NULL和TEXT。每一列的关联类型是NONE，VM不会尝试去转换初始化的存储类型。在图表里，这个记录包含了11个字节(header+data)。所有数据都是16进制格式的。\n\n1. Header有4个字节：一个字节是用来标识头部大小，后续的三个数据都有一个字节来标识数据类型。数字4会被编码为单个字节的0x04。\n2. Type 1是被编码为单个字节的2.代表有两个字节的无符号整数\n3. Type 2是被编码为单个字节的0.代表NULL\n4. Type 3是被编码为单个字节的23.代表纯文本，文本长度为(23-13/2=)5个字节。\n5. Data 1是一个2个字节长的00B1,也就是117。这里117是无法编码为单个字节的，因为B1是-79而不是177.\n6. Data 2是NULL，它不会在记录里占据任何的字节大小。\n7. Data 3是5个字节长的字符串68 65 6C 6F。终止符0被忽略了。\n\n`sqlite3_column_*`开头的API方法，在SQLite引擎外读取数据。这些方法会在合适的时候转换数据类型。举个例子，如果内部的类型是FLOAT，但是结果要求是一个字符串(方法 sqlite3_column_text)，那么VM会使用`sprintf()`库方法在返回值给调用者的时候在内部做一次数据转换。下面的表格就是VM将内部数据为上层应用创建输出数据的转换规则。\n\n**数据转换规则**\n\n| 内部类型 | 要求数据类型 | 转换结果 |\n| ---- | ---- | ---- |\n| NULL | INTEGER | 结果是 0 |\n| NULL | FLOAT | 结果是 0 |\n| NULL | TEXT | 结果是NULL指针 |\n| NULL | BLOB | 结果是NULL指针 |\n| INTEGER | FLOAT | 整型转换为浮点型 |\n| INTEGER | TEXT | 整数的ASCII呈现 |\n| INTEGER | BLOB | 和上面一样 |\n| FLOAT | INTEGER | 浮点型转换为整型 |\n| FLOAT | TEXT | 浮点数的ASCII呈现 |\n| FLOAT | BLOB | 和上面一样 |\n| TEXT | INTEGER | 使用atoi() C库函数 |\n| TEXT | FLOAT | 使用atof() C库函数 |\n| TEXT | BLOB | 没有变化 |\n| BLOB | INTEGER | 使用atoi() 转换 |\n| BLOB | FLOAT | 使用atof() 转换 |\n| BLOB | TEXT | 如果有必要的话，增加\\000终止符 |\n\nVM可能会先转换内部数据，然后再与另一个进行比较或评估表达式.它会使用以下规则来转换内部数据.\n\n\n#### 3.2.1 处理NULL值\n\nNULL值可以在任何一个表列使用，除了主键列。NULL值的存储类型是NULL。无论它们的存储类型如何，NULL值与给定列的所有有效值都不同。SQL标准对于如何处理表达式列中的NULL值不是很具体。根据标准尚不清楚在所有情况下应如何正确处理NULL值。例如，我们如何比较NULL和其他值？SQLite以许多其他DBMS一样的方式处理NULL。在SELECT DISTINCT语句，使用UNION操作符的SELECT的组合语句，和GROUP BY语句中NULL是一样的。但是，NULL在UNIQUE列中却是不同的。NULL由SQL标准指定的内置SUM函数处理。对NULL进行算术运算会产生NULL。\n\n\n#### 3.2.2 表达式中的类型\n\nSQLite支持三种比较操作符：\n\n* 二元比较运算符 =, <, <=, >, >= 和 !=\n* 成员运算符 IN\n* 三元比较运算符 BETWEEN\n\n根据以下规则，比较的结果取决于要比较的两个值的存储类型：\n1. 如果运算符左侧的值是NULL，那么这个值一般都会认为比其他的小。（如果其他的值中有NULL，也是这样）\n2. INTEGER或REAL比TEXT或BLOB值小。如果INTEGER或REAL和另一个INTEGER或REAL比较，那么就是常规的数字比较了。\n3. TEXT值比BLOB值小。如果两个TEXT值比较，那么就是使用标准C库的memcmp函数来比较。但是这个函数是可以被用户自定义的函数重写的。\n4. 当两个BLOB比较的时候，始终使用memcmp函数比较。\n\n在应用这些规则之前，VM的首要任务是确定比较运算符的操作数的存储类型。它首先确定操作数的初步存储类型，然后（如有必要）根据它们的相似性在类型之间转换值。最后，它使用以上四个规则进行比较。\n\n如果一个表达式是某列，或者是使用别名指向的某列，或者是一个子查询返回的一个列，或者是rowid，那么这个列的关联性就会被用作这个表达式的关联性。否则，这个表达式没有SQL类型，并且它的关联性是NONE。SQLite会尝试在比较运算之前，在（INTEGER和REAL）和TEXT之间做转换。对于二元比较，会在下列情况下完成。这里说的表达式，是除了列值以外的任何SQL标量表达式或者文字。\n* 当两个列的值比较的时候，如果其中任何一列的值有NUMERIC关联性，那么这两个值会优先使用这个关联性。也就是说，VM尝试在比较之前转换其他列的值。\n* 当将列值与表达式的结果进行比较时，在进行比较之前，将列的关联性同样应用于这个表达式的结果。\n* 比较两个表达式的值时，将不进行任何转换。按照上述四个标准规则比较这些值。例如，如果将字符串与数字进行比较，则数字将始终小于字符串。\n\n在SQLite中表达式`a BETWEEN b AND c`对于`a >= b AND a <= c`是等价的，尽管在两次比较中，a列的关联性会不一样。\n\n对于表达式`a IN (SELECT b ...)`来说，就会使用上面提到的=号的二元操作符的规则来处理(例如,a=b)。举个例子，如果b是一个列的值，a是一个表达式，那么在比较之前b的关联性就会被应用到a上。SQLite处理表达式`a IN (x,y,z)`和处理`a = x OR a = y OR a = z`是一样的，尽管a的关联性是不一样的。\n\n有些简单的例子。假设，你有一个通过`CREATE TABLE t1(a TEXT,b NUMERIC, c BLOB)`语句创建的表。你可以通过执行`INSERT INTO t1 VALUES(‘500’，‘500’，‘500’)`插入一条记录。那么最终，a,b,c三列的存储类型就会变成TEXT，INTEGER，TEXT。\n\n* `SELECT a < 60,a < 40 FROM t1`，会把60和40转换为\"60\"和\"40\"，因为a列具有TEXT关联性，值就会被当做TEXT来比较。并且整个语句返回`1|0`作为输出，因为\"500\"比\"60\"小，但是比\"40\"大。\n* `SELECT b < 60,b < 600 FROM t1`不会转换任何值，会被当做普通的数字比较，那么就会返回`0|1`\n* `SELECT c < 60,c < 600 FROM t1`不会转换值，因为c的关联性是NONE。存储的两个值（存储类类型是NUMERIC）都是小于\"500\"(存储类型是TEXT)，那么就会返回`0|0`\n\n#### 3.2.3 操作符类型\n\n所有的数学运算符(除了 || 串联运算符以外)都将NUMERIC关联到所有的操作数上，并求值。如果所有操作数都无法转换为NUMERIC，那么运算结果为NULL。对于串联运算符来说，TEXT将关联到两个操作数上。如果任何一个操作数都无法转换为TEXT(NULL或者BLOB)，那么串联的结果为NULL。\n\n#### 3.2.4 ORDER BY里的类型\n当值被ORDER BY语句排序的时候，在排序之前不会有存储类型的转换。遵循先前规定的标准比较规则：NULL在最前面，然后是按值大小的INTEGER和REAL，再然后是TEXT，最后是BLOB，后面两个通常是memcmp()排序顺序。同样的文本排序方法可以被用户定义的函数重写。\n\n#### 3.2.5 GROUP BY里的类型\n当值被GROUP BY语句分组的时候，在分组之前不会有存储类型的转换。具有不同存储类型的值被认为是不同的，但INTEGER和REAL值除外，如果它们在数值上相等，则被视为相等。\n\n#### 3.2.6 复合SELECT里的类型\n复合SELECT操作符(UNION，INTERSECT和EXCEPT)，在值之间进行隐式比较。在执行这些比较之前，可以将关联性应用于每个值。相同的关联性（如果有的话）将应用于可能在复合SELECT结果集的单个列中返回的所有值。所应用的关联性是最左边的SELECT返回的列的关联性，该组件在该位置具有列值（而不是其他某种表达式）","slug":"17.inside-sqlite-chapter-6","published":1,"updated":"2022-07-28T13:38:40.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwo7000vp9c93dzbhx5v","content":"<blockquote>\n<p>source: inside-sqlite</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"SQLite-引擎\"><a href=\"#SQLite-引擎\" class=\"headerlink\" title=\"SQLite 引擎\"></a>SQLite 引擎</h2><p>后端最顶层的模块在SQLite术语中通常被称之为虚拟数据库引擎，或虚拟机（VM）。VM是SQLite的核心，并且是前端和后端之间的接口。在VM中会处理一些核心信息。它在原生的操作系统上层实现了一个抽象的虚拟的机器，并且它可以执行用SQLite内部的字节码程序语言编写的程序。这个程序语言是特地设计用来搜索，读取和修改数据库的。VM接受由前端生成的字节码程序，并且执行这个程序（您可能还记得字节码程序是准备好的语句）。VM使用B+树提供的”基础能力”来执行字节码程序，并且输出程序的执行结果。</p>\n<p>VM不会做任何的查询语句优化操作。它会无条件地执行字节码程序。这样，它可以将数据从一个格式转换为另一个格式。即时的数据转换，是VM的主要任务。所有事情都会在它所执行的字节码程序的控制之下。</p>\n<p>一个内存对象 sqlite3_stmt(内部为Vdbe)封装了一个字节码程序。</p>\n<p>一个Vdbe对象包含以下的内部状态：</p>\n<ul>\n<li>一个字节码程序</li>\n<li>所有结果列的名字和数据类型</li>\n<li>绑定到输入参数的值</li>\n<li>一个程序计数器</li>\n<li>操作对象的执行栈</li>\n<li>任意数量的“编号”存储单元</li>\n<li>其他运行时的状态信息（例如打开的BTree对象，排序器，列表和集合）</li>\n</ul>\n<h3 id=\"1-字节码程序语言\"><a href=\"#1-字节码程序语言\" class=\"headerlink\" title=\"1 字节码程序语言\"></a>1 字节码程序语言</h3><p>SQLite定义了一种内部的编程语言来准备字节码程序。该语言类似于物理机和虚拟机使用的汇编语言：它定义了字节码指令。一个字节码指令按照如下格式&lt;opcode, P1, P2, P3&gt;, opcode 标识了特定的字节码操作，并且P1, P2, P3是这个操作符的操作数。每一个字节码操作符定义了少量的VM工作。P1操作数是一个32位的有符号整型数。P2 操作数是一个31位的非负整型，在任何一个可能会导致跳转的操作中，P2永远是跳转的目标，当然它也会被用在其他用途。P3操作数是一个指向具有Null终止符的字符串的指针，或者是一个指向不同的结构化的对象或者NULL指针。有些操作符使用三个操作数，一些典型的操作符会忽略一个或者两个操作数，并且很多甚至会忽略三个操作数。</p>\n<p>操作符是VM内部的操作名，并且它们不是SQLite接口规范的一部分。所以，它们的操作语义可能会从一个版本更改为另一个版本。SQLite的开发者团队不鼓励SQLite的用户自己去写字节码程序。</p>\n<p><a href=\"\">表6-1</a>表述了一个等价于 SELECT * FROM t1 的典型的字节码程序。表t1有两列，命名为x和y。除了第一行以外，后面的每一行都是一个字节码指令。</p>\n<table>\n<thead>\n<tr>\n<th>Address</th>\n<th>Opcode</th>\n<th>p1</th>\n<th>p2</th>\n<th>p3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>Goto</td>\n<td>0</td>\n<td>11</td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>Integer</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>OpenRead</td>\n<td>0</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>SetNumColumn</td>\n<td>0</td>\n<td>2</td>\n<td>#t1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Rewind</td>\n<td>0</td>\n<td>9</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Column</td>\n<td>0</td>\n<td>0</td>\n<td>#x</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Column</td>\n<td>0</td>\n<td>1</td>\n<td>#y</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Callback</td>\n<td>2</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Next</td>\n<td>0</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>Close</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>Halt</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>Transaction</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>VerifyCookie</td>\n<td>0</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>Goto</td>\n<td>0</td>\n<td>1</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>如果说VM是一个解释器，那么下面的就是它的结构:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (; pc &lt; nOp &amp;&amp; rc == SQLITE_OK; pc++)&#123; </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (aOp[pc].opcode)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Add:</span><br><span class=\"line\">        <span class=\"comment\">/* Implementation of the ADD operation here */</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Goto:</span><br><span class=\"line\">        pc = op[pc].p2<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Halt:</span><br><span class=\"line\">        pc = nOp;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* other cases for other opcodes */</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个解释器是一个包含了一个巨大的Switch语句的循环体。每一个case的语句实现了一个字节码指令（操作码的名字以 OP_ 开头）。在每一次迭代中，VM从程序中拉取下一次的字节码指令。例如：从aOp数组中以pc作为下标索引获取下一个字节码指令。它会解码并且执行指定的指令。VM从指令号0开始执行一个字节码程序。</p>\n<p>VM使用游标来访问数据库。在一个数据库上可以有若干个打开的游标。每一个游标都是一个指向单个表或者索引的树。光标可以通过一个指定的key直接检索到一个条目，或者遍历整个树上的条目。VM在光标上的当前条目处插入新条目，检索键&#x2F;数据或删除条目。</p>\n<p>VM使用操作数栈和一个任意大小的内存来保存中间结果。许多操作码都从栈中获取使用操作数。计算结果也保存在栈上。每一个栈或者内存位置都保存一个单个数据值。内存位置通常用于保存作为较大表达式一部分的标量SELECT的结果。</p>\n<p>VM会一直执行字节码程序，一直到它处理一个停止指令或者遇到一个错误（在解释程序中，rc变量存储了指令的执行状态），或者程序计数器指向了最后一条指令。当程序终止的时候，它会释放所有已经分配的内存，并且关闭所有的游标。如果执行因为错误而终止了，VM会终止事务或者子事务，并且移除当前事务或者子事务引起的变更。</p>\n<h3 id=\"2-记录的格式\"><a href=\"#2-记录的格式\" class=\"headerlink\" title=\"2 记录的格式\"></a>2 记录的格式</h3><p>VM把数据值以记录(record)的形式存储在B&#x2F;B+树内。每一条记录包含一个<strong>key项</strong>和<strong>可选的数据项</strong>。VM仅负责维护key和数据的内部结构（尽管B+-tree模块可以在树（叶或内部）和多个溢出页之间拆分单个记录，但是VM是把每一条记录看做一个逻辑上连续的字节串）。VM在表记录和索引记录上使用了两种不同但是类似的记录格式。</p>\n<p>有两种格式来格式化data&#x2F;key记录：固定长度和可变长度。对于固定的长度来说，对于表或者索引的所有记录都是使用了相同大小的空间；在表或者索引的创建的时候就已经知道每一个字段的大小了。对于可变长度的格式来说，每一个字段的空间大小可能根据不同的记录而不一样。SQLite使用可变的变量长度来格式化记录，因为它有几个优势。数据库因为没有空间的浪费而变得更小。同样也会让整个系统跑得更快，因为在内存和磁盘之间需要同步的bytes数量更小。另外，使用可变长度的记录可以允许SQLite可以使用显式类型而不是静态类型。</p>\n<p>每一个数据库内存储的或者VM操作的值，都有一个相关联的数据类型。称之为数据值的存储类型。我们可以对数据进行的操作取决于数据的类型。大部分的SQL数据库使用静态类型：一个数据类型与表内的列相关联，只允许将该特定数据类型的值存储在该列中。SQLite通过使用显式类型放宽了此限制。在显式类型中，数据的类型是数据自己本身的一个属性，而不属于存储这个值的列或者变量。SQLite使用显式类型（即使SQL语言规范要求静态类型），即把数据类型作为数据的一部分来存储。SQLite允许用户不用管当前列声明的数据类型，而在该列中存储任何类型的任何数据。（有一个例外是，一个整型类型的主键列只允许存整型。）</p>\n<p>表记录的格式</p>\n<table>\n<thead>\n<tr>\n<th>Header size</th>\n<th>Type 1</th>\n<th>Type 2</th>\n<th>…</th>\n<th>Data1</th>\n<th>Data2</th>\n</tr>\n</thead>\n</table>\n<p>上面给出了一个表记录(row data)的格式。记录有两部分组成：头部和记录内容。头部由一个大小字段开始，后面跟着字段的类型。头部后面跟着记录的数据项。Header size是Data1之前的字节数。这个大小是一个哈夫曼编码的64位的可变长度的integer值，并且它包含了它自身所占用的大小。这个大小也可以被用作Data1项的指针。在header size大小之后紧跟着的是数据类型字段，每一个数据值都按照它在字段中出现的顺序排列。每一个类型字段Type i是一个可变长的无符号整型（最大是2^64），对应编码了数据字段Data i的存储类型。</p>\n<p>VM支持5种存储类型：有符号整型，有符号的浮点类型，字符串，字节流和SQL NULL。每一个在内存或者文件中存储的数据必须是以上五种之一。注意到一些数据可能在某个时间有多种含义。举个例子，123可以是一个整型数据，浮点小数，或者一个字符串。字节流和NULL没有其他的含义。所以从一种类型隐式转换为另一种类型也是有必要的。</p>\n<p>存储类型取值和它们的含义</p>\n<table>\n<thead>\n<tr>\n<th>类型值</th>\n<th>含义</th>\n<th>数据长度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>NULL</td>\n<td>0</td>\n</tr>\n<tr>\n<td>N in {1..4}</td>\n<td>有符号整数</td>\n<td>N</td>\n</tr>\n<tr>\n<td>5</td>\n<td>有符号整数</td>\n<td>6</td>\n</tr>\n<tr>\n<td>6</td>\n<td>有符号整数</td>\n<td>8</td>\n</tr>\n<tr>\n<td>7</td>\n<td>IEEE 浮点</td>\n<td>8</td>\n</tr>\n<tr>\n<td>8</td>\n<td>常数 0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>9</td>\n<td>常数 1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>10、11</td>\n<td>扩展保留</td>\n<td>N&#x2F;A</td>\n</tr>\n<tr>\n<td>N&gt;&#x3D;12 偶数</td>\n<td>字节流</td>\n<td>(N-12)&#x2F;2</td>\n</tr>\n<tr>\n<td>N&gt;&#x3D;12 奇数</td>\n<td>纯文本</td>\n<td>(N-13)&#x2F;2</td>\n</tr>\n</tbody></table>\n<p>NULL类型代表了SQL的NULL值。对于INTEGER类型，数据值是一个有符号的整型，根据数据大小的不同，存储在1，2，3，4，6或8个字节内。对于REAL类型，数据值是一个浮点小数，按照IEEE浮点数表示标准中的规定，存储在8个字节内。8，9两个数据类型，分别代表了整型常量0和1.对于TEXT类型，数据值就是一个文本字符串，使用默认编码(UTF-8, UTF-16BE, or UTF-16-LE)格式存储文本。对于后两者来说，字节顺序分别是大端或者小端。（每个数据库文件只会用一种UTF编码）对于BLOB类型，数据值是一个字节流，完全和用户输入的字节流一致。</p>\n<p>在SQLite中，每一个B+-Tree必须有一个唯一的key。尽管一个定义好的关系型表不包含相同的行，但是实际上用户是可以在关系表中存储重复的行的。但是数据库系统必须有办法来区分这些相同的行。该系统必须能够关联其他信息以实现差异化目的。这也就意味着，系统需要为这个关系提供一个新的唯一的属性。因此，在内部，每个表都有唯一的主键，并且该键由表的创建者或SQLite来定义。</p>\n<p>对于每一个SQL表，SQLite指定了一列作为rowid(或oid或_rowid_)，这一列的值唯一标识了在表中的每一行。它是表的隐式主键，表B+树的唯一搜索关键字。如果表内的任何一列被声明为 integer primary key，那么这列就会被当做这个表的rowid（作为别名）。否则的话，SQLite会创建一个独立的名为rowid作为唯一主键列。因此，每一个表不论是否声明了 integer primary key列，都有一个唯一的整型key，命名为rowid。对于后一种情况，rowid本身在内部被视为表的整数主键。无论哪种情况，rowid都是[-2^63, 2^63-1]范围内的有符号整数值</p>\n<p>下面的表展示了一个典型的SQL表的内容，这个表由SQL语句:<code>create table t1(x, y)</code>创建。rowid列由SQLite新增。rowid值通常由SQLite确定。不过你可以通过<code>insert into t1(rowid, x, y) values(100, &#39;hello&#39;, &#39;world&#39;)</code>为rowid插入任何值。</p>\n<p>一个典型的SQL表</p>\n<table>\n<thead>\n<tr>\n<th>rowid</th>\n<th>x</th>\n<th>y</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-5</td>\n<td>abc</td>\n<td>xyz</td>\n</tr>\n<tr>\n<td>1</td>\n<td>abc</td>\n<td>12345</td>\n</tr>\n<tr>\n<td>2</td>\n<td>456</td>\n<td>def</td>\n</tr>\n<tr>\n<td>100</td>\n<td>hello</td>\n<td>world</td>\n</tr>\n<tr>\n<td>54321</td>\n<td>NULL</td>\n<td>987</td>\n</tr>\n</tbody></table>\n<p><strong>注意</strong></p>\n<p>如果rowid作为一个列的别名出现(例如，声明了 INTEGER PRIMARY KEY)，数据库的用户将要负责对这个列的值的维护。如果rowid是由SQLite添加的，那么SQLite负责这个值的生成，并且它需要保证这个值的唯一性。当一行被插入的时候，如果没有指定一行内的rowid的值，SQLite会访问表的B+树并且为rowid找到一个没有使用过的整型数、</p>\n<p>这个rowid的值，如果作为数据记录的一部分存储，那么就会具有一个内部的整型类型。而如果作为key来存储，那么它就是一个可变长度的哈夫曼编码。rowid允许可以使用负数，但是他们通常使用9个字节来存储，所以一般不鼓励这样使用。当rowid由SQLite生成的时候，它们通常是非负的，尽管你可以指定这个rowid为一个负数，上面的表里-5就是一个例子。</p>\n<p>在前面的一小节里，你已经看到了，每个表的B+树的key是一个整型，并且数据记录就是表内其中的一行。索引表也保留了这个设计安排。对于一个索引记录来说，键(key)是要存储在索引表中的行的所有索引列的组合值，而数据是行的rowid。要访问具有某些用于索引列的特定值的表行，SQLite首先搜索索引表以找到相应的rowid整数值，然后使用该整数值在表的B+树中查找完整记录。</p>\n<p>索引记录的格式</p>\n<table>\n<thead>\n<tr>\n<th>Header size</th>\n<th>Type 1</th>\n<th>Type 2</th>\n<th>···</th>\n<th>Data1</th>\n<th>Data2</th>\n<th>rowid</th>\n</tr>\n</thead>\n</table>\n<p>SQLite把索引也当做一个表，并且在它自己的B-Tree中存储索引。它将一个搜索的key映射到了一个rowid上。它可以有自己的关键字的比较器，例如，使用排序方法来排序索引条目。每一个索引记录包含了索引列值的拷贝，并且紧跟着被索引的这个行的rowid。上面给出了索引记录的格式。整个记录都当做了B-Tree的key；没有数据部分。索引记录的编码和数据表的记录的一样，除了后面跟了一个rowid，并且rowid的数据类型，没有在记录头部显式声明。因为rowid的类型只能是有符号整数并且是用哈夫曼编码表示的（不是内部的整型类型）。（其它数据的值和数据的类型都从表内拷贝）在x列上的内容索引，如下所示.</p>\n<table>\n<thead>\n<tr>\n<th>x</th>\n<th>rowid</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NULL</td>\n<td>54321</td>\n</tr>\n<tr>\n<td>456</td>\n<td>2</td>\n</tr>\n<tr>\n<td>abc</td>\n<td>-5</td>\n</tr>\n<tr>\n<td>abc</td>\n<td>1</td>\n</tr>\n<tr>\n<td>hello</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>SQLite也支持多列索引。下表展示了y列和x列的索引内容。索引的条目根据他们的第一列的值排序，后面的列用作子排序。</p>\n<p>y列和x列的索引</p>\n<table>\n<thead>\n<tr>\n<th>y</th>\n<th>x</th>\n<th>rowid</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>987</td>\n<td>NULL</td>\n<td>54321</td>\n</tr>\n<tr>\n<td>12345</td>\n<td>abc</td>\n<td>1</td>\n</tr>\n<tr>\n<td>def</td>\n<td>456</td>\n<td>2</td>\n</tr>\n<tr>\n<td>xyz</td>\n<td>abc</td>\n<td>-5</td>\n</tr>\n<tr>\n<td>world</td>\n<td>hello</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>索引主要是用来加速数据库查询的。举个例子，思考一下以下查询<code>SELECT y FROM t1 WHERE x=</code>。SQLite 在索引<code>t1(x)</code>上做一次索引搜索，并且找到所有x&#x3D;?的rowid；对于每一个rowid，再在表t1的B+树上做一次搜索来获取到y列的值。</p>\n<h3 id=\"3-数据类型管理\"><a href=\"#3-数据类型管理\" class=\"headerlink\" title=\"3 数据类型管理\"></a>3 数据类型管理</h3><p>SQLite的数据处理是发生在VM模块的。VM是数据库内数据存储的唯一操纵者；所有事情都是通过字节码的执行来控制的。它决定了在某个地方存储什么数据，以及在某个地方检索什么数据。给合适的数据分配合适的数据类型，并且做必要的数据转换都是VM的主要任务。有三个数据交换的地方可能会触发数据转换：从应用到引擎，从引擎到应用，从引擎到引擎。对于前两个情况，VM为用户数据分配数据类型，VM会尽可能将用户提供的数据转换为在列上声明的数据类型，反之亦然。对于后一种情况，表达式转换会引起数据转换。在下面三个小节中，我们讨论一下这三种数据转换。</p>\n<p>在记录格式那一节中，我们讨论了表和索引记录的存储格式。每一个记录的字段值都有一个存储类型。每一个提交给SQLite的值，不论是否是作为文字嵌入到SQL语句中，亦或是准备语句的时候绑定的值，在语句执行的时候都会被指派一个数据类型。这个类型是用来将这个值实际编码为一个合适的”物理格式”。VM通过三个步骤来决定一个值的数据类型：它首先确定输入数据的存储类型，然后确定列的声明的SQL类型，最后，如果需要，它再进行类型转换。在后面章节的讲述中，SQLite可能会在查询期间在数字存储类型（INTEGER和REAL）与TEXT之间转换数据。</p>\n<h4 id=\"3-1-1-输入数据类型\"><a href=\"#3-1-1-输入数据类型\" class=\"headerlink\" title=\"3.1.1 输入数据类型\"></a>3.1.1 输入数据类型</h4><p>VM根据如下情况，为一个用户数据指派一个初始化的存储类型。一个嵌入在SQL语句中的文字将会被指派以下的几个存储类型中的一个:</p>\n<ul>\n<li>如果值被单双引号包含，那么指派为TEXT</li>\n<li>如果值是不带小数点或指数的，不带引号的数字，那么指派为INTEGER</li>\n<li>如果值是带小数点或指数的不带引号的数字，那么指派为REAL</li>\n<li>如果值是字符串NULL，且周围没有引号，那么指派为NULL</li>\n<li>如果使用X’ABCD’标记指定值，那么指派为BLOB</li>\n</ul>\n<p>除这些之外，输入的值会被拒绝，并且查询会失败。使用sqlite3_bind_ * API函数提供的SQL参数值将分配给与函数名绑定最接近的存储类型（例如，sqlite3_bind_blob 绑定一个具有存储类型BLOB的值）。</p>\n<p>SQL标量运算符结果的值的存储类型取决于表达式的最外层运算符。用户定义的函数可以返回任何存储类型的值。通常在SQL语句的准备时间阶段无法确定表达式结果的类型。VM在运行时获取值的时候分配存储类型。</p>\n<h4 id=\"3-1-2-列关联性\"><a href=\"#3-1-2-列关联性\" class=\"headerlink\" title=\"3.1.2 列关联性\"></a>3.1.2 列关联性</h4><p>尽管每个列（整数主键除外）都可以存储任何类型的值，但是该值也是会具有其声明的SQL类型的关联性。其他SQL数据库引擎使用限制性更强的静态类型，其中类型与容器关联，而不与值关联。为了最大程度地提高SQLite与其他数据库引擎之间的兼容性，SQLite支持在列上使用类型关联性的概念。对于该列中存储的值，建议使用列类型相似性：”建议使用，不是必需的。”任何列仍可以存储任何类型的数据。只是，某些列（在有选择的情况下）宁愿使用关联的那种类型而不是其他类型。</p>\n<p><strong>注意</strong></p>\n<p>SQLite是无类型的，即没有域约束。它允许在已经声明了数据类型的任何一列内存储任何类型。（除了rowid的这一列，这一列只能存整型，不能存任何其他类型）SQLite可以让你在创建语句中忽略掉SQL类型。例如，<code>create table T1(a, b, c)</code>在SQLite中是一个有效的SQL语句。</p>\n<p>列的首选类型称为其关联类型。每一列只能分配为以下五个类型之一：TEXT, NUMERIC, INTEGER, REAL, and NONE。（你可能注意到了一些与上文的冲突，”text,” “integer,”和”real”也是用于存储类型的名字。但是，您可以根据上下文确定类型类别）根据<code>CREATE TABLE</code>语句中声明的SQL类型，根据以下规则确定列的关联类型（SQLite对SQL类型声明中的拼写错误完全不严格）:</p>\n<ol>\n<li>如果SQL类型包含子字符串INT，则该列具有INTEGER关联。</li>\n<li>如果SQL类型包含任何子字符串CHAR，BLOB或TEXT，则该列具有TEXT关联性。 （SQL类型VARCHAR包含字符串CHAR，因此也具有TEXT关联性。）</li>\n<li>如果SQL类型包含子字符串BLOB，或者未指定类型，则列具有NONE关联。</li>\n<li>如果SQL类型包含任何子串REAL，FLOA或DOUB，则列具有REAL关联。</li>\n<li>除此之外, 列具有NUMERIC关联。</li>\n</ol>\n<p>VM按照与上述相同的顺序评估规则。模式匹配不区分大小写。例如，如果声明的列的SQL类型为BLOBINT，则关联性为INTEGER，而不是NONE。如果使用<code>create table table1 as select ...</code>语句创建了SQL表，则所有列都没有SQL类型，并且它们的关联性为NONE。隐式rowid的类型始终是整数.</p>\n<h4 id=\"3-1-3-类型转换\"><a href=\"#3-1-3-类型转换\" class=\"headerlink\" title=\"3.1.3 类型转换\"></a>3.1.3 类型转换</h4><p>在关联类型和存储类型之间有点关系。如果用户为列提供的值不满足该关系，则该值将被拒绝或转换为适当的格式。在将值插入列中时，VM首先分配最合适的存储类型（请参见“输入数据类型”部分），然后尝试将初始存储类型转换为其与列相关联类型的格式（请参见“列关联”部分）。它会按照下面的规则执行：</p>\n<ol>\n<li>具有TEXT关联性的列存储所有具有NULL，TEXT或BLOB存储类型的数据。如果将数值（整数或实数）插入列中，则该值将转换为文本形式，并且最终的存储类型为TEXT。</li>\n<li>具有NUMERIC关联性的列可能包含所有五种存储类型的值。将文本值插入NUMERIC列时，将尝试将值转换为整数或实数。如果转换成功，则使用INTEGER或REAL存储类型存储转换后的值。如果无法执行转换，则使用TEXT存储类型存储该值。不会尝试转换NULL或BLOB值。</li>\n<li>具有INTEGER关联性的列的行为与具有NUMERIC关联性的列的行为相同，不同之处在于，如果插入没有浮点分量的实数值（或转换为此类的文本值），则该值将转换为整数并使用INTEGER存储类型。</li>\n<li>具有REAL关联性的列的行为类似于具有NUMERIC关联性的列，不同之处在于它强制将整数值转换为浮点表示形式。（作为一种优化，整数值以整数形式存储在磁-盘上，以占用更少的空间，并且仅当从表中读取该值时才将其转换为浮点数。）</li>\n<li>关联性为NONE的列不会更偏向于哪个存储类型。 VM不会尝试转换任何输入值。</li>\n</ol>\n<p><strong>注意</strong></p>\n<p>所有的SQL数据库引擎都会执行数据转换。它们一般都会拒绝一些无法转换为目标类型的输入数据。区别是在于，当不能格式化数据的时候，SQLite依旧会存储这个值。举个例子，如果你有一个表列，声明了SQL类型为INTEGER，并且尝试插入一个字符串(如：”123”或者”abc”)，VM会鉴别一下这个字符串，看看它是否是像一个数字。如果字符串看起来像是一个数字(例如”123”)，它就会被转换为一个数字（如果数字没有小数部分，那就会被转换为整型），并且存储为一个REAL或者INTEGER存储类型。但是，如果这个字符串的内容不是一个数字格式的话(如：”abc”)，它就会被存储为TEXT存储类型。一个具有TEXT关联性的列在存储之前会尝试把数字转换为ASCII码文本。但是BLOBs存储在TEXT列的时候就不会发生转换，因为SQLite无法转换。SQLite允许把字符串的值转换为整型。这是一个特性，不是bug。</p>\n<h4 id=\"3-1-4-一个简单的例子\"><a href=\"#3-1-4-一个简单的例子\" class=\"headerlink\" title=\"3.1.4 一个简单的例子\"></a>3.1.4 一个简单的例子</h4><p>一个典型的表数据记录</p>\n<p><code>CREATE TABLE T1(a,b,c);</code><br><code>INSERT INTO T1 VALUES(177,NULL,&#39;hello&#39;);</code></p>\n<table>\n    <tr>\n        <th style=\"color:grey\">Header size</th>\n        <th style=\"color:grey\">Type 1</th>\n        <th style=\"color:grey\">Type 2</th>\n        <th style=\"color:grey\">Type 3</th>\n        <th style=\"color:grey\" colspan=\"2\">Data 1</th>\n        <th style=\"color:grey\">Data 2</th>\n        <th style=\"color:grey\" colspan=\"5\">Data 3</th>\n    </tr>\n    <tr>\n        <th>04</th>\n        <th>02</th>\n        <th>00</th>\n        <th>17</th>\n        <th>00</th>\n        <th>B1</th>\n        <th></th>\n        <th>68</th>\n        <th>65</th>\n        <th>6C</th>\n        <th>6C</th>\n        <th>6F</th>\n    </tr>\n</table>\n\n<p>让我们更清晰的了解一个非常简单的例子。上面的表给出了一个典型的无类型的表记录。a,b,c三列的初始化的输入类型是integer，NULL和TEXT。每一列的关联类型是NONE，VM不会尝试去转换初始化的存储类型。在图表里，这个记录包含了11个字节(header+data)。所有数据都是16进制格式的。</p>\n<ol>\n<li>Header有4个字节：一个字节是用来标识头部大小，后续的三个数据都有一个字节来标识数据类型。数字4会被编码为单个字节的0x04。</li>\n<li>Type 1是被编码为单个字节的2.代表有两个字节的无符号整数</li>\n<li>Type 2是被编码为单个字节的0.代表NULL</li>\n<li>Type 3是被编码为单个字节的23.代表纯文本，文本长度为(23-13&#x2F;2&#x3D;)5个字节。</li>\n<li>Data 1是一个2个字节长的00B1,也就是117。这里117是无法编码为单个字节的，因为B1是-79而不是177.</li>\n<li>Data 2是NULL，它不会在记录里占据任何的字节大小。</li>\n<li>Data 3是5个字节长的字符串68 65 6C 6F。终止符0被忽略了。</li>\n</ol>\n<p><code>sqlite3_column_*</code>开头的API方法，在SQLite引擎外读取数据。这些方法会在合适的时候转换数据类型。举个例子，如果内部的类型是FLOAT，但是结果要求是一个字符串(方法 sqlite3_column_text)，那么VM会使用<code>sprintf()</code>库方法在返回值给调用者的时候在内部做一次数据转换。下面的表格就是VM将内部数据为上层应用创建输出数据的转换规则。</p>\n<p><strong>数据转换规则</strong></p>\n<table>\n<thead>\n<tr>\n<th>内部类型</th>\n<th>要求数据类型</th>\n<th>转换结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NULL</td>\n<td>INTEGER</td>\n<td>结果是 0</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>FLOAT</td>\n<td>结果是 0</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>TEXT</td>\n<td>结果是NULL指针</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>BLOB</td>\n<td>结果是NULL指针</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>FLOAT</td>\n<td>整型转换为浮点型</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>TEXT</td>\n<td>整数的ASCII呈现</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>BLOB</td>\n<td>和上面一样</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>INTEGER</td>\n<td>浮点型转换为整型</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>TEXT</td>\n<td>浮点数的ASCII呈现</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>BLOB</td>\n<td>和上面一样</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>INTEGER</td>\n<td>使用atoi() C库函数</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>FLOAT</td>\n<td>使用atof() C库函数</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>BLOB</td>\n<td>没有变化</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>INTEGER</td>\n<td>使用atoi() 转换</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>FLOAT</td>\n<td>使用atof() 转换</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>TEXT</td>\n<td>如果有必要的话，增加\\000终止符</td>\n</tr>\n</tbody></table>\n<p>VM可能会先转换内部数据，然后再与另一个进行比较或评估表达式.它会使用以下规则来转换内部数据.</p>\n<h4 id=\"3-2-1-处理NULL值\"><a href=\"#3-2-1-处理NULL值\" class=\"headerlink\" title=\"3.2.1 处理NULL值\"></a>3.2.1 处理NULL值</h4><p>NULL值可以在任何一个表列使用，除了主键列。NULL值的存储类型是NULL。无论它们的存储类型如何，NULL值与给定列的所有有效值都不同。SQL标准对于如何处理表达式列中的NULL值不是很具体。根据标准尚不清楚在所有情况下应如何正确处理NULL值。例如，我们如何比较NULL和其他值？SQLite以许多其他DBMS一样的方式处理NULL。在SELECT DISTINCT语句，使用UNION操作符的SELECT的组合语句，和GROUP BY语句中NULL是一样的。但是，NULL在UNIQUE列中却是不同的。NULL由SQL标准指定的内置SUM函数处理。对NULL进行算术运算会产生NULL。</p>\n<h4 id=\"3-2-2-表达式中的类型\"><a href=\"#3-2-2-表达式中的类型\" class=\"headerlink\" title=\"3.2.2 表达式中的类型\"></a>3.2.2 表达式中的类型</h4><p>SQLite支持三种比较操作符：</p>\n<ul>\n<li>二元比较运算符 &#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D; 和 !&#x3D;</li>\n<li>成员运算符 IN</li>\n<li>三元比较运算符 BETWEEN</li>\n</ul>\n<p>根据以下规则，比较的结果取决于要比较的两个值的存储类型：</p>\n<ol>\n<li>如果运算符左侧的值是NULL，那么这个值一般都会认为比其他的小。（如果其他的值中有NULL，也是这样）</li>\n<li>INTEGER或REAL比TEXT或BLOB值小。如果INTEGER或REAL和另一个INTEGER或REAL比较，那么就是常规的数字比较了。</li>\n<li>TEXT值比BLOB值小。如果两个TEXT值比较，那么就是使用标准C库的memcmp函数来比较。但是这个函数是可以被用户自定义的函数重写的。</li>\n<li>当两个BLOB比较的时候，始终使用memcmp函数比较。</li>\n</ol>\n<p>在应用这些规则之前，VM的首要任务是确定比较运算符的操作数的存储类型。它首先确定操作数的初步存储类型，然后（如有必要）根据它们的相似性在类型之间转换值。最后，它使用以上四个规则进行比较。</p>\n<p>如果一个表达式是某列，或者是使用别名指向的某列，或者是一个子查询返回的一个列，或者是rowid，那么这个列的关联性就会被用作这个表达式的关联性。否则，这个表达式没有SQL类型，并且它的关联性是NONE。SQLite会尝试在比较运算之前，在（INTEGER和REAL）和TEXT之间做转换。对于二元比较，会在下列情况下完成。这里说的表达式，是除了列值以外的任何SQL标量表达式或者文字。</p>\n<ul>\n<li>当两个列的值比较的时候，如果其中任何一列的值有NUMERIC关联性，那么这两个值会优先使用这个关联性。也就是说，VM尝试在比较之前转换其他列的值。</li>\n<li>当将列值与表达式的结果进行比较时，在进行比较之前，将列的关联性同样应用于这个表达式的结果。</li>\n<li>比较两个表达式的值时，将不进行任何转换。按照上述四个标准规则比较这些值。例如，如果将字符串与数字进行比较，则数字将始终小于字符串。</li>\n</ul>\n<p>在SQLite中表达式<code>a BETWEEN b AND c</code>对于<code>a &gt;= b AND a &lt;= c</code>是等价的，尽管在两次比较中，a列的关联性会不一样。</p>\n<p>对于表达式<code>a IN (SELECT b ...)</code>来说，就会使用上面提到的&#x3D;号的二元操作符的规则来处理(例如,a&#x3D;b)。举个例子，如果b是一个列的值，a是一个表达式，那么在比较之前b的关联性就会被应用到a上。SQLite处理表达式<code>a IN (x,y,z)</code>和处理<code>a = x OR a = y OR a = z</code>是一样的，尽管a的关联性是不一样的。</p>\n<p>有些简单的例子。假设，你有一个通过<code>CREATE TABLE t1(a TEXT,b NUMERIC, c BLOB)</code>语句创建的表。你可以通过执行<code>INSERT INTO t1 VALUES(‘500’，‘500’，‘500’)</code>插入一条记录。那么最终，a,b,c三列的存储类型就会变成TEXT，INTEGER，TEXT。</p>\n<ul>\n<li><code>SELECT a &lt; 60,a &lt; 40 FROM t1</code>，会把60和40转换为”60”和”40”，因为a列具有TEXT关联性，值就会被当做TEXT来比较。并且整个语句返回<code>1|0</code>作为输出，因为”500”比”60”小，但是比”40”大。</li>\n<li><code>SELECT b &lt; 60,b &lt; 600 FROM t1</code>不会转换任何值，会被当做普通的数字比较，那么就会返回<code>0|1</code></li>\n<li><code>SELECT c &lt; 60,c &lt; 600 FROM t1</code>不会转换值，因为c的关联性是NONE。存储的两个值（存储类类型是NUMERIC）都是小于”500”(存储类型是TEXT)，那么就会返回<code>0|0</code></li>\n</ul>\n<h4 id=\"3-2-3-操作符类型\"><a href=\"#3-2-3-操作符类型\" class=\"headerlink\" title=\"3.2.3 操作符类型\"></a>3.2.3 操作符类型</h4><p>所有的数学运算符(除了 || 串联运算符以外)都将NUMERIC关联到所有的操作数上，并求值。如果所有操作数都无法转换为NUMERIC，那么运算结果为NULL。对于串联运算符来说，TEXT将关联到两个操作数上。如果任何一个操作数都无法转换为TEXT(NULL或者BLOB)，那么串联的结果为NULL。</p>\n<h4 id=\"3-2-4-ORDER-BY里的类型\"><a href=\"#3-2-4-ORDER-BY里的类型\" class=\"headerlink\" title=\"3.2.4 ORDER BY里的类型\"></a>3.2.4 ORDER BY里的类型</h4><p>当值被ORDER BY语句排序的时候，在排序之前不会有存储类型的转换。遵循先前规定的标准比较规则：NULL在最前面，然后是按值大小的INTEGER和REAL，再然后是TEXT，最后是BLOB，后面两个通常是memcmp()排序顺序。同样的文本排序方法可以被用户定义的函数重写。</p>\n<h4 id=\"3-2-5-GROUP-BY里的类型\"><a href=\"#3-2-5-GROUP-BY里的类型\" class=\"headerlink\" title=\"3.2.5 GROUP BY里的类型\"></a>3.2.5 GROUP BY里的类型</h4><p>当值被GROUP BY语句分组的时候，在分组之前不会有存储类型的转换。具有不同存储类型的值被认为是不同的，但INTEGER和REAL值除外，如果它们在数值上相等，则被视为相等。</p>\n<h4 id=\"3-2-6-复合SELECT里的类型\"><a href=\"#3-2-6-复合SELECT里的类型\" class=\"headerlink\" title=\"3.2.6 复合SELECT里的类型\"></a>3.2.6 复合SELECT里的类型</h4><p>复合SELECT操作符(UNION，INTERSECT和EXCEPT)，在值之间进行隐式比较。在执行这些比较之前，可以将关联性应用于每个值。相同的关联性（如果有的话）将应用于可能在复合SELECT结果集的单个列中返回的所有值。所应用的关联性是最左边的SELECT返回的列的关联性，该组件在该位置具有列值（而不是其他某种表达式）</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>source: inside-sqlite</p>\n</blockquote>","more":"<h2 id=\"SQLite-引擎\"><a href=\"#SQLite-引擎\" class=\"headerlink\" title=\"SQLite 引擎\"></a>SQLite 引擎</h2><p>后端最顶层的模块在SQLite术语中通常被称之为虚拟数据库引擎，或虚拟机（VM）。VM是SQLite的核心，并且是前端和后端之间的接口。在VM中会处理一些核心信息。它在原生的操作系统上层实现了一个抽象的虚拟的机器，并且它可以执行用SQLite内部的字节码程序语言编写的程序。这个程序语言是特地设计用来搜索，读取和修改数据库的。VM接受由前端生成的字节码程序，并且执行这个程序（您可能还记得字节码程序是准备好的语句）。VM使用B+树提供的”基础能力”来执行字节码程序，并且输出程序的执行结果。</p>\n<p>VM不会做任何的查询语句优化操作。它会无条件地执行字节码程序。这样，它可以将数据从一个格式转换为另一个格式。即时的数据转换，是VM的主要任务。所有事情都会在它所执行的字节码程序的控制之下。</p>\n<p>一个内存对象 sqlite3_stmt(内部为Vdbe)封装了一个字节码程序。</p>\n<p>一个Vdbe对象包含以下的内部状态：</p>\n<ul>\n<li>一个字节码程序</li>\n<li>所有结果列的名字和数据类型</li>\n<li>绑定到输入参数的值</li>\n<li>一个程序计数器</li>\n<li>操作对象的执行栈</li>\n<li>任意数量的“编号”存储单元</li>\n<li>其他运行时的状态信息（例如打开的BTree对象，排序器，列表和集合）</li>\n</ul>\n<h3 id=\"1-字节码程序语言\"><a href=\"#1-字节码程序语言\" class=\"headerlink\" title=\"1 字节码程序语言\"></a>1 字节码程序语言</h3><p>SQLite定义了一种内部的编程语言来准备字节码程序。该语言类似于物理机和虚拟机使用的汇编语言：它定义了字节码指令。一个字节码指令按照如下格式&lt;opcode, P1, P2, P3&gt;, opcode 标识了特定的字节码操作，并且P1, P2, P3是这个操作符的操作数。每一个字节码操作符定义了少量的VM工作。P1操作数是一个32位的有符号整型数。P2 操作数是一个31位的非负整型，在任何一个可能会导致跳转的操作中，P2永远是跳转的目标，当然它也会被用在其他用途。P3操作数是一个指向具有Null终止符的字符串的指针，或者是一个指向不同的结构化的对象或者NULL指针。有些操作符使用三个操作数，一些典型的操作符会忽略一个或者两个操作数，并且很多甚至会忽略三个操作数。</p>\n<p>操作符是VM内部的操作名，并且它们不是SQLite接口规范的一部分。所以，它们的操作语义可能会从一个版本更改为另一个版本。SQLite的开发者团队不鼓励SQLite的用户自己去写字节码程序。</p>\n<p><a href=\"\">表6-1</a>表述了一个等价于 SELECT * FROM t1 的典型的字节码程序。表t1有两列，命名为x和y。除了第一行以外，后面的每一行都是一个字节码指令。</p>\n<table>\n<thead>\n<tr>\n<th>Address</th>\n<th>Opcode</th>\n<th>p1</th>\n<th>p2</th>\n<th>p3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>Goto</td>\n<td>0</td>\n<td>11</td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>Integer</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>OpenRead</td>\n<td>0</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>SetNumColumn</td>\n<td>0</td>\n<td>2</td>\n<td>#t1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Rewind</td>\n<td>0</td>\n<td>9</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Column</td>\n<td>0</td>\n<td>0</td>\n<td>#x</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Column</td>\n<td>0</td>\n<td>1</td>\n<td>#y</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Callback</td>\n<td>2</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Next</td>\n<td>0</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>Close</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>Halt</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>Transaction</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>VerifyCookie</td>\n<td>0</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>Goto</td>\n<td>0</td>\n<td>1</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>如果说VM是一个解释器，那么下面的就是它的结构:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (; pc &lt; nOp &amp;&amp; rc == SQLITE_OK; pc++)&#123; </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (aOp[pc].opcode)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Add:</span><br><span class=\"line\">        <span class=\"comment\">/* Implementation of the ADD operation here */</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Goto:</span><br><span class=\"line\">        pc = op[pc].p2<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Halt:</span><br><span class=\"line\">        pc = nOp;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* other cases for other opcodes */</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个解释器是一个包含了一个巨大的Switch语句的循环体。每一个case的语句实现了一个字节码指令（操作码的名字以 OP_ 开头）。在每一次迭代中，VM从程序中拉取下一次的字节码指令。例如：从aOp数组中以pc作为下标索引获取下一个字节码指令。它会解码并且执行指定的指令。VM从指令号0开始执行一个字节码程序。</p>\n<p>VM使用游标来访问数据库。在一个数据库上可以有若干个打开的游标。每一个游标都是一个指向单个表或者索引的树。光标可以通过一个指定的key直接检索到一个条目，或者遍历整个树上的条目。VM在光标上的当前条目处插入新条目，检索键&#x2F;数据或删除条目。</p>\n<p>VM使用操作数栈和一个任意大小的内存来保存中间结果。许多操作码都从栈中获取使用操作数。计算结果也保存在栈上。每一个栈或者内存位置都保存一个单个数据值。内存位置通常用于保存作为较大表达式一部分的标量SELECT的结果。</p>\n<p>VM会一直执行字节码程序，一直到它处理一个停止指令或者遇到一个错误（在解释程序中，rc变量存储了指令的执行状态），或者程序计数器指向了最后一条指令。当程序终止的时候，它会释放所有已经分配的内存，并且关闭所有的游标。如果执行因为错误而终止了，VM会终止事务或者子事务，并且移除当前事务或者子事务引起的变更。</p>\n<h3 id=\"2-记录的格式\"><a href=\"#2-记录的格式\" class=\"headerlink\" title=\"2 记录的格式\"></a>2 记录的格式</h3><p>VM把数据值以记录(record)的形式存储在B&#x2F;B+树内。每一条记录包含一个<strong>key项</strong>和<strong>可选的数据项</strong>。VM仅负责维护key和数据的内部结构（尽管B+-tree模块可以在树（叶或内部）和多个溢出页之间拆分单个记录，但是VM是把每一条记录看做一个逻辑上连续的字节串）。VM在表记录和索引记录上使用了两种不同但是类似的记录格式。</p>\n<p>有两种格式来格式化data&#x2F;key记录：固定长度和可变长度。对于固定的长度来说，对于表或者索引的所有记录都是使用了相同大小的空间；在表或者索引的创建的时候就已经知道每一个字段的大小了。对于可变长度的格式来说，每一个字段的空间大小可能根据不同的记录而不一样。SQLite使用可变的变量长度来格式化记录，因为它有几个优势。数据库因为没有空间的浪费而变得更小。同样也会让整个系统跑得更快，因为在内存和磁盘之间需要同步的bytes数量更小。另外，使用可变长度的记录可以允许SQLite可以使用显式类型而不是静态类型。</p>\n<p>每一个数据库内存储的或者VM操作的值，都有一个相关联的数据类型。称之为数据值的存储类型。我们可以对数据进行的操作取决于数据的类型。大部分的SQL数据库使用静态类型：一个数据类型与表内的列相关联，只允许将该特定数据类型的值存储在该列中。SQLite通过使用显式类型放宽了此限制。在显式类型中，数据的类型是数据自己本身的一个属性，而不属于存储这个值的列或者变量。SQLite使用显式类型（即使SQL语言规范要求静态类型），即把数据类型作为数据的一部分来存储。SQLite允许用户不用管当前列声明的数据类型，而在该列中存储任何类型的任何数据。（有一个例外是，一个整型类型的主键列只允许存整型。）</p>\n<p>表记录的格式</p>\n<table>\n<thead>\n<tr>\n<th>Header size</th>\n<th>Type 1</th>\n<th>Type 2</th>\n<th>…</th>\n<th>Data1</th>\n<th>Data2</th>\n</tr>\n</thead>\n</table>\n<p>上面给出了一个表记录(row data)的格式。记录有两部分组成：头部和记录内容。头部由一个大小字段开始，后面跟着字段的类型。头部后面跟着记录的数据项。Header size是Data1之前的字节数。这个大小是一个哈夫曼编码的64位的可变长度的integer值，并且它包含了它自身所占用的大小。这个大小也可以被用作Data1项的指针。在header size大小之后紧跟着的是数据类型字段，每一个数据值都按照它在字段中出现的顺序排列。每一个类型字段Type i是一个可变长的无符号整型（最大是2^64），对应编码了数据字段Data i的存储类型。</p>\n<p>VM支持5种存储类型：有符号整型，有符号的浮点类型，字符串，字节流和SQL NULL。每一个在内存或者文件中存储的数据必须是以上五种之一。注意到一些数据可能在某个时间有多种含义。举个例子，123可以是一个整型数据，浮点小数，或者一个字符串。字节流和NULL没有其他的含义。所以从一种类型隐式转换为另一种类型也是有必要的。</p>\n<p>存储类型取值和它们的含义</p>\n<table>\n<thead>\n<tr>\n<th>类型值</th>\n<th>含义</th>\n<th>数据长度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>NULL</td>\n<td>0</td>\n</tr>\n<tr>\n<td>N in {1..4}</td>\n<td>有符号整数</td>\n<td>N</td>\n</tr>\n<tr>\n<td>5</td>\n<td>有符号整数</td>\n<td>6</td>\n</tr>\n<tr>\n<td>6</td>\n<td>有符号整数</td>\n<td>8</td>\n</tr>\n<tr>\n<td>7</td>\n<td>IEEE 浮点</td>\n<td>8</td>\n</tr>\n<tr>\n<td>8</td>\n<td>常数 0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>9</td>\n<td>常数 1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>10、11</td>\n<td>扩展保留</td>\n<td>N&#x2F;A</td>\n</tr>\n<tr>\n<td>N&gt;&#x3D;12 偶数</td>\n<td>字节流</td>\n<td>(N-12)&#x2F;2</td>\n</tr>\n<tr>\n<td>N&gt;&#x3D;12 奇数</td>\n<td>纯文本</td>\n<td>(N-13)&#x2F;2</td>\n</tr>\n</tbody></table>\n<p>NULL类型代表了SQL的NULL值。对于INTEGER类型，数据值是一个有符号的整型，根据数据大小的不同，存储在1，2，3，4，6或8个字节内。对于REAL类型，数据值是一个浮点小数，按照IEEE浮点数表示标准中的规定，存储在8个字节内。8，9两个数据类型，分别代表了整型常量0和1.对于TEXT类型，数据值就是一个文本字符串，使用默认编码(UTF-8, UTF-16BE, or UTF-16-LE)格式存储文本。对于后两者来说，字节顺序分别是大端或者小端。（每个数据库文件只会用一种UTF编码）对于BLOB类型，数据值是一个字节流，完全和用户输入的字节流一致。</p>\n<p>在SQLite中，每一个B+-Tree必须有一个唯一的key。尽管一个定义好的关系型表不包含相同的行，但是实际上用户是可以在关系表中存储重复的行的。但是数据库系统必须有办法来区分这些相同的行。该系统必须能够关联其他信息以实现差异化目的。这也就意味着，系统需要为这个关系提供一个新的唯一的属性。因此，在内部，每个表都有唯一的主键，并且该键由表的创建者或SQLite来定义。</p>\n<p>对于每一个SQL表，SQLite指定了一列作为rowid(或oid或_rowid_)，这一列的值唯一标识了在表中的每一行。它是表的隐式主键，表B+树的唯一搜索关键字。如果表内的任何一列被声明为 integer primary key，那么这列就会被当做这个表的rowid（作为别名）。否则的话，SQLite会创建一个独立的名为rowid作为唯一主键列。因此，每一个表不论是否声明了 integer primary key列，都有一个唯一的整型key，命名为rowid。对于后一种情况，rowid本身在内部被视为表的整数主键。无论哪种情况，rowid都是[-2^63, 2^63-1]范围内的有符号整数值</p>\n<p>下面的表展示了一个典型的SQL表的内容，这个表由SQL语句:<code>create table t1(x, y)</code>创建。rowid列由SQLite新增。rowid值通常由SQLite确定。不过你可以通过<code>insert into t1(rowid, x, y) values(100, &#39;hello&#39;, &#39;world&#39;)</code>为rowid插入任何值。</p>\n<p>一个典型的SQL表</p>\n<table>\n<thead>\n<tr>\n<th>rowid</th>\n<th>x</th>\n<th>y</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-5</td>\n<td>abc</td>\n<td>xyz</td>\n</tr>\n<tr>\n<td>1</td>\n<td>abc</td>\n<td>12345</td>\n</tr>\n<tr>\n<td>2</td>\n<td>456</td>\n<td>def</td>\n</tr>\n<tr>\n<td>100</td>\n<td>hello</td>\n<td>world</td>\n</tr>\n<tr>\n<td>54321</td>\n<td>NULL</td>\n<td>987</td>\n</tr>\n</tbody></table>\n<p><strong>注意</strong></p>\n<p>如果rowid作为一个列的别名出现(例如，声明了 INTEGER PRIMARY KEY)，数据库的用户将要负责对这个列的值的维护。如果rowid是由SQLite添加的，那么SQLite负责这个值的生成，并且它需要保证这个值的唯一性。当一行被插入的时候，如果没有指定一行内的rowid的值，SQLite会访问表的B+树并且为rowid找到一个没有使用过的整型数、</p>\n<p>这个rowid的值，如果作为数据记录的一部分存储，那么就会具有一个内部的整型类型。而如果作为key来存储，那么它就是一个可变长度的哈夫曼编码。rowid允许可以使用负数，但是他们通常使用9个字节来存储，所以一般不鼓励这样使用。当rowid由SQLite生成的时候，它们通常是非负的，尽管你可以指定这个rowid为一个负数，上面的表里-5就是一个例子。</p>\n<p>在前面的一小节里，你已经看到了，每个表的B+树的key是一个整型，并且数据记录就是表内其中的一行。索引表也保留了这个设计安排。对于一个索引记录来说，键(key)是要存储在索引表中的行的所有索引列的组合值，而数据是行的rowid。要访问具有某些用于索引列的特定值的表行，SQLite首先搜索索引表以找到相应的rowid整数值，然后使用该整数值在表的B+树中查找完整记录。</p>\n<p>索引记录的格式</p>\n<table>\n<thead>\n<tr>\n<th>Header size</th>\n<th>Type 1</th>\n<th>Type 2</th>\n<th>···</th>\n<th>Data1</th>\n<th>Data2</th>\n<th>rowid</th>\n</tr>\n</thead>\n</table>\n<p>SQLite把索引也当做一个表，并且在它自己的B-Tree中存储索引。它将一个搜索的key映射到了一个rowid上。它可以有自己的关键字的比较器，例如，使用排序方法来排序索引条目。每一个索引记录包含了索引列值的拷贝，并且紧跟着被索引的这个行的rowid。上面给出了索引记录的格式。整个记录都当做了B-Tree的key；没有数据部分。索引记录的编码和数据表的记录的一样，除了后面跟了一个rowid，并且rowid的数据类型，没有在记录头部显式声明。因为rowid的类型只能是有符号整数并且是用哈夫曼编码表示的（不是内部的整型类型）。（其它数据的值和数据的类型都从表内拷贝）在x列上的内容索引，如下所示.</p>\n<table>\n<thead>\n<tr>\n<th>x</th>\n<th>rowid</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NULL</td>\n<td>54321</td>\n</tr>\n<tr>\n<td>456</td>\n<td>2</td>\n</tr>\n<tr>\n<td>abc</td>\n<td>-5</td>\n</tr>\n<tr>\n<td>abc</td>\n<td>1</td>\n</tr>\n<tr>\n<td>hello</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>SQLite也支持多列索引。下表展示了y列和x列的索引内容。索引的条目根据他们的第一列的值排序，后面的列用作子排序。</p>\n<p>y列和x列的索引</p>\n<table>\n<thead>\n<tr>\n<th>y</th>\n<th>x</th>\n<th>rowid</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>987</td>\n<td>NULL</td>\n<td>54321</td>\n</tr>\n<tr>\n<td>12345</td>\n<td>abc</td>\n<td>1</td>\n</tr>\n<tr>\n<td>def</td>\n<td>456</td>\n<td>2</td>\n</tr>\n<tr>\n<td>xyz</td>\n<td>abc</td>\n<td>-5</td>\n</tr>\n<tr>\n<td>world</td>\n<td>hello</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>索引主要是用来加速数据库查询的。举个例子，思考一下以下查询<code>SELECT y FROM t1 WHERE x=</code>。SQLite 在索引<code>t1(x)</code>上做一次索引搜索，并且找到所有x&#x3D;?的rowid；对于每一个rowid，再在表t1的B+树上做一次搜索来获取到y列的值。</p>\n<h3 id=\"3-数据类型管理\"><a href=\"#3-数据类型管理\" class=\"headerlink\" title=\"3 数据类型管理\"></a>3 数据类型管理</h3><p>SQLite的数据处理是发生在VM模块的。VM是数据库内数据存储的唯一操纵者；所有事情都是通过字节码的执行来控制的。它决定了在某个地方存储什么数据，以及在某个地方检索什么数据。给合适的数据分配合适的数据类型，并且做必要的数据转换都是VM的主要任务。有三个数据交换的地方可能会触发数据转换：从应用到引擎，从引擎到应用，从引擎到引擎。对于前两个情况，VM为用户数据分配数据类型，VM会尽可能将用户提供的数据转换为在列上声明的数据类型，反之亦然。对于后一种情况，表达式转换会引起数据转换。在下面三个小节中，我们讨论一下这三种数据转换。</p>\n<p>在记录格式那一节中，我们讨论了表和索引记录的存储格式。每一个记录的字段值都有一个存储类型。每一个提交给SQLite的值，不论是否是作为文字嵌入到SQL语句中，亦或是准备语句的时候绑定的值，在语句执行的时候都会被指派一个数据类型。这个类型是用来将这个值实际编码为一个合适的”物理格式”。VM通过三个步骤来决定一个值的数据类型：它首先确定输入数据的存储类型，然后确定列的声明的SQL类型，最后，如果需要，它再进行类型转换。在后面章节的讲述中，SQLite可能会在查询期间在数字存储类型（INTEGER和REAL）与TEXT之间转换数据。</p>\n<h4 id=\"3-1-1-输入数据类型\"><a href=\"#3-1-1-输入数据类型\" class=\"headerlink\" title=\"3.1.1 输入数据类型\"></a>3.1.1 输入数据类型</h4><p>VM根据如下情况，为一个用户数据指派一个初始化的存储类型。一个嵌入在SQL语句中的文字将会被指派以下的几个存储类型中的一个:</p>\n<ul>\n<li>如果值被单双引号包含，那么指派为TEXT</li>\n<li>如果值是不带小数点或指数的，不带引号的数字，那么指派为INTEGER</li>\n<li>如果值是带小数点或指数的不带引号的数字，那么指派为REAL</li>\n<li>如果值是字符串NULL，且周围没有引号，那么指派为NULL</li>\n<li>如果使用X’ABCD’标记指定值，那么指派为BLOB</li>\n</ul>\n<p>除这些之外，输入的值会被拒绝，并且查询会失败。使用sqlite3_bind_ * API函数提供的SQL参数值将分配给与函数名绑定最接近的存储类型（例如，sqlite3_bind_blob 绑定一个具有存储类型BLOB的值）。</p>\n<p>SQL标量运算符结果的值的存储类型取决于表达式的最外层运算符。用户定义的函数可以返回任何存储类型的值。通常在SQL语句的准备时间阶段无法确定表达式结果的类型。VM在运行时获取值的时候分配存储类型。</p>\n<h4 id=\"3-1-2-列关联性\"><a href=\"#3-1-2-列关联性\" class=\"headerlink\" title=\"3.1.2 列关联性\"></a>3.1.2 列关联性</h4><p>尽管每个列（整数主键除外）都可以存储任何类型的值，但是该值也是会具有其声明的SQL类型的关联性。其他SQL数据库引擎使用限制性更强的静态类型，其中类型与容器关联，而不与值关联。为了最大程度地提高SQLite与其他数据库引擎之间的兼容性，SQLite支持在列上使用类型关联性的概念。对于该列中存储的值，建议使用列类型相似性：”建议使用，不是必需的。”任何列仍可以存储任何类型的数据。只是，某些列（在有选择的情况下）宁愿使用关联的那种类型而不是其他类型。</p>\n<p><strong>注意</strong></p>\n<p>SQLite是无类型的，即没有域约束。它允许在已经声明了数据类型的任何一列内存储任何类型。（除了rowid的这一列，这一列只能存整型，不能存任何其他类型）SQLite可以让你在创建语句中忽略掉SQL类型。例如，<code>create table T1(a, b, c)</code>在SQLite中是一个有效的SQL语句。</p>\n<p>列的首选类型称为其关联类型。每一列只能分配为以下五个类型之一：TEXT, NUMERIC, INTEGER, REAL, and NONE。（你可能注意到了一些与上文的冲突，”text,” “integer,”和”real”也是用于存储类型的名字。但是，您可以根据上下文确定类型类别）根据<code>CREATE TABLE</code>语句中声明的SQL类型，根据以下规则确定列的关联类型（SQLite对SQL类型声明中的拼写错误完全不严格）:</p>\n<ol>\n<li>如果SQL类型包含子字符串INT，则该列具有INTEGER关联。</li>\n<li>如果SQL类型包含任何子字符串CHAR，BLOB或TEXT，则该列具有TEXT关联性。 （SQL类型VARCHAR包含字符串CHAR，因此也具有TEXT关联性。）</li>\n<li>如果SQL类型包含子字符串BLOB，或者未指定类型，则列具有NONE关联。</li>\n<li>如果SQL类型包含任何子串REAL，FLOA或DOUB，则列具有REAL关联。</li>\n<li>除此之外, 列具有NUMERIC关联。</li>\n</ol>\n<p>VM按照与上述相同的顺序评估规则。模式匹配不区分大小写。例如，如果声明的列的SQL类型为BLOBINT，则关联性为INTEGER，而不是NONE。如果使用<code>create table table1 as select ...</code>语句创建了SQL表，则所有列都没有SQL类型，并且它们的关联性为NONE。隐式rowid的类型始终是整数.</p>\n<h4 id=\"3-1-3-类型转换\"><a href=\"#3-1-3-类型转换\" class=\"headerlink\" title=\"3.1.3 类型转换\"></a>3.1.3 类型转换</h4><p>在关联类型和存储类型之间有点关系。如果用户为列提供的值不满足该关系，则该值将被拒绝或转换为适当的格式。在将值插入列中时，VM首先分配最合适的存储类型（请参见“输入数据类型”部分），然后尝试将初始存储类型转换为其与列相关联类型的格式（请参见“列关联”部分）。它会按照下面的规则执行：</p>\n<ol>\n<li>具有TEXT关联性的列存储所有具有NULL，TEXT或BLOB存储类型的数据。如果将数值（整数或实数）插入列中，则该值将转换为文本形式，并且最终的存储类型为TEXT。</li>\n<li>具有NUMERIC关联性的列可能包含所有五种存储类型的值。将文本值插入NUMERIC列时，将尝试将值转换为整数或实数。如果转换成功，则使用INTEGER或REAL存储类型存储转换后的值。如果无法执行转换，则使用TEXT存储类型存储该值。不会尝试转换NULL或BLOB值。</li>\n<li>具有INTEGER关联性的列的行为与具有NUMERIC关联性的列的行为相同，不同之处在于，如果插入没有浮点分量的实数值（或转换为此类的文本值），则该值将转换为整数并使用INTEGER存储类型。</li>\n<li>具有REAL关联性的列的行为类似于具有NUMERIC关联性的列，不同之处在于它强制将整数值转换为浮点表示形式。（作为一种优化，整数值以整数形式存储在磁-盘上，以占用更少的空间，并且仅当从表中读取该值时才将其转换为浮点数。）</li>\n<li>关联性为NONE的列不会更偏向于哪个存储类型。 VM不会尝试转换任何输入值。</li>\n</ol>\n<p><strong>注意</strong></p>\n<p>所有的SQL数据库引擎都会执行数据转换。它们一般都会拒绝一些无法转换为目标类型的输入数据。区别是在于，当不能格式化数据的时候，SQLite依旧会存储这个值。举个例子，如果你有一个表列，声明了SQL类型为INTEGER，并且尝试插入一个字符串(如：”123”或者”abc”)，VM会鉴别一下这个字符串，看看它是否是像一个数字。如果字符串看起来像是一个数字(例如”123”)，它就会被转换为一个数字（如果数字没有小数部分，那就会被转换为整型），并且存储为一个REAL或者INTEGER存储类型。但是，如果这个字符串的内容不是一个数字格式的话(如：”abc”)，它就会被存储为TEXT存储类型。一个具有TEXT关联性的列在存储之前会尝试把数字转换为ASCII码文本。但是BLOBs存储在TEXT列的时候就不会发生转换，因为SQLite无法转换。SQLite允许把字符串的值转换为整型。这是一个特性，不是bug。</p>\n<h4 id=\"3-1-4-一个简单的例子\"><a href=\"#3-1-4-一个简单的例子\" class=\"headerlink\" title=\"3.1.4 一个简单的例子\"></a>3.1.4 一个简单的例子</h4><p>一个典型的表数据记录</p>\n<p><code>CREATE TABLE T1(a,b,c);</code><br><code>INSERT INTO T1 VALUES(177,NULL,&#39;hello&#39;);</code></p>\n<table>\n    <tr>\n        <th style=\"color:grey\">Header size</th>\n        <th style=\"color:grey\">Type 1</th>\n        <th style=\"color:grey\">Type 2</th>\n        <th style=\"color:grey\">Type 3</th>\n        <th style=\"color:grey\" colspan=\"2\">Data 1</th>\n        <th style=\"color:grey\">Data 2</th>\n        <th style=\"color:grey\" colspan=\"5\">Data 3</th>\n    </tr>\n    <tr>\n        <th>04</th>\n        <th>02</th>\n        <th>00</th>\n        <th>17</th>\n        <th>00</th>\n        <th>B1</th>\n        <th></th>\n        <th>68</th>\n        <th>65</th>\n        <th>6C</th>\n        <th>6C</th>\n        <th>6F</th>\n    </tr>\n</table>\n\n<p>让我们更清晰的了解一个非常简单的例子。上面的表给出了一个典型的无类型的表记录。a,b,c三列的初始化的输入类型是integer，NULL和TEXT。每一列的关联类型是NONE，VM不会尝试去转换初始化的存储类型。在图表里，这个记录包含了11个字节(header+data)。所有数据都是16进制格式的。</p>\n<ol>\n<li>Header有4个字节：一个字节是用来标识头部大小，后续的三个数据都有一个字节来标识数据类型。数字4会被编码为单个字节的0x04。</li>\n<li>Type 1是被编码为单个字节的2.代表有两个字节的无符号整数</li>\n<li>Type 2是被编码为单个字节的0.代表NULL</li>\n<li>Type 3是被编码为单个字节的23.代表纯文本，文本长度为(23-13&#x2F;2&#x3D;)5个字节。</li>\n<li>Data 1是一个2个字节长的00B1,也就是117。这里117是无法编码为单个字节的，因为B1是-79而不是177.</li>\n<li>Data 2是NULL，它不会在记录里占据任何的字节大小。</li>\n<li>Data 3是5个字节长的字符串68 65 6C 6F。终止符0被忽略了。</li>\n</ol>\n<p><code>sqlite3_column_*</code>开头的API方法，在SQLite引擎外读取数据。这些方法会在合适的时候转换数据类型。举个例子，如果内部的类型是FLOAT，但是结果要求是一个字符串(方法 sqlite3_column_text)，那么VM会使用<code>sprintf()</code>库方法在返回值给调用者的时候在内部做一次数据转换。下面的表格就是VM将内部数据为上层应用创建输出数据的转换规则。</p>\n<p><strong>数据转换规则</strong></p>\n<table>\n<thead>\n<tr>\n<th>内部类型</th>\n<th>要求数据类型</th>\n<th>转换结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NULL</td>\n<td>INTEGER</td>\n<td>结果是 0</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>FLOAT</td>\n<td>结果是 0</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>TEXT</td>\n<td>结果是NULL指针</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>BLOB</td>\n<td>结果是NULL指针</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>FLOAT</td>\n<td>整型转换为浮点型</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>TEXT</td>\n<td>整数的ASCII呈现</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>BLOB</td>\n<td>和上面一样</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>INTEGER</td>\n<td>浮点型转换为整型</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>TEXT</td>\n<td>浮点数的ASCII呈现</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>BLOB</td>\n<td>和上面一样</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>INTEGER</td>\n<td>使用atoi() C库函数</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>FLOAT</td>\n<td>使用atof() C库函数</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>BLOB</td>\n<td>没有变化</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>INTEGER</td>\n<td>使用atoi() 转换</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>FLOAT</td>\n<td>使用atof() 转换</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>TEXT</td>\n<td>如果有必要的话，增加\\000终止符</td>\n</tr>\n</tbody></table>\n<p>VM可能会先转换内部数据，然后再与另一个进行比较或评估表达式.它会使用以下规则来转换内部数据.</p>\n<h4 id=\"3-2-1-处理NULL值\"><a href=\"#3-2-1-处理NULL值\" class=\"headerlink\" title=\"3.2.1 处理NULL值\"></a>3.2.1 处理NULL值</h4><p>NULL值可以在任何一个表列使用，除了主键列。NULL值的存储类型是NULL。无论它们的存储类型如何，NULL值与给定列的所有有效值都不同。SQL标准对于如何处理表达式列中的NULL值不是很具体。根据标准尚不清楚在所有情况下应如何正确处理NULL值。例如，我们如何比较NULL和其他值？SQLite以许多其他DBMS一样的方式处理NULL。在SELECT DISTINCT语句，使用UNION操作符的SELECT的组合语句，和GROUP BY语句中NULL是一样的。但是，NULL在UNIQUE列中却是不同的。NULL由SQL标准指定的内置SUM函数处理。对NULL进行算术运算会产生NULL。</p>\n<h4 id=\"3-2-2-表达式中的类型\"><a href=\"#3-2-2-表达式中的类型\" class=\"headerlink\" title=\"3.2.2 表达式中的类型\"></a>3.2.2 表达式中的类型</h4><p>SQLite支持三种比较操作符：</p>\n<ul>\n<li>二元比较运算符 &#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D; 和 !&#x3D;</li>\n<li>成员运算符 IN</li>\n<li>三元比较运算符 BETWEEN</li>\n</ul>\n<p>根据以下规则，比较的结果取决于要比较的两个值的存储类型：</p>\n<ol>\n<li>如果运算符左侧的值是NULL，那么这个值一般都会认为比其他的小。（如果其他的值中有NULL，也是这样）</li>\n<li>INTEGER或REAL比TEXT或BLOB值小。如果INTEGER或REAL和另一个INTEGER或REAL比较，那么就是常规的数字比较了。</li>\n<li>TEXT值比BLOB值小。如果两个TEXT值比较，那么就是使用标准C库的memcmp函数来比较。但是这个函数是可以被用户自定义的函数重写的。</li>\n<li>当两个BLOB比较的时候，始终使用memcmp函数比较。</li>\n</ol>\n<p>在应用这些规则之前，VM的首要任务是确定比较运算符的操作数的存储类型。它首先确定操作数的初步存储类型，然后（如有必要）根据它们的相似性在类型之间转换值。最后，它使用以上四个规则进行比较。</p>\n<p>如果一个表达式是某列，或者是使用别名指向的某列，或者是一个子查询返回的一个列，或者是rowid，那么这个列的关联性就会被用作这个表达式的关联性。否则，这个表达式没有SQL类型，并且它的关联性是NONE。SQLite会尝试在比较运算之前，在（INTEGER和REAL）和TEXT之间做转换。对于二元比较，会在下列情况下完成。这里说的表达式，是除了列值以外的任何SQL标量表达式或者文字。</p>\n<ul>\n<li>当两个列的值比较的时候，如果其中任何一列的值有NUMERIC关联性，那么这两个值会优先使用这个关联性。也就是说，VM尝试在比较之前转换其他列的值。</li>\n<li>当将列值与表达式的结果进行比较时，在进行比较之前，将列的关联性同样应用于这个表达式的结果。</li>\n<li>比较两个表达式的值时，将不进行任何转换。按照上述四个标准规则比较这些值。例如，如果将字符串与数字进行比较，则数字将始终小于字符串。</li>\n</ul>\n<p>在SQLite中表达式<code>a BETWEEN b AND c</code>对于<code>a &gt;= b AND a &lt;= c</code>是等价的，尽管在两次比较中，a列的关联性会不一样。</p>\n<p>对于表达式<code>a IN (SELECT b ...)</code>来说，就会使用上面提到的&#x3D;号的二元操作符的规则来处理(例如,a&#x3D;b)。举个例子，如果b是一个列的值，a是一个表达式，那么在比较之前b的关联性就会被应用到a上。SQLite处理表达式<code>a IN (x,y,z)</code>和处理<code>a = x OR a = y OR a = z</code>是一样的，尽管a的关联性是不一样的。</p>\n<p>有些简单的例子。假设，你有一个通过<code>CREATE TABLE t1(a TEXT,b NUMERIC, c BLOB)</code>语句创建的表。你可以通过执行<code>INSERT INTO t1 VALUES(‘500’，‘500’，‘500’)</code>插入一条记录。那么最终，a,b,c三列的存储类型就会变成TEXT，INTEGER，TEXT。</p>\n<ul>\n<li><code>SELECT a &lt; 60,a &lt; 40 FROM t1</code>，会把60和40转换为”60”和”40”，因为a列具有TEXT关联性，值就会被当做TEXT来比较。并且整个语句返回<code>1|0</code>作为输出，因为”500”比”60”小，但是比”40”大。</li>\n<li><code>SELECT b &lt; 60,b &lt; 600 FROM t1</code>不会转换任何值，会被当做普通的数字比较，那么就会返回<code>0|1</code></li>\n<li><code>SELECT c &lt; 60,c &lt; 600 FROM t1</code>不会转换值，因为c的关联性是NONE。存储的两个值（存储类类型是NUMERIC）都是小于”500”(存储类型是TEXT)，那么就会返回<code>0|0</code></li>\n</ul>\n<h4 id=\"3-2-3-操作符类型\"><a href=\"#3-2-3-操作符类型\" class=\"headerlink\" title=\"3.2.3 操作符类型\"></a>3.2.3 操作符类型</h4><p>所有的数学运算符(除了 || 串联运算符以外)都将NUMERIC关联到所有的操作数上，并求值。如果所有操作数都无法转换为NUMERIC，那么运算结果为NULL。对于串联运算符来说，TEXT将关联到两个操作数上。如果任何一个操作数都无法转换为TEXT(NULL或者BLOB)，那么串联的结果为NULL。</p>\n<h4 id=\"3-2-4-ORDER-BY里的类型\"><a href=\"#3-2-4-ORDER-BY里的类型\" class=\"headerlink\" title=\"3.2.4 ORDER BY里的类型\"></a>3.2.4 ORDER BY里的类型</h4><p>当值被ORDER BY语句排序的时候，在排序之前不会有存储类型的转换。遵循先前规定的标准比较规则：NULL在最前面，然后是按值大小的INTEGER和REAL，再然后是TEXT，最后是BLOB，后面两个通常是memcmp()排序顺序。同样的文本排序方法可以被用户定义的函数重写。</p>\n<h4 id=\"3-2-5-GROUP-BY里的类型\"><a href=\"#3-2-5-GROUP-BY里的类型\" class=\"headerlink\" title=\"3.2.5 GROUP BY里的类型\"></a>3.2.5 GROUP BY里的类型</h4><p>当值被GROUP BY语句分组的时候，在分组之前不会有存储类型的转换。具有不同存储类型的值被认为是不同的，但INTEGER和REAL值除外，如果它们在数值上相等，则被视为相等。</p>\n<h4 id=\"3-2-6-复合SELECT里的类型\"><a href=\"#3-2-6-复合SELECT里的类型\" class=\"headerlink\" title=\"3.2.6 复合SELECT里的类型\"></a>3.2.6 复合SELECT里的类型</h4><p>复合SELECT操作符(UNION，INTERSECT和EXCEPT)，在值之间进行隐式比较。在执行这些比较之前，可以将关联性应用于每个值。相同的关联性（如果有的话）将应用于可能在复合SELECT结果集的单个列中返回的所有值。所应用的关联性是最左边的SELECT返回的列的关联性，该组件在该位置具有列值（而不是其他某种表达式）</p>"},{"title":"Manacher算法 -- LeetCode[5]","date":"2019-12-10T16:00:00.000Z","_content":"\n>   虽然LeetCode上这是一道Medium的题目，题目的解法有很多种。但是其中的最优解，也是本文需要探讨的算法，算是理解难度最高的一种。\n\n拿到这个道题的第一反应，应该是从回文序列的对称中心向两侧看。算出以字符串中每一个字符为中心的最大回文串长度。然后取一个最长的，即为本题解。\n\n在上述算法过程中，会有一部分算法的\"冗余\"。所谓算法冗余，即是对重复而无意义数据的计算。而Mangcher算法的优化就是去除了重复和无意义计算的部分。\n\n<!-- more -->\n\n> 说明：\n1.Manacher算法的优化，其实是针对了具体的特殊“数据结构”而做的优化。做题的时候，也许可以从题中给出的特殊结构，来获取一些优化策略。本题中的特殊“数据结构”就是回文字符串。\n2.在动态规划的思想中，dp[i]=fn(dp[i-n])，即当前的计算结果依赖之前某一次（这里没有说是上一次）已有的计算结果。\n----->而最长回文子序列的计算，则是综合了上两种思想。\n\n\n与动态规划思想类似，从“通项公式”的角度来考虑。\n\n假如我们已经有了 下标索引为 i-1 之前所有的计算结果。即 以 小于 i-1 索引的字符 为中心的回文子序列已经全部计算出来了。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog//2019/12/ee8ab9d8c2692bd40a4f791003760a7f.png)\n\n如何计算i的值就是Manacher算法解决的问题\n\n按照上面的**说明**，dp[i]=fn(dp[i-n])。那先看，第i个字符和小于i的某个字符的最长回文子序列有什么关系？\n\n每个 i 都有以自己为中心的回文子序列，那么，把右边界最远的回文子序列称为最远序列。\n\n第i个字符和这个 最远序列 有两种关系：\n1. 第i个字符在最远序列 内\n2. 第i个字符在最远序列 外\n\n这里为什么要用最远序列？后文再解释。\n如下图，m表示 小于i的某个字符的最长回文子序列\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog//2019/12/19fc8764fa0e1773234f34a1d9a497fa.png)\n\n### 当前字符在最远回文序列的内部\n\n在这种情况下，需要充分利用已有的回文序列的特征。\n\n以下把索引i对应的字符 记作 c , 把当前最远回文序列记作s, 当前最远回文序列的中心点记为 si\n\nc在一个已有的 s 内，那么根据回文序列的特点，必然还有一个字符关于这个 s 的中心点与c成轴对称。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/10e38e0c55390f8a15bc190b125faad6.png)\n\n那么在这个前提之下，在这个 s 内，如果以c为中心的是回文序列，那么对称点应该也是回文序列吧。\n\n以下把 c 在 s 内的对称点记作 c', c‘的索引计算为 si-(i-si) = 2*si - i\n再仔细思考一下，还是需要分情况讨论。\n\n**1. 如果已计算出的 c' 的最长回文序列的左边缘在 s 的左边缘内**\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/a78abcc5d265dd94b8a735c9f0fcc899.png)\ndp[i] = dp[2*si-1]\n也就是说，c 的最长回文子序列，就是c'的最长回文子序列。\n\n条件一：c' 和 c 轴对称 条件二：c' 的最长回文子序列整个都在s内\n由以上两个条件可以推出，以 c 和 c' 为对称中心的回文子序列一样。\n\n**2. 如果已计算出的 c' 的最长回文序列的左边缘在 s 的左边缘外**\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/71925b1f859701ebf763399e59266672.png)\ndp[i] = (i-si)*2+1\n\n在这种情况下，c 的右边缘应该是紧贴 s 的右边缘。\n\n想象一下， 如果 c 的右侧可以超出 s 的右边缘，那么 s 的最长回文子序列应该不止如此吧。\n也就是说 c 的长度是 s 的瓶颈。\n\n**3. 如果已计算出的 c' 的最长回文序列的左边缘在 s 的左边缘上**\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b0d22609c8522fe8e2558601a14414a5.png)\ndp[i] = dp[2*si-i] + fn(si+1)\n\n在这种情况下，以 c 为中心的回文子序列的最左边缘就不确定了,需要通过递增扩大右边缘来逐步确定以 c 为中心的最大子序列\n\n### 当前字符在最远回文序列的外部\n\n这个条件下只有一种情况，即 i = s 序列的右边缘 + 1。与上面的第三种情况一样，也是通过递增来寻找 以 c 为中心的 最大子序列。\n\n### 注\n1. 在实际操作的时候，有些细节，例如把字符串间隔中插入#来避免奇偶问题（if else处理奇偶问题确实很蛋疼）。字符串的长度会变成 2*s+1.\n2. 在计算完成之后，需要再把#移除\n3. 这里解释一下，为什么要用最远序列，而不是前 i-1 回文序列。i-1并不一定是最远的，命中 i 在 i-1 的序列中概率不是很大。为了提高利用的<i关于某个中心的对称点>这一重复计算的概率，故用最远序列来处理。\n\n**细节是魔鬼，看代码**\n```go\nfunc longestPalindrome(s string) string {\n\tfs := formatString(s)\n\tr := coreCal(fs)\n\tret := cutString(r)\n\treturn ret\n}\n\n//在字符串中插入#\nfunc formatString(s string) []byte {\n\tc := byte('#')\n\tos := []byte(s)\n\tns := make([]byte, 2*len(s)+1)\n\tns[0] = c\n\tfor index := 0; index < len(s)*2+1; index++ {\n\t\tif index%2 == 0 {\n\t\t\tns[index] = c\n\t\t} else {\n\t\t\tns[index] = os[index/2]\n\t\t}\n\t}\n\n\treturn ns\n}\n\n//移除字符串中的 #\nfunc cutString(s []byte) string {\n\trs := make([]byte, len(s)/2)\n\tc := byte('#')\n\tfor index := 0; index < len(s); index++ {\n\t\tif s[index] != c {\n\t\t\trs[index/2] = s[index]\n\t\t}\n\t}\n\n\treturn string(rs)\n}\n\n//计算最长回文子序列\nfunc coreCal(fs []byte) []byte {\n\t// fs.len 是奇数\n\tdp := make([]int, len(fs))\n\n\tvar longestString []byte\n\n\trightEdge := -1\n\tsi := 0\n\n\tfor i := 0; i < len(fs); i++ {\n\t\tif i > rightEdge {\n\t\t\tpLen := deepFind(fs, i-1, i+1)\n\n\t\t\tsi = i\n\t\t\trightEdge = si + pLen/2\n\n\t\t\tif pLen > len(longestString) {\n\t\t\t\tlongestString = fs[si-pLen/2 : si+pLen/2+1]\n\t\t\t}\n\n\t\t\tdp[i] = pLen\n\t\t} else {\n\t\t\tii := 2*si - i //对称点\n\t\t\tiiLeft := ii - dp[ii]/2\n\n\t\t\tsiLeft := si - dp[si]/2\n\t\t\tsiRight := si + dp[si]/2\n\n\t\t\tif iiLeft > siLeft {\n\t\t\t\tdp[i] = dp[ii]\n\t\t\t} else if iiLeft < siLeft {\n\t\t\t\tdp[i] = 2*(siRight-i) + 1\n\t\t\t} else {\n\t\t\t\tpLen := deepFind(fs, 2*i-siRight-1, siRight+1)\n\n\t\t\t\tsi = i\n\t\t\t\trightEdge = si + pLen/2\n\n\t\t\t\tif pLen > len(longestString) {\n\t\t\t\t\tlongestString = fs[si-pLen/2 : si+pLen/2+1]\n\t\t\t\t}\n\n\t\t\t\tdp[i] = pLen\n\t\t\t}\n\t\t}\n\t}\n\n\treturn longestString\n}\n\n//从left=l,right=r开始向左右两侧寻找回文序列\nfunc deepFind(fs []byte, l int, r int) int {\n\tfor l >= 0 && r < len(fs) {\n\t\tif fs[l] != fs[r] {\n\t\t\tbreak\n\t\t}\n\t\tl--\n\t\tr++\n\t}\n\n\treturn r - l - 1\n}\n```","source":"_posts/2.leetcode5.md","raw":"---\ntitle: Manacher算法 -- LeetCode[5]\ndate: 2019-12-11\ntags: [leetcode,回文]\ncategories: 算法\n---\n\n>   虽然LeetCode上这是一道Medium的题目，题目的解法有很多种。但是其中的最优解，也是本文需要探讨的算法，算是理解难度最高的一种。\n\n拿到这个道题的第一反应，应该是从回文序列的对称中心向两侧看。算出以字符串中每一个字符为中心的最大回文串长度。然后取一个最长的，即为本题解。\n\n在上述算法过程中，会有一部分算法的\"冗余\"。所谓算法冗余，即是对重复而无意义数据的计算。而Mangcher算法的优化就是去除了重复和无意义计算的部分。\n\n<!-- more -->\n\n> 说明：\n1.Manacher算法的优化，其实是针对了具体的特殊“数据结构”而做的优化。做题的时候，也许可以从题中给出的特殊结构，来获取一些优化策略。本题中的特殊“数据结构”就是回文字符串。\n2.在动态规划的思想中，dp[i]=fn(dp[i-n])，即当前的计算结果依赖之前某一次（这里没有说是上一次）已有的计算结果。\n----->而最长回文子序列的计算，则是综合了上两种思想。\n\n\n与动态规划思想类似，从“通项公式”的角度来考虑。\n\n假如我们已经有了 下标索引为 i-1 之前所有的计算结果。即 以 小于 i-1 索引的字符 为中心的回文子序列已经全部计算出来了。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog//2019/12/ee8ab9d8c2692bd40a4f791003760a7f.png)\n\n如何计算i的值就是Manacher算法解决的问题\n\n按照上面的**说明**，dp[i]=fn(dp[i-n])。那先看，第i个字符和小于i的某个字符的最长回文子序列有什么关系？\n\n每个 i 都有以自己为中心的回文子序列，那么，把右边界最远的回文子序列称为最远序列。\n\n第i个字符和这个 最远序列 有两种关系：\n1. 第i个字符在最远序列 内\n2. 第i个字符在最远序列 外\n\n这里为什么要用最远序列？后文再解释。\n如下图，m表示 小于i的某个字符的最长回文子序列\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog//2019/12/19fc8764fa0e1773234f34a1d9a497fa.png)\n\n### 当前字符在最远回文序列的内部\n\n在这种情况下，需要充分利用已有的回文序列的特征。\n\n以下把索引i对应的字符 记作 c , 把当前最远回文序列记作s, 当前最远回文序列的中心点记为 si\n\nc在一个已有的 s 内，那么根据回文序列的特点，必然还有一个字符关于这个 s 的中心点与c成轴对称。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/10e38e0c55390f8a15bc190b125faad6.png)\n\n那么在这个前提之下，在这个 s 内，如果以c为中心的是回文序列，那么对称点应该也是回文序列吧。\n\n以下把 c 在 s 内的对称点记作 c', c‘的索引计算为 si-(i-si) = 2*si - i\n再仔细思考一下，还是需要分情况讨论。\n\n**1. 如果已计算出的 c' 的最长回文序列的左边缘在 s 的左边缘内**\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/a78abcc5d265dd94b8a735c9f0fcc899.png)\ndp[i] = dp[2*si-1]\n也就是说，c 的最长回文子序列，就是c'的最长回文子序列。\n\n条件一：c' 和 c 轴对称 条件二：c' 的最长回文子序列整个都在s内\n由以上两个条件可以推出，以 c 和 c' 为对称中心的回文子序列一样。\n\n**2. 如果已计算出的 c' 的最长回文序列的左边缘在 s 的左边缘外**\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/71925b1f859701ebf763399e59266672.png)\ndp[i] = (i-si)*2+1\n\n在这种情况下，c 的右边缘应该是紧贴 s 的右边缘。\n\n想象一下， 如果 c 的右侧可以超出 s 的右边缘，那么 s 的最长回文子序列应该不止如此吧。\n也就是说 c 的长度是 s 的瓶颈。\n\n**3. 如果已计算出的 c' 的最长回文序列的左边缘在 s 的左边缘上**\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b0d22609c8522fe8e2558601a14414a5.png)\ndp[i] = dp[2*si-i] + fn(si+1)\n\n在这种情况下，以 c 为中心的回文子序列的最左边缘就不确定了,需要通过递增扩大右边缘来逐步确定以 c 为中心的最大子序列\n\n### 当前字符在最远回文序列的外部\n\n这个条件下只有一种情况，即 i = s 序列的右边缘 + 1。与上面的第三种情况一样，也是通过递增来寻找 以 c 为中心的 最大子序列。\n\n### 注\n1. 在实际操作的时候，有些细节，例如把字符串间隔中插入#来避免奇偶问题（if else处理奇偶问题确实很蛋疼）。字符串的长度会变成 2*s+1.\n2. 在计算完成之后，需要再把#移除\n3. 这里解释一下，为什么要用最远序列，而不是前 i-1 回文序列。i-1并不一定是最远的，命中 i 在 i-1 的序列中概率不是很大。为了提高利用的<i关于某个中心的对称点>这一重复计算的概率，故用最远序列来处理。\n\n**细节是魔鬼，看代码**\n```go\nfunc longestPalindrome(s string) string {\n\tfs := formatString(s)\n\tr := coreCal(fs)\n\tret := cutString(r)\n\treturn ret\n}\n\n//在字符串中插入#\nfunc formatString(s string) []byte {\n\tc := byte('#')\n\tos := []byte(s)\n\tns := make([]byte, 2*len(s)+1)\n\tns[0] = c\n\tfor index := 0; index < len(s)*2+1; index++ {\n\t\tif index%2 == 0 {\n\t\t\tns[index] = c\n\t\t} else {\n\t\t\tns[index] = os[index/2]\n\t\t}\n\t}\n\n\treturn ns\n}\n\n//移除字符串中的 #\nfunc cutString(s []byte) string {\n\trs := make([]byte, len(s)/2)\n\tc := byte('#')\n\tfor index := 0; index < len(s); index++ {\n\t\tif s[index] != c {\n\t\t\trs[index/2] = s[index]\n\t\t}\n\t}\n\n\treturn string(rs)\n}\n\n//计算最长回文子序列\nfunc coreCal(fs []byte) []byte {\n\t// fs.len 是奇数\n\tdp := make([]int, len(fs))\n\n\tvar longestString []byte\n\n\trightEdge := -1\n\tsi := 0\n\n\tfor i := 0; i < len(fs); i++ {\n\t\tif i > rightEdge {\n\t\t\tpLen := deepFind(fs, i-1, i+1)\n\n\t\t\tsi = i\n\t\t\trightEdge = si + pLen/2\n\n\t\t\tif pLen > len(longestString) {\n\t\t\t\tlongestString = fs[si-pLen/2 : si+pLen/2+1]\n\t\t\t}\n\n\t\t\tdp[i] = pLen\n\t\t} else {\n\t\t\tii := 2*si - i //对称点\n\t\t\tiiLeft := ii - dp[ii]/2\n\n\t\t\tsiLeft := si - dp[si]/2\n\t\t\tsiRight := si + dp[si]/2\n\n\t\t\tif iiLeft > siLeft {\n\t\t\t\tdp[i] = dp[ii]\n\t\t\t} else if iiLeft < siLeft {\n\t\t\t\tdp[i] = 2*(siRight-i) + 1\n\t\t\t} else {\n\t\t\t\tpLen := deepFind(fs, 2*i-siRight-1, siRight+1)\n\n\t\t\t\tsi = i\n\t\t\t\trightEdge = si + pLen/2\n\n\t\t\t\tif pLen > len(longestString) {\n\t\t\t\t\tlongestString = fs[si-pLen/2 : si+pLen/2+1]\n\t\t\t\t}\n\n\t\t\t\tdp[i] = pLen\n\t\t\t}\n\t\t}\n\t}\n\n\treturn longestString\n}\n\n//从left=l,right=r开始向左右两侧寻找回文序列\nfunc deepFind(fs []byte, l int, r int) int {\n\tfor l >= 0 && r < len(fs) {\n\t\tif fs[l] != fs[r] {\n\t\t\tbreak\n\t\t}\n\t\tl--\n\t\tr++\n\t}\n\n\treturn r - l - 1\n}\n```","slug":"2.leetcode5","published":1,"updated":"2020-08-29T14:42:58.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwo8000zp9c93ekf9x2p","content":"<blockquote>\n<p>  虽然LeetCode上这是一道Medium的题目，题目的解法有很多种。但是其中的最优解，也是本文需要探讨的算法，算是理解难度最高的一种。</p>\n</blockquote>\n<p>拿到这个道题的第一反应，应该是从回文序列的对称中心向两侧看。算出以字符串中每一个字符为中心的最大回文串长度。然后取一个最长的，即为本题解。</p>\n<p>在上述算法过程中，会有一部分算法的”冗余”。所谓算法冗余，即是对重复而无意义数据的计算。而Mangcher算法的优化就是去除了重复和无意义计算的部分。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>说明：<br>1.Manacher算法的优化，其实是针对了具体的特殊“数据结构”而做的优化。做题的时候，也许可以从题中给出的特殊结构，来获取一些优化策略。本题中的特殊“数据结构”就是回文字符串。<br>2.在动态规划的思想中，dp[i]&#x3D;fn(dp[i-n])，即当前的计算结果依赖之前某一次（这里没有说是上一次）已有的计算结果。<br>—–&gt;而最长回文子序列的计算，则是综合了上两种思想。</p>\n</blockquote>\n<p>与动态规划思想类似，从“通项公式”的角度来考虑。</p>\n<p>假如我们已经有了 下标索引为 i-1 之前所有的计算结果。即 以 小于 i-1 索引的字符 为中心的回文子序列已经全部计算出来了。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog//2019/12/ee8ab9d8c2692bd40a4f791003760a7f.png\"></p>\n<p>如何计算i的值就是Manacher算法解决的问题</p>\n<p>按照上面的<strong>说明</strong>，dp[i]&#x3D;fn(dp[i-n])。那先看，第i个字符和小于i的某个字符的最长回文子序列有什么关系？</p>\n<p>每个 i 都有以自己为中心的回文子序列，那么，把右边界最远的回文子序列称为最远序列。</p>\n<p>第i个字符和这个 最远序列 有两种关系：</p>\n<ol>\n<li>第i个字符在最远序列 内</li>\n<li>第i个字符在最远序列 外</li>\n</ol>\n<p>这里为什么要用最远序列？后文再解释。<br>如下图，m表示 小于i的某个字符的最长回文子序列<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog//2019/12/19fc8764fa0e1773234f34a1d9a497fa.png\"></p>\n<h3 id=\"当前字符在最远回文序列的内部\"><a href=\"#当前字符在最远回文序列的内部\" class=\"headerlink\" title=\"当前字符在最远回文序列的内部\"></a>当前字符在最远回文序列的内部</h3><p>在这种情况下，需要充分利用已有的回文序列的特征。</p>\n<p>以下把索引i对应的字符 记作 c , 把当前最远回文序列记作s, 当前最远回文序列的中心点记为 si</p>\n<p>c在一个已有的 s 内，那么根据回文序列的特点，必然还有一个字符关于这个 s 的中心点与c成轴对称。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/10e38e0c55390f8a15bc190b125faad6.png\"></p>\n<p>那么在这个前提之下，在这个 s 内，如果以c为中心的是回文序列，那么对称点应该也是回文序列吧。</p>\n<p>以下把 c 在 s 内的对称点记作 c’, c‘的索引计算为 si-(i-si) &#x3D; 2*si - i<br>再仔细思考一下，还是需要分情况讨论。</p>\n<p><strong>1. 如果已计算出的 c’ 的最长回文序列的左边缘在 s 的左边缘内</strong><br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/a78abcc5d265dd94b8a735c9f0fcc899.png\"><br>dp[i] &#x3D; dp[2*si-1]<br>也就是说，c 的最长回文子序列，就是c’的最长回文子序列。</p>\n<p>条件一：c’ 和 c 轴对称 条件二：c’ 的最长回文子序列整个都在s内<br>由以上两个条件可以推出，以 c 和 c’ 为对称中心的回文子序列一样。</p>\n<p><strong>2. 如果已计算出的 c’ 的最长回文序列的左边缘在 s 的左边缘外</strong><br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/71925b1f859701ebf763399e59266672.png\"><br>dp[i] &#x3D; (i-si)*2+1</p>\n<p>在这种情况下，c 的右边缘应该是紧贴 s 的右边缘。</p>\n<p>想象一下， 如果 c 的右侧可以超出 s 的右边缘，那么 s 的最长回文子序列应该不止如此吧。<br>也就是说 c 的长度是 s 的瓶颈。</p>\n<p><strong>3. 如果已计算出的 c’ 的最长回文序列的左边缘在 s 的左边缘上</strong><br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b0d22609c8522fe8e2558601a14414a5.png\"><br>dp[i] &#x3D; dp[2*si-i] + fn(si+1)</p>\n<p>在这种情况下，以 c 为中心的回文子序列的最左边缘就不确定了,需要通过递增扩大右边缘来逐步确定以 c 为中心的最大子序列</p>\n<h3 id=\"当前字符在最远回文序列的外部\"><a href=\"#当前字符在最远回文序列的外部\" class=\"headerlink\" title=\"当前字符在最远回文序列的外部\"></a>当前字符在最远回文序列的外部</h3><p>这个条件下只有一种情况，即 i &#x3D; s 序列的右边缘 + 1。与上面的第三种情况一样，也是通过递增来寻找 以 c 为中心的 最大子序列。</p>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><ol>\n<li>在实际操作的时候，有些细节，例如把字符串间隔中插入#来避免奇偶问题（if else处理奇偶问题确实很蛋疼）。字符串的长度会变成 2*s+1.</li>\n<li>在计算完成之后，需要再把#移除</li>\n<li>这里解释一下，为什么要用最远序列，而不是前 i-1 回文序列。i-1并不一定是最远的，命中 i 在 i-1 的序列中概率不是很大。为了提高利用的&lt;i关于某个中心的对称点&gt;这一重复计算的概率，故用最远序列来处理。</li>\n</ol>\n<p><strong>细节是魔鬼，看代码</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\tfs := formatString(s)</span><br><span class=\"line\">\tr := coreCal(fs)</span><br><span class=\"line\">\tret := cutString(r)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在字符串中插入#</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">formatString</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">byte</span> &#123;</span><br><span class=\"line\">\tc := <span class=\"type\">byte</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\tos := []<span class=\"type\">byte</span>(s)</span><br><span class=\"line\">\tns := <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">2</span>*<span class=\"built_in\">len</span>(s)+<span class=\"number\">1</span>)</span><br><span class=\"line\">\tns[<span class=\"number\">0</span>] = c</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> index := <span class=\"number\">0</span>; index &lt; <span class=\"built_in\">len</span>(s)*<span class=\"number\">2</span>+<span class=\"number\">1</span>; index++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> index%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tns[index] = c</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tns[index] = os[index/<span class=\"number\">2</span>]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ns</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除字符串中的 #</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cutString</span><span class=\"params\">(s []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trs := <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"built_in\">len</span>(s)/<span class=\"number\">2</span>)</span><br><span class=\"line\">\tc := <span class=\"type\">byte</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> index := <span class=\"number\">0</span>; index &lt; <span class=\"built_in\">len</span>(s); index++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[index] != c &#123;</span><br><span class=\"line\">\t\t\trs[index/<span class=\"number\">2</span>] = s[index]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(rs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计算最长回文子序列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coreCal</span><span class=\"params\">(fs []<span class=\"type\">byte</span>)</span></span> []<span class=\"type\">byte</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// fs.len 是奇数</span></span><br><span class=\"line\">\tdp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(fs))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> longestString []<span class=\"type\">byte</span></span><br><span class=\"line\"></span><br><span class=\"line\">\trightEdge := <span class=\"number\">-1</span></span><br><span class=\"line\">\tsi := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(fs); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &gt; rightEdge &#123;</span><br><span class=\"line\">\t\t\tpLen := deepFind(fs, i<span class=\"number\">-1</span>, i+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tsi = i</span><br><span class=\"line\">\t\t\trightEdge = si + pLen/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> pLen &gt; <span class=\"built_in\">len</span>(longestString) &#123;</span><br><span class=\"line\">\t\t\t\tlongestString = fs[si-pLen/<span class=\"number\">2</span> : si+pLen/<span class=\"number\">2</span>+<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tdp[i] = pLen</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tii := <span class=\"number\">2</span>*si - i <span class=\"comment\">//对称点</span></span><br><span class=\"line\">\t\t\tiiLeft := ii - dp[ii]/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tsiLeft := si - dp[si]/<span class=\"number\">2</span></span><br><span class=\"line\">\t\t\tsiRight := si + dp[si]/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> iiLeft &gt; siLeft &#123;</span><br><span class=\"line\">\t\t\t\tdp[i] = dp[ii]</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> iiLeft &lt; siLeft &#123;</span><br><span class=\"line\">\t\t\t\tdp[i] = <span class=\"number\">2</span>*(siRight-i) + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tpLen := deepFind(fs, <span class=\"number\">2</span>*i-siRight<span class=\"number\">-1</span>, siRight+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tsi = i</span><br><span class=\"line\">\t\t\t\trightEdge = si + pLen/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> pLen &gt; <span class=\"built_in\">len</span>(longestString) &#123;</span><br><span class=\"line\">\t\t\t\t\tlongestString = fs[si-pLen/<span class=\"number\">2</span> : si+pLen/<span class=\"number\">2</span>+<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tdp[i] = pLen</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> longestString</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从left=l,right=r开始向左右两侧寻找回文序列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deepFind</span><span class=\"params\">(fs []<span class=\"type\">byte</span>, l <span class=\"type\">int</span>, r <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &gt;= <span class=\"number\">0</span> &amp;&amp; r &lt; <span class=\"built_in\">len</span>(fs) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> fs[l] != fs[r] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tl--</span><br><span class=\"line\">\t\tr++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r - l - <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote>\n<p>  虽然LeetCode上这是一道Medium的题目，题目的解法有很多种。但是其中的最优解，也是本文需要探讨的算法，算是理解难度最高的一种。</p>\n</blockquote>\n<p>拿到这个道题的第一反应，应该是从回文序列的对称中心向两侧看。算出以字符串中每一个字符为中心的最大回文串长度。然后取一个最长的，即为本题解。</p>\n<p>在上述算法过程中，会有一部分算法的”冗余”。所谓算法冗余，即是对重复而无意义数据的计算。而Mangcher算法的优化就是去除了重复和无意义计算的部分。</p>","more":"<blockquote>\n<p>说明：<br>1.Manacher算法的优化，其实是针对了具体的特殊“数据结构”而做的优化。做题的时候，也许可以从题中给出的特殊结构，来获取一些优化策略。本题中的特殊“数据结构”就是回文字符串。<br>2.在动态规划的思想中，dp[i]&#x3D;fn(dp[i-n])，即当前的计算结果依赖之前某一次（这里没有说是上一次）已有的计算结果。<br>—–&gt;而最长回文子序列的计算，则是综合了上两种思想。</p>\n</blockquote>\n<p>与动态规划思想类似，从“通项公式”的角度来考虑。</p>\n<p>假如我们已经有了 下标索引为 i-1 之前所有的计算结果。即 以 小于 i-1 索引的字符 为中心的回文子序列已经全部计算出来了。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog//2019/12/ee8ab9d8c2692bd40a4f791003760a7f.png\"></p>\n<p>如何计算i的值就是Manacher算法解决的问题</p>\n<p>按照上面的<strong>说明</strong>，dp[i]&#x3D;fn(dp[i-n])。那先看，第i个字符和小于i的某个字符的最长回文子序列有什么关系？</p>\n<p>每个 i 都有以自己为中心的回文子序列，那么，把右边界最远的回文子序列称为最远序列。</p>\n<p>第i个字符和这个 最远序列 有两种关系：</p>\n<ol>\n<li>第i个字符在最远序列 内</li>\n<li>第i个字符在最远序列 外</li>\n</ol>\n<p>这里为什么要用最远序列？后文再解释。<br>如下图，m表示 小于i的某个字符的最长回文子序列<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog//2019/12/19fc8764fa0e1773234f34a1d9a497fa.png\"></p>\n<h3 id=\"当前字符在最远回文序列的内部\"><a href=\"#当前字符在最远回文序列的内部\" class=\"headerlink\" title=\"当前字符在最远回文序列的内部\"></a>当前字符在最远回文序列的内部</h3><p>在这种情况下，需要充分利用已有的回文序列的特征。</p>\n<p>以下把索引i对应的字符 记作 c , 把当前最远回文序列记作s, 当前最远回文序列的中心点记为 si</p>\n<p>c在一个已有的 s 内，那么根据回文序列的特点，必然还有一个字符关于这个 s 的中心点与c成轴对称。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/10e38e0c55390f8a15bc190b125faad6.png\"></p>\n<p>那么在这个前提之下，在这个 s 内，如果以c为中心的是回文序列，那么对称点应该也是回文序列吧。</p>\n<p>以下把 c 在 s 内的对称点记作 c’, c‘的索引计算为 si-(i-si) &#x3D; 2*si - i<br>再仔细思考一下，还是需要分情况讨论。</p>\n<p><strong>1. 如果已计算出的 c’ 的最长回文序列的左边缘在 s 的左边缘内</strong><br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/a78abcc5d265dd94b8a735c9f0fcc899.png\"><br>dp[i] &#x3D; dp[2*si-1]<br>也就是说，c 的最长回文子序列，就是c’的最长回文子序列。</p>\n<p>条件一：c’ 和 c 轴对称 条件二：c’ 的最长回文子序列整个都在s内<br>由以上两个条件可以推出，以 c 和 c’ 为对称中心的回文子序列一样。</p>\n<p><strong>2. 如果已计算出的 c’ 的最长回文序列的左边缘在 s 的左边缘外</strong><br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/71925b1f859701ebf763399e59266672.png\"><br>dp[i] &#x3D; (i-si)*2+1</p>\n<p>在这种情况下，c 的右边缘应该是紧贴 s 的右边缘。</p>\n<p>想象一下， 如果 c 的右侧可以超出 s 的右边缘，那么 s 的最长回文子序列应该不止如此吧。<br>也就是说 c 的长度是 s 的瓶颈。</p>\n<p><strong>3. 如果已计算出的 c’ 的最长回文序列的左边缘在 s 的左边缘上</strong><br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b0d22609c8522fe8e2558601a14414a5.png\"><br>dp[i] &#x3D; dp[2*si-i] + fn(si+1)</p>\n<p>在这种情况下，以 c 为中心的回文子序列的最左边缘就不确定了,需要通过递增扩大右边缘来逐步确定以 c 为中心的最大子序列</p>\n<h3 id=\"当前字符在最远回文序列的外部\"><a href=\"#当前字符在最远回文序列的外部\" class=\"headerlink\" title=\"当前字符在最远回文序列的外部\"></a>当前字符在最远回文序列的外部</h3><p>这个条件下只有一种情况，即 i &#x3D; s 序列的右边缘 + 1。与上面的第三种情况一样，也是通过递增来寻找 以 c 为中心的 最大子序列。</p>\n<h3 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h3><ol>\n<li>在实际操作的时候，有些细节，例如把字符串间隔中插入#来避免奇偶问题（if else处理奇偶问题确实很蛋疼）。字符串的长度会变成 2*s+1.</li>\n<li>在计算完成之后，需要再把#移除</li>\n<li>这里解释一下，为什么要用最远序列，而不是前 i-1 回文序列。i-1并不一定是最远的，命中 i 在 i-1 的序列中概率不是很大。为了提高利用的&lt;i关于某个中心的对称点&gt;这一重复计算的概率，故用最远序列来处理。</li>\n</ol>\n<p><strong>细节是魔鬼，看代码</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\tfs := formatString(s)</span><br><span class=\"line\">\tr := coreCal(fs)</span><br><span class=\"line\">\tret := cutString(r)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在字符串中插入#</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">formatString</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">byte</span> &#123;</span><br><span class=\"line\">\tc := <span class=\"type\">byte</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\tos := []<span class=\"type\">byte</span>(s)</span><br><span class=\"line\">\tns := <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">2</span>*<span class=\"built_in\">len</span>(s)+<span class=\"number\">1</span>)</span><br><span class=\"line\">\tns[<span class=\"number\">0</span>] = c</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> index := <span class=\"number\">0</span>; index &lt; <span class=\"built_in\">len</span>(s)*<span class=\"number\">2</span>+<span class=\"number\">1</span>; index++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> index%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tns[index] = c</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tns[index] = os[index/<span class=\"number\">2</span>]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ns</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除字符串中的 #</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cutString</span><span class=\"params\">(s []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trs := <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"built_in\">len</span>(s)/<span class=\"number\">2</span>)</span><br><span class=\"line\">\tc := <span class=\"type\">byte</span>(<span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> index := <span class=\"number\">0</span>; index &lt; <span class=\"built_in\">len</span>(s); index++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[index] != c &#123;</span><br><span class=\"line\">\t\t\trs[index/<span class=\"number\">2</span>] = s[index]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(rs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计算最长回文子序列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coreCal</span><span class=\"params\">(fs []<span class=\"type\">byte</span>)</span></span> []<span class=\"type\">byte</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// fs.len 是奇数</span></span><br><span class=\"line\">\tdp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(fs))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> longestString []<span class=\"type\">byte</span></span><br><span class=\"line\"></span><br><span class=\"line\">\trightEdge := <span class=\"number\">-1</span></span><br><span class=\"line\">\tsi := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(fs); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &gt; rightEdge &#123;</span><br><span class=\"line\">\t\t\tpLen := deepFind(fs, i<span class=\"number\">-1</span>, i+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tsi = i</span><br><span class=\"line\">\t\t\trightEdge = si + pLen/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> pLen &gt; <span class=\"built_in\">len</span>(longestString) &#123;</span><br><span class=\"line\">\t\t\t\tlongestString = fs[si-pLen/<span class=\"number\">2</span> : si+pLen/<span class=\"number\">2</span>+<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tdp[i] = pLen</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tii := <span class=\"number\">2</span>*si - i <span class=\"comment\">//对称点</span></span><br><span class=\"line\">\t\t\tiiLeft := ii - dp[ii]/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tsiLeft := si - dp[si]/<span class=\"number\">2</span></span><br><span class=\"line\">\t\t\tsiRight := si + dp[si]/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> iiLeft &gt; siLeft &#123;</span><br><span class=\"line\">\t\t\t\tdp[i] = dp[ii]</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> iiLeft &lt; siLeft &#123;</span><br><span class=\"line\">\t\t\t\tdp[i] = <span class=\"number\">2</span>*(siRight-i) + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tpLen := deepFind(fs, <span class=\"number\">2</span>*i-siRight<span class=\"number\">-1</span>, siRight+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tsi = i</span><br><span class=\"line\">\t\t\t\trightEdge = si + pLen/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> pLen &gt; <span class=\"built_in\">len</span>(longestString) &#123;</span><br><span class=\"line\">\t\t\t\t\tlongestString = fs[si-pLen/<span class=\"number\">2</span> : si+pLen/<span class=\"number\">2</span>+<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tdp[i] = pLen</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> longestString</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从left=l,right=r开始向左右两侧寻找回文序列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deepFind</span><span class=\"params\">(fs []<span class=\"type\">byte</span>, l <span class=\"type\">int</span>, r <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &gt;= <span class=\"number\">0</span> &amp;&amp; r &lt; <span class=\"built_in\">len</span>(fs) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> fs[l] != fs[r] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tl--</span><br><span class=\"line\">\t\tr++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r - l - <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"SQLite--Tokenize(词法分析器)","date":"2020-07-20T16:00:00.000Z","top":300,"_content":"\n> SQLite的词法分析器的代码逻辑其实很简单，但是其中也不乏SQLite对于执行效率的优化。甚至可以说SQLite在追求高效的每一个细节点，都无所不用其极。文章从源码的角度分别看具体的实现逻辑与优化的细节\n\n<!-- more -->\n\n## 关于前端的大致结构\n\nTokenize是SQLite的最前端，它的职责就是，将用户输入的一个SQL字符串，分割为一个一个独立的词。并且以*特征ID*的形式一个一个输入给Parser，而不是一个一个单词。因为parser只认识这些*特征ID*。\n\n先说一下Parser\n\nParser是SQLite开发的一个语法分析器。在`$root/tool/`目录下有一个`lemon.c`的工具。SQLite是通过`cmake`来配置源码的编译，在`autoconf`配置下产生的Makefile中有几个关于这个的指令:\n\n```\n# 编译lemon.c，生成lemon可执行文件\n#\nlemon$(BEXE):\t$(TOP)/tool/lemon.c $(TOP)/tool/lempar.c\n\t$(BCC) -o $@ $(TOP)/tool/lemon.c\n\tcp $(TOP)/tool/lempar.c .\n```\n\n```\n# parse.h 和 parse.c文件都依赖于lemon可执行文件\n# 通过command可以看到，lemon依赖parse.y这个文件生成了parse.h和parse.c\n#\nparse.h:\tparse.c\n\nparse.c:\t$(TOP)/src/parse.y lemon$(BEXE) $(TOP)/tool/addopcodes.tcl\n\tcp $(TOP)/src/parse.y .\n\trm -f parse.h\n\t./lemon$(BEXE) $(OPT_FEATURE_FLAGS) $(OPTS) parse.y\n\tmv parse.h parse.h.temp\n\t$(TCLSH_CMD) $(TOP)/tool/addopcodes.tcl parse.h.temp >parse.h\n```\n\n```\n# fts5也是使用的lemon程序，通过fts5parse.y的定义来生成解析器\nfts5parse.c:\t$(TOP)/ext/fts5/fts5parse.y lemon\n\tcp $(TOP)/ext/fts5/fts5parse.y .\n\trm -f fts5parse.h\n\t./lemon$(BEXE) $(OPTS) fts5parse.y\n```\n\nParser的核心代码都是使用lemon这个工具生成的，通过不断地输入在parse.h中定义的特征ID来生成一个语法树。\n\n那特征ID哪来呢？就是上面已经提到的Tokenize。\n\n在SQLite API中的\n`int sqlite3_prepare();`\n`int sqlite3_prepare_v2();`\n`int sqlite3_prepare_v3();`\n\n三个SQL预处理方法都是通过先调用tokenize，然后调用parser，通过vm的*编译*生成*字节码*\n\n大致的函数调用时序:\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/07/2020-07-23-00-11.jpg)\n\n## 词法分析器源码\n\n`tokenize.c`的源码结构非常简单。只有两个核心函数 `int sqlite3GetToken(const unsigned char *z, int *tokenType)` 与 `int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg)`\n\n`prepare`函数会直接调用`sqlite3RunParser`函数，这个函数虽然很长，但是把核心代码提取出来后，就一目了然。\n\n```c\nint sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){\n  int nErr = 0;                   /* Number of errors encountered */\n  void *pEngine;                  /* The LEMON-generated LALR(1) parser */\n  int n = 0;                      /* Length of the next token token */\n  int tokenType;                  /* type of the next token */\n  int lastTokenParsed = -1;       /* type of the previous token */\n  sqlite3 *db = pParse->db;       /* The database connection */\n  int mxSqlLen;                   /* Max length of an SQL string */\n  pParse->zTail = zSql;\n\n  pEngine = sqlite3ParserAlloc(sqlite3Malloc, pParse);\n\n  while( 1 ){\n    n = sqlite3GetToken((u8*)zSql, &tokenType);\n    mxSqlLen -= n;\n    if( mxSqlLen<0 ){\n      pParse->rc = SQLITE_TOOBIG;\n      break;\n    }\n    if( tokenType>=TK_SPACE ){\n      assert( tokenType==TK_SPACE || tokenType==TK_ILLEGAL );\n      if( db->u1.isInterrupted ){\n        pParse->rc = SQLITE_INTERRUPT;\n        break;\n      }\n      if( tokenType==TK_SPACE ){\n        zSql += n;\n        continue;\n      }\n      if( zSql[0]==0 ){\n        /* Upon reaching the end of input, call the parser two more times\n        ** with tokens TK_SEMI and 0, in that order. */\n        if( lastTokenParsed==TK_SEMI ){\n          tokenType = 0;\n        }else if( lastTokenParsed==0 ){\n          break;\n        }else{\n          tokenType = TK_SEMI;\n        }\n        n = 0;\n      }else{\n        sqlite3ErrorMsg(pParse, \"unrecognized token: \\\"%.*s\\\"\", n, zSql);\n        break;\n      }\n    }\n    pParse->sLastToken.z = zSql;\n    pParse->sLastToken.n = n;\n    sqlite3Parser(pEngine, tokenType, pParse->sLastToken);\n    lastTokenParsed = tokenType;\n    zSql += n;\n    if( pParse->rc!=SQLITE_OK || db->mallocFailed ) break;\n  }\n  // mem free code...\n  return nErr;\n}\n```\n\n这样似乎看起来还是很多，再精简一下。\n\n```c\nwhile( 1 ){\n    n = sqlite3GetToken((u8*)zSql, &tokenType);\n    sqlite3Parser(pEngine, tokenType, pParse->sLastToken);    \n}\n```\n\n只有两个步骤，取词，调用parser，然后不断地循环，一直到全部读完为止。这也印证了上面的话。\n\n从SQL语句中取词无非也就是根据分割符，不断的裁剪分割罢了。但是开头提到，SQLite为了追求效率，做了很多优化。\n\n后面详细说一下优化的细节。\n\n## 词法分析器效率的优化\n\n`sqlite3RunParser`函数主要是流程化的代码，主要优化都在`sqlite3GetToken`函数内，看下源码。\n\n```c\n/*\n** Return the length (in bytes) of the token that begins at z[0]. \n** Store the token type in *tokenType before returning.\n*/\nint sqlite3GetToken(const unsigned char *z, int *tokenType){\n  int i, c;\n  switch( aiClass[*z] ){  /* Switch on the character-class of the first byte\n                          ** of the token. See the comment on the CC_ defines\n                          ** above. */\n    case CC_SPACE: {\n      testcase( z[0]==' ' );\n      testcase( z[0]=='\\t' );\n      testcase( z[0]=='\\n' );\n      testcase( z[0]=='\\f' );\n      testcase( z[0]=='\\r' );\n      for(i=1; sqlite3Isspace(z[i]); i++){}\n      *tokenType = TK_SPACE;\n      return i;\n    }\n    case CC_VARNUM: {\n      *tokenType = TK_VARIABLE;\n      for(i=1; sqlite3Isdigit(z[i]); i++){}\n      return i;\n    }\n\n    // .... more case\n\n    case CC_KYWD: {\n      for(i=1; aiClass[z[i]]<=CC_KYWD; i++){}\n      if( IdChar(z[i]) ){\n        /* This token started out using characters that can appear in keywords,\n        ** but z[i] is a character not allowed within keywords, so this must\n        ** be an identifier instead */\n        i++;\n        break;\n      }\n      *tokenType = TK_ID;\n      return keywordCode((char*)z, i, tokenType);\n    }\n    case CC_X: {\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n      testcase( z[0]=='x' ); testcase( z[0]=='X' );\n      if( z[1]=='\\'' ){\n        *tokenType = TK_BLOB;\n        for(i=2; sqlite3Isxdigit(z[i]); i++){}\n        if( z[i]!='\\'' || i%2 ){\n          *tokenType = TK_ILLEGAL;\n          while( z[i] && z[i]!='\\'' ){ i++; }\n        }\n        if( z[i] ) i++;\n        return i;\n      }\n#endif\n      /* If it is not a BLOB literal, then it must be an ID, since no\n      ** SQL keywords start with the letter 'x'.  Fall through */\n    }\n    case CC_ID: {\n      i = 1;\n      break;\n    }\n    case CC_NUL: {\n      *tokenType = TK_ILLEGAL;\n      return 0;\n    }\n    default: {\n      *tokenType = TK_ILLEGAL;\n      return 1;\n    }\n  }\n  while( IdChar(z[i]) ){ i++; }\n  *tokenType = TK_ID;\n  return i;\n}\n```\n\n从代码可以看到，`sqlite3GetToken`输入一个SQL字符串，然后根据这个串的第一个字符判断是什么类型(CC_SPACE,CC_NUL,...)等等，用一个巨大的switch-case来处理不同的*词*，因为这个函数需要依次返回各种词的类型(tokenType)，也就是上文提到的在Parser.h中定义的类型。\n\n但是...`aiClass[*z]`这个是干什么用的？为什么不直接使用`switch(*z)`？\n\n这里就不得不讲到 *Switch-Case* 的编译实现了。\n\nswitch-case在使用的时候编译器会根据case中的constant值来决定使用哪种方式做检索。具体了解的话可以看这篇文章[关于C/C++ switch语句你也许不知道的一些事](http://blog.csdn.net/simmerlee/article/details/50845706)\n\n1. 编译器使用二级表的方式，将case下的代码块与一个维表索引形成映射关系，以及将case的值与这个一维表再形成索引关系。\n2. 编译器使用一级表的方式，将case下的代码块直接和case的值形成映射关系。\n3. 编译器使用二分查找的方式，通过O(logn)的时间复杂度来查找。\n\n根据case下不同的值，或者值不同的大小，编译器会选择不同的实现方式。前两种是O(1)的时间复杂度，第三种的时间复杂度是O(logn)。SQLite为了保证它能够在能高的效率下执行，也做了一次类似的\"二级映射\"。\n\n只考虑ASCII码的情况:\n\nASCII码可以使用7bit或者8bit来表示128或者256种字符，后128个是扩展ASCII。SQLite对这256个ASCII做了一个一维映射。构建了一个256个元素的一维表，而这个表就是上面看到的`aiClass`表。表内的值，就代表了这个ASCII码对应的符号的类型。SQLite将所有符号的类型归纳为29种，可以在tokenize.c的前半部分看到所有的29个宏定义。之所以这样做，就是为了能够在switch-case执行的时候让编译器可以在O(1)的时间复杂度内完成索引与比较。\n\n下面列出了ASCII码对应的 aiClass 表 以及对应的类型。\n\n``` c\n/* Character classes for tokenizing\n**\n** In the sqlite3GetToken() function, a switch() on aiClass[c] is implemented\n** using a lookup table, whereas a switch() directly on c uses a binary search.\n** The lookup table is much faster.  To maximize speed, and to ensure that\n** a lookup table is used, all of the classes need to be small integers and\n** all of them need to be used within the switch.\n*/\n#define CC_X          0    /* The letter 'x', or start of BLOB literal */\n#define CC_KYWD       1    /* Alphabetics or '_'.  Usable in a keyword */\n#define CC_ID         2    /* unicode characters usable in IDs */\n#define CC_DIGIT      3    /* Digits */\n#define CC_DOLLAR     4    /* '$' */\n#define CC_VARALPHA   5    /* '@', '#', ':'.  Alphabetic SQL variables */\n#define CC_VARNUM     6    /* '?'.  Numeric SQL variables */\n#define CC_SPACE      7    /* Space characters */\n#define CC_QUOTE      8    /* '\"', '\\'', or '`'.  String literals, quoted ids */\n#define CC_QUOTE2     9    /* '['.   [...] style quoted ids */\n#define CC_PIPE      10    /* '|'.   Bitwise OR or concatenate */\n#define CC_MINUS     11    /* '-'.  Minus or SQL-style comment */\n#define CC_LT        12    /* '<'.  Part of < or <= or <> */\n#define CC_GT        13    /* '>'.  Part of > or >= */\n#define CC_EQ        14    /* '='.  Part of = or == */\n#define CC_BANG      15    /* '!'.  Part of != */\n#define CC_SLASH     16    /* '/'.  / or c-style comment */\n#define CC_LP        17    /* '(' */\n#define CC_RP        18    /* ')' */\n#define CC_SEMI      19    /* ';' */\n#define CC_PLUS      20    /* '+' */\n#define CC_STAR      21    /* '*' */\n#define CC_PERCENT   22    /* '%' */\n#define CC_COMMA     23    /* ',' */\n#define CC_AND       24    /* '&' */\n#define CC_TILDA     25    /* '~' */\n#define CC_DOT       26    /* '.' */\n#define CC_ILLEGAL   27    /* Illegal character */\n#define CC_NUL       28    /* 0x00 */\n\nstatic const unsigned char aiClass[] = {\n#ifdef SQLITE_ASCII\n/*         x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf */\n/* 0x */   28, 27, 27, 27, 27, 27, 27, 27, 27,  7,  7, 27,  7,  7, 27, 27,\n/* 1x */   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n/* 2x */    7, 15,  8,  5,  4, 22, 24,  8, 17, 18, 21, 20, 23, 11, 26, 16,\n/* 3x */    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  5, 19, 12, 14, 13,  6,\n/* 4x */    5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n/* 5x */    1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  9, 27, 27, 27,  1,\n/* 6x */    8,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n/* 7x */    1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1, 27, 10, 27, 25, 27,\n/* 8x */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, //后128个字符都是 2，也就是 CC_ID。\n/* 9x */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Ax */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Bx */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Cx */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Dx */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Ex */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Fx */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2\n#endif\n};\n```\n\n在case CC_KYWD的情况下，获取到一个完整的单词之后，通过调用`keywordCode`函数，还要再次判断，这个单词是否是SQLite的关键字，并且返回具体的关键字的*特征ID*。关于`keywordCode`函数的原理和优化，可以看后续的[SQLite--KeywordHash](https://caio.ink/2020/07/16/19.SQLite-KeywordHash/)","source":"_posts/20.SQLite-Tokenize.md","raw":"---\ntitle: SQLite--Tokenize(词法分析器)\ndate: 2020-07-21\ntags: [sqlite3]\ntop: 300\ncategories: sqlite3\n---\n\n> SQLite的词法分析器的代码逻辑其实很简单，但是其中也不乏SQLite对于执行效率的优化。甚至可以说SQLite在追求高效的每一个细节点，都无所不用其极。文章从源码的角度分别看具体的实现逻辑与优化的细节\n\n<!-- more -->\n\n## 关于前端的大致结构\n\nTokenize是SQLite的最前端，它的职责就是，将用户输入的一个SQL字符串，分割为一个一个独立的词。并且以*特征ID*的形式一个一个输入给Parser，而不是一个一个单词。因为parser只认识这些*特征ID*。\n\n先说一下Parser\n\nParser是SQLite开发的一个语法分析器。在`$root/tool/`目录下有一个`lemon.c`的工具。SQLite是通过`cmake`来配置源码的编译，在`autoconf`配置下产生的Makefile中有几个关于这个的指令:\n\n```\n# 编译lemon.c，生成lemon可执行文件\n#\nlemon$(BEXE):\t$(TOP)/tool/lemon.c $(TOP)/tool/lempar.c\n\t$(BCC) -o $@ $(TOP)/tool/lemon.c\n\tcp $(TOP)/tool/lempar.c .\n```\n\n```\n# parse.h 和 parse.c文件都依赖于lemon可执行文件\n# 通过command可以看到，lemon依赖parse.y这个文件生成了parse.h和parse.c\n#\nparse.h:\tparse.c\n\nparse.c:\t$(TOP)/src/parse.y lemon$(BEXE) $(TOP)/tool/addopcodes.tcl\n\tcp $(TOP)/src/parse.y .\n\trm -f parse.h\n\t./lemon$(BEXE) $(OPT_FEATURE_FLAGS) $(OPTS) parse.y\n\tmv parse.h parse.h.temp\n\t$(TCLSH_CMD) $(TOP)/tool/addopcodes.tcl parse.h.temp >parse.h\n```\n\n```\n# fts5也是使用的lemon程序，通过fts5parse.y的定义来生成解析器\nfts5parse.c:\t$(TOP)/ext/fts5/fts5parse.y lemon\n\tcp $(TOP)/ext/fts5/fts5parse.y .\n\trm -f fts5parse.h\n\t./lemon$(BEXE) $(OPTS) fts5parse.y\n```\n\nParser的核心代码都是使用lemon这个工具生成的，通过不断地输入在parse.h中定义的特征ID来生成一个语法树。\n\n那特征ID哪来呢？就是上面已经提到的Tokenize。\n\n在SQLite API中的\n`int sqlite3_prepare();`\n`int sqlite3_prepare_v2();`\n`int sqlite3_prepare_v3();`\n\n三个SQL预处理方法都是通过先调用tokenize，然后调用parser，通过vm的*编译*生成*字节码*\n\n大致的函数调用时序:\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/07/2020-07-23-00-11.jpg)\n\n## 词法分析器源码\n\n`tokenize.c`的源码结构非常简单。只有两个核心函数 `int sqlite3GetToken(const unsigned char *z, int *tokenType)` 与 `int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg)`\n\n`prepare`函数会直接调用`sqlite3RunParser`函数，这个函数虽然很长，但是把核心代码提取出来后，就一目了然。\n\n```c\nint sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){\n  int nErr = 0;                   /* Number of errors encountered */\n  void *pEngine;                  /* The LEMON-generated LALR(1) parser */\n  int n = 0;                      /* Length of the next token token */\n  int tokenType;                  /* type of the next token */\n  int lastTokenParsed = -1;       /* type of the previous token */\n  sqlite3 *db = pParse->db;       /* The database connection */\n  int mxSqlLen;                   /* Max length of an SQL string */\n  pParse->zTail = zSql;\n\n  pEngine = sqlite3ParserAlloc(sqlite3Malloc, pParse);\n\n  while( 1 ){\n    n = sqlite3GetToken((u8*)zSql, &tokenType);\n    mxSqlLen -= n;\n    if( mxSqlLen<0 ){\n      pParse->rc = SQLITE_TOOBIG;\n      break;\n    }\n    if( tokenType>=TK_SPACE ){\n      assert( tokenType==TK_SPACE || tokenType==TK_ILLEGAL );\n      if( db->u1.isInterrupted ){\n        pParse->rc = SQLITE_INTERRUPT;\n        break;\n      }\n      if( tokenType==TK_SPACE ){\n        zSql += n;\n        continue;\n      }\n      if( zSql[0]==0 ){\n        /* Upon reaching the end of input, call the parser two more times\n        ** with tokens TK_SEMI and 0, in that order. */\n        if( lastTokenParsed==TK_SEMI ){\n          tokenType = 0;\n        }else if( lastTokenParsed==0 ){\n          break;\n        }else{\n          tokenType = TK_SEMI;\n        }\n        n = 0;\n      }else{\n        sqlite3ErrorMsg(pParse, \"unrecognized token: \\\"%.*s\\\"\", n, zSql);\n        break;\n      }\n    }\n    pParse->sLastToken.z = zSql;\n    pParse->sLastToken.n = n;\n    sqlite3Parser(pEngine, tokenType, pParse->sLastToken);\n    lastTokenParsed = tokenType;\n    zSql += n;\n    if( pParse->rc!=SQLITE_OK || db->mallocFailed ) break;\n  }\n  // mem free code...\n  return nErr;\n}\n```\n\n这样似乎看起来还是很多，再精简一下。\n\n```c\nwhile( 1 ){\n    n = sqlite3GetToken((u8*)zSql, &tokenType);\n    sqlite3Parser(pEngine, tokenType, pParse->sLastToken);    \n}\n```\n\n只有两个步骤，取词，调用parser，然后不断地循环，一直到全部读完为止。这也印证了上面的话。\n\n从SQL语句中取词无非也就是根据分割符，不断的裁剪分割罢了。但是开头提到，SQLite为了追求效率，做了很多优化。\n\n后面详细说一下优化的细节。\n\n## 词法分析器效率的优化\n\n`sqlite3RunParser`函数主要是流程化的代码，主要优化都在`sqlite3GetToken`函数内，看下源码。\n\n```c\n/*\n** Return the length (in bytes) of the token that begins at z[0]. \n** Store the token type in *tokenType before returning.\n*/\nint sqlite3GetToken(const unsigned char *z, int *tokenType){\n  int i, c;\n  switch( aiClass[*z] ){  /* Switch on the character-class of the first byte\n                          ** of the token. See the comment on the CC_ defines\n                          ** above. */\n    case CC_SPACE: {\n      testcase( z[0]==' ' );\n      testcase( z[0]=='\\t' );\n      testcase( z[0]=='\\n' );\n      testcase( z[0]=='\\f' );\n      testcase( z[0]=='\\r' );\n      for(i=1; sqlite3Isspace(z[i]); i++){}\n      *tokenType = TK_SPACE;\n      return i;\n    }\n    case CC_VARNUM: {\n      *tokenType = TK_VARIABLE;\n      for(i=1; sqlite3Isdigit(z[i]); i++){}\n      return i;\n    }\n\n    // .... more case\n\n    case CC_KYWD: {\n      for(i=1; aiClass[z[i]]<=CC_KYWD; i++){}\n      if( IdChar(z[i]) ){\n        /* This token started out using characters that can appear in keywords,\n        ** but z[i] is a character not allowed within keywords, so this must\n        ** be an identifier instead */\n        i++;\n        break;\n      }\n      *tokenType = TK_ID;\n      return keywordCode((char*)z, i, tokenType);\n    }\n    case CC_X: {\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n      testcase( z[0]=='x' ); testcase( z[0]=='X' );\n      if( z[1]=='\\'' ){\n        *tokenType = TK_BLOB;\n        for(i=2; sqlite3Isxdigit(z[i]); i++){}\n        if( z[i]!='\\'' || i%2 ){\n          *tokenType = TK_ILLEGAL;\n          while( z[i] && z[i]!='\\'' ){ i++; }\n        }\n        if( z[i] ) i++;\n        return i;\n      }\n#endif\n      /* If it is not a BLOB literal, then it must be an ID, since no\n      ** SQL keywords start with the letter 'x'.  Fall through */\n    }\n    case CC_ID: {\n      i = 1;\n      break;\n    }\n    case CC_NUL: {\n      *tokenType = TK_ILLEGAL;\n      return 0;\n    }\n    default: {\n      *tokenType = TK_ILLEGAL;\n      return 1;\n    }\n  }\n  while( IdChar(z[i]) ){ i++; }\n  *tokenType = TK_ID;\n  return i;\n}\n```\n\n从代码可以看到，`sqlite3GetToken`输入一个SQL字符串，然后根据这个串的第一个字符判断是什么类型(CC_SPACE,CC_NUL,...)等等，用一个巨大的switch-case来处理不同的*词*，因为这个函数需要依次返回各种词的类型(tokenType)，也就是上文提到的在Parser.h中定义的类型。\n\n但是...`aiClass[*z]`这个是干什么用的？为什么不直接使用`switch(*z)`？\n\n这里就不得不讲到 *Switch-Case* 的编译实现了。\n\nswitch-case在使用的时候编译器会根据case中的constant值来决定使用哪种方式做检索。具体了解的话可以看这篇文章[关于C/C++ switch语句你也许不知道的一些事](http://blog.csdn.net/simmerlee/article/details/50845706)\n\n1. 编译器使用二级表的方式，将case下的代码块与一个维表索引形成映射关系，以及将case的值与这个一维表再形成索引关系。\n2. 编译器使用一级表的方式，将case下的代码块直接和case的值形成映射关系。\n3. 编译器使用二分查找的方式，通过O(logn)的时间复杂度来查找。\n\n根据case下不同的值，或者值不同的大小，编译器会选择不同的实现方式。前两种是O(1)的时间复杂度，第三种的时间复杂度是O(logn)。SQLite为了保证它能够在能高的效率下执行，也做了一次类似的\"二级映射\"。\n\n只考虑ASCII码的情况:\n\nASCII码可以使用7bit或者8bit来表示128或者256种字符，后128个是扩展ASCII。SQLite对这256个ASCII做了一个一维映射。构建了一个256个元素的一维表，而这个表就是上面看到的`aiClass`表。表内的值，就代表了这个ASCII码对应的符号的类型。SQLite将所有符号的类型归纳为29种，可以在tokenize.c的前半部分看到所有的29个宏定义。之所以这样做，就是为了能够在switch-case执行的时候让编译器可以在O(1)的时间复杂度内完成索引与比较。\n\n下面列出了ASCII码对应的 aiClass 表 以及对应的类型。\n\n``` c\n/* Character classes for tokenizing\n**\n** In the sqlite3GetToken() function, a switch() on aiClass[c] is implemented\n** using a lookup table, whereas a switch() directly on c uses a binary search.\n** The lookup table is much faster.  To maximize speed, and to ensure that\n** a lookup table is used, all of the classes need to be small integers and\n** all of them need to be used within the switch.\n*/\n#define CC_X          0    /* The letter 'x', or start of BLOB literal */\n#define CC_KYWD       1    /* Alphabetics or '_'.  Usable in a keyword */\n#define CC_ID         2    /* unicode characters usable in IDs */\n#define CC_DIGIT      3    /* Digits */\n#define CC_DOLLAR     4    /* '$' */\n#define CC_VARALPHA   5    /* '@', '#', ':'.  Alphabetic SQL variables */\n#define CC_VARNUM     6    /* '?'.  Numeric SQL variables */\n#define CC_SPACE      7    /* Space characters */\n#define CC_QUOTE      8    /* '\"', '\\'', or '`'.  String literals, quoted ids */\n#define CC_QUOTE2     9    /* '['.   [...] style quoted ids */\n#define CC_PIPE      10    /* '|'.   Bitwise OR or concatenate */\n#define CC_MINUS     11    /* '-'.  Minus or SQL-style comment */\n#define CC_LT        12    /* '<'.  Part of < or <= or <> */\n#define CC_GT        13    /* '>'.  Part of > or >= */\n#define CC_EQ        14    /* '='.  Part of = or == */\n#define CC_BANG      15    /* '!'.  Part of != */\n#define CC_SLASH     16    /* '/'.  / or c-style comment */\n#define CC_LP        17    /* '(' */\n#define CC_RP        18    /* ')' */\n#define CC_SEMI      19    /* ';' */\n#define CC_PLUS      20    /* '+' */\n#define CC_STAR      21    /* '*' */\n#define CC_PERCENT   22    /* '%' */\n#define CC_COMMA     23    /* ',' */\n#define CC_AND       24    /* '&' */\n#define CC_TILDA     25    /* '~' */\n#define CC_DOT       26    /* '.' */\n#define CC_ILLEGAL   27    /* Illegal character */\n#define CC_NUL       28    /* 0x00 */\n\nstatic const unsigned char aiClass[] = {\n#ifdef SQLITE_ASCII\n/*         x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf */\n/* 0x */   28, 27, 27, 27, 27, 27, 27, 27, 27,  7,  7, 27,  7,  7, 27, 27,\n/* 1x */   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n/* 2x */    7, 15,  8,  5,  4, 22, 24,  8, 17, 18, 21, 20, 23, 11, 26, 16,\n/* 3x */    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  5, 19, 12, 14, 13,  6,\n/* 4x */    5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n/* 5x */    1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  9, 27, 27, 27,  1,\n/* 6x */    8,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n/* 7x */    1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1, 27, 10, 27, 25, 27,\n/* 8x */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, //后128个字符都是 2，也就是 CC_ID。\n/* 9x */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Ax */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Bx */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Cx */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Dx */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Ex */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n/* Fx */    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2\n#endif\n};\n```\n\n在case CC_KYWD的情况下，获取到一个完整的单词之后，通过调用`keywordCode`函数，还要再次判断，这个单词是否是SQLite的关键字，并且返回具体的关键字的*特征ID*。关于`keywordCode`函数的原理和优化，可以看后续的[SQLite--KeywordHash](https://caio.ink/2020/07/16/19.SQLite-KeywordHash/)","slug":"20.SQLite-Tokenize","published":1,"updated":"2022-07-28T13:38:40.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwo80011p9c91fqsbmcj","content":"<blockquote>\n<p>SQLite的词法分析器的代码逻辑其实很简单，但是其中也不乏SQLite对于执行效率的优化。甚至可以说SQLite在追求高效的每一个细节点，都无所不用其极。文章从源码的角度分别看具体的实现逻辑与优化的细节</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"关于前端的大致结构\"><a href=\"#关于前端的大致结构\" class=\"headerlink\" title=\"关于前端的大致结构\"></a>关于前端的大致结构</h2><p>Tokenize是SQLite的最前端，它的职责就是，将用户输入的一个SQL字符串，分割为一个一个独立的词。并且以<em>特征ID</em>的形式一个一个输入给Parser，而不是一个一个单词。因为parser只认识这些<em>特征ID</em>。</p>\n<p>先说一下Parser</p>\n<p>Parser是SQLite开发的一个语法分析器。在<code>$root/tool/</code>目录下有一个<code>lemon.c</code>的工具。SQLite是通过<code>cmake</code>来配置源码的编译，在<code>autoconf</code>配置下产生的Makefile中有几个关于这个的指令:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 编译lemon.c，生成lemon可执行文件</span><br><span class=\"line\">#</span><br><span class=\"line\">lemon$(BEXE):\t$(TOP)/tool/lemon.c $(TOP)/tool/lempar.c</span><br><span class=\"line\">\t$(BCC) -o $@ $(TOP)/tool/lemon.c</span><br><span class=\"line\">\tcp $(TOP)/tool/lempar.c .</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># parse.h 和 parse.c文件都依赖于lemon可执行文件</span><br><span class=\"line\"># 通过command可以看到，lemon依赖parse.y这个文件生成了parse.h和parse.c</span><br><span class=\"line\">#</span><br><span class=\"line\">parse.h:\tparse.c</span><br><span class=\"line\"></span><br><span class=\"line\">parse.c:\t$(TOP)/src/parse.y lemon$(BEXE) $(TOP)/tool/addopcodes.tcl</span><br><span class=\"line\">\tcp $(TOP)/src/parse.y .</span><br><span class=\"line\">\trm -f parse.h</span><br><span class=\"line\">\t./lemon$(BEXE) $(OPT_FEATURE_FLAGS) $(OPTS) parse.y</span><br><span class=\"line\">\tmv parse.h parse.h.temp</span><br><span class=\"line\">\t$(TCLSH_CMD) $(TOP)/tool/addopcodes.tcl parse.h.temp &gt;parse.h</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># fts5也是使用的lemon程序，通过fts5parse.y的定义来生成解析器</span><br><span class=\"line\">fts5parse.c:\t$(TOP)/ext/fts5/fts5parse.y lemon</span><br><span class=\"line\">\tcp $(TOP)/ext/fts5/fts5parse.y .</span><br><span class=\"line\">\trm -f fts5parse.h</span><br><span class=\"line\">\t./lemon$(BEXE) $(OPTS) fts5parse.y</span><br></pre></td></tr></table></figure>\n\n<p>Parser的核心代码都是使用lemon这个工具生成的，通过不断地输入在parse.h中定义的特征ID来生成一个语法树。</p>\n<p>那特征ID哪来呢？就是上面已经提到的Tokenize。</p>\n<p>在SQLite API中的<br><code>int sqlite3_prepare();</code><br><code>int sqlite3_prepare_v2();</code><br><code>int sqlite3_prepare_v3();</code></p>\n<p>三个SQL预处理方法都是通过先调用tokenize，然后调用parser，通过vm的<em>编译</em>生成<em>字节码</em></p>\n<p>大致的函数调用时序:</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/07/2020-07-23-00-11.jpg\"></p>\n<h2 id=\"词法分析器源码\"><a href=\"#词法分析器源码\" class=\"headerlink\" title=\"词法分析器源码\"></a>词法分析器源码</h2><p><code>tokenize.c</code>的源码结构非常简单。只有两个核心函数 <code>int sqlite3GetToken(const unsigned char *z, int *tokenType)</code> 与 <code>int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg)</code></p>\n<p><code>prepare</code>函数会直接调用<code>sqlite3RunParser</code>函数，这个函数虽然很长，但是把核心代码提取出来后，就一目了然。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3RunParser</span><span class=\"params\">(Parse *pParse, <span class=\"type\">const</span> <span class=\"type\">char</span> *zSql, <span class=\"type\">char</span> **pzErrMsg)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> nErr = <span class=\"number\">0</span>;                   <span class=\"comment\">/* Number of errors encountered */</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *pEngine;                  <span class=\"comment\">/* The LEMON-generated LALR(1) parser */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> n = <span class=\"number\">0</span>;                      <span class=\"comment\">/* Length of the next token token */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tokenType;                  <span class=\"comment\">/* type of the next token */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> lastTokenParsed = <span class=\"number\">-1</span>;       <span class=\"comment\">/* type of the previous token */</span></span><br><span class=\"line\">  sqlite3 *db = pParse-&gt;db;       <span class=\"comment\">/* The database connection */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> mxSqlLen;                   <span class=\"comment\">/* Max length of an SQL string */</span></span><br><span class=\"line\">  pParse-&gt;zTail = zSql;</span><br><span class=\"line\"></span><br><span class=\"line\">  pEngine = sqlite3ParserAlloc(sqlite3Malloc, pParse);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>( <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">    n = sqlite3GetToken((u8*)zSql, &amp;tokenType);</span><br><span class=\"line\">    mxSqlLen -= n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( mxSqlLen&lt;<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">      pParse-&gt;rc = SQLITE_TOOBIG;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( tokenType&gt;=TK_SPACE )&#123;</span><br><span class=\"line\">      assert( tokenType==TK_SPACE || tokenType==TK_ILLEGAL );</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( db-&gt;u1.isInterrupted )&#123;</span><br><span class=\"line\">        pParse-&gt;rc = SQLITE_INTERRUPT;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( tokenType==TK_SPACE )&#123;</span><br><span class=\"line\">        zSql += n;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( zSql[<span class=\"number\">0</span>]==<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Upon reaching the end of input, call the parser two more times</span></span><br><span class=\"line\"><span class=\"comment\">        ** with tokens TK_SEMI and 0, in that order. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( lastTokenParsed==TK_SEMI )&#123;</span><br><span class=\"line\">          tokenType = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( lastTokenParsed==<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          tokenType = TK_SEMI;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        sqlite3ErrorMsg(pParse, <span class=\"string\">&quot;unrecognized token: \\&quot;%.*s\\&quot;&quot;</span>, n, zSql);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pParse-&gt;sLastToken.z = zSql;</span><br><span class=\"line\">    pParse-&gt;sLastToken.n = n;</span><br><span class=\"line\">    sqlite3Parser(pEngine, tokenType, pParse-&gt;sLastToken);</span><br><span class=\"line\">    lastTokenParsed = tokenType;</span><br><span class=\"line\">    zSql += n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( pParse-&gt;rc!=SQLITE_OK || db-&gt;mallocFailed ) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// mem free code...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> nErr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样似乎看起来还是很多，再精简一下。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>( <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">    n = sqlite3GetToken((u8*)zSql, &amp;tokenType);</span><br><span class=\"line\">    sqlite3Parser(pEngine, tokenType, pParse-&gt;sLastToken);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只有两个步骤，取词，调用parser，然后不断地循环，一直到全部读完为止。这也印证了上面的话。</p>\n<p>从SQL语句中取词无非也就是根据分割符，不断的裁剪分割罢了。但是开头提到，SQLite为了追求效率，做了很多优化。</p>\n<p>后面详细说一下优化的细节。</p>\n<h2 id=\"词法分析器效率的优化\"><a href=\"#词法分析器效率的优化\" class=\"headerlink\" title=\"词法分析器效率的优化\"></a>词法分析器效率的优化</h2><p><code>sqlite3RunParser</code>函数主要是流程化的代码，主要优化都在<code>sqlite3GetToken</code>函数内，看下源码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** Return the length (in bytes) of the token that begins at z[0]. </span></span><br><span class=\"line\"><span class=\"comment\">** Store the token type in *tokenType before returning.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3GetToken</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *z, <span class=\"type\">int</span> *tokenType)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i, c;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>( aiClass[*z] )&#123;  <span class=\"comment\">/* Switch on the character-class of the first byte</span></span><br><span class=\"line\"><span class=\"comment\">                          ** of the token. See the comment on the CC_ defines</span></span><br><span class=\"line\"><span class=\"comment\">                          ** above. */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_SPACE: &#123;</span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27; &#x27;</span> );</span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;\\t&#x27;</span> );</span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;\\n&#x27;</span> );</span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;\\f&#x27;</span> );</span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;\\r&#x27;</span> );</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; sqlite3Isspace(z[i]); i++)&#123;&#125;</span><br><span class=\"line\">      *tokenType = TK_SPACE;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_VARNUM: &#123;</span><br><span class=\"line\">      *tokenType = TK_VARIABLE;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; sqlite3Isdigit(z[i]); i++)&#123;&#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// .... more case</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_KYWD: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; aiClass[z[i]]&lt;=CC_KYWD; i++)&#123;&#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( IdChar(z[i]) )&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* This token started out using characters that can appear in keywords,</span></span><br><span class=\"line\"><span class=\"comment\">        ** but z[i] is a character not allowed within keywords, so this must</span></span><br><span class=\"line\"><span class=\"comment\">        ** be an identifier instead */</span></span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      *tokenType = TK_ID;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> keywordCode((<span class=\"type\">char</span>*)z, i, tokenType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_X: &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> SQLITE_OMIT_BLOB_LITERAL</span></span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;x&#x27;</span> ); testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;X&#x27;</span> );</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( z[<span class=\"number\">1</span>]==<span class=\"string\">&#x27;\\&#x27;&#x27;</span> )&#123;</span><br><span class=\"line\">        *tokenType = TK_BLOB;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">2</span>; sqlite3Isxdigit(z[i]); i++)&#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( z[i]!=<span class=\"string\">&#x27;\\&#x27;&#x27;</span> || i%<span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">          *tokenType = TK_ILLEGAL;</span><br><span class=\"line\">          <span class=\"keyword\">while</span>( z[i] &amp;&amp; z[i]!=<span class=\"string\">&#x27;\\&#x27;&#x27;</span> )&#123; i++; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( z[i] ) i++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">      <span class=\"comment\">/* If it is not a BLOB literal, then it must be an ID, since no</span></span><br><span class=\"line\"><span class=\"comment\">      ** SQL keywords start with the letter &#x27;x&#x27;.  Fall through */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_ID: &#123;</span><br><span class=\"line\">      i = <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_NUL: &#123;</span><br><span class=\"line\">      *tokenType = TK_ILLEGAL;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">      *tokenType = TK_ILLEGAL;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>( IdChar(z[i]) )&#123; i++; &#125;</span><br><span class=\"line\">  *tokenType = TK_ID;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从代码可以看到，<code>sqlite3GetToken</code>输入一个SQL字符串，然后根据这个串的第一个字符判断是什么类型(CC_SPACE,CC_NUL,…)等等，用一个巨大的switch-case来处理不同的<em>词</em>，因为这个函数需要依次返回各种词的类型(tokenType)，也就是上文提到的在Parser.h中定义的类型。</p>\n<p>但是…<code>aiClass[*z]</code>这个是干什么用的？为什么不直接使用<code>switch(*z)</code>？</p>\n<p>这里就不得不讲到 <em>Switch-Case</em> 的编译实现了。</p>\n<p>switch-case在使用的时候编译器会根据case中的constant值来决定使用哪种方式做检索。具体了解的话可以看这篇文章<a href=\"http://blog.csdn.net/simmerlee/article/details/50845706\">关于C&#x2F;C++ switch语句你也许不知道的一些事</a></p>\n<ol>\n<li>编译器使用二级表的方式，将case下的代码块与一个维表索引形成映射关系，以及将case的值与这个一维表再形成索引关系。</li>\n<li>编译器使用一级表的方式，将case下的代码块直接和case的值形成映射关系。</li>\n<li>编译器使用二分查找的方式，通过O(logn)的时间复杂度来查找。</li>\n</ol>\n<p>根据case下不同的值，或者值不同的大小，编译器会选择不同的实现方式。前两种是O(1)的时间复杂度，第三种的时间复杂度是O(logn)。SQLite为了保证它能够在能高的效率下执行，也做了一次类似的”二级映射”。</p>\n<p>只考虑ASCII码的情况:</p>\n<p>ASCII码可以使用7bit或者8bit来表示128或者256种字符，后128个是扩展ASCII。SQLite对这256个ASCII做了一个一维映射。构建了一个256个元素的一维表，而这个表就是上面看到的<code>aiClass</code>表。表内的值，就代表了这个ASCII码对应的符号的类型。SQLite将所有符号的类型归纳为29种，可以在tokenize.c的前半部分看到所有的29个宏定义。之所以这样做，就是为了能够在switch-case执行的时候让编译器可以在O(1)的时间复杂度内完成索引与比较。</p>\n<p>下面列出了ASCII码对应的 aiClass 表 以及对应的类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Character classes for tokenizing</span></span><br><span class=\"line\"><span class=\"comment\">**</span></span><br><span class=\"line\"><span class=\"comment\">** In the sqlite3GetToken() function, a switch() on aiClass[c] is implemented</span></span><br><span class=\"line\"><span class=\"comment\">** using a lookup table, whereas a switch() directly on c uses a binary search.</span></span><br><span class=\"line\"><span class=\"comment\">** The lookup table is much faster.  To maximize speed, and to ensure that</span></span><br><span class=\"line\"><span class=\"comment\">** a lookup table is used, all of the classes need to be small integers and</span></span><br><span class=\"line\"><span class=\"comment\">** all of them need to be used within the switch.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_X          0    <span class=\"comment\">/* The letter &#x27;x&#x27;, or start of BLOB literal */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_KYWD       1    <span class=\"comment\">/* Alphabetics or &#x27;_&#x27;.  Usable in a keyword */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_ID         2    <span class=\"comment\">/* unicode characters usable in IDs */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_DIGIT      3    <span class=\"comment\">/* Digits */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_DOLLAR     4    <span class=\"comment\">/* &#x27;$&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_VARALPHA   5    <span class=\"comment\">/* &#x27;@&#x27;, &#x27;#&#x27;, &#x27;:&#x27;.  Alphabetic SQL variables */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_VARNUM     6    <span class=\"comment\">/* &#x27;?&#x27;.  Numeric SQL variables */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_SPACE      7    <span class=\"comment\">/* Space characters */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_QUOTE      8    <span class=\"comment\">/* &#x27;&quot;&#x27;, &#x27;\\&#x27;&#x27;, or &#x27;`&#x27;.  String literals, quoted ids */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_QUOTE2     9    <span class=\"comment\">/* &#x27;[&#x27;.   [...] style quoted ids */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_PIPE      10    <span class=\"comment\">/* &#x27;|&#x27;.   Bitwise OR or concatenate */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_MINUS     11    <span class=\"comment\">/* &#x27;-&#x27;.  Minus or SQL-style comment */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_LT        12    <span class=\"comment\">/* &#x27;&lt;&#x27;.  Part of &lt; or &lt;= or &lt;&gt; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_GT        13    <span class=\"comment\">/* &#x27;&gt;&#x27;.  Part of &gt; or &gt;= */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_EQ        14    <span class=\"comment\">/* &#x27;=&#x27;.  Part of = or == */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_BANG      15    <span class=\"comment\">/* &#x27;!&#x27;.  Part of != */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_SLASH     16    <span class=\"comment\">/* &#x27;/&#x27;.  / or c-style comment */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_LP        17    <span class=\"comment\">/* &#x27;(&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_RP        18    <span class=\"comment\">/* &#x27;)&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_SEMI      19    <span class=\"comment\">/* &#x27;;&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_PLUS      20    <span class=\"comment\">/* &#x27;+&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_STAR      21    <span class=\"comment\">/* &#x27;*&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_PERCENT   22    <span class=\"comment\">/* &#x27;%&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_COMMA     23    <span class=\"comment\">/* &#x27;,&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_AND       24    <span class=\"comment\">/* &#x27;&amp;&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_TILDA     25    <span class=\"comment\">/* &#x27;~&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_DOT       26    <span class=\"comment\">/* &#x27;.&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_ILLEGAL   27    <span class=\"comment\">/* Illegal character */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_NUL       28    <span class=\"comment\">/* 0x00 */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">char</span> aiClass[] = &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> SQLITE_ASCII</span></span><br><span class=\"line\"><span class=\"comment\">/*         x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf */</span></span><br><span class=\"line\"><span class=\"comment\">/* 0x */</span>   <span class=\"number\">28</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>,  <span class=\"number\">7</span>,  <span class=\"number\">7</span>, <span class=\"number\">27</span>,  <span class=\"number\">7</span>,  <span class=\"number\">7</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 1x */</span>   <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 2x */</span>    <span class=\"number\">7</span>, <span class=\"number\">15</span>,  <span class=\"number\">8</span>,  <span class=\"number\">5</span>,  <span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">24</span>,  <span class=\"number\">8</span>, <span class=\"number\">17</span>, <span class=\"number\">18</span>, <span class=\"number\">21</span>, <span class=\"number\">20</span>, <span class=\"number\">23</span>, <span class=\"number\">11</span>, <span class=\"number\">26</span>, <span class=\"number\">16</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 3x */</span>    <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">5</span>, <span class=\"number\">19</span>, <span class=\"number\">12</span>, <span class=\"number\">14</span>, <span class=\"number\">13</span>,  <span class=\"number\">6</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 4x */</span>    <span class=\"number\">5</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 5x */</span>    <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">0</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">9</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>,  <span class=\"number\">1</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 6x */</span>    <span class=\"number\">8</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 7x */</span>    <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">0</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>, <span class=\"number\">27</span>, <span class=\"number\">10</span>, <span class=\"number\">27</span>, <span class=\"number\">25</span>, <span class=\"number\">27</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 8x */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>, <span class=\"comment\">//后128个字符都是 2，也就是 CC_ID。</span></span><br><span class=\"line\"><span class=\"comment\">/* 9x */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Ax */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Bx */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Cx */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Dx */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Ex */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Fx */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在case CC_KYWD的情况下，获取到一个完整的单词之后，通过调用<code>keywordCode</code>函数，还要再次判断，这个单词是否是SQLite的关键字，并且返回具体的关键字的<em>特征ID</em>。关于<code>keywordCode</code>函数的原理和优化，可以看后续的<a href=\"https://caio.ink/2020/07/16/19.SQLite-KeywordHash/\">SQLite–KeywordHash</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>SQLite的词法分析器的代码逻辑其实很简单，但是其中也不乏SQLite对于执行效率的优化。甚至可以说SQLite在追求高效的每一个细节点，都无所不用其极。文章从源码的角度分别看具体的实现逻辑与优化的细节</p>\n</blockquote>","more":"<h2 id=\"关于前端的大致结构\"><a href=\"#关于前端的大致结构\" class=\"headerlink\" title=\"关于前端的大致结构\"></a>关于前端的大致结构</h2><p>Tokenize是SQLite的最前端，它的职责就是，将用户输入的一个SQL字符串，分割为一个一个独立的词。并且以<em>特征ID</em>的形式一个一个输入给Parser，而不是一个一个单词。因为parser只认识这些<em>特征ID</em>。</p>\n<p>先说一下Parser</p>\n<p>Parser是SQLite开发的一个语法分析器。在<code>$root/tool/</code>目录下有一个<code>lemon.c</code>的工具。SQLite是通过<code>cmake</code>来配置源码的编译，在<code>autoconf</code>配置下产生的Makefile中有几个关于这个的指令:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 编译lemon.c，生成lemon可执行文件</span><br><span class=\"line\">#</span><br><span class=\"line\">lemon$(BEXE):\t$(TOP)/tool/lemon.c $(TOP)/tool/lempar.c</span><br><span class=\"line\">\t$(BCC) -o $@ $(TOP)/tool/lemon.c</span><br><span class=\"line\">\tcp $(TOP)/tool/lempar.c .</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># parse.h 和 parse.c文件都依赖于lemon可执行文件</span><br><span class=\"line\"># 通过command可以看到，lemon依赖parse.y这个文件生成了parse.h和parse.c</span><br><span class=\"line\">#</span><br><span class=\"line\">parse.h:\tparse.c</span><br><span class=\"line\"></span><br><span class=\"line\">parse.c:\t$(TOP)/src/parse.y lemon$(BEXE) $(TOP)/tool/addopcodes.tcl</span><br><span class=\"line\">\tcp $(TOP)/src/parse.y .</span><br><span class=\"line\">\trm -f parse.h</span><br><span class=\"line\">\t./lemon$(BEXE) $(OPT_FEATURE_FLAGS) $(OPTS) parse.y</span><br><span class=\"line\">\tmv parse.h parse.h.temp</span><br><span class=\"line\">\t$(TCLSH_CMD) $(TOP)/tool/addopcodes.tcl parse.h.temp &gt;parse.h</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># fts5也是使用的lemon程序，通过fts5parse.y的定义来生成解析器</span><br><span class=\"line\">fts5parse.c:\t$(TOP)/ext/fts5/fts5parse.y lemon</span><br><span class=\"line\">\tcp $(TOP)/ext/fts5/fts5parse.y .</span><br><span class=\"line\">\trm -f fts5parse.h</span><br><span class=\"line\">\t./lemon$(BEXE) $(OPTS) fts5parse.y</span><br></pre></td></tr></table></figure>\n\n<p>Parser的核心代码都是使用lemon这个工具生成的，通过不断地输入在parse.h中定义的特征ID来生成一个语法树。</p>\n<p>那特征ID哪来呢？就是上面已经提到的Tokenize。</p>\n<p>在SQLite API中的<br><code>int sqlite3_prepare();</code><br><code>int sqlite3_prepare_v2();</code><br><code>int sqlite3_prepare_v3();</code></p>\n<p>三个SQL预处理方法都是通过先调用tokenize，然后调用parser，通过vm的<em>编译</em>生成<em>字节码</em></p>\n<p>大致的函数调用时序:</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/07/2020-07-23-00-11.jpg\"></p>\n<h2 id=\"词法分析器源码\"><a href=\"#词法分析器源码\" class=\"headerlink\" title=\"词法分析器源码\"></a>词法分析器源码</h2><p><code>tokenize.c</code>的源码结构非常简单。只有两个核心函数 <code>int sqlite3GetToken(const unsigned char *z, int *tokenType)</code> 与 <code>int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg)</code></p>\n<p><code>prepare</code>函数会直接调用<code>sqlite3RunParser</code>函数，这个函数虽然很长，但是把核心代码提取出来后，就一目了然。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3RunParser</span><span class=\"params\">(Parse *pParse, <span class=\"type\">const</span> <span class=\"type\">char</span> *zSql, <span class=\"type\">char</span> **pzErrMsg)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> nErr = <span class=\"number\">0</span>;                   <span class=\"comment\">/* Number of errors encountered */</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *pEngine;                  <span class=\"comment\">/* The LEMON-generated LALR(1) parser */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> n = <span class=\"number\">0</span>;                      <span class=\"comment\">/* Length of the next token token */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tokenType;                  <span class=\"comment\">/* type of the next token */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> lastTokenParsed = <span class=\"number\">-1</span>;       <span class=\"comment\">/* type of the previous token */</span></span><br><span class=\"line\">  sqlite3 *db = pParse-&gt;db;       <span class=\"comment\">/* The database connection */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> mxSqlLen;                   <span class=\"comment\">/* Max length of an SQL string */</span></span><br><span class=\"line\">  pParse-&gt;zTail = zSql;</span><br><span class=\"line\"></span><br><span class=\"line\">  pEngine = sqlite3ParserAlloc(sqlite3Malloc, pParse);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>( <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">    n = sqlite3GetToken((u8*)zSql, &amp;tokenType);</span><br><span class=\"line\">    mxSqlLen -= n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( mxSqlLen&lt;<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">      pParse-&gt;rc = SQLITE_TOOBIG;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( tokenType&gt;=TK_SPACE )&#123;</span><br><span class=\"line\">      assert( tokenType==TK_SPACE || tokenType==TK_ILLEGAL );</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( db-&gt;u1.isInterrupted )&#123;</span><br><span class=\"line\">        pParse-&gt;rc = SQLITE_INTERRUPT;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( tokenType==TK_SPACE )&#123;</span><br><span class=\"line\">        zSql += n;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( zSql[<span class=\"number\">0</span>]==<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Upon reaching the end of input, call the parser two more times</span></span><br><span class=\"line\"><span class=\"comment\">        ** with tokens TK_SEMI and 0, in that order. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( lastTokenParsed==TK_SEMI )&#123;</span><br><span class=\"line\">          tokenType = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( lastTokenParsed==<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          tokenType = TK_SEMI;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        sqlite3ErrorMsg(pParse, <span class=\"string\">&quot;unrecognized token: \\&quot;%.*s\\&quot;&quot;</span>, n, zSql);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pParse-&gt;sLastToken.z = zSql;</span><br><span class=\"line\">    pParse-&gt;sLastToken.n = n;</span><br><span class=\"line\">    sqlite3Parser(pEngine, tokenType, pParse-&gt;sLastToken);</span><br><span class=\"line\">    lastTokenParsed = tokenType;</span><br><span class=\"line\">    zSql += n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( pParse-&gt;rc!=SQLITE_OK || db-&gt;mallocFailed ) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// mem free code...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> nErr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样似乎看起来还是很多，再精简一下。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>( <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">    n = sqlite3GetToken((u8*)zSql, &amp;tokenType);</span><br><span class=\"line\">    sqlite3Parser(pEngine, tokenType, pParse-&gt;sLastToken);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只有两个步骤，取词，调用parser，然后不断地循环，一直到全部读完为止。这也印证了上面的话。</p>\n<p>从SQL语句中取词无非也就是根据分割符，不断的裁剪分割罢了。但是开头提到，SQLite为了追求效率，做了很多优化。</p>\n<p>后面详细说一下优化的细节。</p>\n<h2 id=\"词法分析器效率的优化\"><a href=\"#词法分析器效率的优化\" class=\"headerlink\" title=\"词法分析器效率的优化\"></a>词法分析器效率的优化</h2><p><code>sqlite3RunParser</code>函数主要是流程化的代码，主要优化都在<code>sqlite3GetToken</code>函数内，看下源码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** Return the length (in bytes) of the token that begins at z[0]. </span></span><br><span class=\"line\"><span class=\"comment\">** Store the token type in *tokenType before returning.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sqlite3GetToken</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *z, <span class=\"type\">int</span> *tokenType)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i, c;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>( aiClass[*z] )&#123;  <span class=\"comment\">/* Switch on the character-class of the first byte</span></span><br><span class=\"line\"><span class=\"comment\">                          ** of the token. See the comment on the CC_ defines</span></span><br><span class=\"line\"><span class=\"comment\">                          ** above. */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_SPACE: &#123;</span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27; &#x27;</span> );</span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;\\t&#x27;</span> );</span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;\\n&#x27;</span> );</span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;\\f&#x27;</span> );</span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;\\r&#x27;</span> );</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; sqlite3Isspace(z[i]); i++)&#123;&#125;</span><br><span class=\"line\">      *tokenType = TK_SPACE;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_VARNUM: &#123;</span><br><span class=\"line\">      *tokenType = TK_VARIABLE;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; sqlite3Isdigit(z[i]); i++)&#123;&#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// .... more case</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_KYWD: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; aiClass[z[i]]&lt;=CC_KYWD; i++)&#123;&#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( IdChar(z[i]) )&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* This token started out using characters that can appear in keywords,</span></span><br><span class=\"line\"><span class=\"comment\">        ** but z[i] is a character not allowed within keywords, so this must</span></span><br><span class=\"line\"><span class=\"comment\">        ** be an identifier instead */</span></span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      *tokenType = TK_ID;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> keywordCode((<span class=\"type\">char</span>*)z, i, tokenType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_X: &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> SQLITE_OMIT_BLOB_LITERAL</span></span><br><span class=\"line\">      testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;x&#x27;</span> ); testcase( z[<span class=\"number\">0</span>]==<span class=\"string\">&#x27;X&#x27;</span> );</span><br><span class=\"line\">      <span class=\"keyword\">if</span>( z[<span class=\"number\">1</span>]==<span class=\"string\">&#x27;\\&#x27;&#x27;</span> )&#123;</span><br><span class=\"line\">        *tokenType = TK_BLOB;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">2</span>; sqlite3Isxdigit(z[i]); i++)&#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( z[i]!=<span class=\"string\">&#x27;\\&#x27;&#x27;</span> || i%<span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">          *tokenType = TK_ILLEGAL;</span><br><span class=\"line\">          <span class=\"keyword\">while</span>( z[i] &amp;&amp; z[i]!=<span class=\"string\">&#x27;\\&#x27;&#x27;</span> )&#123; i++; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( z[i] ) i++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">      <span class=\"comment\">/* If it is not a BLOB literal, then it must be an ID, since no</span></span><br><span class=\"line\"><span class=\"comment\">      ** SQL keywords start with the letter &#x27;x&#x27;.  Fall through */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_ID: &#123;</span><br><span class=\"line\">      i = <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> CC_NUL: &#123;</span><br><span class=\"line\">      *tokenType = TK_ILLEGAL;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">      *tokenType = TK_ILLEGAL;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>( IdChar(z[i]) )&#123; i++; &#125;</span><br><span class=\"line\">  *tokenType = TK_ID;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从代码可以看到，<code>sqlite3GetToken</code>输入一个SQL字符串，然后根据这个串的第一个字符判断是什么类型(CC_SPACE,CC_NUL,…)等等，用一个巨大的switch-case来处理不同的<em>词</em>，因为这个函数需要依次返回各种词的类型(tokenType)，也就是上文提到的在Parser.h中定义的类型。</p>\n<p>但是…<code>aiClass[*z]</code>这个是干什么用的？为什么不直接使用<code>switch(*z)</code>？</p>\n<p>这里就不得不讲到 <em>Switch-Case</em> 的编译实现了。</p>\n<p>switch-case在使用的时候编译器会根据case中的constant值来决定使用哪种方式做检索。具体了解的话可以看这篇文章<a href=\"http://blog.csdn.net/simmerlee/article/details/50845706\">关于C&#x2F;C++ switch语句你也许不知道的一些事</a></p>\n<ol>\n<li>编译器使用二级表的方式，将case下的代码块与一个维表索引形成映射关系，以及将case的值与这个一维表再形成索引关系。</li>\n<li>编译器使用一级表的方式，将case下的代码块直接和case的值形成映射关系。</li>\n<li>编译器使用二分查找的方式，通过O(logn)的时间复杂度来查找。</li>\n</ol>\n<p>根据case下不同的值，或者值不同的大小，编译器会选择不同的实现方式。前两种是O(1)的时间复杂度，第三种的时间复杂度是O(logn)。SQLite为了保证它能够在能高的效率下执行，也做了一次类似的”二级映射”。</p>\n<p>只考虑ASCII码的情况:</p>\n<p>ASCII码可以使用7bit或者8bit来表示128或者256种字符，后128个是扩展ASCII。SQLite对这256个ASCII做了一个一维映射。构建了一个256个元素的一维表，而这个表就是上面看到的<code>aiClass</code>表。表内的值，就代表了这个ASCII码对应的符号的类型。SQLite将所有符号的类型归纳为29种，可以在tokenize.c的前半部分看到所有的29个宏定义。之所以这样做，就是为了能够在switch-case执行的时候让编译器可以在O(1)的时间复杂度内完成索引与比较。</p>\n<p>下面列出了ASCII码对应的 aiClass 表 以及对应的类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Character classes for tokenizing</span></span><br><span class=\"line\"><span class=\"comment\">**</span></span><br><span class=\"line\"><span class=\"comment\">** In the sqlite3GetToken() function, a switch() on aiClass[c] is implemented</span></span><br><span class=\"line\"><span class=\"comment\">** using a lookup table, whereas a switch() directly on c uses a binary search.</span></span><br><span class=\"line\"><span class=\"comment\">** The lookup table is much faster.  To maximize speed, and to ensure that</span></span><br><span class=\"line\"><span class=\"comment\">** a lookup table is used, all of the classes need to be small integers and</span></span><br><span class=\"line\"><span class=\"comment\">** all of them need to be used within the switch.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_X          0    <span class=\"comment\">/* The letter &#x27;x&#x27;, or start of BLOB literal */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_KYWD       1    <span class=\"comment\">/* Alphabetics or &#x27;_&#x27;.  Usable in a keyword */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_ID         2    <span class=\"comment\">/* unicode characters usable in IDs */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_DIGIT      3    <span class=\"comment\">/* Digits */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_DOLLAR     4    <span class=\"comment\">/* &#x27;$&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_VARALPHA   5    <span class=\"comment\">/* &#x27;@&#x27;, &#x27;#&#x27;, &#x27;:&#x27;.  Alphabetic SQL variables */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_VARNUM     6    <span class=\"comment\">/* &#x27;?&#x27;.  Numeric SQL variables */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_SPACE      7    <span class=\"comment\">/* Space characters */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_QUOTE      8    <span class=\"comment\">/* &#x27;&quot;&#x27;, &#x27;\\&#x27;&#x27;, or &#x27;`&#x27;.  String literals, quoted ids */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_QUOTE2     9    <span class=\"comment\">/* &#x27;[&#x27;.   [...] style quoted ids */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_PIPE      10    <span class=\"comment\">/* &#x27;|&#x27;.   Bitwise OR or concatenate */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_MINUS     11    <span class=\"comment\">/* &#x27;-&#x27;.  Minus or SQL-style comment */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_LT        12    <span class=\"comment\">/* &#x27;&lt;&#x27;.  Part of &lt; or &lt;= or &lt;&gt; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_GT        13    <span class=\"comment\">/* &#x27;&gt;&#x27;.  Part of &gt; or &gt;= */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_EQ        14    <span class=\"comment\">/* &#x27;=&#x27;.  Part of = or == */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_BANG      15    <span class=\"comment\">/* &#x27;!&#x27;.  Part of != */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_SLASH     16    <span class=\"comment\">/* &#x27;/&#x27;.  / or c-style comment */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_LP        17    <span class=\"comment\">/* &#x27;(&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_RP        18    <span class=\"comment\">/* &#x27;)&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_SEMI      19    <span class=\"comment\">/* &#x27;;&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_PLUS      20    <span class=\"comment\">/* &#x27;+&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_STAR      21    <span class=\"comment\">/* &#x27;*&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_PERCENT   22    <span class=\"comment\">/* &#x27;%&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_COMMA     23    <span class=\"comment\">/* &#x27;,&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_AND       24    <span class=\"comment\">/* &#x27;&amp;&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_TILDA     25    <span class=\"comment\">/* &#x27;~&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_DOT       26    <span class=\"comment\">/* &#x27;.&#x27; */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_ILLEGAL   27    <span class=\"comment\">/* Illegal character */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CC_NUL       28    <span class=\"comment\">/* 0x00 */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">char</span> aiClass[] = &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> SQLITE_ASCII</span></span><br><span class=\"line\"><span class=\"comment\">/*         x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf */</span></span><br><span class=\"line\"><span class=\"comment\">/* 0x */</span>   <span class=\"number\">28</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>,  <span class=\"number\">7</span>,  <span class=\"number\">7</span>, <span class=\"number\">27</span>,  <span class=\"number\">7</span>,  <span class=\"number\">7</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 1x */</span>   <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 2x */</span>    <span class=\"number\">7</span>, <span class=\"number\">15</span>,  <span class=\"number\">8</span>,  <span class=\"number\">5</span>,  <span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">24</span>,  <span class=\"number\">8</span>, <span class=\"number\">17</span>, <span class=\"number\">18</span>, <span class=\"number\">21</span>, <span class=\"number\">20</span>, <span class=\"number\">23</span>, <span class=\"number\">11</span>, <span class=\"number\">26</span>, <span class=\"number\">16</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 3x */</span>    <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">3</span>,  <span class=\"number\">5</span>, <span class=\"number\">19</span>, <span class=\"number\">12</span>, <span class=\"number\">14</span>, <span class=\"number\">13</span>,  <span class=\"number\">6</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 4x */</span>    <span class=\"number\">5</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 5x */</span>    <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">0</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">9</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>, <span class=\"number\">27</span>,  <span class=\"number\">1</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 6x */</span>    <span class=\"number\">8</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 7x */</span>    <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">0</span>,  <span class=\"number\">1</span>,  <span class=\"number\">1</span>, <span class=\"number\">27</span>, <span class=\"number\">10</span>, <span class=\"number\">27</span>, <span class=\"number\">25</span>, <span class=\"number\">27</span>,</span><br><span class=\"line\"><span class=\"comment\">/* 8x */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>, <span class=\"comment\">//后128个字符都是 2，也就是 CC_ID。</span></span><br><span class=\"line\"><span class=\"comment\">/* 9x */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Ax */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Bx */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Cx */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Dx */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Ex */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,</span><br><span class=\"line\"><span class=\"comment\">/* Fx */</span>    <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span>,  <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在case CC_KYWD的情况下，获取到一个完整的单词之后，通过调用<code>keywordCode</code>函数，还要再次判断，这个单词是否是SQLite的关键字，并且返回具体的关键字的<em>特征ID</em>。关于<code>keywordCode</code>函数的原理和优化，可以看后续的<a href=\"https://caio.ink/2020/07/16/19.SQLite-KeywordHash/\">SQLite–KeywordHash</a></p>"},{"title":"The Virtual Machine Module","date":"2020-06-28T16:00:00.000Z","top":300,"_content":"\n本文讨论了SQLite虚拟机（VM）是如何解释执行了一个通过SQLite内部的字节码语言编写的程序。VM是存储在本地数据库文件中数据唯一的操作者。它支持5种原始的数据类型:NULL,integer,real,character string,blob,这五种数据类型代表了在文件或者内存中存储的原始的数据项。由VM来完成用户数据和内部数据表示之间的转换。在做表达式评估的时候它也会做一些数据类型转换。VM是如何工作的，以及它在存储表和索引记录到B-，B+树之前，如何做数据格式化。\n\n<!-- more -->\n\n**本文目标**\n\n* 5种数据类型和它们代表的含义\n* 一个编译好的SQL语句的内部表述\n* 在SQL类型和C类型之间是如何做转换的\n* 表记录和索引记录的逻辑结构\n* 清单类型在编码数据值中的优势\n\n# 虚拟机\n\n后端最顶层的模块在SQLite术语中通常被称之为虚拟数据库引擎，或虚拟机（VM）。VM是SQLite的核心，并且是前端和后端之间的接口。一些核心信息(计算和逻辑)只会在VM中处理，因为下层模块就存储的信息而言是被动的。它在原生的操作系统上层实现了一个抽象的虚拟的机器，并且它可以执行用SQLite内部的字节码程序语言编写的程序。这个程序语言是特地设计用来搜索，读取和修改数据库的。VM接受由前端生成的字节码程序，并且执行这个程序。VM使用B+树提供的\"基础能力\"来执行字节码程序，并且输出程序的执行结果。\n\nSQLite开发团队认为VM的使用对于这个库的开发和调试有巨大的好处。VM在前端（解析SQL语句并生成VM应用程序的部分）和后端（执行字节码应用程序并计算结果的部分）之间扮演了一个粘合剂的角色。字节码程序比解释集成数据对象的复杂网格更易于阅读。虚拟机还可以帮助SQLite引擎开发人员清楚地了解引擎正在尝试对其所编译的每个SQL语句执行的操作。\n\n**字节码执行跟踪**:对于人类来说，读取字节码程序比解释数据结构值更容易。它还具有跟踪每个VM应用程序的程序执行的能力--打印每个字节码指令以及随着执行的进展而生成的结果。这个取决于SQLite源代码的编译方式。\n\n一个字节码应用程序在内存中由一个`sqlite3_stmt`对象表示(内部称为Vdbe)。以下SQLite API 可以用在这个对象上，从而实现把某个输入的值关联到SQL参数上，或者执行字节码程序，或者检索程序执行产生的输出。\n\n1. sqlite3_bind_*:这系列方法会指派值给SQL参数，并且作为字节码程序的输入。\n2. sqlite3_step:它会让字节码程序执行推进到下一个断点，或者到一个终止点。\n3. sqlite3_reset:它让程序执行倒退到起点，并且使得同一个程序可以准备进行二次执行。\n4. sqlite3_column_*:这系列方法会从程序产生的当前输出行中逐列提取结果。\n5. sqlite3_finalize:它会销毁sqlite3_stmt对象和字节码程序\n\nVdbe对象（又称预处理语句）的内部状态包括以下内容：\n* 一个字节码程序\n* 所有结果列的名字和数据类型\n* 绑定到输出参数的值\n* 一个程序计数器\n* 任意数量的“编号”存储单元（称为寄存器位置）\n* 其他运行时的状态信息(例如一个打开的BTree对象，集合，列表，排序器...)\n\nVM不会做任何查询优化操作。它会无条件地执行字节码程序。这样，它可以按需将数据从一个格式转换为另一个格式。即时的数据转换，是VM的主要任务。所有事情都会在它所执行的字节码程序的控制之下。本文主要介绍数据转换和操作任务。在此之前，下一部分概述字节码编程语言，字节码程序和程序执行逻辑。\n\n## 字节码编程语言\n\nSQLite定义了一种内部编程语言来准备字节码程序。该语言类似于物理和虚拟机（例如Java以及使用的字节码）使用的汇编语言：它定义了字节码指令。每个字节码指令执行少量信息处理工作或做出逻辑决策。而一个字节码程序则包含了一个线性的字节码指令序列。一个字节码指令可以最多有5个操作数，<opcode,P1,P2,P3,P4,P5>,opcode定义了一系列的字节码操作，而P1,P2,P3,P4,P5则是当前操作的操作数或者操作数对应的寄存器。前三个操作数都是一个32位的有符号整数。如果当前操作触发了一个跳转，那么P2就一定是一个目标地址。P4是一个32/64为的有符号整数，或者是64位的浮点小数，或者是一个指向具有终止符的字符串，字节块，一个归类的比较方法，一个SQL方法，等等。P5操作数是一个无符号的字符。这5个操作数不是左右的操作符都会使用的。\n\n**注意**\n操作码是VM操作的内部名称，不属于SQLite的接口定义。总之，它们的含义可能会由于版本的更新而更新。SQLite的开发团队不鼓励SQLite的用户来直接编写字节码。字节码编程语言仅供内部使用。\n\n下面的表格展示了一个典型的字节码程序。这个字节码程序等价于`SELECT * FROM t1`。这个表格有x,y两列。字节码程序从0号指令开始执行，一直执行到一个终止指令或者超出了最后一条指令。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/06/UOiFYp.png)\n\n### 字节码指令\n\n大概一共有142个操作码。操作码可以分为5类：1.计算和逻辑。2.数据移动。3.控制流。4.B-和B+树相关。5.专门的类型。第一类操作码包含 加, 减, 乘, 除, 求余, 位或, 位与, 二进制反码, 二进制补码, 右移动, 左移 和 字符串连接。第二类操作码在内存单元之间移动值。第三类操作码包含goto , gosub, return , halt 和 条件转移。第四类操作码包含(i) 创建, 销毁, 和 清空 B/ B+树, (ii) 打开 和 关闭 B/B+ 树上的游标, (iii) 向前 和 向后移动游标 或 移动到指定的key, (iv)光标移动的分支,(v)插入, 删除 B/B+ 树的记录,(vi)开始, 提交 和 回滚 事务。第五类操作码包含(a)获取一个不在使用的rowid,(b)组合n个内存元素为一个记录，(c)从一个表行中提取第i个列的数据，等等。\n\n每一个字节码指令在内部都由一个VdbeOp对象表示。这是一个比较简单的对象，它有以下成员：(1)opcode，表明需要执行的操作，(2)(3)(4)(5)(6)p1-p5持有5个操作数。(7)p4type表明了p4操作数的数据类型。p4有13个类型。一个虚拟机应用程序实际上是一个VdbeOp对象的线性集合。\n\n下面展示了一些操作码的含义。最新SQLite版本的操作码都在[SQLite官方网站](http://www.sqlite.org/opcode.html)找到。在SQLite源码中，每一个操作码的名字都由OP_开头，并且都分配了不同的整数。\n\n1. Trace: 这个操作码检查了SQLite库是否开启了tracing mode。如果开启了，那么在每次跟踪回调的时候都会输出P4的内容(一个UTF8字符串)。你可以使用`sqlite3_trace`API方法开启跟踪。\n2. Goto: 无条件跳转到P2所指定的地址。VM执行的下一条指令将是距程序开始偏移为P2的指令。\n3. OpenRead: 打开一个B/B+树的只读的游标。这个树的root page由P2指定。（如果P5不为0，那么就是寄存器P2包含了这个page号，而不是P2的内容）数据库文件由P3操作数指定--0表示主数据库，1表示临时数据库，大于1表示附加连接的数据库。P1操作数(一个非负的整数)将会是新的游标的标识。P4的值是一个整数或者一个指向KeyInfo结构体的指针。如果光标在B树（SQL索引）上打开，则KeyInfo结构定义了 内容和排序 的顺序。如果P4是一个整型的值，则代表了表列的数量。\n    \n如果在只读游标打开的时候，数据库没有上锁，那么在这个指令指向的时候，会请求一个共享锁。如果它无法获取一个共享锁，虚拟机会终止字节码的执行，并且返回一个SQLITE_BUSY错误码。（这个可以看后端的实现逻辑）\n4. Rewind：重置游标P1。这个游标将会指向表或者索引的第一项，对应树中最小的一项。如果树是空的，并且P2 > 0,那么就会立刻跳转到P2对应的地址。否则，遵循以下说明。\n5. Column: 获取P1游标指向的记录中，P2对应的列的值。(这里会把P1指向的记录解析为一个数据结构，而这个数据结构是由MakeRecord指令构建的，可以看下面的MakeRecord指令)，如果记录中的字段个数少于P2个，那么提取的值就会变成NULL；如果P4的数据类型是一个P4_MEM,那么就会使用P4的值作为结果。返回的值会存储在P3寄存器内。\n6. MakeRecord：将从寄存器P1开始的P2个寄存器合并转换为一个可以用作数据库表中的记录项，或者转换为一个索引的key。也就是说P1包含了第一个数据项目，P1+1是第二个数据项目，以此类推。\n7. ResultRow: 寄存器P1到P1+P2-1包含一个单行记录。在上层应用执行`sqlite_step`方法的时候这个指令就会执行。并且这个方法执行返回SQLITE_ROW。\n8. Next: 推进P1游标，这样它就可以指向树上的下一项。如果树上面没有下一项了，那么就会遵循以下说明。否则就会立刻跳转到P2地址。\n9. Close: 关闭先前打开的P1游标。如果P1游标没有打开，那么这个指令就无操作。\n10. Halt: 在关闭所有已打开的游标、FIFOs（又名RowSet对象）后立刻退出。P1是`sqlite3_exec`,`sqlite3_reset`,`sqlite3_finalize`三个API返回的结果值。对于通常的结束来说，返回的结果值都是SQLITE_OK(=0)。如果出现了错误，那么这个错误码就是其他值了。如果P1!=0，那么P2就决定了当前的事务是否需要做一个回滚。当P2=OE_Fail的时候就无需回滚；当P2=OE_Rollback的时候就需要回滚；当P2=OE_Abort的时候，撤消此执行过程中发生的所有更改，但不回滚事务。P4指向的是一个错误信息。\n\n`Halt 0 0 0 0 0`是一个默认的终止指令，会被插入到每一个字节码程序的最后面。因此，跳过程序的最后一条指令与执行终止指令是一样的。\n11. Transaction: 开启一个新的事务。P1是标识了开启事务的数据库文件类型。0代表主数据库文件，1代表临时数据库，大于1的时候代表附加连接的数据库。如果P2是0，表示数据库文件上会获取一个共享读锁。如果P2非零，就会开始一个写事务，数据库上会获取一个保留锁。如果P2是2或者更大，那么就会获取一个排它锁。开启写事务的时候也需要创建一个回滚文件。\n12. VerifyCookie: 检查全局数据库参数号0的值(schema版本的cookie)，并且保证这个值和P2的值是一致的，并且在本地模式解析中的迭代计数器和P3的值是一致的(?)。P1是标识了数据库文件类型与上面一致。（你可以回想一下，每当数据库模式更改时，cookie值都会更改）这个验证的操作是用来检测，当cookie发生便跟的时候，当前的进程需要重新去读取schema。在执行此操作码之前，要么需要启动事务，要么需要执行OpenRead / Open Write（至少在数据库上建立共享锁）。\n13. TableLock: 在数据库P1上获取根page为P2的表的锁。如果P3为0，那么加读锁，如果P3为1，加写锁。P4包含了一个指向这个表名的指针。\n\n在下面两个小节中，将会表述SQL insert 和join处理的VM执行逻辑。这样可以给出更加清晰的描述来显示如何为一个SQL语句生成一个字节码程序的。\n\n### 插入逻辑\n\n假设，有一个包含两列的表T1。这两列分别是c1 text和c2 integer;这个表没有任何的索引。如果你执行`insert into T1 values('Hello,Wold!', 2000)`的语句，VM会根据下面的算法步骤来执行:\n\n1. 在主数据库上打开一个写事务。\n2. 检查数据库的schema版本，保证在这个语句的字节码生成期间没有被别人修改过。\n3. 在表\"T1\"的B+树上，打开一个写游标。\n4. 创建一个新的rowid，并且将'Hello,Wold!'和2000合并创建一个记录项。\n5. 通过打开的游标，将这个记录项插入到B+树中。\n6. 关闭游标。\n7. 给调用者返回执行结果。\n\n如果在T1上还有索引，在第三步的时候，VM会在每一个索引表上打开一个写游标，并且分别在第四步和第五步的时候准备和插入一个记录项。\n\n### 连接逻辑\n\n在连接操作中，会合并两个或者多个表来创建一个结果表。结果表包含要连接的表中所有可能的行组合。实现连接的最简单，最自然的方法是使用嵌套循环。SQLite仅执行循环联接，而不执行合并联接。在FROM语句中的最左侧的表构成最外侧的循环，最右侧的表构成了最内侧的循环。\n\n考虑以下SQL 查询语句: `select * from t1, t2 where ...`，假设这两个表上都没有索引。那么这个查询语句的伪代码，就类似于下面这样。\n\n1. 在主数据库上打开一个读事务。\n2. 同样的检查schema版本。\n3. 打开两个游标，一个是T1的，一个是t2的。\n4. \n``` c\nfor each record in T1, do:\n    for each record in T2, do:\n        if WHERE语句为TRUE\n            计算当前行的所有结果列\n            为当前结果行调用默认回调函数的\n            \n```\n5. 关闭两个游标。\n\n### 程序的执行\n\nVM从序号为0的指令开始执行一个字节码程序，直到它(1)处理一个停止指令或者(2)遇到一个错误，或者(2)程序计数器超过了最后一条指令。当程序终止的时候，它会释放所有已经分配的内存，并且关闭所有打开的游标。如果执行因为错误而终止了，后续的事务就会终止，并且回滚引起的数据库变更。\n\n下面用C语言给出了这个VM解释器的结构。解释器（带Vdbe对象指针的sqlite3VdbeExec函数）是一个简单的for循环，其中包含了一个大量case的Switch语句。每一个case的语句实现了一个字节码指令（在源代码中，操作码名称以OP_prefix开头。操作码名称的数字值不是静态编号的。它们是在SQLite源代码编译时分配的。数字可能因一个SQLite版本而异。）在每一次迭代中，VM从程序中拉取下一次的字节码指令。例如：从aOp数组中以pc作为下标(这两个都是Vdbe对象的成员变量)索引获取下一个字节码指令。它会解码并执行指令指定的操作。一般来说，程序的执行会从一个字节码执行到下一个(pc++)，但是pc可以由跳转指令变更。这个for循环会一直执行，一直到VM处理了一个终止指令或者循环的条件不成立了(也就是pc计数超过了指令个数)，那么我们就说字节码程序已经终止了。这个是一个正常的终止。\n\n```c\nfor (; pc < nOp && rc == SQLITE_OK; pc++){ \n    switch (aOp[pc].opcode){\n    case OP_Add:\n        /* Implementation of the ADD operation here */\n        break; \n    case OP_Goto:\n        pc = op[pc].p2-1;\n        break; \n    case OP_Halt:\n        pc = nOp;\n        break;\n    /* other cases for other opcodes */ }\n}\n```\n\n`sqlite3_prepare`API方法返回了`sqlite3_stmt`对象指针。而这个对象实际上指向的是Vbe对象(它代表了虚拟数据库引擎)。这个对象包含了完整的VM状态。下面展示了这个对象的一些组件。`aOp`数组包含了所有的操作码。这个程序执行需要的所有内存均位于大小为`nMem`的`aMem`数组中。\n\n| 成员变量 | 描述 |\n| ---- | ---- |\n| db | sqlite3数据库连接对象 |\n| aOp | VM程序 |\n| nOp | aOp的数量 |\n| apCsr | 打开的游标数组 |\n| nCursor | apCsr的大小 |\n| aMem | 程序执行需要的内存 |\n| nMem | aMem的大小 |\n| rc | 需要返回的值 |\n| pc | 程序计数器 |\n| ... | 其他变量 |\n\nVM使用游标来访问数据库(这些游标和在Tree模块使用的`BtCursors`不一样)。在数据库上可能有几个已经打开游标的数据库。每一个游标都是指向数据库中表和索引的树。游标可以通过一个key指向到任何一个项或者遍历树中的所有项。VM可以在游标指向的当前项创建新的或者检索key/value值，或者删除项。\n\n在同一个索引或者表的树上可以同时有多个游标。尽管在同一个索引或者表上可以有多个游标，但是它们都是独立操作的。在VM中，一个VdbeCursor对象代表了一个打开的游标。下面的表格展示了VdbeCursor的结构体。字节码程序的质量可以创建一个新的游标（通过操作码OP_OpenRead或者OP_OpenWrite），从游标中读取数据（通过操作码OP_Column），然后在表或者树上推进游标到下一项（通过操作码OP_Next）以及其他的一些操作。在VM终止执行字节码程序的时候，所有的游标都会自动关闭。\n\n| 成员变量 | 描述 |\n| ---- | ---- |\n| pCursor | 后端的(BtCursor)游标结构体 |\n| iDb | 游标所在的数据库 |\n| pBt | 这个游标的临时文件的临时表 |\n| pKeyInfo | 索引表的游标需要索引的key的一些信息 |\n| aType | 在记录里所有项的类型值 |\n| aOffset | 每一列数据缓存的从起始点开始的偏移 |\n| aRow | 当前行的数据(如果所有的数据都在一页page内) |\n| ... | 其他变量 |\n\n## 内部的数据类型\n\nVM使用任意数量的编号内存位置来保存所有中间结果。每一个内存地址存储了一个数据值。VM处理的每个值是一下五种数据类型之一:\n1. INTEGER: 一个有符号的整型数字；\n2. REAL: 一个有符号的浮点型数字；\n3. TEXT: 一个字符串值；\n4. BLOB: 一个字节块；\n5. NULL: 一个SQL NULL值；\n\nVM只支持5种原始的数据类型。这个类型决定了一个数据在实际物理存储的时候应该如何表示。每一个存储在内存或者本地数据库文件中的数据类型都必须是这几种数据类型之一。有些值可能具有多种数据类型。举个例子，123可以是一个整型，一个浮点型，也可以是一个字符串。BLOB和NULL的值没有多种含义。在必要的情况下，SQLite会做一些数据转换。你可以使用SQLite内置的方法`typeof`来获取一个值的类型--`select a,typeof(a) from t1`将会返回a字段的值以及他们对应的存储类型。在使用`sqlite3_step`方法返回一行记录的时候，API`sqlite3_column_type`会返回某列字段值的存储类型。\n\n在VM内部，所有的操作对象几乎都是Mem对象。每一个Mem对象可能会缓存数据的多个存储类型。而一个值(也就是Mem对象)有如下的属性: 每个值恰好是以上提到的五种存储类型之一。(每个Vbe.aMem数组元素就是一个aMem对象。)\n\n| 成员 | 描述 |\n| ---- | ---- |\n| type | 这个Mem对象锁代表的值的类型 |\n| i | 整型值 |\n| r | 浮点型值 |\n| z | 字符串或者字节块值 |\n| n | z的大小 |\n| enc | 如果z是一个字符串的话，这个字符串的UTF编码类型 |\n| ... | 其他变量 |\n\n## 记录格式\n\nVM会把数据组合为一条记录存储在他们对应的B树或者B+树内。每一个记录都包含key和一个可选的value。VM仅负责维护键和值的内部结构(尽管，Tree模块可能会把一条记录拆分为叶子节点，内部节点或者多个溢出页，VM把整条记录视为一个连续的字节串)。VM使用了两个相似但是也略有不同的结构来描述表和索引记录。\n\n有两种格式来格式化data/key记录：固定长度和可变长度。对于固定的长度来说，对于表或者索引的所有记录都是使用了相同大小的空间；在表或者索引的创建的时候就已经知道每一个字段的大小了。对于可变长度的格式来说，每一个字段的空间大小可能根据不同的记录而不一样。SQLite使用可变的变量长度来格式化记录，因为它有几个优势。数据库因为没有空间的浪费而变得更小。同样也会让整个系统跑得更快，因为在内存和磁盘之间需要同步的bytes数量更小。另外，使用可变长度的记录可以允许SQLite可以使用清单类型而不是静态类型。接下来两节先讨论一下这个清单类型。\n\n\n### 清单类型\n\n不论是存储在内存中还是在文件中，每一个原始的数据都有一个数据类型与之关联。这个数据类型称之为存储类型。大部分SQL数据库使用静态类型:一个表内的每列关联了一个数据类型，并且只允许存储每列关联的数据类型。这样非常死板，也有它自己的优缺点。SQLite通过使用清单类型解除了这一个限制。在这个方法下，数据的类型是数据本身的一个属性，而不是数据存储列的。这样，每一列就允许你存储任何变量，任何类型的数据，并且不会丢失这个数据的类型。SQLite会将数据的类型作为数据的一部分存储。它允许你在列内存储任何类型的数据，而不用关心每一列声明的数据类型。(在这里有一个例外，就是一个声明了`integer primary key`的列只能存储[-2^63, 2^63-1]的整型值)。\n\n### 类型编码\n\n存储类型会被编码为整型。这个整型值的编码关系在下表给出了。这种编码的好处在于类型编码也会包含数据长度。NULL类型代表了SQL NULL类型。对于INTEGER类型，数据的值是一个有符号的整型数字，由(1,2,3,4,6或8个字节)组成。具体的长度取决于值的大小。对于REAL类型，数据值是一个浮点小数，根据IEEE的浮点数标准，存储在8个字节内。8，9两个数据类型，分别代表了整型常量0和1.对于TEXT类型，数据值就是一个文本字符串，使用默认编码(UTF-8, UTF-16BE, or UTF-16-LE)格式存储文本。对于后两者来说，字节顺序分别是大端或者小端。（每个数据库文件只会用一种UTF编码）对于BLOB类型，数据值是一个字节流，完全和用户输入的字节流一致。\n\n**布尔值:**布尔值就使用8，9两个常量类型来表述。\n\n| 类型值 | 含义 | 数据长度 |\n| ---- | ---- | ---- |\n| 0 | NULL | 0 |\n| N in {1..4} | 有符号整数 | N |\n| 5 | 有符号整数 | 6 |\n| 6 | 有符号整数 | 8 |\n| 7 | IEEE 浮点 | 8 |\n| 8 | 常数 0 | 0 |\n| 9 | 常数 1 | 0 |\n| 10、11 | 扩展保留 | N/A |\n| N>=12 偶数 | 字节流 | (N-12)/2 |\n| N>=12 奇数 | 纯文本 | (N-13)/2 |\n\n### 表记录格式\n\n下表中描述了一个表记录的格式。由两部分组成：头部和记录内容。头部由一个size字段开始，后面跟着字段的类型。头部后面跟着记录的数据项。(SQLite不会修改在创建语句中声明的字段顺序。建议表结构的设计者在设计早期，把小而使用频率高的列放在记录中，从而尽可能避免触发溢出的规则。)\n\n<table>\n<tr>\n        <th style=\"color:grey\" colspan=\"5\">头部</th>\n        <th style=\"color:grey\" colspan=\"4\">记录内容</th>\n    </tr>\n    <tr>\n        <th>Header size</th>\n        <th>Type 1</th>\n        <th>Type 2</th>\n        <th>...</th>\n        <th>Type N</th>\n        <th>Data 1</th>\n        <th>Data 2</th>\n        <th>...</th>\n        <th>Data N</th>\n    </tr>\n</table>\n\nHeader size是Data1之前的字节数。这个大小是一个哈夫曼编码的64位的可变长度的integer值，并且它包含了它自身所占用的大小。这个大小也可以被用作Data1项的指针。在header size大小之后紧跟着的是数据类型字段，每一个数据值都按照它在字段中出现的顺序排列。每一个类型字段Type i是一个可变长的无符号整型（最大是2^64），对应编码了数据字段Data i的存储类型。\n\n**零长度的数据:**对于类型值为0，8，9，12和13来说，数据的长度是0，因此数据不会存储在记录中。\n\n### 表key的格式\n\n在SQLite中，每一个B+-Tree必须有一个唯一的key。尽管一个定义好的关系型表不包含相同的行，但是实际上用户是可以在关系表中存储重复的行的。但是数据库系统必须有办法来区分这些相同的行。该系统必须能够关联其他信息以实现差异化目的。这也就意味着，系统需要为这个关系提供一个新的唯一的属性。因此，在内部，每个表都有唯一的主键，并且该键由表的创建者或SQLite来定义。主键是一个名为rowid的整型值。\n\n#### Rowid列\n\n在每一个SQL表里，SQLite会指定一列作为rowid(也称为oid或_rowid_)。这一列中的值在表内的每一行都是唯一定义的。这列将会是表的隐式主键，也是表B+树的唯一搜索关键字。如果表内的任何一列被声明为 integer primary key，那么这列就会被当做这个表的rowid（作为别名）。否则的话，SQLite会创建一个独立的名为rowid作为唯一主键列。(如果表中已经存在了相同的这三个名字(rowid,oid,_rowid_),那么名称将引用这些列，而不是内部rowid列)因此，每一个表不论是否声明了 integer primary key列，都有一个唯一的整型key，命名为rowid。对于后一种情况，rowid本身在内部被视为表的整数主键。无论哪种情况，rowid都是[-2^63, 2^63-1]范围内的有符号整数值(在编译器有宏可以限制这个rowid为32位)。在表的B+树上的排序顺序是按照整型的大小，并且无法用其他的排序顺序。这些B+树是表的主要索引。rowid作为表B+树的逆向指针存储在二级索引里。\n\n#### Rowid值\n\n如果rowid是一个别名列(例如声明了INTEGER PRIMARY KEY),数据库的使用者是知道这个列的。如果SQLite插入了一列rowid，那么他们是不知道这列的存在的。无论哪种情况，用户都可以定义rowid值，或者SQLite可以为用户定义值。它保证了他们的唯一性。当有一条记录插入到表中而没有指定rowid值的时候，SQLite会访问B+树，为rowid获取到一个未使用的整型数字。通常来说，这个值都是比表格内最大的值要大。但是，如果已经到了最大值，那么SQLite就随机选一个未使用的值。如果找不到，那么就会返回SQLITE_FULL错误码。\n\n#### Rowid的含义\n\nRowid的含义取决于是谁创建的。如果rowid列是由SQLite创建的，那么表记录中就不包含它。否则，将在每个表记录中存储一个NULL（类型值0）。SQLite通过key来获取到真正的值。这个值是可变长的哈夫曼编码。可以允许负值的rowid，但是这样的话，它们就会占据9个字节，所以不鼓励这样做。如果rowid是由SQLite生成的，那么它们一定不会是负数，尽管你可以指定一个负整数。\n\n### 索引key的格式\n\n在前两节中你可以看到，每一个表的B+树都是一个整型key，然后这个表格的一行就是一个数据记录。索引与之相反。对于一个索引项，key是存储在索引表内的一行所有索引列值的一个组合。而数据才是这一行的rowid。为了通过一个索引列的指定数据来访问某一行，VM首先搜索索引表来找到对应的rowid，然后使用这个整型来找到表B+树内完整的记录。尽管许多人认为通过主键来指向每一行，开销太大，但是SQLite简单起见。\n\nSQLite通过创建一个存储在一个单独的B树内的单独的'索引表'来实现表内的每一个索引。每一个索引B树映射了搜索的关键字和rowid。索引B树有自己的关键字比较器，来排序索引项。VM会提供给Tree模块一个合适的关键字比较函数指针。\n\nSQLite会为create语句中的每一个`UNIQUE`唯一列创建一个索引，包括`PRIMARY KEY`列。你不能单独删除这些索引。你可以在一个非目录表上使用`CREATE INDEX`为指定列创建索引。你也可以单独删除这些索引。当一个表被删除的时候，这个表对应的所有的索引都被删除了。还有一些其他方法在SQLite中创建索引。以下是在表T1(a,b,c)上的a,b列创建索引的例子。\n\n1. 直接声明创建索引\n* `CREATE TABLE T1(a,b,c)`\n* `CREATE INDEX idx1 ON T1(a,b)`\n2. 声明列唯一\n* `CREATE TABLE T1(a,b,c,UNIQUE(a,b))`\n3. 声明列为主键\n* `CREATE TABLE T1(a,b,c,PRIMARY KEY(a,b))`\n\n**注意:**`INTEGER PRIMARY KEY`比较特殊，它不会生成一个单独的索引。表的B+树由这个别名为rowid的列来排序。\n\nSQLite可以在一列上同时创建多个索引，思考一下下面这个例子\n`CREATE TABLE T2(x VARCHAR(5) UNIQUE PRIMARY KEY , y BLOB);`\n`CREATE INDEX idx2 ON T2(x);`\n\n上面的例子中，SQLite在x列上创建了三个索引，一个是`PRIMARY KEY`,一个是`UNIQUE`，一个是指定创建的索引。索引会减慢`INSERT`,`UPDATE`和`DELETE`的执行，并且加大了数据库文件的大小。\n\n|Header size| Type 1 | Type 2| ··· | Data1 | Data2 | rowid |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n\n正如上面提及的，SQLite会把索引当做一个表，然后在它自己的B树中存储。它把关键字隐射到了rowid上。下面描述了一个索引记录的格式。整个记录都当做了B-Tree的key；没有数据部分。索引记录的编码和数据表的记录的一样，除了后面跟了一个rowid，并且rowid的数据类型，没有在记录头部显式声明。因为rowid的类型只能是有符号整数并且是用哈夫曼编码表示的（不是内部的整型类型）。（其它数据的值和数据的存储类型都从索引表内拷贝）在x列上的内容索引，如下所示.\n\n| x | rowid |\n| ---- | ---- |\n| NULL | 54321 |\n| 456 | 2 |\n| abc | -5 |\n| abc | 1 |\n| hello | 100 |\n\n索引主要是用来加速数据库搜索的。两次B+树搜索时间一般都会远小于一个全表扫描搜索。\n\n**临时索引:**SQLite可以在执行SQL语句时使用order by或group by子句，或在聚合查询中进行except，或使用union或intersect进行复合选择，从而动态创建临时索引。临时索引会存储在临时文件中。\n\n## 数据类型管理\n\nSQLite的数据处理是发生在VM模块的，这个模块驱动了后端在数据库中存储，检索数据。VM是数据库内存储的数据的唯一操作者；所有事情都是通过字节码的执行来控制的。它决定了在某个地方存储什么数据，以及在某个地方检索什么数据。给合适的数据分配合适的数据类型，并且做必要的数据转换都是VM的主要任务。有三个数据交换的地方可能会触发数据转换：从SQLite应用到引擎，从引擎到SQLite应用，从引擎到引擎。对于前两个情况，VM为用户数据分配数据类型，VM会尽可能将用户提供的数据转换为在列上声明的数据类型，反之亦然。对于后一种情况，表达式转换会引起数据转换。在下面三个小节中，我们讨论一下这三种数据转换。\n\n### 指派类型给用户数据\n\n之前已经讨论过表记录和索引记录的存储格式了。每一个记录的字段都有一个存储类型。应用层传递字段值给SQLite有两种方式:(1)嵌入在SQL语句中,(2)通过预处理绑定值。(VM也是通过执行表达式语句来分派字段值。)在VM执行预处理语句之前，它会给每一个输入的值分配一个存储类型。这个存储类型是用来将输入的数据编码为一个合适的屋里存储格式。\n\nVM通过三个步骤来决定一个输入值的存储类型：它首先确定输入数据的存储类型，然后确定列的声明的SQL类型，最后，如果需要，它再进行类型转换。在后面章节的讲述中，SQLite可能会在数字存储类型（INTEGER和REAL）与TEXT之间转换数据。(你可能注意到了，SQL标准里没有提供关于数据编码的指南，除了一些日期，时间和时间戳。)这些会在下面的章节中讨论。\n\n#### 决定存储类型\n\nSQLite是‘无类型’的，例如，没有预约束。(SQLite开发者团队希望一直是无类型的。)无类型允许在任何表里面存储任何数据类型，而不用在意那一列声明的是什么数据类型。(除了声明了INTEGER PRIMARY KEY的，这一列只能存储整型，其他类型的VM都会拒绝。)SQLite允许在创建语句中无SQL类型声明。例如`create table T1(a,b,c)`在SQLite中其实是一个有效的SQL语句。那现在的问题是，VM是如何在一个值存入指定列的时候为它分配具体的数据类型的呢？\n\nVM按照如下的步骤来给用户输入的数据分配一个初始化的存储类型。正如前面提到的，有两种方法给SQLite提供输入数据。\n\n1. 如果一个值是嵌入SQL语句中提供的，那么会被指派为一下数据类型之一:\n    * 如果值被单双引号包含，那么指派为TEXT\n    * 如果值是不带小数点或指数的，不带引号的数字，那么指派为INTEGER\n    * 如果值是带小数点或指数的不带引号的数字，那么指派为REAL\n    * 如果值是字符串NULL，且周围没有引号，那么指派为NULL\n    * 如果使用X'ABCD'标记指定值，那么指派为BLOB(ABCD是十六进制数字)\n\n    否则输入的值将会被VM拒绝，并且查询将会失败。\n2. `sqlite3_bind_*`API方法中提供的SQL参数值将会指派为与原生类型最接近的数据类型。例如，`sqlite3_bind_blob`绑定了一个存储类型为BLOB的值。\n\nSQL标量运算符结果的值的存储类型取决于表达式的最外层运算符。用户定义的函数可以返回任何存储类型的值。通常在SQL语句的预处理阶段无法确定表达式结果的类型。VM在运行时一获取值就会分配存储类型。\n\n#### 决定列的相似关联性\n\nSQLite允许在任何一列存储任一类型的数据。因此数据类型和数据值存在一起。其他SQL数据库引擎使用限制性更强的静态类型，其中类型与容器关联，而不与值关联。SQLite更具有灵活性。为了最大程度地提高SQLite与其他数据库引擎之间的兼容性，SQLite支持在列上使用类型相似性的概念。每一个输入的值可能具有SQL语句声明的类型的一个相关联的类型。对于该列中存储的值，建议使用列类型的相似类型：\"建议使用，不是必需的\"。\n\n某一个列优先使用的值的类型，称之为这个列的关联类型。列的关联类型和列的声明类型是不一样的，尽管前者还是由后者派生而来。每一个列有以下5种相似类型的其中一个:TEXT,NUMERIC,INTEGER,REAL和NONE。根据`CREATE TABLE`语句中声明的SQL类型，SQLite遵循以下的规则，来决定某个列的关联类型。\n\n1. 如果SQL类型包含子字符串INT，则该列具有INTEGER关联。\n2. 如果SQL类型包含任何子字符串CHAR，BLOB或TEXT，则该列具有TEXT关联性。 （SQL类型VARCHAR包含字符串CHAR，因此也具有TEXT关联性。）\n3. 如果SQL类型包含子字符串BLOB，或者未指定类型，则列具有NONE关联。\n4. 如果SQL类型包含任何子串REAL，FLOA或DOUB，则列具有REAL关联。\n5. 除此之外, 列具有NUMERIC关联。\n\nVM会按照上面给出的顺序来评估这个规则。模式匹配不区分大小写。例如，如果声明的列的SQL类型为BLOBINT，则关联性为INTEGER，而不是NONE。\n\n**注意:**如果使用`create table table1 as select ...`语句创建了SQL表，每列的声明类型由create table语句的select部分中相应表达式的相关联类型确定。如果一个表达式的关联类型是text, numeric, integer, real, 或 none，那么声明的类型分别就是text, num, int, real, 或 \"\"。每个此类列的默认值为SQL NULL。隐式rowid的类型始终是整数，不能为NULL。\n\n#### 数据转换\n\nSQLite在关联类型和存储类型之间定义了一种关系。如果用户给某一列提供的数据不满足这个关系，那么这个值就会拒绝或者转换为一个合适的格式。当一个值即将被插入到一列的时候，VM首先会给这个值指派一个最合适的存储类型，然后来决定存入的这个列的关联类型，最后再尝试将这个初始的存储类型转换为这个列的关联类型。它会按照如下规则转换:\n\n1. 具有TEXT关联关系的列可以存储所有NULL,TEXT,BLOB存储类型的数据。如果一个数字类型的(整型或者浮点型)被插入的时候，这个数字会被转换为文本类型，那么它的最终存储类型就会变成TEXT。\n2. 一个具有NUMERIC关联类型的列可以存储所有的5种类型。当一个文本类型的数据插入到这一列的时候，VM会尝试把这个文本转换为整型或者浮点型。如果这个转换是成功的(无损且可逆)，那么这个转换的值就会相应的使用整型和浮点型的存储类型。如果这个转换无法执行的话，那么这个值就会以TEXT的存储类型来存储。VM不会尝试转换NULL或者BLOB值。\n3. 一个具有INTEGER关联类型的列和上面的NUMERIC的行为一致，除了一种情况:当一个没有小数部分的浮点型值或者一个文本值，VM会把这个值转换为整型并且存储的最终存储类型为INTEGER。\n4. 一个具有REAL关联类型的列和上面的NUMERIC的行为一致，除了一种情况:他会强制转换一个整型的值为一个浮点数。(但是，SQLite会做一个优化，只在磁盘上存储整数，等待读出数据的时候才会转换为浮点数)\n5. 一个具有NONE关联类型的列可以存储所有的5种类型，并且不会转换任何类型。\n\n**注意:**所有的SQL数据库引擎都会转换数据类型。这些数据库都是类型强要求的，但SQLite可以是不是强要求的。举个例子，如果你有个表的列声明了SQL类型为整型的并且尝试插入一个字符串(“123”或\"abc\"),那么VM会分析这个字符串看看是否像一个数字。如果看起来像是一个数字，那么它就会被转换为一个数字(如果没有小数部分，会被转换为一个整型)。如果不是一个数字的格式，那么就会以TEXT的数据类型存储。一个具有TEXT关联类型的会尝试把输入数字以ASCII编码的形式存储。\n\n#### 一个简单的例子\n\n从一个简单的例子来看存储类型，关联类型和类型转换。下面是一个典型的字段无类型的图表。假设你在这个表内执行了一个插入的语句。表格里也同样描述了插入到T1表B+树的记录。输入值(a,b,c)初始化的存储类型分别是整型，NULL和文本。所有列的关联类型都是NONE，并且VM不会转换初始化存储类型。在图里，这个记录(头+数据项)包含了11个字节。(记录里所有的数字都是以十六进制给出的。上面提及到SQLite不会重排序每列的位置:和创建语句中的顺序保持一致。)\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/07/KZKZlm.png)\n\n1. 头部有四个字节:第一个字节是头部的大小，加上三个字节分别是每一个值的类型。\n2. 类型1的数字是2，代表2个字节的有符号整型。\n3. 类型2的数字是0，代表NULL。\n4. 类型3的数字是22，代表(22-12)/2=5个字节的字符串。\n5. 数据1是2个字节的整型00B1,值是177。(一个字节是无法表示177的，因为B1的值是-79)\n6. 数据2是NULL，不占据数据段的任何空间。\n7. 数据3是5个字节的字符串 68 65 6C 6C 6F。忽略了终止符。\n\n#### 列关联性的例子\n\n考虑下面的场景：有SQL语句`create table T1(t TEXT,n NUMERIC,i INTEGER, r REAL,b BLOB)`创建了一个表。假设执行如下的SQL语句：`insert into T1 values('1.0', '1.0', '1.0', '1.0', '1.0')`。所有值的初始化存储类型都是TEXT，因为他们都是有单引号的。基于之前给出的规则，列t,n,i,r,b的关联类型分别是TEXT，NUMERIC，INTEGER，REAL 和 NONE。那t,n,i,r,b几个列的最终的存储类型是TEXT，INTEGER，INTEGER，REAL 和 TEXT。对于NUMERIC关联类型，'1.0'看起来像是一个整型1，因此它的最终存储类型就是整型。而关联性为NONE的列不会做任何的数据类型转换，因此，依旧会把初始化类型存入。假设再执行`insert into T1 values(1.0, 1.0, 1.0, 1.0, 1.0)`。所有值的初始化存储类型都是REAL，并且最终的存储类型分别是TEXT，INTEGER，INTEGER，REAL 和 REAL。对于TEXT列，1.0会被转换为文本\"1.0\"作为TEXT存储类型。假设再执行`insert into T1 values(1, 1, 1, 1, 1)`。所有值的初始化存储类型都是INTEGER，并且最终的存储类型分别是TEXT, INTEGER, INTEGER, REAL 和 INTEGER。你可以在[这个网站上](http://www.sqlite.org/datatype3.html.)找到更多关于列关联性类型的例子。\n\n#### 其他相似关联性的模式\n\n上面小节中讨论的是数据库引擎在'通常'和默认关联模式下的数据库操作。SQLite支持另外两种关联性模式相关的特性。\n\n* **严格关联模式** 在和这个模式下，如果需要在初始存储类型和关联类型之间进行转换，引擎就会返回一个错误，并且当前的语句执行就会失败。\n* **无关联模式** 在这个模式下，VM不会做任何的存储类型的转换。\n\n### 给应用层转换引擎的数据\n\n应用层可以通过调用`sqlite3_column_*`API方法来从SQLite引擎中读取数据。这些方法在合适的地方会尝试转换数据值。举个例子，如果内部的表示是REAL，但是通过API`sqlite3_column_text`方法请求了一个字符串值，VM会使用sprintf()库方法内部做一个转换，并且把值返回给应用层。下面的表展示了VM应用在内部数据的转换规则。\n\n| 内部类型 | 请求类型 | 转换 |\n| ---- | ---- | ---- |\n| NULL | INTEGER | 返回结果为0 |\n| NULL | FLOAT | 返回结果为0 |\n| NULL | TEXT | 返回结果是NULL指针 |\n| NULL | BLOB | 返回结果是NULL指针 |\n| INTEGER | FLOAT | 从整型转换为浮点型 |\n| INTEGER | TEXT | 通过ASCII码转换 |\n| INTEGER | BLOB | 和上面一样 |\n| FLOAT | INTEGER | 从浮点型转换为整型 |\n| FLOAT | TEXT | 通过ASCII转换 |\n| FLOAT | BLOB | 和上面一样 |\n| TEXT | INTEGER | 使用atoi() |\n| TEXT | FLOAT | 使用atof() |\n| TEXT | BLOB | 没有变更 |\n| BLOB | INTEGER | 先转换为TEXT然后使用atoi() |\n| BLOB | FLOAT | 先转换为TEXT然后使用atof() |\n| BLOB | TEXT | 如果需要的话在后面增加一个\\000 |\n\n### 为表达式指派数据类型\n\nVM可能先转换内部数据，然后再将内部数据与另一个内部数据进行比较或者评估表达式，在后面的章节中，我们将讨论VM是如何处理内部数据的。\n\n#### 处理SQL NULL值\n\nSQL NULL值可以在任何一个表列使用，除了主键列。NULL值的存储类型是NULL。无论它们的存储类型是什么，NULL值与这个列的所有其他有效值都不同。SQL标准对于如何处理表达式中列的NULL值不是很具体。根据标准还尚不清楚在各种情况下应如何正确处理NULL值。例如，我们如何比较NULL和其他值？SQLite以许多其他RDBMS一样的方式处理NULL。在SELECT DISTINCT语句，使用UNION操作符的SELECT的组合语句，和GROUP BY语句中NULL是一样的。但是，NULL在UNIQUE列中却是不同的。NULL由SQL标准指定的内置SUM函数处理。对NULL进行算术运算的结果始终是NULL。\n\n#### 表达式中的类型\n\nSQLite支持四种比较操作符：\n\n* 二元比较运算符 =, ==, <, <=, >, >=, <>, 和 !=\n* 三元比较运算符 'BETWEEN'\n* 成员运算符 'IN' 和 'NOT IN'\n* 判空操作符 'IS NULL' 和 'IS NOT NULL'\n\n**注意:**判空操作符'IS NULL'和'IS NOT NULL'分别和'='和'!='操作符一样。\n\n根据以下规则，比较的结果取决于要比较的两个值的存储类型：\n1. 如果运算符左侧的值是NULL，那么这个NULL一般都会认为比其他的小。（如果其他的值中有NULL，也是认为左侧的小）\n2. INTEGER或REAL比TEXT或BLOB值小。\n3. 如果INTEGER或REAL和另一个INTEGER或REAL比较，那么就是常规的数字比较了。\n4. TEXT值比BLOB值小。\n5. 如果两个TEXT值比较，那么就是使用标准C库的memcmp函数来比较。但是这个函数是可以被用户自定义的函数重写的。\n6. 当两个BLOB比较的时候，始终使用memcmp函数比较。\n\n在应用这些规则之前，VM的首要任务是确定比较运算符的操作数的存储类型。它首先确定操作数的初步存储类型，然后（如有必要）根据它们的列的关联性转换类型。最后，它使用以上四个规则进行比较。\n\n如果一个表达式是某个列，或者是使用别名指向的某个列，或者是一个子查询返回的一个列，或者是rowid，那么这个这个表达式的关联性就会使用列的关联性。否则，这个表达式没有SQL类型，并且它的关联性是NONE。SQLite会尝试在比较运算之前，在（INTEGER和REAL）和TEXT之间做转换。对于二元比较，会在下列情况下完成(可以看expr.c文件中的sqlite3CompareAffinity方法)。这里说的表达式，是除了列值以外的任何SQL标量表达式或者纯文本。\n\n* 当两个列的值比较的时候，如果其中任何一列有NUMERIC关联性，那么这两个值会优先使用这个关联性。也就是说，VM尝试在比较之前转换其他列的值。\n* 当将列值与表达式的结果进行比较时，在进行比较之前，会将列的关联性同样应用于这个表达式的结果。\n* 比较两个表达式的值时，将不进行任何转换。按照上述标准规则比较这些值。例如，如果将字符串与数字进行比较，则数字将始终小于字符串。\n\n在SQLite中表达式`a BETWEEN b AND c`等价于`a >= b AND a <= c`，但是在两次的比较中，a列的关联性会不一样。\n\n对于表达式`a IN (SELECT b ...)`来说，就会使用上面提到的 = 号的二元操作符的规则来处理(例如,a=b)。举个例子，如果b是一个列的值，a是一个表达式，那么在比较之前b的关联性就会被应用到a上。SQLite处理表达式`a IN (x,y,z)`和处理`a = x OR a = y OR a = z`是一样的，但是a的关联性是不一样的。\n\n有些简单的例子，你可以在[这个网站](http://www.sqlite.org/datatype3.html)上找到更多例子。假设，你有一个通过`CREATE TABLE t1(a TEXT,b NUMERIC, c BLOB, d)`语句创建的表。你可以通过执行`INSERT INTO t1 VALUES(‘500’，‘500’，‘500’, 500)`插入一条记录。那么最终，a,b,c三列的存储类型就会变成TEXT，INTEGER，TEXT 和 INTEGER。\n\n* `SELECT a < 600, a < 60, a < 40 FROM t1`，会把600,60和40转换为\"600\",\"60\"和\"40\"，因为a列具有TEXT关联性，值就会被当做TEXT来比较。并且整个语句返回`1|1|0`作为输出，因为\"500\"比\"600\"和\"60\"小，但是比\"40\"大。\n* `SELECT b < 40, b < 60, b < 600 FROM t1`不会转换任何值，会被当做普通的数字比较，那么就会返回`0|0|1`\n* `SELECT c < 40, c < 60, c < 600 FROM t1`不会转换任何值，因为c列是NONE关联类型。三个值(存储类型为NUMERIC)都比\"500\"小(存储类型为TEXT)，所以返回值为`0|0|0`\n* `SELECT d < 40, d < 60, d < 600 FROM t1`不会转换值，因为d的关联性是NUMERIC。返回`0|0|1`，因为存储的值都是整型比较。\n\n#### 操作符中的类型\n\n所有的数学运算符(除了 || 串联运算符以外)都将NUMERIC关联到所有的操作数上，并求值。如果所有操作数都无法转换为NUMERIC，那么运算结果为NULL。对于串联运算符来说，TEXT将关联到两个操作数上。如果任何一个操作数都无法转换为TEXT(NULL或者BLOB)，那么串联的结果为NULL。\n\n#### order by中的类型\n\n当值被ORDER BY语句排序的时候，在排序之前不会有存储类型的转换。遵循先前规定的标准比较规则：NULL在最前面，然后是按值大小的INTEGER和REAL，再然后是TEXT，最后是BLOB，后面两个通常是memcmp()排序顺序。同样的文本排序方法可以被用户定义的函数重写。\n\n#### group by中的类型\n\n当值被GROUP BY语句分组的时候，在分组之前不会有存储类型的转换。具有不同存储类型的值被认为是不同的，但INTEGER和REAL值除外，如果它们在数值上相等，则被视为相等。GROUP BY语句的结果中也不会做任何的存储类型的转换。\n\n#### 组合SELECTs中的类型\n复合SELECT操作符(UNION，INTERSECT和EXCEPT)，在值之间进行隐式比较。在比较之前，VM不会执行任何关联类型转换。它们就按照原始值进行比较。\n\n# 总结\nVM模块是后端数据库引擎。数据操作逻辑就在这个模块内。它会执行一个使用特殊的字节码语言编写的程序。（类似于其他汇编语言）一个字节码程序实际上就是字节码指令的线性组合。一个字节码指令可以有一个操作码和最多5个操作数或者持有操作数的寄存器组成。\n\n一个`Vdbe`对象代表了一个由前端生成的字节码程序(在内部是一个`sqlite3_stmt`指针)。应用层可以在这个对象上执行SQLite API方法。举个例子，当应用层执行`sqlite3_step`API方法的时候，它会循环迭代执行这个程序，一直执行遇到终止或者遇到一个可以输出的结果记录。\n\nVM支持五种数据类型：integer,real,text,blob和SQL NULL。在数据库文件或者内存中的数据必须是这五种之一。这个类型称之为存储类型。当需要的时候，VM会做类型的转换。应用程序可以使用typeof SQL函数来确定值的数据类型。\n\nVM是数据的唯一操作者。它维护表和索引树中的记录。这两者的记录格式很相似。SQLite使用一个可变长度的记录格式。它使用清单类型来表示记录中的单个值。这个清单类型是指，每一个数据的存储类型信息都被存在记录中了。此方案允许在任何列中存储任何存储类型的值，而与该列的声明的SQL类型无关，但有一个例外，即整数主键列仅存储整数值。值的存储类型被编码为整数，并且该整数还编码该值的（字节）长度。每个表记录均以头部大小（即可变长度的霍夫曼代码）开头，然后是数据值的清单类型，然后是各个数据值。\n\n数据类型管理在SQLite中有点复杂。SQLite根据声明的SQL类型为列分配关联类型。首先尝试将输入数据值转换为关联类型。如果转换失败，则原始值仍将存储在该列中。 SQLite进行类似的数据转换来评估表达式和函数。","source":"_posts/18.db-system-design-imp(VM).md","raw":"---\ntitle: The Virtual Machine Module\ndate: 2020-06-29\ntags: [sqlite3]\ntop: 300\ncategories: sqlite3\n---\n\n本文讨论了SQLite虚拟机（VM）是如何解释执行了一个通过SQLite内部的字节码语言编写的程序。VM是存储在本地数据库文件中数据唯一的操作者。它支持5种原始的数据类型:NULL,integer,real,character string,blob,这五种数据类型代表了在文件或者内存中存储的原始的数据项。由VM来完成用户数据和内部数据表示之间的转换。在做表达式评估的时候它也会做一些数据类型转换。VM是如何工作的，以及它在存储表和索引记录到B-，B+树之前，如何做数据格式化。\n\n<!-- more -->\n\n**本文目标**\n\n* 5种数据类型和它们代表的含义\n* 一个编译好的SQL语句的内部表述\n* 在SQL类型和C类型之间是如何做转换的\n* 表记录和索引记录的逻辑结构\n* 清单类型在编码数据值中的优势\n\n# 虚拟机\n\n后端最顶层的模块在SQLite术语中通常被称之为虚拟数据库引擎，或虚拟机（VM）。VM是SQLite的核心，并且是前端和后端之间的接口。一些核心信息(计算和逻辑)只会在VM中处理，因为下层模块就存储的信息而言是被动的。它在原生的操作系统上层实现了一个抽象的虚拟的机器，并且它可以执行用SQLite内部的字节码程序语言编写的程序。这个程序语言是特地设计用来搜索，读取和修改数据库的。VM接受由前端生成的字节码程序，并且执行这个程序。VM使用B+树提供的\"基础能力\"来执行字节码程序，并且输出程序的执行结果。\n\nSQLite开发团队认为VM的使用对于这个库的开发和调试有巨大的好处。VM在前端（解析SQL语句并生成VM应用程序的部分）和后端（执行字节码应用程序并计算结果的部分）之间扮演了一个粘合剂的角色。字节码程序比解释集成数据对象的复杂网格更易于阅读。虚拟机还可以帮助SQLite引擎开发人员清楚地了解引擎正在尝试对其所编译的每个SQL语句执行的操作。\n\n**字节码执行跟踪**:对于人类来说，读取字节码程序比解释数据结构值更容易。它还具有跟踪每个VM应用程序的程序执行的能力--打印每个字节码指令以及随着执行的进展而生成的结果。这个取决于SQLite源代码的编译方式。\n\n一个字节码应用程序在内存中由一个`sqlite3_stmt`对象表示(内部称为Vdbe)。以下SQLite API 可以用在这个对象上，从而实现把某个输入的值关联到SQL参数上，或者执行字节码程序，或者检索程序执行产生的输出。\n\n1. sqlite3_bind_*:这系列方法会指派值给SQL参数，并且作为字节码程序的输入。\n2. sqlite3_step:它会让字节码程序执行推进到下一个断点，或者到一个终止点。\n3. sqlite3_reset:它让程序执行倒退到起点，并且使得同一个程序可以准备进行二次执行。\n4. sqlite3_column_*:这系列方法会从程序产生的当前输出行中逐列提取结果。\n5. sqlite3_finalize:它会销毁sqlite3_stmt对象和字节码程序\n\nVdbe对象（又称预处理语句）的内部状态包括以下内容：\n* 一个字节码程序\n* 所有结果列的名字和数据类型\n* 绑定到输出参数的值\n* 一个程序计数器\n* 任意数量的“编号”存储单元（称为寄存器位置）\n* 其他运行时的状态信息(例如一个打开的BTree对象，集合，列表，排序器...)\n\nVM不会做任何查询优化操作。它会无条件地执行字节码程序。这样，它可以按需将数据从一个格式转换为另一个格式。即时的数据转换，是VM的主要任务。所有事情都会在它所执行的字节码程序的控制之下。本文主要介绍数据转换和操作任务。在此之前，下一部分概述字节码编程语言，字节码程序和程序执行逻辑。\n\n## 字节码编程语言\n\nSQLite定义了一种内部编程语言来准备字节码程序。该语言类似于物理和虚拟机（例如Java以及使用的字节码）使用的汇编语言：它定义了字节码指令。每个字节码指令执行少量信息处理工作或做出逻辑决策。而一个字节码程序则包含了一个线性的字节码指令序列。一个字节码指令可以最多有5个操作数，<opcode,P1,P2,P3,P4,P5>,opcode定义了一系列的字节码操作，而P1,P2,P3,P4,P5则是当前操作的操作数或者操作数对应的寄存器。前三个操作数都是一个32位的有符号整数。如果当前操作触发了一个跳转，那么P2就一定是一个目标地址。P4是一个32/64为的有符号整数，或者是64位的浮点小数，或者是一个指向具有终止符的字符串，字节块，一个归类的比较方法，一个SQL方法，等等。P5操作数是一个无符号的字符。这5个操作数不是左右的操作符都会使用的。\n\n**注意**\n操作码是VM操作的内部名称，不属于SQLite的接口定义。总之，它们的含义可能会由于版本的更新而更新。SQLite的开发团队不鼓励SQLite的用户来直接编写字节码。字节码编程语言仅供内部使用。\n\n下面的表格展示了一个典型的字节码程序。这个字节码程序等价于`SELECT * FROM t1`。这个表格有x,y两列。字节码程序从0号指令开始执行，一直执行到一个终止指令或者超出了最后一条指令。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/06/UOiFYp.png)\n\n### 字节码指令\n\n大概一共有142个操作码。操作码可以分为5类：1.计算和逻辑。2.数据移动。3.控制流。4.B-和B+树相关。5.专门的类型。第一类操作码包含 加, 减, 乘, 除, 求余, 位或, 位与, 二进制反码, 二进制补码, 右移动, 左移 和 字符串连接。第二类操作码在内存单元之间移动值。第三类操作码包含goto , gosub, return , halt 和 条件转移。第四类操作码包含(i) 创建, 销毁, 和 清空 B/ B+树, (ii) 打开 和 关闭 B/B+ 树上的游标, (iii) 向前 和 向后移动游标 或 移动到指定的key, (iv)光标移动的分支,(v)插入, 删除 B/B+ 树的记录,(vi)开始, 提交 和 回滚 事务。第五类操作码包含(a)获取一个不在使用的rowid,(b)组合n个内存元素为一个记录，(c)从一个表行中提取第i个列的数据，等等。\n\n每一个字节码指令在内部都由一个VdbeOp对象表示。这是一个比较简单的对象，它有以下成员：(1)opcode，表明需要执行的操作，(2)(3)(4)(5)(6)p1-p5持有5个操作数。(7)p4type表明了p4操作数的数据类型。p4有13个类型。一个虚拟机应用程序实际上是一个VdbeOp对象的线性集合。\n\n下面展示了一些操作码的含义。最新SQLite版本的操作码都在[SQLite官方网站](http://www.sqlite.org/opcode.html)找到。在SQLite源码中，每一个操作码的名字都由OP_开头，并且都分配了不同的整数。\n\n1. Trace: 这个操作码检查了SQLite库是否开启了tracing mode。如果开启了，那么在每次跟踪回调的时候都会输出P4的内容(一个UTF8字符串)。你可以使用`sqlite3_trace`API方法开启跟踪。\n2. Goto: 无条件跳转到P2所指定的地址。VM执行的下一条指令将是距程序开始偏移为P2的指令。\n3. OpenRead: 打开一个B/B+树的只读的游标。这个树的root page由P2指定。（如果P5不为0，那么就是寄存器P2包含了这个page号，而不是P2的内容）数据库文件由P3操作数指定--0表示主数据库，1表示临时数据库，大于1表示附加连接的数据库。P1操作数(一个非负的整数)将会是新的游标的标识。P4的值是一个整数或者一个指向KeyInfo结构体的指针。如果光标在B树（SQL索引）上打开，则KeyInfo结构定义了 内容和排序 的顺序。如果P4是一个整型的值，则代表了表列的数量。\n    \n如果在只读游标打开的时候，数据库没有上锁，那么在这个指令指向的时候，会请求一个共享锁。如果它无法获取一个共享锁，虚拟机会终止字节码的执行，并且返回一个SQLITE_BUSY错误码。（这个可以看后端的实现逻辑）\n4. Rewind：重置游标P1。这个游标将会指向表或者索引的第一项，对应树中最小的一项。如果树是空的，并且P2 > 0,那么就会立刻跳转到P2对应的地址。否则，遵循以下说明。\n5. Column: 获取P1游标指向的记录中，P2对应的列的值。(这里会把P1指向的记录解析为一个数据结构，而这个数据结构是由MakeRecord指令构建的，可以看下面的MakeRecord指令)，如果记录中的字段个数少于P2个，那么提取的值就会变成NULL；如果P4的数据类型是一个P4_MEM,那么就会使用P4的值作为结果。返回的值会存储在P3寄存器内。\n6. MakeRecord：将从寄存器P1开始的P2个寄存器合并转换为一个可以用作数据库表中的记录项，或者转换为一个索引的key。也就是说P1包含了第一个数据项目，P1+1是第二个数据项目，以此类推。\n7. ResultRow: 寄存器P1到P1+P2-1包含一个单行记录。在上层应用执行`sqlite_step`方法的时候这个指令就会执行。并且这个方法执行返回SQLITE_ROW。\n8. Next: 推进P1游标，这样它就可以指向树上的下一项。如果树上面没有下一项了，那么就会遵循以下说明。否则就会立刻跳转到P2地址。\n9. Close: 关闭先前打开的P1游标。如果P1游标没有打开，那么这个指令就无操作。\n10. Halt: 在关闭所有已打开的游标、FIFOs（又名RowSet对象）后立刻退出。P1是`sqlite3_exec`,`sqlite3_reset`,`sqlite3_finalize`三个API返回的结果值。对于通常的结束来说，返回的结果值都是SQLITE_OK(=0)。如果出现了错误，那么这个错误码就是其他值了。如果P1!=0，那么P2就决定了当前的事务是否需要做一个回滚。当P2=OE_Fail的时候就无需回滚；当P2=OE_Rollback的时候就需要回滚；当P2=OE_Abort的时候，撤消此执行过程中发生的所有更改，但不回滚事务。P4指向的是一个错误信息。\n\n`Halt 0 0 0 0 0`是一个默认的终止指令，会被插入到每一个字节码程序的最后面。因此，跳过程序的最后一条指令与执行终止指令是一样的。\n11. Transaction: 开启一个新的事务。P1是标识了开启事务的数据库文件类型。0代表主数据库文件，1代表临时数据库，大于1的时候代表附加连接的数据库。如果P2是0，表示数据库文件上会获取一个共享读锁。如果P2非零，就会开始一个写事务，数据库上会获取一个保留锁。如果P2是2或者更大，那么就会获取一个排它锁。开启写事务的时候也需要创建一个回滚文件。\n12. VerifyCookie: 检查全局数据库参数号0的值(schema版本的cookie)，并且保证这个值和P2的值是一致的，并且在本地模式解析中的迭代计数器和P3的值是一致的(?)。P1是标识了数据库文件类型与上面一致。（你可以回想一下，每当数据库模式更改时，cookie值都会更改）这个验证的操作是用来检测，当cookie发生便跟的时候，当前的进程需要重新去读取schema。在执行此操作码之前，要么需要启动事务，要么需要执行OpenRead / Open Write（至少在数据库上建立共享锁）。\n13. TableLock: 在数据库P1上获取根page为P2的表的锁。如果P3为0，那么加读锁，如果P3为1，加写锁。P4包含了一个指向这个表名的指针。\n\n在下面两个小节中，将会表述SQL insert 和join处理的VM执行逻辑。这样可以给出更加清晰的描述来显示如何为一个SQL语句生成一个字节码程序的。\n\n### 插入逻辑\n\n假设，有一个包含两列的表T1。这两列分别是c1 text和c2 integer;这个表没有任何的索引。如果你执行`insert into T1 values('Hello,Wold!', 2000)`的语句，VM会根据下面的算法步骤来执行:\n\n1. 在主数据库上打开一个写事务。\n2. 检查数据库的schema版本，保证在这个语句的字节码生成期间没有被别人修改过。\n3. 在表\"T1\"的B+树上，打开一个写游标。\n4. 创建一个新的rowid，并且将'Hello,Wold!'和2000合并创建一个记录项。\n5. 通过打开的游标，将这个记录项插入到B+树中。\n6. 关闭游标。\n7. 给调用者返回执行结果。\n\n如果在T1上还有索引，在第三步的时候，VM会在每一个索引表上打开一个写游标，并且分别在第四步和第五步的时候准备和插入一个记录项。\n\n### 连接逻辑\n\n在连接操作中，会合并两个或者多个表来创建一个结果表。结果表包含要连接的表中所有可能的行组合。实现连接的最简单，最自然的方法是使用嵌套循环。SQLite仅执行循环联接，而不执行合并联接。在FROM语句中的最左侧的表构成最外侧的循环，最右侧的表构成了最内侧的循环。\n\n考虑以下SQL 查询语句: `select * from t1, t2 where ...`，假设这两个表上都没有索引。那么这个查询语句的伪代码，就类似于下面这样。\n\n1. 在主数据库上打开一个读事务。\n2. 同样的检查schema版本。\n3. 打开两个游标，一个是T1的，一个是t2的。\n4. \n``` c\nfor each record in T1, do:\n    for each record in T2, do:\n        if WHERE语句为TRUE\n            计算当前行的所有结果列\n            为当前结果行调用默认回调函数的\n            \n```\n5. 关闭两个游标。\n\n### 程序的执行\n\nVM从序号为0的指令开始执行一个字节码程序，直到它(1)处理一个停止指令或者(2)遇到一个错误，或者(2)程序计数器超过了最后一条指令。当程序终止的时候，它会释放所有已经分配的内存，并且关闭所有打开的游标。如果执行因为错误而终止了，后续的事务就会终止，并且回滚引起的数据库变更。\n\n下面用C语言给出了这个VM解释器的结构。解释器（带Vdbe对象指针的sqlite3VdbeExec函数）是一个简单的for循环，其中包含了一个大量case的Switch语句。每一个case的语句实现了一个字节码指令（在源代码中，操作码名称以OP_prefix开头。操作码名称的数字值不是静态编号的。它们是在SQLite源代码编译时分配的。数字可能因一个SQLite版本而异。）在每一次迭代中，VM从程序中拉取下一次的字节码指令。例如：从aOp数组中以pc作为下标(这两个都是Vdbe对象的成员变量)索引获取下一个字节码指令。它会解码并执行指令指定的操作。一般来说，程序的执行会从一个字节码执行到下一个(pc++)，但是pc可以由跳转指令变更。这个for循环会一直执行，一直到VM处理了一个终止指令或者循环的条件不成立了(也就是pc计数超过了指令个数)，那么我们就说字节码程序已经终止了。这个是一个正常的终止。\n\n```c\nfor (; pc < nOp && rc == SQLITE_OK; pc++){ \n    switch (aOp[pc].opcode){\n    case OP_Add:\n        /* Implementation of the ADD operation here */\n        break; \n    case OP_Goto:\n        pc = op[pc].p2-1;\n        break; \n    case OP_Halt:\n        pc = nOp;\n        break;\n    /* other cases for other opcodes */ }\n}\n```\n\n`sqlite3_prepare`API方法返回了`sqlite3_stmt`对象指针。而这个对象实际上指向的是Vbe对象(它代表了虚拟数据库引擎)。这个对象包含了完整的VM状态。下面展示了这个对象的一些组件。`aOp`数组包含了所有的操作码。这个程序执行需要的所有内存均位于大小为`nMem`的`aMem`数组中。\n\n| 成员变量 | 描述 |\n| ---- | ---- |\n| db | sqlite3数据库连接对象 |\n| aOp | VM程序 |\n| nOp | aOp的数量 |\n| apCsr | 打开的游标数组 |\n| nCursor | apCsr的大小 |\n| aMem | 程序执行需要的内存 |\n| nMem | aMem的大小 |\n| rc | 需要返回的值 |\n| pc | 程序计数器 |\n| ... | 其他变量 |\n\nVM使用游标来访问数据库(这些游标和在Tree模块使用的`BtCursors`不一样)。在数据库上可能有几个已经打开游标的数据库。每一个游标都是指向数据库中表和索引的树。游标可以通过一个key指向到任何一个项或者遍历树中的所有项。VM可以在游标指向的当前项创建新的或者检索key/value值，或者删除项。\n\n在同一个索引或者表的树上可以同时有多个游标。尽管在同一个索引或者表上可以有多个游标，但是它们都是独立操作的。在VM中，一个VdbeCursor对象代表了一个打开的游标。下面的表格展示了VdbeCursor的结构体。字节码程序的质量可以创建一个新的游标（通过操作码OP_OpenRead或者OP_OpenWrite），从游标中读取数据（通过操作码OP_Column），然后在表或者树上推进游标到下一项（通过操作码OP_Next）以及其他的一些操作。在VM终止执行字节码程序的时候，所有的游标都会自动关闭。\n\n| 成员变量 | 描述 |\n| ---- | ---- |\n| pCursor | 后端的(BtCursor)游标结构体 |\n| iDb | 游标所在的数据库 |\n| pBt | 这个游标的临时文件的临时表 |\n| pKeyInfo | 索引表的游标需要索引的key的一些信息 |\n| aType | 在记录里所有项的类型值 |\n| aOffset | 每一列数据缓存的从起始点开始的偏移 |\n| aRow | 当前行的数据(如果所有的数据都在一页page内) |\n| ... | 其他变量 |\n\n## 内部的数据类型\n\nVM使用任意数量的编号内存位置来保存所有中间结果。每一个内存地址存储了一个数据值。VM处理的每个值是一下五种数据类型之一:\n1. INTEGER: 一个有符号的整型数字；\n2. REAL: 一个有符号的浮点型数字；\n3. TEXT: 一个字符串值；\n4. BLOB: 一个字节块；\n5. NULL: 一个SQL NULL值；\n\nVM只支持5种原始的数据类型。这个类型决定了一个数据在实际物理存储的时候应该如何表示。每一个存储在内存或者本地数据库文件中的数据类型都必须是这几种数据类型之一。有些值可能具有多种数据类型。举个例子，123可以是一个整型，一个浮点型，也可以是一个字符串。BLOB和NULL的值没有多种含义。在必要的情况下，SQLite会做一些数据转换。你可以使用SQLite内置的方法`typeof`来获取一个值的类型--`select a,typeof(a) from t1`将会返回a字段的值以及他们对应的存储类型。在使用`sqlite3_step`方法返回一行记录的时候，API`sqlite3_column_type`会返回某列字段值的存储类型。\n\n在VM内部，所有的操作对象几乎都是Mem对象。每一个Mem对象可能会缓存数据的多个存储类型。而一个值(也就是Mem对象)有如下的属性: 每个值恰好是以上提到的五种存储类型之一。(每个Vbe.aMem数组元素就是一个aMem对象。)\n\n| 成员 | 描述 |\n| ---- | ---- |\n| type | 这个Mem对象锁代表的值的类型 |\n| i | 整型值 |\n| r | 浮点型值 |\n| z | 字符串或者字节块值 |\n| n | z的大小 |\n| enc | 如果z是一个字符串的话，这个字符串的UTF编码类型 |\n| ... | 其他变量 |\n\n## 记录格式\n\nVM会把数据组合为一条记录存储在他们对应的B树或者B+树内。每一个记录都包含key和一个可选的value。VM仅负责维护键和值的内部结构(尽管，Tree模块可能会把一条记录拆分为叶子节点，内部节点或者多个溢出页，VM把整条记录视为一个连续的字节串)。VM使用了两个相似但是也略有不同的结构来描述表和索引记录。\n\n有两种格式来格式化data/key记录：固定长度和可变长度。对于固定的长度来说，对于表或者索引的所有记录都是使用了相同大小的空间；在表或者索引的创建的时候就已经知道每一个字段的大小了。对于可变长度的格式来说，每一个字段的空间大小可能根据不同的记录而不一样。SQLite使用可变的变量长度来格式化记录，因为它有几个优势。数据库因为没有空间的浪费而变得更小。同样也会让整个系统跑得更快，因为在内存和磁盘之间需要同步的bytes数量更小。另外，使用可变长度的记录可以允许SQLite可以使用清单类型而不是静态类型。接下来两节先讨论一下这个清单类型。\n\n\n### 清单类型\n\n不论是存储在内存中还是在文件中，每一个原始的数据都有一个数据类型与之关联。这个数据类型称之为存储类型。大部分SQL数据库使用静态类型:一个表内的每列关联了一个数据类型，并且只允许存储每列关联的数据类型。这样非常死板，也有它自己的优缺点。SQLite通过使用清单类型解除了这一个限制。在这个方法下，数据的类型是数据本身的一个属性，而不是数据存储列的。这样，每一列就允许你存储任何变量，任何类型的数据，并且不会丢失这个数据的类型。SQLite会将数据的类型作为数据的一部分存储。它允许你在列内存储任何类型的数据，而不用关心每一列声明的数据类型。(在这里有一个例外，就是一个声明了`integer primary key`的列只能存储[-2^63, 2^63-1]的整型值)。\n\n### 类型编码\n\n存储类型会被编码为整型。这个整型值的编码关系在下表给出了。这种编码的好处在于类型编码也会包含数据长度。NULL类型代表了SQL NULL类型。对于INTEGER类型，数据的值是一个有符号的整型数字，由(1,2,3,4,6或8个字节)组成。具体的长度取决于值的大小。对于REAL类型，数据值是一个浮点小数，根据IEEE的浮点数标准，存储在8个字节内。8，9两个数据类型，分别代表了整型常量0和1.对于TEXT类型，数据值就是一个文本字符串，使用默认编码(UTF-8, UTF-16BE, or UTF-16-LE)格式存储文本。对于后两者来说，字节顺序分别是大端或者小端。（每个数据库文件只会用一种UTF编码）对于BLOB类型，数据值是一个字节流，完全和用户输入的字节流一致。\n\n**布尔值:**布尔值就使用8，9两个常量类型来表述。\n\n| 类型值 | 含义 | 数据长度 |\n| ---- | ---- | ---- |\n| 0 | NULL | 0 |\n| N in {1..4} | 有符号整数 | N |\n| 5 | 有符号整数 | 6 |\n| 6 | 有符号整数 | 8 |\n| 7 | IEEE 浮点 | 8 |\n| 8 | 常数 0 | 0 |\n| 9 | 常数 1 | 0 |\n| 10、11 | 扩展保留 | N/A |\n| N>=12 偶数 | 字节流 | (N-12)/2 |\n| N>=12 奇数 | 纯文本 | (N-13)/2 |\n\n### 表记录格式\n\n下表中描述了一个表记录的格式。由两部分组成：头部和记录内容。头部由一个size字段开始，后面跟着字段的类型。头部后面跟着记录的数据项。(SQLite不会修改在创建语句中声明的字段顺序。建议表结构的设计者在设计早期，把小而使用频率高的列放在记录中，从而尽可能避免触发溢出的规则。)\n\n<table>\n<tr>\n        <th style=\"color:grey\" colspan=\"5\">头部</th>\n        <th style=\"color:grey\" colspan=\"4\">记录内容</th>\n    </tr>\n    <tr>\n        <th>Header size</th>\n        <th>Type 1</th>\n        <th>Type 2</th>\n        <th>...</th>\n        <th>Type N</th>\n        <th>Data 1</th>\n        <th>Data 2</th>\n        <th>...</th>\n        <th>Data N</th>\n    </tr>\n</table>\n\nHeader size是Data1之前的字节数。这个大小是一个哈夫曼编码的64位的可变长度的integer值，并且它包含了它自身所占用的大小。这个大小也可以被用作Data1项的指针。在header size大小之后紧跟着的是数据类型字段，每一个数据值都按照它在字段中出现的顺序排列。每一个类型字段Type i是一个可变长的无符号整型（最大是2^64），对应编码了数据字段Data i的存储类型。\n\n**零长度的数据:**对于类型值为0，8，9，12和13来说，数据的长度是0，因此数据不会存储在记录中。\n\n### 表key的格式\n\n在SQLite中，每一个B+-Tree必须有一个唯一的key。尽管一个定义好的关系型表不包含相同的行，但是实际上用户是可以在关系表中存储重复的行的。但是数据库系统必须有办法来区分这些相同的行。该系统必须能够关联其他信息以实现差异化目的。这也就意味着，系统需要为这个关系提供一个新的唯一的属性。因此，在内部，每个表都有唯一的主键，并且该键由表的创建者或SQLite来定义。主键是一个名为rowid的整型值。\n\n#### Rowid列\n\n在每一个SQL表里，SQLite会指定一列作为rowid(也称为oid或_rowid_)。这一列中的值在表内的每一行都是唯一定义的。这列将会是表的隐式主键，也是表B+树的唯一搜索关键字。如果表内的任何一列被声明为 integer primary key，那么这列就会被当做这个表的rowid（作为别名）。否则的话，SQLite会创建一个独立的名为rowid作为唯一主键列。(如果表中已经存在了相同的这三个名字(rowid,oid,_rowid_),那么名称将引用这些列，而不是内部rowid列)因此，每一个表不论是否声明了 integer primary key列，都有一个唯一的整型key，命名为rowid。对于后一种情况，rowid本身在内部被视为表的整数主键。无论哪种情况，rowid都是[-2^63, 2^63-1]范围内的有符号整数值(在编译器有宏可以限制这个rowid为32位)。在表的B+树上的排序顺序是按照整型的大小，并且无法用其他的排序顺序。这些B+树是表的主要索引。rowid作为表B+树的逆向指针存储在二级索引里。\n\n#### Rowid值\n\n如果rowid是一个别名列(例如声明了INTEGER PRIMARY KEY),数据库的使用者是知道这个列的。如果SQLite插入了一列rowid，那么他们是不知道这列的存在的。无论哪种情况，用户都可以定义rowid值，或者SQLite可以为用户定义值。它保证了他们的唯一性。当有一条记录插入到表中而没有指定rowid值的时候，SQLite会访问B+树，为rowid获取到一个未使用的整型数字。通常来说，这个值都是比表格内最大的值要大。但是，如果已经到了最大值，那么SQLite就随机选一个未使用的值。如果找不到，那么就会返回SQLITE_FULL错误码。\n\n#### Rowid的含义\n\nRowid的含义取决于是谁创建的。如果rowid列是由SQLite创建的，那么表记录中就不包含它。否则，将在每个表记录中存储一个NULL（类型值0）。SQLite通过key来获取到真正的值。这个值是可变长的哈夫曼编码。可以允许负值的rowid，但是这样的话，它们就会占据9个字节，所以不鼓励这样做。如果rowid是由SQLite生成的，那么它们一定不会是负数，尽管你可以指定一个负整数。\n\n### 索引key的格式\n\n在前两节中你可以看到，每一个表的B+树都是一个整型key，然后这个表格的一行就是一个数据记录。索引与之相反。对于一个索引项，key是存储在索引表内的一行所有索引列值的一个组合。而数据才是这一行的rowid。为了通过一个索引列的指定数据来访问某一行，VM首先搜索索引表来找到对应的rowid，然后使用这个整型来找到表B+树内完整的记录。尽管许多人认为通过主键来指向每一行，开销太大，但是SQLite简单起见。\n\nSQLite通过创建一个存储在一个单独的B树内的单独的'索引表'来实现表内的每一个索引。每一个索引B树映射了搜索的关键字和rowid。索引B树有自己的关键字比较器，来排序索引项。VM会提供给Tree模块一个合适的关键字比较函数指针。\n\nSQLite会为create语句中的每一个`UNIQUE`唯一列创建一个索引，包括`PRIMARY KEY`列。你不能单独删除这些索引。你可以在一个非目录表上使用`CREATE INDEX`为指定列创建索引。你也可以单独删除这些索引。当一个表被删除的时候，这个表对应的所有的索引都被删除了。还有一些其他方法在SQLite中创建索引。以下是在表T1(a,b,c)上的a,b列创建索引的例子。\n\n1. 直接声明创建索引\n* `CREATE TABLE T1(a,b,c)`\n* `CREATE INDEX idx1 ON T1(a,b)`\n2. 声明列唯一\n* `CREATE TABLE T1(a,b,c,UNIQUE(a,b))`\n3. 声明列为主键\n* `CREATE TABLE T1(a,b,c,PRIMARY KEY(a,b))`\n\n**注意:**`INTEGER PRIMARY KEY`比较特殊，它不会生成一个单独的索引。表的B+树由这个别名为rowid的列来排序。\n\nSQLite可以在一列上同时创建多个索引，思考一下下面这个例子\n`CREATE TABLE T2(x VARCHAR(5) UNIQUE PRIMARY KEY , y BLOB);`\n`CREATE INDEX idx2 ON T2(x);`\n\n上面的例子中，SQLite在x列上创建了三个索引，一个是`PRIMARY KEY`,一个是`UNIQUE`，一个是指定创建的索引。索引会减慢`INSERT`,`UPDATE`和`DELETE`的执行，并且加大了数据库文件的大小。\n\n|Header size| Type 1 | Type 2| ··· | Data1 | Data2 | rowid |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n\n正如上面提及的，SQLite会把索引当做一个表，然后在它自己的B树中存储。它把关键字隐射到了rowid上。下面描述了一个索引记录的格式。整个记录都当做了B-Tree的key；没有数据部分。索引记录的编码和数据表的记录的一样，除了后面跟了一个rowid，并且rowid的数据类型，没有在记录头部显式声明。因为rowid的类型只能是有符号整数并且是用哈夫曼编码表示的（不是内部的整型类型）。（其它数据的值和数据的存储类型都从索引表内拷贝）在x列上的内容索引，如下所示.\n\n| x | rowid |\n| ---- | ---- |\n| NULL | 54321 |\n| 456 | 2 |\n| abc | -5 |\n| abc | 1 |\n| hello | 100 |\n\n索引主要是用来加速数据库搜索的。两次B+树搜索时间一般都会远小于一个全表扫描搜索。\n\n**临时索引:**SQLite可以在执行SQL语句时使用order by或group by子句，或在聚合查询中进行except，或使用union或intersect进行复合选择，从而动态创建临时索引。临时索引会存储在临时文件中。\n\n## 数据类型管理\n\nSQLite的数据处理是发生在VM模块的，这个模块驱动了后端在数据库中存储，检索数据。VM是数据库内存储的数据的唯一操作者；所有事情都是通过字节码的执行来控制的。它决定了在某个地方存储什么数据，以及在某个地方检索什么数据。给合适的数据分配合适的数据类型，并且做必要的数据转换都是VM的主要任务。有三个数据交换的地方可能会触发数据转换：从SQLite应用到引擎，从引擎到SQLite应用，从引擎到引擎。对于前两个情况，VM为用户数据分配数据类型，VM会尽可能将用户提供的数据转换为在列上声明的数据类型，反之亦然。对于后一种情况，表达式转换会引起数据转换。在下面三个小节中，我们讨论一下这三种数据转换。\n\n### 指派类型给用户数据\n\n之前已经讨论过表记录和索引记录的存储格式了。每一个记录的字段都有一个存储类型。应用层传递字段值给SQLite有两种方式:(1)嵌入在SQL语句中,(2)通过预处理绑定值。(VM也是通过执行表达式语句来分派字段值。)在VM执行预处理语句之前，它会给每一个输入的值分配一个存储类型。这个存储类型是用来将输入的数据编码为一个合适的屋里存储格式。\n\nVM通过三个步骤来决定一个输入值的存储类型：它首先确定输入数据的存储类型，然后确定列的声明的SQL类型，最后，如果需要，它再进行类型转换。在后面章节的讲述中，SQLite可能会在数字存储类型（INTEGER和REAL）与TEXT之间转换数据。(你可能注意到了，SQL标准里没有提供关于数据编码的指南，除了一些日期，时间和时间戳。)这些会在下面的章节中讨论。\n\n#### 决定存储类型\n\nSQLite是‘无类型’的，例如，没有预约束。(SQLite开发者团队希望一直是无类型的。)无类型允许在任何表里面存储任何数据类型，而不用在意那一列声明的是什么数据类型。(除了声明了INTEGER PRIMARY KEY的，这一列只能存储整型，其他类型的VM都会拒绝。)SQLite允许在创建语句中无SQL类型声明。例如`create table T1(a,b,c)`在SQLite中其实是一个有效的SQL语句。那现在的问题是，VM是如何在一个值存入指定列的时候为它分配具体的数据类型的呢？\n\nVM按照如下的步骤来给用户输入的数据分配一个初始化的存储类型。正如前面提到的，有两种方法给SQLite提供输入数据。\n\n1. 如果一个值是嵌入SQL语句中提供的，那么会被指派为一下数据类型之一:\n    * 如果值被单双引号包含，那么指派为TEXT\n    * 如果值是不带小数点或指数的，不带引号的数字，那么指派为INTEGER\n    * 如果值是带小数点或指数的不带引号的数字，那么指派为REAL\n    * 如果值是字符串NULL，且周围没有引号，那么指派为NULL\n    * 如果使用X'ABCD'标记指定值，那么指派为BLOB(ABCD是十六进制数字)\n\n    否则输入的值将会被VM拒绝，并且查询将会失败。\n2. `sqlite3_bind_*`API方法中提供的SQL参数值将会指派为与原生类型最接近的数据类型。例如，`sqlite3_bind_blob`绑定了一个存储类型为BLOB的值。\n\nSQL标量运算符结果的值的存储类型取决于表达式的最外层运算符。用户定义的函数可以返回任何存储类型的值。通常在SQL语句的预处理阶段无法确定表达式结果的类型。VM在运行时一获取值就会分配存储类型。\n\n#### 决定列的相似关联性\n\nSQLite允许在任何一列存储任一类型的数据。因此数据类型和数据值存在一起。其他SQL数据库引擎使用限制性更强的静态类型，其中类型与容器关联，而不与值关联。SQLite更具有灵活性。为了最大程度地提高SQLite与其他数据库引擎之间的兼容性，SQLite支持在列上使用类型相似性的概念。每一个输入的值可能具有SQL语句声明的类型的一个相关联的类型。对于该列中存储的值，建议使用列类型的相似类型：\"建议使用，不是必需的\"。\n\n某一个列优先使用的值的类型，称之为这个列的关联类型。列的关联类型和列的声明类型是不一样的，尽管前者还是由后者派生而来。每一个列有以下5种相似类型的其中一个:TEXT,NUMERIC,INTEGER,REAL和NONE。根据`CREATE TABLE`语句中声明的SQL类型，SQLite遵循以下的规则，来决定某个列的关联类型。\n\n1. 如果SQL类型包含子字符串INT，则该列具有INTEGER关联。\n2. 如果SQL类型包含任何子字符串CHAR，BLOB或TEXT，则该列具有TEXT关联性。 （SQL类型VARCHAR包含字符串CHAR，因此也具有TEXT关联性。）\n3. 如果SQL类型包含子字符串BLOB，或者未指定类型，则列具有NONE关联。\n4. 如果SQL类型包含任何子串REAL，FLOA或DOUB，则列具有REAL关联。\n5. 除此之外, 列具有NUMERIC关联。\n\nVM会按照上面给出的顺序来评估这个规则。模式匹配不区分大小写。例如，如果声明的列的SQL类型为BLOBINT，则关联性为INTEGER，而不是NONE。\n\n**注意:**如果使用`create table table1 as select ...`语句创建了SQL表，每列的声明类型由create table语句的select部分中相应表达式的相关联类型确定。如果一个表达式的关联类型是text, numeric, integer, real, 或 none，那么声明的类型分别就是text, num, int, real, 或 \"\"。每个此类列的默认值为SQL NULL。隐式rowid的类型始终是整数，不能为NULL。\n\n#### 数据转换\n\nSQLite在关联类型和存储类型之间定义了一种关系。如果用户给某一列提供的数据不满足这个关系，那么这个值就会拒绝或者转换为一个合适的格式。当一个值即将被插入到一列的时候，VM首先会给这个值指派一个最合适的存储类型，然后来决定存入的这个列的关联类型，最后再尝试将这个初始的存储类型转换为这个列的关联类型。它会按照如下规则转换:\n\n1. 具有TEXT关联关系的列可以存储所有NULL,TEXT,BLOB存储类型的数据。如果一个数字类型的(整型或者浮点型)被插入的时候，这个数字会被转换为文本类型，那么它的最终存储类型就会变成TEXT。\n2. 一个具有NUMERIC关联类型的列可以存储所有的5种类型。当一个文本类型的数据插入到这一列的时候，VM会尝试把这个文本转换为整型或者浮点型。如果这个转换是成功的(无损且可逆)，那么这个转换的值就会相应的使用整型和浮点型的存储类型。如果这个转换无法执行的话，那么这个值就会以TEXT的存储类型来存储。VM不会尝试转换NULL或者BLOB值。\n3. 一个具有INTEGER关联类型的列和上面的NUMERIC的行为一致，除了一种情况:当一个没有小数部分的浮点型值或者一个文本值，VM会把这个值转换为整型并且存储的最终存储类型为INTEGER。\n4. 一个具有REAL关联类型的列和上面的NUMERIC的行为一致，除了一种情况:他会强制转换一个整型的值为一个浮点数。(但是，SQLite会做一个优化，只在磁盘上存储整数，等待读出数据的时候才会转换为浮点数)\n5. 一个具有NONE关联类型的列可以存储所有的5种类型，并且不会转换任何类型。\n\n**注意:**所有的SQL数据库引擎都会转换数据类型。这些数据库都是类型强要求的，但SQLite可以是不是强要求的。举个例子，如果你有个表的列声明了SQL类型为整型的并且尝试插入一个字符串(“123”或\"abc\"),那么VM会分析这个字符串看看是否像一个数字。如果看起来像是一个数字，那么它就会被转换为一个数字(如果没有小数部分，会被转换为一个整型)。如果不是一个数字的格式，那么就会以TEXT的数据类型存储。一个具有TEXT关联类型的会尝试把输入数字以ASCII编码的形式存储。\n\n#### 一个简单的例子\n\n从一个简单的例子来看存储类型，关联类型和类型转换。下面是一个典型的字段无类型的图表。假设你在这个表内执行了一个插入的语句。表格里也同样描述了插入到T1表B+树的记录。输入值(a,b,c)初始化的存储类型分别是整型，NULL和文本。所有列的关联类型都是NONE，并且VM不会转换初始化存储类型。在图里，这个记录(头+数据项)包含了11个字节。(记录里所有的数字都是以十六进制给出的。上面提及到SQLite不会重排序每列的位置:和创建语句中的顺序保持一致。)\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/07/KZKZlm.png)\n\n1. 头部有四个字节:第一个字节是头部的大小，加上三个字节分别是每一个值的类型。\n2. 类型1的数字是2，代表2个字节的有符号整型。\n3. 类型2的数字是0，代表NULL。\n4. 类型3的数字是22，代表(22-12)/2=5个字节的字符串。\n5. 数据1是2个字节的整型00B1,值是177。(一个字节是无法表示177的，因为B1的值是-79)\n6. 数据2是NULL，不占据数据段的任何空间。\n7. 数据3是5个字节的字符串 68 65 6C 6C 6F。忽略了终止符。\n\n#### 列关联性的例子\n\n考虑下面的场景：有SQL语句`create table T1(t TEXT,n NUMERIC,i INTEGER, r REAL,b BLOB)`创建了一个表。假设执行如下的SQL语句：`insert into T1 values('1.0', '1.0', '1.0', '1.0', '1.0')`。所有值的初始化存储类型都是TEXT，因为他们都是有单引号的。基于之前给出的规则，列t,n,i,r,b的关联类型分别是TEXT，NUMERIC，INTEGER，REAL 和 NONE。那t,n,i,r,b几个列的最终的存储类型是TEXT，INTEGER，INTEGER，REAL 和 TEXT。对于NUMERIC关联类型，'1.0'看起来像是一个整型1，因此它的最终存储类型就是整型。而关联性为NONE的列不会做任何的数据类型转换，因此，依旧会把初始化类型存入。假设再执行`insert into T1 values(1.0, 1.0, 1.0, 1.0, 1.0)`。所有值的初始化存储类型都是REAL，并且最终的存储类型分别是TEXT，INTEGER，INTEGER，REAL 和 REAL。对于TEXT列，1.0会被转换为文本\"1.0\"作为TEXT存储类型。假设再执行`insert into T1 values(1, 1, 1, 1, 1)`。所有值的初始化存储类型都是INTEGER，并且最终的存储类型分别是TEXT, INTEGER, INTEGER, REAL 和 INTEGER。你可以在[这个网站上](http://www.sqlite.org/datatype3.html.)找到更多关于列关联性类型的例子。\n\n#### 其他相似关联性的模式\n\n上面小节中讨论的是数据库引擎在'通常'和默认关联模式下的数据库操作。SQLite支持另外两种关联性模式相关的特性。\n\n* **严格关联模式** 在和这个模式下，如果需要在初始存储类型和关联类型之间进行转换，引擎就会返回一个错误，并且当前的语句执行就会失败。\n* **无关联模式** 在这个模式下，VM不会做任何的存储类型的转换。\n\n### 给应用层转换引擎的数据\n\n应用层可以通过调用`sqlite3_column_*`API方法来从SQLite引擎中读取数据。这些方法在合适的地方会尝试转换数据值。举个例子，如果内部的表示是REAL，但是通过API`sqlite3_column_text`方法请求了一个字符串值，VM会使用sprintf()库方法内部做一个转换，并且把值返回给应用层。下面的表展示了VM应用在内部数据的转换规则。\n\n| 内部类型 | 请求类型 | 转换 |\n| ---- | ---- | ---- |\n| NULL | INTEGER | 返回结果为0 |\n| NULL | FLOAT | 返回结果为0 |\n| NULL | TEXT | 返回结果是NULL指针 |\n| NULL | BLOB | 返回结果是NULL指针 |\n| INTEGER | FLOAT | 从整型转换为浮点型 |\n| INTEGER | TEXT | 通过ASCII码转换 |\n| INTEGER | BLOB | 和上面一样 |\n| FLOAT | INTEGER | 从浮点型转换为整型 |\n| FLOAT | TEXT | 通过ASCII转换 |\n| FLOAT | BLOB | 和上面一样 |\n| TEXT | INTEGER | 使用atoi() |\n| TEXT | FLOAT | 使用atof() |\n| TEXT | BLOB | 没有变更 |\n| BLOB | INTEGER | 先转换为TEXT然后使用atoi() |\n| BLOB | FLOAT | 先转换为TEXT然后使用atof() |\n| BLOB | TEXT | 如果需要的话在后面增加一个\\000 |\n\n### 为表达式指派数据类型\n\nVM可能先转换内部数据，然后再将内部数据与另一个内部数据进行比较或者评估表达式，在后面的章节中，我们将讨论VM是如何处理内部数据的。\n\n#### 处理SQL NULL值\n\nSQL NULL值可以在任何一个表列使用，除了主键列。NULL值的存储类型是NULL。无论它们的存储类型是什么，NULL值与这个列的所有其他有效值都不同。SQL标准对于如何处理表达式中列的NULL值不是很具体。根据标准还尚不清楚在各种情况下应如何正确处理NULL值。例如，我们如何比较NULL和其他值？SQLite以许多其他RDBMS一样的方式处理NULL。在SELECT DISTINCT语句，使用UNION操作符的SELECT的组合语句，和GROUP BY语句中NULL是一样的。但是，NULL在UNIQUE列中却是不同的。NULL由SQL标准指定的内置SUM函数处理。对NULL进行算术运算的结果始终是NULL。\n\n#### 表达式中的类型\n\nSQLite支持四种比较操作符：\n\n* 二元比较运算符 =, ==, <, <=, >, >=, <>, 和 !=\n* 三元比较运算符 'BETWEEN'\n* 成员运算符 'IN' 和 'NOT IN'\n* 判空操作符 'IS NULL' 和 'IS NOT NULL'\n\n**注意:**判空操作符'IS NULL'和'IS NOT NULL'分别和'='和'!='操作符一样。\n\n根据以下规则，比较的结果取决于要比较的两个值的存储类型：\n1. 如果运算符左侧的值是NULL，那么这个NULL一般都会认为比其他的小。（如果其他的值中有NULL，也是认为左侧的小）\n2. INTEGER或REAL比TEXT或BLOB值小。\n3. 如果INTEGER或REAL和另一个INTEGER或REAL比较，那么就是常规的数字比较了。\n4. TEXT值比BLOB值小。\n5. 如果两个TEXT值比较，那么就是使用标准C库的memcmp函数来比较。但是这个函数是可以被用户自定义的函数重写的。\n6. 当两个BLOB比较的时候，始终使用memcmp函数比较。\n\n在应用这些规则之前，VM的首要任务是确定比较运算符的操作数的存储类型。它首先确定操作数的初步存储类型，然后（如有必要）根据它们的列的关联性转换类型。最后，它使用以上四个规则进行比较。\n\n如果一个表达式是某个列，或者是使用别名指向的某个列，或者是一个子查询返回的一个列，或者是rowid，那么这个这个表达式的关联性就会使用列的关联性。否则，这个表达式没有SQL类型，并且它的关联性是NONE。SQLite会尝试在比较运算之前，在（INTEGER和REAL）和TEXT之间做转换。对于二元比较，会在下列情况下完成(可以看expr.c文件中的sqlite3CompareAffinity方法)。这里说的表达式，是除了列值以外的任何SQL标量表达式或者纯文本。\n\n* 当两个列的值比较的时候，如果其中任何一列有NUMERIC关联性，那么这两个值会优先使用这个关联性。也就是说，VM尝试在比较之前转换其他列的值。\n* 当将列值与表达式的结果进行比较时，在进行比较之前，会将列的关联性同样应用于这个表达式的结果。\n* 比较两个表达式的值时，将不进行任何转换。按照上述标准规则比较这些值。例如，如果将字符串与数字进行比较，则数字将始终小于字符串。\n\n在SQLite中表达式`a BETWEEN b AND c`等价于`a >= b AND a <= c`，但是在两次的比较中，a列的关联性会不一样。\n\n对于表达式`a IN (SELECT b ...)`来说，就会使用上面提到的 = 号的二元操作符的规则来处理(例如,a=b)。举个例子，如果b是一个列的值，a是一个表达式，那么在比较之前b的关联性就会被应用到a上。SQLite处理表达式`a IN (x,y,z)`和处理`a = x OR a = y OR a = z`是一样的，但是a的关联性是不一样的。\n\n有些简单的例子，你可以在[这个网站](http://www.sqlite.org/datatype3.html)上找到更多例子。假设，你有一个通过`CREATE TABLE t1(a TEXT,b NUMERIC, c BLOB, d)`语句创建的表。你可以通过执行`INSERT INTO t1 VALUES(‘500’，‘500’，‘500’, 500)`插入一条记录。那么最终，a,b,c三列的存储类型就会变成TEXT，INTEGER，TEXT 和 INTEGER。\n\n* `SELECT a < 600, a < 60, a < 40 FROM t1`，会把600,60和40转换为\"600\",\"60\"和\"40\"，因为a列具有TEXT关联性，值就会被当做TEXT来比较。并且整个语句返回`1|1|0`作为输出，因为\"500\"比\"600\"和\"60\"小，但是比\"40\"大。\n* `SELECT b < 40, b < 60, b < 600 FROM t1`不会转换任何值，会被当做普通的数字比较，那么就会返回`0|0|1`\n* `SELECT c < 40, c < 60, c < 600 FROM t1`不会转换任何值，因为c列是NONE关联类型。三个值(存储类型为NUMERIC)都比\"500\"小(存储类型为TEXT)，所以返回值为`0|0|0`\n* `SELECT d < 40, d < 60, d < 600 FROM t1`不会转换值，因为d的关联性是NUMERIC。返回`0|0|1`，因为存储的值都是整型比较。\n\n#### 操作符中的类型\n\n所有的数学运算符(除了 || 串联运算符以外)都将NUMERIC关联到所有的操作数上，并求值。如果所有操作数都无法转换为NUMERIC，那么运算结果为NULL。对于串联运算符来说，TEXT将关联到两个操作数上。如果任何一个操作数都无法转换为TEXT(NULL或者BLOB)，那么串联的结果为NULL。\n\n#### order by中的类型\n\n当值被ORDER BY语句排序的时候，在排序之前不会有存储类型的转换。遵循先前规定的标准比较规则：NULL在最前面，然后是按值大小的INTEGER和REAL，再然后是TEXT，最后是BLOB，后面两个通常是memcmp()排序顺序。同样的文本排序方法可以被用户定义的函数重写。\n\n#### group by中的类型\n\n当值被GROUP BY语句分组的时候，在分组之前不会有存储类型的转换。具有不同存储类型的值被认为是不同的，但INTEGER和REAL值除外，如果它们在数值上相等，则被视为相等。GROUP BY语句的结果中也不会做任何的存储类型的转换。\n\n#### 组合SELECTs中的类型\n复合SELECT操作符(UNION，INTERSECT和EXCEPT)，在值之间进行隐式比较。在比较之前，VM不会执行任何关联类型转换。它们就按照原始值进行比较。\n\n# 总结\nVM模块是后端数据库引擎。数据操作逻辑就在这个模块内。它会执行一个使用特殊的字节码语言编写的程序。（类似于其他汇编语言）一个字节码程序实际上就是字节码指令的线性组合。一个字节码指令可以有一个操作码和最多5个操作数或者持有操作数的寄存器组成。\n\n一个`Vdbe`对象代表了一个由前端生成的字节码程序(在内部是一个`sqlite3_stmt`指针)。应用层可以在这个对象上执行SQLite API方法。举个例子，当应用层执行`sqlite3_step`API方法的时候，它会循环迭代执行这个程序，一直执行遇到终止或者遇到一个可以输出的结果记录。\n\nVM支持五种数据类型：integer,real,text,blob和SQL NULL。在数据库文件或者内存中的数据必须是这五种之一。这个类型称之为存储类型。当需要的时候，VM会做类型的转换。应用程序可以使用typeof SQL函数来确定值的数据类型。\n\nVM是数据的唯一操作者。它维护表和索引树中的记录。这两者的记录格式很相似。SQLite使用一个可变长度的记录格式。它使用清单类型来表示记录中的单个值。这个清单类型是指，每一个数据的存储类型信息都被存在记录中了。此方案允许在任何列中存储任何存储类型的值，而与该列的声明的SQL类型无关，但有一个例外，即整数主键列仅存储整数值。值的存储类型被编码为整数，并且该整数还编码该值的（字节）长度。每个表记录均以头部大小（即可变长度的霍夫曼代码）开头，然后是数据值的清单类型，然后是各个数据值。\n\n数据类型管理在SQLite中有点复杂。SQLite根据声明的SQL类型为列分配关联类型。首先尝试将输入数据值转换为关联类型。如果转换失败，则原始值仍将存储在该列中。 SQLite进行类似的数据转换来评估表达式和函数。","slug":"18.db-system-design-imp(VM)","published":1,"updated":"2022-07-28T13:38:40.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwo90013p9c9f6rn3w43","content":"<p>本文讨论了SQLite虚拟机（VM）是如何解释执行了一个通过SQLite内部的字节码语言编写的程序。VM是存储在本地数据库文件中数据唯一的操作者。它支持5种原始的数据类型:NULL,integer,real,character string,blob,这五种数据类型代表了在文件或者内存中存储的原始的数据项。由VM来完成用户数据和内部数据表示之间的转换。在做表达式评估的时候它也会做一些数据类型转换。VM是如何工作的，以及它在存储表和索引记录到B-，B+树之前，如何做数据格式化。</p>\n<span id=\"more\"></span>\n\n<p><strong>本文目标</strong></p>\n<ul>\n<li>5种数据类型和它们代表的含义</li>\n<li>一个编译好的SQL语句的内部表述</li>\n<li>在SQL类型和C类型之间是如何做转换的</li>\n<li>表记录和索引记录的逻辑结构</li>\n<li>清单类型在编码数据值中的优势</li>\n</ul>\n<h1 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h1><p>后端最顶层的模块在SQLite术语中通常被称之为虚拟数据库引擎，或虚拟机（VM）。VM是SQLite的核心，并且是前端和后端之间的接口。一些核心信息(计算和逻辑)只会在VM中处理，因为下层模块就存储的信息而言是被动的。它在原生的操作系统上层实现了一个抽象的虚拟的机器，并且它可以执行用SQLite内部的字节码程序语言编写的程序。这个程序语言是特地设计用来搜索，读取和修改数据库的。VM接受由前端生成的字节码程序，并且执行这个程序。VM使用B+树提供的”基础能力”来执行字节码程序，并且输出程序的执行结果。</p>\n<p>SQLite开发团队认为VM的使用对于这个库的开发和调试有巨大的好处。VM在前端（解析SQL语句并生成VM应用程序的部分）和后端（执行字节码应用程序并计算结果的部分）之间扮演了一个粘合剂的角色。字节码程序比解释集成数据对象的复杂网格更易于阅读。虚拟机还可以帮助SQLite引擎开发人员清楚地了解引擎正在尝试对其所编译的每个SQL语句执行的操作。</p>\n<p><strong>字节码执行跟踪</strong>:对于人类来说，读取字节码程序比解释数据结构值更容易。它还具有跟踪每个VM应用程序的程序执行的能力–打印每个字节码指令以及随着执行的进展而生成的结果。这个取决于SQLite源代码的编译方式。</p>\n<p>一个字节码应用程序在内存中由一个<code>sqlite3_stmt</code>对象表示(内部称为Vdbe)。以下SQLite API 可以用在这个对象上，从而实现把某个输入的值关联到SQL参数上，或者执行字节码程序，或者检索程序执行产生的输出。</p>\n<ol>\n<li>sqlite3_bind_*:这系列方法会指派值给SQL参数，并且作为字节码程序的输入。</li>\n<li>sqlite3_step:它会让字节码程序执行推进到下一个断点，或者到一个终止点。</li>\n<li>sqlite3_reset:它让程序执行倒退到起点，并且使得同一个程序可以准备进行二次执行。</li>\n<li>sqlite3_column_*:这系列方法会从程序产生的当前输出行中逐列提取结果。</li>\n<li>sqlite3_finalize:它会销毁sqlite3_stmt对象和字节码程序</li>\n</ol>\n<p>Vdbe对象（又称预处理语句）的内部状态包括以下内容：</p>\n<ul>\n<li>一个字节码程序</li>\n<li>所有结果列的名字和数据类型</li>\n<li>绑定到输出参数的值</li>\n<li>一个程序计数器</li>\n<li>任意数量的“编号”存储单元（称为寄存器位置）</li>\n<li>其他运行时的状态信息(例如一个打开的BTree对象，集合，列表，排序器…)</li>\n</ul>\n<p>VM不会做任何查询优化操作。它会无条件地执行字节码程序。这样，它可以按需将数据从一个格式转换为另一个格式。即时的数据转换，是VM的主要任务。所有事情都会在它所执行的字节码程序的控制之下。本文主要介绍数据转换和操作任务。在此之前，下一部分概述字节码编程语言，字节码程序和程序执行逻辑。</p>\n<h2 id=\"字节码编程语言\"><a href=\"#字节码编程语言\" class=\"headerlink\" title=\"字节码编程语言\"></a>字节码编程语言</h2><p>SQLite定义了一种内部编程语言来准备字节码程序。该语言类似于物理和虚拟机（例如Java以及使用的字节码）使用的汇编语言：它定义了字节码指令。每个字节码指令执行少量信息处理工作或做出逻辑决策。而一个字节码程序则包含了一个线性的字节码指令序列。一个字节码指令可以最多有5个操作数，&lt;opcode,P1,P2,P3,P4,P5&gt;,opcode定义了一系列的字节码操作，而P1,P2,P3,P4,P5则是当前操作的操作数或者操作数对应的寄存器。前三个操作数都是一个32位的有符号整数。如果当前操作触发了一个跳转，那么P2就一定是一个目标地址。P4是一个32&#x2F;64为的有符号整数，或者是64位的浮点小数，或者是一个指向具有终止符的字符串，字节块，一个归类的比较方法，一个SQL方法，等等。P5操作数是一个无符号的字符。这5个操作数不是左右的操作符都会使用的。</p>\n<p><strong>注意</strong><br>操作码是VM操作的内部名称，不属于SQLite的接口定义。总之，它们的含义可能会由于版本的更新而更新。SQLite的开发团队不鼓励SQLite的用户来直接编写字节码。字节码编程语言仅供内部使用。</p>\n<p>下面的表格展示了一个典型的字节码程序。这个字节码程序等价于<code>SELECT * FROM t1</code>。这个表格有x,y两列。字节码程序从0号指令开始执行，一直执行到一个终止指令或者超出了最后一条指令。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/06/UOiFYp.png\"></p>\n<h3 id=\"字节码指令\"><a href=\"#字节码指令\" class=\"headerlink\" title=\"字节码指令\"></a>字节码指令</h3><p>大概一共有142个操作码。操作码可以分为5类：1.计算和逻辑。2.数据移动。3.控制流。4.B-和B+树相关。5.专门的类型。第一类操作码包含 加, 减, 乘, 除, 求余, 位或, 位与, 二进制反码, 二进制补码, 右移动, 左移 和 字符串连接。第二类操作码在内存单元之间移动值。第三类操作码包含goto , gosub, return , halt 和 条件转移。第四类操作码包含(i) 创建, 销毁, 和 清空 B&#x2F; B+树, (ii) 打开 和 关闭 B&#x2F;B+ 树上的游标, (iii) 向前 和 向后移动游标 或 移动到指定的key, (iv)光标移动的分支,(v)插入, 删除 B&#x2F;B+ 树的记录,(vi)开始, 提交 和 回滚 事务。第五类操作码包含(a)获取一个不在使用的rowid,(b)组合n个内存元素为一个记录，(c)从一个表行中提取第i个列的数据，等等。</p>\n<p>每一个字节码指令在内部都由一个VdbeOp对象表示。这是一个比较简单的对象，它有以下成员：(1)opcode，表明需要执行的操作，(2)(3)(4)(5)(6)p1-p5持有5个操作数。(7)p4type表明了p4操作数的数据类型。p4有13个类型。一个虚拟机应用程序实际上是一个VdbeOp对象的线性集合。</p>\n<p>下面展示了一些操作码的含义。最新SQLite版本的操作码都在<a href=\"http://www.sqlite.org/opcode.html\">SQLite官方网站</a>找到。在SQLite源码中，每一个操作码的名字都由OP_开头，并且都分配了不同的整数。</p>\n<ol>\n<li>Trace: 这个操作码检查了SQLite库是否开启了tracing mode。如果开启了，那么在每次跟踪回调的时候都会输出P4的内容(一个UTF8字符串)。你可以使用<code>sqlite3_trace</code>API方法开启跟踪。</li>\n<li>Goto: 无条件跳转到P2所指定的地址。VM执行的下一条指令将是距程序开始偏移为P2的指令。</li>\n<li>OpenRead: 打开一个B&#x2F;B+树的只读的游标。这个树的root page由P2指定。（如果P5不为0，那么就是寄存器P2包含了这个page号，而不是P2的内容）数据库文件由P3操作数指定–0表示主数据库，1表示临时数据库，大于1表示附加连接的数据库。P1操作数(一个非负的整数)将会是新的游标的标识。P4的值是一个整数或者一个指向KeyInfo结构体的指针。如果光标在B树（SQL索引）上打开，则KeyInfo结构定义了 内容和排序 的顺序。如果P4是一个整型的值，则代表了表列的数量。</li>\n</ol>\n<p>如果在只读游标打开的时候，数据库没有上锁，那么在这个指令指向的时候，会请求一个共享锁。如果它无法获取一个共享锁，虚拟机会终止字节码的执行，并且返回一个SQLITE_BUSY错误码。（这个可以看后端的实现逻辑）<br>4. Rewind：重置游标P1。这个游标将会指向表或者索引的第一项，对应树中最小的一项。如果树是空的，并且P2 &gt; 0,那么就会立刻跳转到P2对应的地址。否则，遵循以下说明。<br>5. Column: 获取P1游标指向的记录中，P2对应的列的值。(这里会把P1指向的记录解析为一个数据结构，而这个数据结构是由MakeRecord指令构建的，可以看下面的MakeRecord指令)，如果记录中的字段个数少于P2个，那么提取的值就会变成NULL；如果P4的数据类型是一个P4_MEM,那么就会使用P4的值作为结果。返回的值会存储在P3寄存器内。<br>6. MakeRecord：将从寄存器P1开始的P2个寄存器合并转换为一个可以用作数据库表中的记录项，或者转换为一个索引的key。也就是说P1包含了第一个数据项目，P1+1是第二个数据项目，以此类推。<br>7. ResultRow: 寄存器P1到P1+P2-1包含一个单行记录。在上层应用执行<code>sqlite_step</code>方法的时候这个指令就会执行。并且这个方法执行返回SQLITE_ROW。<br>8. Next: 推进P1游标，这样它就可以指向树上的下一项。如果树上面没有下一项了，那么就会遵循以下说明。否则就会立刻跳转到P2地址。<br>9. Close: 关闭先前打开的P1游标。如果P1游标没有打开，那么这个指令就无操作。<br>10. Halt: 在关闭所有已打开的游标、FIFOs（又名RowSet对象）后立刻退出。P1是<code>sqlite3_exec</code>,<code>sqlite3_reset</code>,<code>sqlite3_finalize</code>三个API返回的结果值。对于通常的结束来说，返回的结果值都是SQLITE_OK(&#x3D;0)。如果出现了错误，那么这个错误码就是其他值了。如果P1!&#x3D;0，那么P2就决定了当前的事务是否需要做一个回滚。当P2&#x3D;OE_Fail的时候就无需回滚；当P2&#x3D;OE_Rollback的时候就需要回滚；当P2&#x3D;OE_Abort的时候，撤消此执行过程中发生的所有更改，但不回滚事务。P4指向的是一个错误信息。</p>\n<p><code>Halt 0 0 0 0 0</code>是一个默认的终止指令，会被插入到每一个字节码程序的最后面。因此，跳过程序的最后一条指令与执行终止指令是一样的。<br>11. Transaction: 开启一个新的事务。P1是标识了开启事务的数据库文件类型。0代表主数据库文件，1代表临时数据库，大于1的时候代表附加连接的数据库。如果P2是0，表示数据库文件上会获取一个共享读锁。如果P2非零，就会开始一个写事务，数据库上会获取一个保留锁。如果P2是2或者更大，那么就会获取一个排它锁。开启写事务的时候也需要创建一个回滚文件。<br>12. VerifyCookie: 检查全局数据库参数号0的值(schema版本的cookie)，并且保证这个值和P2的值是一致的，并且在本地模式解析中的迭代计数器和P3的值是一致的(?)。P1是标识了数据库文件类型与上面一致。（你可以回想一下，每当数据库模式更改时，cookie值都会更改）这个验证的操作是用来检测，当cookie发生便跟的时候，当前的进程需要重新去读取schema。在执行此操作码之前，要么需要启动事务，要么需要执行OpenRead &#x2F; Open Write（至少在数据库上建立共享锁）。<br>13. TableLock: 在数据库P1上获取根page为P2的表的锁。如果P3为0，那么加读锁，如果P3为1，加写锁。P4包含了一个指向这个表名的指针。</p>\n<p>在下面两个小节中，将会表述SQL insert 和join处理的VM执行逻辑。这样可以给出更加清晰的描述来显示如何为一个SQL语句生成一个字节码程序的。</p>\n<h3 id=\"插入逻辑\"><a href=\"#插入逻辑\" class=\"headerlink\" title=\"插入逻辑\"></a>插入逻辑</h3><p>假设，有一个包含两列的表T1。这两列分别是c1 text和c2 integer;这个表没有任何的索引。如果你执行<code>insert into T1 values(&#39;Hello,Wold!&#39;, 2000)</code>的语句，VM会根据下面的算法步骤来执行:</p>\n<ol>\n<li>在主数据库上打开一个写事务。</li>\n<li>检查数据库的schema版本，保证在这个语句的字节码生成期间没有被别人修改过。</li>\n<li>在表”T1”的B+树上，打开一个写游标。</li>\n<li>创建一个新的rowid，并且将’Hello,Wold!’和2000合并创建一个记录项。</li>\n<li>通过打开的游标，将这个记录项插入到B+树中。</li>\n<li>关闭游标。</li>\n<li>给调用者返回执行结果。</li>\n</ol>\n<p>如果在T1上还有索引，在第三步的时候，VM会在每一个索引表上打开一个写游标，并且分别在第四步和第五步的时候准备和插入一个记录项。</p>\n<h3 id=\"连接逻辑\"><a href=\"#连接逻辑\" class=\"headerlink\" title=\"连接逻辑\"></a>连接逻辑</h3><p>在连接操作中，会合并两个或者多个表来创建一个结果表。结果表包含要连接的表中所有可能的行组合。实现连接的最简单，最自然的方法是使用嵌套循环。SQLite仅执行循环联接，而不执行合并联接。在FROM语句中的最左侧的表构成最外侧的循环，最右侧的表构成了最内侧的循环。</p>\n<p>考虑以下SQL 查询语句: <code>select * from t1, t2 where ...</code>，假设这两个表上都没有索引。那么这个查询语句的伪代码，就类似于下面这样。</p>\n<ol>\n<li>在主数据库上打开一个读事务。</li>\n<li>同样的检查schema版本。</li>\n<li>打开两个游标，一个是T1的，一个是t2的。</li>\n<li><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> each record in T1, <span class=\"keyword\">do</span>:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each record in T2, <span class=\"keyword\">do</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> WHERE语句为TRUE</span><br><span class=\"line\">            计算当前行的所有结果列</span><br><span class=\"line\">            为当前结果行调用默认回调函数的</span><br><span class=\"line\">            </span><br></pre></td></tr></table></figure></li>\n<li>关闭两个游标。</li>\n</ol>\n<h3 id=\"程序的执行\"><a href=\"#程序的执行\" class=\"headerlink\" title=\"程序的执行\"></a>程序的执行</h3><p>VM从序号为0的指令开始执行一个字节码程序，直到它(1)处理一个停止指令或者(2)遇到一个错误，或者(2)程序计数器超过了最后一条指令。当程序终止的时候，它会释放所有已经分配的内存，并且关闭所有打开的游标。如果执行因为错误而终止了，后续的事务就会终止，并且回滚引起的数据库变更。</p>\n<p>下面用C语言给出了这个VM解释器的结构。解释器（带Vdbe对象指针的sqlite3VdbeExec函数）是一个简单的for循环，其中包含了一个大量case的Switch语句。每一个case的语句实现了一个字节码指令（在源代码中，操作码名称以OP_prefix开头。操作码名称的数字值不是静态编号的。它们是在SQLite源代码编译时分配的。数字可能因一个SQLite版本而异。）在每一次迭代中，VM从程序中拉取下一次的字节码指令。例如：从aOp数组中以pc作为下标(这两个都是Vdbe对象的成员变量)索引获取下一个字节码指令。它会解码并执行指令指定的操作。一般来说，程序的执行会从一个字节码执行到下一个(pc++)，但是pc可以由跳转指令变更。这个for循环会一直执行，一直到VM处理了一个终止指令或者循环的条件不成立了(也就是pc计数超过了指令个数)，那么我们就说字节码程序已经终止了。这个是一个正常的终止。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (; pc &lt; nOp &amp;&amp; rc == SQLITE_OK; pc++)&#123; </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (aOp[pc].opcode)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Add:</span><br><span class=\"line\">        <span class=\"comment\">/* Implementation of the ADD operation here */</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Goto:</span><br><span class=\"line\">        pc = op[pc].p2<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Halt:</span><br><span class=\"line\">        pc = nOp;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* other cases for other opcodes */</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>sqlite3_prepare</code>API方法返回了<code>sqlite3_stmt</code>对象指针。而这个对象实际上指向的是Vbe对象(它代表了虚拟数据库引擎)。这个对象包含了完整的VM状态。下面展示了这个对象的一些组件。<code>aOp</code>数组包含了所有的操作码。这个程序执行需要的所有内存均位于大小为<code>nMem</code>的<code>aMem</code>数组中。</p>\n<table>\n<thead>\n<tr>\n<th>成员变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>db</td>\n<td>sqlite3数据库连接对象</td>\n</tr>\n<tr>\n<td>aOp</td>\n<td>VM程序</td>\n</tr>\n<tr>\n<td>nOp</td>\n<td>aOp的数量</td>\n</tr>\n<tr>\n<td>apCsr</td>\n<td>打开的游标数组</td>\n</tr>\n<tr>\n<td>nCursor</td>\n<td>apCsr的大小</td>\n</tr>\n<tr>\n<td>aMem</td>\n<td>程序执行需要的内存</td>\n</tr>\n<tr>\n<td>nMem</td>\n<td>aMem的大小</td>\n</tr>\n<tr>\n<td>rc</td>\n<td>需要返回的值</td>\n</tr>\n<tr>\n<td>pc</td>\n<td>程序计数器</td>\n</tr>\n<tr>\n<td>…</td>\n<td>其他变量</td>\n</tr>\n</tbody></table>\n<p>VM使用游标来访问数据库(这些游标和在Tree模块使用的<code>BtCursors</code>不一样)。在数据库上可能有几个已经打开游标的数据库。每一个游标都是指向数据库中表和索引的树。游标可以通过一个key指向到任何一个项或者遍历树中的所有项。VM可以在游标指向的当前项创建新的或者检索key&#x2F;value值，或者删除项。</p>\n<p>在同一个索引或者表的树上可以同时有多个游标。尽管在同一个索引或者表上可以有多个游标，但是它们都是独立操作的。在VM中，一个VdbeCursor对象代表了一个打开的游标。下面的表格展示了VdbeCursor的结构体。字节码程序的质量可以创建一个新的游标（通过操作码OP_OpenRead或者OP_OpenWrite），从游标中读取数据（通过操作码OP_Column），然后在表或者树上推进游标到下一项（通过操作码OP_Next）以及其他的一些操作。在VM终止执行字节码程序的时候，所有的游标都会自动关闭。</p>\n<table>\n<thead>\n<tr>\n<th>成员变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pCursor</td>\n<td>后端的(BtCursor)游标结构体</td>\n</tr>\n<tr>\n<td>iDb</td>\n<td>游标所在的数据库</td>\n</tr>\n<tr>\n<td>pBt</td>\n<td>这个游标的临时文件的临时表</td>\n</tr>\n<tr>\n<td>pKeyInfo</td>\n<td>索引表的游标需要索引的key的一些信息</td>\n</tr>\n<tr>\n<td>aType</td>\n<td>在记录里所有项的类型值</td>\n</tr>\n<tr>\n<td>aOffset</td>\n<td>每一列数据缓存的从起始点开始的偏移</td>\n</tr>\n<tr>\n<td>aRow</td>\n<td>当前行的数据(如果所有的数据都在一页page内)</td>\n</tr>\n<tr>\n<td>…</td>\n<td>其他变量</td>\n</tr>\n</tbody></table>\n<h2 id=\"内部的数据类型\"><a href=\"#内部的数据类型\" class=\"headerlink\" title=\"内部的数据类型\"></a>内部的数据类型</h2><p>VM使用任意数量的编号内存位置来保存所有中间结果。每一个内存地址存储了一个数据值。VM处理的每个值是一下五种数据类型之一:</p>\n<ol>\n<li>INTEGER: 一个有符号的整型数字；</li>\n<li>REAL: 一个有符号的浮点型数字；</li>\n<li>TEXT: 一个字符串值；</li>\n<li>BLOB: 一个字节块；</li>\n<li>NULL: 一个SQL NULL值；</li>\n</ol>\n<p>VM只支持5种原始的数据类型。这个类型决定了一个数据在实际物理存储的时候应该如何表示。每一个存储在内存或者本地数据库文件中的数据类型都必须是这几种数据类型之一。有些值可能具有多种数据类型。举个例子，123可以是一个整型，一个浮点型，也可以是一个字符串。BLOB和NULL的值没有多种含义。在必要的情况下，SQLite会做一些数据转换。你可以使用SQLite内置的方法<code>typeof</code>来获取一个值的类型–<code>select a,typeof(a) from t1</code>将会返回a字段的值以及他们对应的存储类型。在使用<code>sqlite3_step</code>方法返回一行记录的时候，API<code>sqlite3_column_type</code>会返回某列字段值的存储类型。</p>\n<p>在VM内部，所有的操作对象几乎都是Mem对象。每一个Mem对象可能会缓存数据的多个存储类型。而一个值(也就是Mem对象)有如下的属性: 每个值恰好是以上提到的五种存储类型之一。(每个Vbe.aMem数组元素就是一个aMem对象。)</p>\n<table>\n<thead>\n<tr>\n<th>成员</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>type</td>\n<td>这个Mem对象锁代表的值的类型</td>\n</tr>\n<tr>\n<td>i</td>\n<td>整型值</td>\n</tr>\n<tr>\n<td>r</td>\n<td>浮点型值</td>\n</tr>\n<tr>\n<td>z</td>\n<td>字符串或者字节块值</td>\n</tr>\n<tr>\n<td>n</td>\n<td>z的大小</td>\n</tr>\n<tr>\n<td>enc</td>\n<td>如果z是一个字符串的话，这个字符串的UTF编码类型</td>\n</tr>\n<tr>\n<td>…</td>\n<td>其他变量</td>\n</tr>\n</tbody></table>\n<h2 id=\"记录格式\"><a href=\"#记录格式\" class=\"headerlink\" title=\"记录格式\"></a>记录格式</h2><p>VM会把数据组合为一条记录存储在他们对应的B树或者B+树内。每一个记录都包含key和一个可选的value。VM仅负责维护键和值的内部结构(尽管，Tree模块可能会把一条记录拆分为叶子节点，内部节点或者多个溢出页，VM把整条记录视为一个连续的字节串)。VM使用了两个相似但是也略有不同的结构来描述表和索引记录。</p>\n<p>有两种格式来格式化data&#x2F;key记录：固定长度和可变长度。对于固定的长度来说，对于表或者索引的所有记录都是使用了相同大小的空间；在表或者索引的创建的时候就已经知道每一个字段的大小了。对于可变长度的格式来说，每一个字段的空间大小可能根据不同的记录而不一样。SQLite使用可变的变量长度来格式化记录，因为它有几个优势。数据库因为没有空间的浪费而变得更小。同样也会让整个系统跑得更快，因为在内存和磁盘之间需要同步的bytes数量更小。另外，使用可变长度的记录可以允许SQLite可以使用清单类型而不是静态类型。接下来两节先讨论一下这个清单类型。</p>\n<h3 id=\"清单类型\"><a href=\"#清单类型\" class=\"headerlink\" title=\"清单类型\"></a>清单类型</h3><p>不论是存储在内存中还是在文件中，每一个原始的数据都有一个数据类型与之关联。这个数据类型称之为存储类型。大部分SQL数据库使用静态类型:一个表内的每列关联了一个数据类型，并且只允许存储每列关联的数据类型。这样非常死板，也有它自己的优缺点。SQLite通过使用清单类型解除了这一个限制。在这个方法下，数据的类型是数据本身的一个属性，而不是数据存储列的。这样，每一列就允许你存储任何变量，任何类型的数据，并且不会丢失这个数据的类型。SQLite会将数据的类型作为数据的一部分存储。它允许你在列内存储任何类型的数据，而不用关心每一列声明的数据类型。(在这里有一个例外，就是一个声明了<code>integer primary key</code>的列只能存储[-2^63, 2^63-1]的整型值)。</p>\n<h3 id=\"类型编码\"><a href=\"#类型编码\" class=\"headerlink\" title=\"类型编码\"></a>类型编码</h3><p>存储类型会被编码为整型。这个整型值的编码关系在下表给出了。这种编码的好处在于类型编码也会包含数据长度。NULL类型代表了SQL NULL类型。对于INTEGER类型，数据的值是一个有符号的整型数字，由(1,2,3,4,6或8个字节)组成。具体的长度取决于值的大小。对于REAL类型，数据值是一个浮点小数，根据IEEE的浮点数标准，存储在8个字节内。8，9两个数据类型，分别代表了整型常量0和1.对于TEXT类型，数据值就是一个文本字符串，使用默认编码(UTF-8, UTF-16BE, or UTF-16-LE)格式存储文本。对于后两者来说，字节顺序分别是大端或者小端。（每个数据库文件只会用一种UTF编码）对于BLOB类型，数据值是一个字节流，完全和用户输入的字节流一致。</p>\n<p>**布尔值:**布尔值就使用8，9两个常量类型来表述。</p>\n<table>\n<thead>\n<tr>\n<th>类型值</th>\n<th>含义</th>\n<th>数据长度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>NULL</td>\n<td>0</td>\n</tr>\n<tr>\n<td>N in {1..4}</td>\n<td>有符号整数</td>\n<td>N</td>\n</tr>\n<tr>\n<td>5</td>\n<td>有符号整数</td>\n<td>6</td>\n</tr>\n<tr>\n<td>6</td>\n<td>有符号整数</td>\n<td>8</td>\n</tr>\n<tr>\n<td>7</td>\n<td>IEEE 浮点</td>\n<td>8</td>\n</tr>\n<tr>\n<td>8</td>\n<td>常数 0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>9</td>\n<td>常数 1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>10、11</td>\n<td>扩展保留</td>\n<td>N&#x2F;A</td>\n</tr>\n<tr>\n<td>N&gt;&#x3D;12 偶数</td>\n<td>字节流</td>\n<td>(N-12)&#x2F;2</td>\n</tr>\n<tr>\n<td>N&gt;&#x3D;12 奇数</td>\n<td>纯文本</td>\n<td>(N-13)&#x2F;2</td>\n</tr>\n</tbody></table>\n<h3 id=\"表记录格式\"><a href=\"#表记录格式\" class=\"headerlink\" title=\"表记录格式\"></a>表记录格式</h3><p>下表中描述了一个表记录的格式。由两部分组成：头部和记录内容。头部由一个size字段开始，后面跟着字段的类型。头部后面跟着记录的数据项。(SQLite不会修改在创建语句中声明的字段顺序。建议表结构的设计者在设计早期，把小而使用频率高的列放在记录中，从而尽可能避免触发溢出的规则。)</p>\n<table>\n<tr>\n        <th style=\"color:grey\" colspan=\"5\">头部</th>\n        <th style=\"color:grey\" colspan=\"4\">记录内容</th>\n    </tr>\n    <tr>\n        <th>Header size</th>\n        <th>Type 1</th>\n        <th>Type 2</th>\n        <th>...</th>\n        <th>Type N</th>\n        <th>Data 1</th>\n        <th>Data 2</th>\n        <th>...</th>\n        <th>Data N</th>\n    </tr>\n</table>\n\n<p>Header size是Data1之前的字节数。这个大小是一个哈夫曼编码的64位的可变长度的integer值，并且它包含了它自身所占用的大小。这个大小也可以被用作Data1项的指针。在header size大小之后紧跟着的是数据类型字段，每一个数据值都按照它在字段中出现的顺序排列。每一个类型字段Type i是一个可变长的无符号整型（最大是2^64），对应编码了数据字段Data i的存储类型。</p>\n<p>**零长度的数据:**对于类型值为0，8，9，12和13来说，数据的长度是0，因此数据不会存储在记录中。</p>\n<h3 id=\"表key的格式\"><a href=\"#表key的格式\" class=\"headerlink\" title=\"表key的格式\"></a>表key的格式</h3><p>在SQLite中，每一个B+-Tree必须有一个唯一的key。尽管一个定义好的关系型表不包含相同的行，但是实际上用户是可以在关系表中存储重复的行的。但是数据库系统必须有办法来区分这些相同的行。该系统必须能够关联其他信息以实现差异化目的。这也就意味着，系统需要为这个关系提供一个新的唯一的属性。因此，在内部，每个表都有唯一的主键，并且该键由表的创建者或SQLite来定义。主键是一个名为rowid的整型值。</p>\n<h4 id=\"Rowid列\"><a href=\"#Rowid列\" class=\"headerlink\" title=\"Rowid列\"></a>Rowid列</h4><p>在每一个SQL表里，SQLite会指定一列作为rowid(也称为oid或_rowid_)。这一列中的值在表内的每一行都是唯一定义的。这列将会是表的隐式主键，也是表B+树的唯一搜索关键字。如果表内的任何一列被声明为 integer primary key，那么这列就会被当做这个表的rowid（作为别名）。否则的话，SQLite会创建一个独立的名为rowid作为唯一主键列。(如果表中已经存在了相同的这三个名字(rowid,oid,<em>rowid</em>),那么名称将引用这些列，而不是内部rowid列)因此，每一个表不论是否声明了 integer primary key列，都有一个唯一的整型key，命名为rowid。对于后一种情况，rowid本身在内部被视为表的整数主键。无论哪种情况，rowid都是[-2^63, 2^63-1]范围内的有符号整数值(在编译器有宏可以限制这个rowid为32位)。在表的B+树上的排序顺序是按照整型的大小，并且无法用其他的排序顺序。这些B+树是表的主要索引。rowid作为表B+树的逆向指针存储在二级索引里。</p>\n<h4 id=\"Rowid值\"><a href=\"#Rowid值\" class=\"headerlink\" title=\"Rowid值\"></a>Rowid值</h4><p>如果rowid是一个别名列(例如声明了INTEGER PRIMARY KEY),数据库的使用者是知道这个列的。如果SQLite插入了一列rowid，那么他们是不知道这列的存在的。无论哪种情况，用户都可以定义rowid值，或者SQLite可以为用户定义值。它保证了他们的唯一性。当有一条记录插入到表中而没有指定rowid值的时候，SQLite会访问B+树，为rowid获取到一个未使用的整型数字。通常来说，这个值都是比表格内最大的值要大。但是，如果已经到了最大值，那么SQLite就随机选一个未使用的值。如果找不到，那么就会返回SQLITE_FULL错误码。</p>\n<h4 id=\"Rowid的含义\"><a href=\"#Rowid的含义\" class=\"headerlink\" title=\"Rowid的含义\"></a>Rowid的含义</h4><p>Rowid的含义取决于是谁创建的。如果rowid列是由SQLite创建的，那么表记录中就不包含它。否则，将在每个表记录中存储一个NULL（类型值0）。SQLite通过key来获取到真正的值。这个值是可变长的哈夫曼编码。可以允许负值的rowid，但是这样的话，它们就会占据9个字节，所以不鼓励这样做。如果rowid是由SQLite生成的，那么它们一定不会是负数，尽管你可以指定一个负整数。</p>\n<h3 id=\"索引key的格式\"><a href=\"#索引key的格式\" class=\"headerlink\" title=\"索引key的格式\"></a>索引key的格式</h3><p>在前两节中你可以看到，每一个表的B+树都是一个整型key，然后这个表格的一行就是一个数据记录。索引与之相反。对于一个索引项，key是存储在索引表内的一行所有索引列值的一个组合。而数据才是这一行的rowid。为了通过一个索引列的指定数据来访问某一行，VM首先搜索索引表来找到对应的rowid，然后使用这个整型来找到表B+树内完整的记录。尽管许多人认为通过主键来指向每一行，开销太大，但是SQLite简单起见。</p>\n<p>SQLite通过创建一个存储在一个单独的B树内的单独的’索引表’来实现表内的每一个索引。每一个索引B树映射了搜索的关键字和rowid。索引B树有自己的关键字比较器，来排序索引项。VM会提供给Tree模块一个合适的关键字比较函数指针。</p>\n<p>SQLite会为create语句中的每一个<code>UNIQUE</code>唯一列创建一个索引，包括<code>PRIMARY KEY</code>列。你不能单独删除这些索引。你可以在一个非目录表上使用<code>CREATE INDEX</code>为指定列创建索引。你也可以单独删除这些索引。当一个表被删除的时候，这个表对应的所有的索引都被删除了。还有一些其他方法在SQLite中创建索引。以下是在表T1(a,b,c)上的a,b列创建索引的例子。</p>\n<ol>\n<li>直接声明创建索引</li>\n</ol>\n<ul>\n<li><code>CREATE TABLE T1(a,b,c)</code></li>\n<li><code>CREATE INDEX idx1 ON T1(a,b)</code></li>\n</ul>\n<ol start=\"2\">\n<li>声明列唯一</li>\n</ol>\n<ul>\n<li><code>CREATE TABLE T1(a,b,c,UNIQUE(a,b))</code></li>\n</ul>\n<ol start=\"3\">\n<li>声明列为主键</li>\n</ol>\n<ul>\n<li><code>CREATE TABLE T1(a,b,c,PRIMARY KEY(a,b))</code></li>\n</ul>\n<p><strong>注意:</strong><code>INTEGER PRIMARY KEY</code>比较特殊，它不会生成一个单独的索引。表的B+树由这个别名为rowid的列来排序。</p>\n<p>SQLite可以在一列上同时创建多个索引，思考一下下面这个例子<br><code>CREATE TABLE T2(x VARCHAR(5) UNIQUE PRIMARY KEY , y BLOB);</code><br><code>CREATE INDEX idx2 ON T2(x);</code></p>\n<p>上面的例子中，SQLite在x列上创建了三个索引，一个是<code>PRIMARY KEY</code>,一个是<code>UNIQUE</code>，一个是指定创建的索引。索引会减慢<code>INSERT</code>,<code>UPDATE</code>和<code>DELETE</code>的执行，并且加大了数据库文件的大小。</p>\n<table>\n<thead>\n<tr>\n<th>Header size</th>\n<th>Type 1</th>\n<th>Type 2</th>\n<th>···</th>\n<th>Data1</th>\n<th>Data2</th>\n<th>rowid</th>\n</tr>\n</thead>\n</table>\n<p>正如上面提及的，SQLite会把索引当做一个表，然后在它自己的B树中存储。它把关键字隐射到了rowid上。下面描述了一个索引记录的格式。整个记录都当做了B-Tree的key；没有数据部分。索引记录的编码和数据表的记录的一样，除了后面跟了一个rowid，并且rowid的数据类型，没有在记录头部显式声明。因为rowid的类型只能是有符号整数并且是用哈夫曼编码表示的（不是内部的整型类型）。（其它数据的值和数据的存储类型都从索引表内拷贝）在x列上的内容索引，如下所示.</p>\n<table>\n<thead>\n<tr>\n<th>x</th>\n<th>rowid</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NULL</td>\n<td>54321</td>\n</tr>\n<tr>\n<td>456</td>\n<td>2</td>\n</tr>\n<tr>\n<td>abc</td>\n<td>-5</td>\n</tr>\n<tr>\n<td>abc</td>\n<td>1</td>\n</tr>\n<tr>\n<td>hello</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>索引主要是用来加速数据库搜索的。两次B+树搜索时间一般都会远小于一个全表扫描搜索。</p>\n<p>**临时索引:**SQLite可以在执行SQL语句时使用order by或group by子句，或在聚合查询中进行except，或使用union或intersect进行复合选择，从而动态创建临时索引。临时索引会存储在临时文件中。</p>\n<h2 id=\"数据类型管理\"><a href=\"#数据类型管理\" class=\"headerlink\" title=\"数据类型管理\"></a>数据类型管理</h2><p>SQLite的数据处理是发生在VM模块的，这个模块驱动了后端在数据库中存储，检索数据。VM是数据库内存储的数据的唯一操作者；所有事情都是通过字节码的执行来控制的。它决定了在某个地方存储什么数据，以及在某个地方检索什么数据。给合适的数据分配合适的数据类型，并且做必要的数据转换都是VM的主要任务。有三个数据交换的地方可能会触发数据转换：从SQLite应用到引擎，从引擎到SQLite应用，从引擎到引擎。对于前两个情况，VM为用户数据分配数据类型，VM会尽可能将用户提供的数据转换为在列上声明的数据类型，反之亦然。对于后一种情况，表达式转换会引起数据转换。在下面三个小节中，我们讨论一下这三种数据转换。</p>\n<h3 id=\"指派类型给用户数据\"><a href=\"#指派类型给用户数据\" class=\"headerlink\" title=\"指派类型给用户数据\"></a>指派类型给用户数据</h3><p>之前已经讨论过表记录和索引记录的存储格式了。每一个记录的字段都有一个存储类型。应用层传递字段值给SQLite有两种方式:(1)嵌入在SQL语句中,(2)通过预处理绑定值。(VM也是通过执行表达式语句来分派字段值。)在VM执行预处理语句之前，它会给每一个输入的值分配一个存储类型。这个存储类型是用来将输入的数据编码为一个合适的屋里存储格式。</p>\n<p>VM通过三个步骤来决定一个输入值的存储类型：它首先确定输入数据的存储类型，然后确定列的声明的SQL类型，最后，如果需要，它再进行类型转换。在后面章节的讲述中，SQLite可能会在数字存储类型（INTEGER和REAL）与TEXT之间转换数据。(你可能注意到了，SQL标准里没有提供关于数据编码的指南，除了一些日期，时间和时间戳。)这些会在下面的章节中讨论。</p>\n<h4 id=\"决定存储类型\"><a href=\"#决定存储类型\" class=\"headerlink\" title=\"决定存储类型\"></a>决定存储类型</h4><p>SQLite是‘无类型’的，例如，没有预约束。(SQLite开发者团队希望一直是无类型的。)无类型允许在任何表里面存储任何数据类型，而不用在意那一列声明的是什么数据类型。(除了声明了INTEGER PRIMARY KEY的，这一列只能存储整型，其他类型的VM都会拒绝。)SQLite允许在创建语句中无SQL类型声明。例如<code>create table T1(a,b,c)</code>在SQLite中其实是一个有效的SQL语句。那现在的问题是，VM是如何在一个值存入指定列的时候为它分配具体的数据类型的呢？</p>\n<p>VM按照如下的步骤来给用户输入的数据分配一个初始化的存储类型。正如前面提到的，有两种方法给SQLite提供输入数据。</p>\n<ol>\n<li><p>如果一个值是嵌入SQL语句中提供的，那么会被指派为一下数据类型之一:</p>\n<ul>\n<li>如果值被单双引号包含，那么指派为TEXT</li>\n<li>如果值是不带小数点或指数的，不带引号的数字，那么指派为INTEGER</li>\n<li>如果值是带小数点或指数的不带引号的数字，那么指派为REAL</li>\n<li>如果值是字符串NULL，且周围没有引号，那么指派为NULL</li>\n<li>如果使用X’ABCD’标记指定值，那么指派为BLOB(ABCD是十六进制数字)</li>\n</ul>\n<p> 否则输入的值将会被VM拒绝，并且查询将会失败。</p>\n</li>\n<li><p><code>sqlite3_bind_*</code>API方法中提供的SQL参数值将会指派为与原生类型最接近的数据类型。例如，<code>sqlite3_bind_blob</code>绑定了一个存储类型为BLOB的值。</p>\n</li>\n</ol>\n<p>SQL标量运算符结果的值的存储类型取决于表达式的最外层运算符。用户定义的函数可以返回任何存储类型的值。通常在SQL语句的预处理阶段无法确定表达式结果的类型。VM在运行时一获取值就会分配存储类型。</p>\n<h4 id=\"决定列的相似关联性\"><a href=\"#决定列的相似关联性\" class=\"headerlink\" title=\"决定列的相似关联性\"></a>决定列的相似关联性</h4><p>SQLite允许在任何一列存储任一类型的数据。因此数据类型和数据值存在一起。其他SQL数据库引擎使用限制性更强的静态类型，其中类型与容器关联，而不与值关联。SQLite更具有灵活性。为了最大程度地提高SQLite与其他数据库引擎之间的兼容性，SQLite支持在列上使用类型相似性的概念。每一个输入的值可能具有SQL语句声明的类型的一个相关联的类型。对于该列中存储的值，建议使用列类型的相似类型：”建议使用，不是必需的”。</p>\n<p>某一个列优先使用的值的类型，称之为这个列的关联类型。列的关联类型和列的声明类型是不一样的，尽管前者还是由后者派生而来。每一个列有以下5种相似类型的其中一个:TEXT,NUMERIC,INTEGER,REAL和NONE。根据<code>CREATE TABLE</code>语句中声明的SQL类型，SQLite遵循以下的规则，来决定某个列的关联类型。</p>\n<ol>\n<li>如果SQL类型包含子字符串INT，则该列具有INTEGER关联。</li>\n<li>如果SQL类型包含任何子字符串CHAR，BLOB或TEXT，则该列具有TEXT关联性。 （SQL类型VARCHAR包含字符串CHAR，因此也具有TEXT关联性。）</li>\n<li>如果SQL类型包含子字符串BLOB，或者未指定类型，则列具有NONE关联。</li>\n<li>如果SQL类型包含任何子串REAL，FLOA或DOUB，则列具有REAL关联。</li>\n<li>除此之外, 列具有NUMERIC关联。</li>\n</ol>\n<p>VM会按照上面给出的顺序来评估这个规则。模式匹配不区分大小写。例如，如果声明的列的SQL类型为BLOBINT，则关联性为INTEGER，而不是NONE。</p>\n<p>**注意:**如果使用<code>create table table1 as select ...</code>语句创建了SQL表，每列的声明类型由create table语句的select部分中相应表达式的相关联类型确定。如果一个表达式的关联类型是text, numeric, integer, real, 或 none，那么声明的类型分别就是text, num, int, real, 或 “”。每个此类列的默认值为SQL NULL。隐式rowid的类型始终是整数，不能为NULL。</p>\n<h4 id=\"数据转换\"><a href=\"#数据转换\" class=\"headerlink\" title=\"数据转换\"></a>数据转换</h4><p>SQLite在关联类型和存储类型之间定义了一种关系。如果用户给某一列提供的数据不满足这个关系，那么这个值就会拒绝或者转换为一个合适的格式。当一个值即将被插入到一列的时候，VM首先会给这个值指派一个最合适的存储类型，然后来决定存入的这个列的关联类型，最后再尝试将这个初始的存储类型转换为这个列的关联类型。它会按照如下规则转换:</p>\n<ol>\n<li>具有TEXT关联关系的列可以存储所有NULL,TEXT,BLOB存储类型的数据。如果一个数字类型的(整型或者浮点型)被插入的时候，这个数字会被转换为文本类型，那么它的最终存储类型就会变成TEXT。</li>\n<li>一个具有NUMERIC关联类型的列可以存储所有的5种类型。当一个文本类型的数据插入到这一列的时候，VM会尝试把这个文本转换为整型或者浮点型。如果这个转换是成功的(无损且可逆)，那么这个转换的值就会相应的使用整型和浮点型的存储类型。如果这个转换无法执行的话，那么这个值就会以TEXT的存储类型来存储。VM不会尝试转换NULL或者BLOB值。</li>\n<li>一个具有INTEGER关联类型的列和上面的NUMERIC的行为一致，除了一种情况:当一个没有小数部分的浮点型值或者一个文本值，VM会把这个值转换为整型并且存储的最终存储类型为INTEGER。</li>\n<li>一个具有REAL关联类型的列和上面的NUMERIC的行为一致，除了一种情况:他会强制转换一个整型的值为一个浮点数。(但是，SQLite会做一个优化，只在磁盘上存储整数，等待读出数据的时候才会转换为浮点数)</li>\n<li>一个具有NONE关联类型的列可以存储所有的5种类型，并且不会转换任何类型。</li>\n</ol>\n<p>**注意:**所有的SQL数据库引擎都会转换数据类型。这些数据库都是类型强要求的，但SQLite可以是不是强要求的。举个例子，如果你有个表的列声明了SQL类型为整型的并且尝试插入一个字符串(“123”或”abc”),那么VM会分析这个字符串看看是否像一个数字。如果看起来像是一个数字，那么它就会被转换为一个数字(如果没有小数部分，会被转换为一个整型)。如果不是一个数字的格式，那么就会以TEXT的数据类型存储。一个具有TEXT关联类型的会尝试把输入数字以ASCII编码的形式存储。</p>\n<h4 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h4><p>从一个简单的例子来看存储类型，关联类型和类型转换。下面是一个典型的字段无类型的图表。假设你在这个表内执行了一个插入的语句。表格里也同样描述了插入到T1表B+树的记录。输入值(a,b,c)初始化的存储类型分别是整型，NULL和文本。所有列的关联类型都是NONE，并且VM不会转换初始化存储类型。在图里，这个记录(头+数据项)包含了11个字节。(记录里所有的数字都是以十六进制给出的。上面提及到SQLite不会重排序每列的位置:和创建语句中的顺序保持一致。)</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/07/KZKZlm.png\"></p>\n<ol>\n<li>头部有四个字节:第一个字节是头部的大小，加上三个字节分别是每一个值的类型。</li>\n<li>类型1的数字是2，代表2个字节的有符号整型。</li>\n<li>类型2的数字是0，代表NULL。</li>\n<li>类型3的数字是22，代表(22-12)&#x2F;2&#x3D;5个字节的字符串。</li>\n<li>数据1是2个字节的整型00B1,值是177。(一个字节是无法表示177的，因为B1的值是-79)</li>\n<li>数据2是NULL，不占据数据段的任何空间。</li>\n<li>数据3是5个字节的字符串 68 65 6C 6C 6F。忽略了终止符。</li>\n</ol>\n<h4 id=\"列关联性的例子\"><a href=\"#列关联性的例子\" class=\"headerlink\" title=\"列关联性的例子\"></a>列关联性的例子</h4><p>考虑下面的场景：有SQL语句<code>create table T1(t TEXT,n NUMERIC,i INTEGER, r REAL,b BLOB)</code>创建了一个表。假设执行如下的SQL语句：<code>insert into T1 values(&#39;1.0&#39;, &#39;1.0&#39;, &#39;1.0&#39;, &#39;1.0&#39;, &#39;1.0&#39;)</code>。所有值的初始化存储类型都是TEXT，因为他们都是有单引号的。基于之前给出的规则，列t,n,i,r,b的关联类型分别是TEXT，NUMERIC，INTEGER，REAL 和 NONE。那t,n,i,r,b几个列的最终的存储类型是TEXT，INTEGER，INTEGER，REAL 和 TEXT。对于NUMERIC关联类型，’1.0’看起来像是一个整型1，因此它的最终存储类型就是整型。而关联性为NONE的列不会做任何的数据类型转换，因此，依旧会把初始化类型存入。假设再执行<code>insert into T1 values(1.0, 1.0, 1.0, 1.0, 1.0)</code>。所有值的初始化存储类型都是REAL，并且最终的存储类型分别是TEXT，INTEGER，INTEGER，REAL 和 REAL。对于TEXT列，1.0会被转换为文本”1.0”作为TEXT存储类型。假设再执行<code>insert into T1 values(1, 1, 1, 1, 1)</code>。所有值的初始化存储类型都是INTEGER，并且最终的存储类型分别是TEXT, INTEGER, INTEGER, REAL 和 INTEGER。你可以在<a href=\"http://www.sqlite.org/datatype3.html.\">这个网站上</a>找到更多关于列关联性类型的例子。</p>\n<h4 id=\"其他相似关联性的模式\"><a href=\"#其他相似关联性的模式\" class=\"headerlink\" title=\"其他相似关联性的模式\"></a>其他相似关联性的模式</h4><p>上面小节中讨论的是数据库引擎在’通常’和默认关联模式下的数据库操作。SQLite支持另外两种关联性模式相关的特性。</p>\n<ul>\n<li><strong>严格关联模式</strong> 在和这个模式下，如果需要在初始存储类型和关联类型之间进行转换，引擎就会返回一个错误，并且当前的语句执行就会失败。</li>\n<li><strong>无关联模式</strong> 在这个模式下，VM不会做任何的存储类型的转换。</li>\n</ul>\n<h3 id=\"给应用层转换引擎的数据\"><a href=\"#给应用层转换引擎的数据\" class=\"headerlink\" title=\"给应用层转换引擎的数据\"></a>给应用层转换引擎的数据</h3><p>应用层可以通过调用<code>sqlite3_column_*</code>API方法来从SQLite引擎中读取数据。这些方法在合适的地方会尝试转换数据值。举个例子，如果内部的表示是REAL，但是通过API<code>sqlite3_column_text</code>方法请求了一个字符串值，VM会使用sprintf()库方法内部做一个转换，并且把值返回给应用层。下面的表展示了VM应用在内部数据的转换规则。</p>\n<table>\n<thead>\n<tr>\n<th>内部类型</th>\n<th>请求类型</th>\n<th>转换</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NULL</td>\n<td>INTEGER</td>\n<td>返回结果为0</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>FLOAT</td>\n<td>返回结果为0</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>TEXT</td>\n<td>返回结果是NULL指针</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>BLOB</td>\n<td>返回结果是NULL指针</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>FLOAT</td>\n<td>从整型转换为浮点型</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>TEXT</td>\n<td>通过ASCII码转换</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>BLOB</td>\n<td>和上面一样</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>INTEGER</td>\n<td>从浮点型转换为整型</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>TEXT</td>\n<td>通过ASCII转换</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>BLOB</td>\n<td>和上面一样</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>INTEGER</td>\n<td>使用atoi()</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>FLOAT</td>\n<td>使用atof()</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>BLOB</td>\n<td>没有变更</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>INTEGER</td>\n<td>先转换为TEXT然后使用atoi()</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>FLOAT</td>\n<td>先转换为TEXT然后使用atof()</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>TEXT</td>\n<td>如果需要的话在后面增加一个\\000</td>\n</tr>\n</tbody></table>\n<h3 id=\"为表达式指派数据类型\"><a href=\"#为表达式指派数据类型\" class=\"headerlink\" title=\"为表达式指派数据类型\"></a>为表达式指派数据类型</h3><p>VM可能先转换内部数据，然后再将内部数据与另一个内部数据进行比较或者评估表达式，在后面的章节中，我们将讨论VM是如何处理内部数据的。</p>\n<h4 id=\"处理SQL-NULL值\"><a href=\"#处理SQL-NULL值\" class=\"headerlink\" title=\"处理SQL NULL值\"></a>处理SQL NULL值</h4><p>SQL NULL值可以在任何一个表列使用，除了主键列。NULL值的存储类型是NULL。无论它们的存储类型是什么，NULL值与这个列的所有其他有效值都不同。SQL标准对于如何处理表达式中列的NULL值不是很具体。根据标准还尚不清楚在各种情况下应如何正确处理NULL值。例如，我们如何比较NULL和其他值？SQLite以许多其他RDBMS一样的方式处理NULL。在SELECT DISTINCT语句，使用UNION操作符的SELECT的组合语句，和GROUP BY语句中NULL是一样的。但是，NULL在UNIQUE列中却是不同的。NULL由SQL标准指定的内置SUM函数处理。对NULL进行算术运算的结果始终是NULL。</p>\n<h4 id=\"表达式中的类型\"><a href=\"#表达式中的类型\" class=\"headerlink\" title=\"表达式中的类型\"></a>表达式中的类型</h4><p>SQLite支持四种比较操作符：</p>\n<ul>\n<li>二元比较运算符 &#x3D;, &#x3D;&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, &lt;&gt;, 和 !&#x3D;</li>\n<li>三元比较运算符 ‘BETWEEN’</li>\n<li>成员运算符 ‘IN’ 和 ‘NOT IN’</li>\n<li>判空操作符 ‘IS NULL’ 和 ‘IS NOT NULL’</li>\n</ul>\n<p>**注意:**判空操作符’IS NULL’和’IS NOT NULL’分别和’&#x3D;’和’!&#x3D;’操作符一样。</p>\n<p>根据以下规则，比较的结果取决于要比较的两个值的存储类型：</p>\n<ol>\n<li>如果运算符左侧的值是NULL，那么这个NULL一般都会认为比其他的小。（如果其他的值中有NULL，也是认为左侧的小）</li>\n<li>INTEGER或REAL比TEXT或BLOB值小。</li>\n<li>如果INTEGER或REAL和另一个INTEGER或REAL比较，那么就是常规的数字比较了。</li>\n<li>TEXT值比BLOB值小。</li>\n<li>如果两个TEXT值比较，那么就是使用标准C库的memcmp函数来比较。但是这个函数是可以被用户自定义的函数重写的。</li>\n<li>当两个BLOB比较的时候，始终使用memcmp函数比较。</li>\n</ol>\n<p>在应用这些规则之前，VM的首要任务是确定比较运算符的操作数的存储类型。它首先确定操作数的初步存储类型，然后（如有必要）根据它们的列的关联性转换类型。最后，它使用以上四个规则进行比较。</p>\n<p>如果一个表达式是某个列，或者是使用别名指向的某个列，或者是一个子查询返回的一个列，或者是rowid，那么这个这个表达式的关联性就会使用列的关联性。否则，这个表达式没有SQL类型，并且它的关联性是NONE。SQLite会尝试在比较运算之前，在（INTEGER和REAL）和TEXT之间做转换。对于二元比较，会在下列情况下完成(可以看expr.c文件中的sqlite3CompareAffinity方法)。这里说的表达式，是除了列值以外的任何SQL标量表达式或者纯文本。</p>\n<ul>\n<li>当两个列的值比较的时候，如果其中任何一列有NUMERIC关联性，那么这两个值会优先使用这个关联性。也就是说，VM尝试在比较之前转换其他列的值。</li>\n<li>当将列值与表达式的结果进行比较时，在进行比较之前，会将列的关联性同样应用于这个表达式的结果。</li>\n<li>比较两个表达式的值时，将不进行任何转换。按照上述标准规则比较这些值。例如，如果将字符串与数字进行比较，则数字将始终小于字符串。</li>\n</ul>\n<p>在SQLite中表达式<code>a BETWEEN b AND c</code>等价于<code>a &gt;= b AND a &lt;= c</code>，但是在两次的比较中，a列的关联性会不一样。</p>\n<p>对于表达式<code>a IN (SELECT b ...)</code>来说，就会使用上面提到的 &#x3D; 号的二元操作符的规则来处理(例如,a&#x3D;b)。举个例子，如果b是一个列的值，a是一个表达式，那么在比较之前b的关联性就会被应用到a上。SQLite处理表达式<code>a IN (x,y,z)</code>和处理<code>a = x OR a = y OR a = z</code>是一样的，但是a的关联性是不一样的。</p>\n<p>有些简单的例子，你可以在<a href=\"http://www.sqlite.org/datatype3.html\">这个网站</a>上找到更多例子。假设，你有一个通过<code>CREATE TABLE t1(a TEXT,b NUMERIC, c BLOB, d)</code>语句创建的表。你可以通过执行<code>INSERT INTO t1 VALUES(‘500’，‘500’，‘500’, 500)</code>插入一条记录。那么最终，a,b,c三列的存储类型就会变成TEXT，INTEGER，TEXT 和 INTEGER。</p>\n<ul>\n<li><code>SELECT a &lt; 600, a &lt; 60, a &lt; 40 FROM t1</code>，会把600,60和40转换为”600”,”60”和”40”，因为a列具有TEXT关联性，值就会被当做TEXT来比较。并且整个语句返回<code>1|1|0</code>作为输出，因为”500”比”600”和”60”小，但是比”40”大。</li>\n<li><code>SELECT b &lt; 40, b &lt; 60, b &lt; 600 FROM t1</code>不会转换任何值，会被当做普通的数字比较，那么就会返回<code>0|0|1</code></li>\n<li><code>SELECT c &lt; 40, c &lt; 60, c &lt; 600 FROM t1</code>不会转换任何值，因为c列是NONE关联类型。三个值(存储类型为NUMERIC)都比”500”小(存储类型为TEXT)，所以返回值为<code>0|0|0</code></li>\n<li><code>SELECT d &lt; 40, d &lt; 60, d &lt; 600 FROM t1</code>不会转换值，因为d的关联性是NUMERIC。返回<code>0|0|1</code>，因为存储的值都是整型比较。</li>\n</ul>\n<h4 id=\"操作符中的类型\"><a href=\"#操作符中的类型\" class=\"headerlink\" title=\"操作符中的类型\"></a>操作符中的类型</h4><p>所有的数学运算符(除了 || 串联运算符以外)都将NUMERIC关联到所有的操作数上，并求值。如果所有操作数都无法转换为NUMERIC，那么运算结果为NULL。对于串联运算符来说，TEXT将关联到两个操作数上。如果任何一个操作数都无法转换为TEXT(NULL或者BLOB)，那么串联的结果为NULL。</p>\n<h4 id=\"order-by中的类型\"><a href=\"#order-by中的类型\" class=\"headerlink\" title=\"order by中的类型\"></a>order by中的类型</h4><p>当值被ORDER BY语句排序的时候，在排序之前不会有存储类型的转换。遵循先前规定的标准比较规则：NULL在最前面，然后是按值大小的INTEGER和REAL，再然后是TEXT，最后是BLOB，后面两个通常是memcmp()排序顺序。同样的文本排序方法可以被用户定义的函数重写。</p>\n<h4 id=\"group-by中的类型\"><a href=\"#group-by中的类型\" class=\"headerlink\" title=\"group by中的类型\"></a>group by中的类型</h4><p>当值被GROUP BY语句分组的时候，在分组之前不会有存储类型的转换。具有不同存储类型的值被认为是不同的，但INTEGER和REAL值除外，如果它们在数值上相等，则被视为相等。GROUP BY语句的结果中也不会做任何的存储类型的转换。</p>\n<h4 id=\"组合SELECTs中的类型\"><a href=\"#组合SELECTs中的类型\" class=\"headerlink\" title=\"组合SELECTs中的类型\"></a>组合SELECTs中的类型</h4><p>复合SELECT操作符(UNION，INTERSECT和EXCEPT)，在值之间进行隐式比较。在比较之前，VM不会执行任何关联类型转换。它们就按照原始值进行比较。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>VM模块是后端数据库引擎。数据操作逻辑就在这个模块内。它会执行一个使用特殊的字节码语言编写的程序。（类似于其他汇编语言）一个字节码程序实际上就是字节码指令的线性组合。一个字节码指令可以有一个操作码和最多5个操作数或者持有操作数的寄存器组成。</p>\n<p>一个<code>Vdbe</code>对象代表了一个由前端生成的字节码程序(在内部是一个<code>sqlite3_stmt</code>指针)。应用层可以在这个对象上执行SQLite API方法。举个例子，当应用层执行<code>sqlite3_step</code>API方法的时候，它会循环迭代执行这个程序，一直执行遇到终止或者遇到一个可以输出的结果记录。</p>\n<p>VM支持五种数据类型：integer,real,text,blob和SQL NULL。在数据库文件或者内存中的数据必须是这五种之一。这个类型称之为存储类型。当需要的时候，VM会做类型的转换。应用程序可以使用typeof SQL函数来确定值的数据类型。</p>\n<p>VM是数据的唯一操作者。它维护表和索引树中的记录。这两者的记录格式很相似。SQLite使用一个可变长度的记录格式。它使用清单类型来表示记录中的单个值。这个清单类型是指，每一个数据的存储类型信息都被存在记录中了。此方案允许在任何列中存储任何存储类型的值，而与该列的声明的SQL类型无关，但有一个例外，即整数主键列仅存储整数值。值的存储类型被编码为整数，并且该整数还编码该值的（字节）长度。每个表记录均以头部大小（即可变长度的霍夫曼代码）开头，然后是数据值的清单类型，然后是各个数据值。</p>\n<p>数据类型管理在SQLite中有点复杂。SQLite根据声明的SQL类型为列分配关联类型。首先尝试将输入数据值转换为关联类型。如果转换失败，则原始值仍将存储在该列中。 SQLite进行类似的数据转换来评估表达式和函数。</p>\n","site":{"data":{}},"excerpt":"<p>本文讨论了SQLite虚拟机（VM）是如何解释执行了一个通过SQLite内部的字节码语言编写的程序。VM是存储在本地数据库文件中数据唯一的操作者。它支持5种原始的数据类型:NULL,integer,real,character string,blob,这五种数据类型代表了在文件或者内存中存储的原始的数据项。由VM来完成用户数据和内部数据表示之间的转换。在做表达式评估的时候它也会做一些数据类型转换。VM是如何工作的，以及它在存储表和索引记录到B-，B+树之前，如何做数据格式化。</p>","more":"<p><strong>本文目标</strong></p>\n<ul>\n<li>5种数据类型和它们代表的含义</li>\n<li>一个编译好的SQL语句的内部表述</li>\n<li>在SQL类型和C类型之间是如何做转换的</li>\n<li>表记录和索引记录的逻辑结构</li>\n<li>清单类型在编码数据值中的优势</li>\n</ul>\n<h1 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h1><p>后端最顶层的模块在SQLite术语中通常被称之为虚拟数据库引擎，或虚拟机（VM）。VM是SQLite的核心，并且是前端和后端之间的接口。一些核心信息(计算和逻辑)只会在VM中处理，因为下层模块就存储的信息而言是被动的。它在原生的操作系统上层实现了一个抽象的虚拟的机器，并且它可以执行用SQLite内部的字节码程序语言编写的程序。这个程序语言是特地设计用来搜索，读取和修改数据库的。VM接受由前端生成的字节码程序，并且执行这个程序。VM使用B+树提供的”基础能力”来执行字节码程序，并且输出程序的执行结果。</p>\n<p>SQLite开发团队认为VM的使用对于这个库的开发和调试有巨大的好处。VM在前端（解析SQL语句并生成VM应用程序的部分）和后端（执行字节码应用程序并计算结果的部分）之间扮演了一个粘合剂的角色。字节码程序比解释集成数据对象的复杂网格更易于阅读。虚拟机还可以帮助SQLite引擎开发人员清楚地了解引擎正在尝试对其所编译的每个SQL语句执行的操作。</p>\n<p><strong>字节码执行跟踪</strong>:对于人类来说，读取字节码程序比解释数据结构值更容易。它还具有跟踪每个VM应用程序的程序执行的能力–打印每个字节码指令以及随着执行的进展而生成的结果。这个取决于SQLite源代码的编译方式。</p>\n<p>一个字节码应用程序在内存中由一个<code>sqlite3_stmt</code>对象表示(内部称为Vdbe)。以下SQLite API 可以用在这个对象上，从而实现把某个输入的值关联到SQL参数上，或者执行字节码程序，或者检索程序执行产生的输出。</p>\n<ol>\n<li>sqlite3_bind_*:这系列方法会指派值给SQL参数，并且作为字节码程序的输入。</li>\n<li>sqlite3_step:它会让字节码程序执行推进到下一个断点，或者到一个终止点。</li>\n<li>sqlite3_reset:它让程序执行倒退到起点，并且使得同一个程序可以准备进行二次执行。</li>\n<li>sqlite3_column_*:这系列方法会从程序产生的当前输出行中逐列提取结果。</li>\n<li>sqlite3_finalize:它会销毁sqlite3_stmt对象和字节码程序</li>\n</ol>\n<p>Vdbe对象（又称预处理语句）的内部状态包括以下内容：</p>\n<ul>\n<li>一个字节码程序</li>\n<li>所有结果列的名字和数据类型</li>\n<li>绑定到输出参数的值</li>\n<li>一个程序计数器</li>\n<li>任意数量的“编号”存储单元（称为寄存器位置）</li>\n<li>其他运行时的状态信息(例如一个打开的BTree对象，集合，列表，排序器…)</li>\n</ul>\n<p>VM不会做任何查询优化操作。它会无条件地执行字节码程序。这样，它可以按需将数据从一个格式转换为另一个格式。即时的数据转换，是VM的主要任务。所有事情都会在它所执行的字节码程序的控制之下。本文主要介绍数据转换和操作任务。在此之前，下一部分概述字节码编程语言，字节码程序和程序执行逻辑。</p>\n<h2 id=\"字节码编程语言\"><a href=\"#字节码编程语言\" class=\"headerlink\" title=\"字节码编程语言\"></a>字节码编程语言</h2><p>SQLite定义了一种内部编程语言来准备字节码程序。该语言类似于物理和虚拟机（例如Java以及使用的字节码）使用的汇编语言：它定义了字节码指令。每个字节码指令执行少量信息处理工作或做出逻辑决策。而一个字节码程序则包含了一个线性的字节码指令序列。一个字节码指令可以最多有5个操作数，&lt;opcode,P1,P2,P3,P4,P5&gt;,opcode定义了一系列的字节码操作，而P1,P2,P3,P4,P5则是当前操作的操作数或者操作数对应的寄存器。前三个操作数都是一个32位的有符号整数。如果当前操作触发了一个跳转，那么P2就一定是一个目标地址。P4是一个32&#x2F;64为的有符号整数，或者是64位的浮点小数，或者是一个指向具有终止符的字符串，字节块，一个归类的比较方法，一个SQL方法，等等。P5操作数是一个无符号的字符。这5个操作数不是左右的操作符都会使用的。</p>\n<p><strong>注意</strong><br>操作码是VM操作的内部名称，不属于SQLite的接口定义。总之，它们的含义可能会由于版本的更新而更新。SQLite的开发团队不鼓励SQLite的用户来直接编写字节码。字节码编程语言仅供内部使用。</p>\n<p>下面的表格展示了一个典型的字节码程序。这个字节码程序等价于<code>SELECT * FROM t1</code>。这个表格有x,y两列。字节码程序从0号指令开始执行，一直执行到一个终止指令或者超出了最后一条指令。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/06/UOiFYp.png\"></p>\n<h3 id=\"字节码指令\"><a href=\"#字节码指令\" class=\"headerlink\" title=\"字节码指令\"></a>字节码指令</h3><p>大概一共有142个操作码。操作码可以分为5类：1.计算和逻辑。2.数据移动。3.控制流。4.B-和B+树相关。5.专门的类型。第一类操作码包含 加, 减, 乘, 除, 求余, 位或, 位与, 二进制反码, 二进制补码, 右移动, 左移 和 字符串连接。第二类操作码在内存单元之间移动值。第三类操作码包含goto , gosub, return , halt 和 条件转移。第四类操作码包含(i) 创建, 销毁, 和 清空 B&#x2F; B+树, (ii) 打开 和 关闭 B&#x2F;B+ 树上的游标, (iii) 向前 和 向后移动游标 或 移动到指定的key, (iv)光标移动的分支,(v)插入, 删除 B&#x2F;B+ 树的记录,(vi)开始, 提交 和 回滚 事务。第五类操作码包含(a)获取一个不在使用的rowid,(b)组合n个内存元素为一个记录，(c)从一个表行中提取第i个列的数据，等等。</p>\n<p>每一个字节码指令在内部都由一个VdbeOp对象表示。这是一个比较简单的对象，它有以下成员：(1)opcode，表明需要执行的操作，(2)(3)(4)(5)(6)p1-p5持有5个操作数。(7)p4type表明了p4操作数的数据类型。p4有13个类型。一个虚拟机应用程序实际上是一个VdbeOp对象的线性集合。</p>\n<p>下面展示了一些操作码的含义。最新SQLite版本的操作码都在<a href=\"http://www.sqlite.org/opcode.html\">SQLite官方网站</a>找到。在SQLite源码中，每一个操作码的名字都由OP_开头，并且都分配了不同的整数。</p>\n<ol>\n<li>Trace: 这个操作码检查了SQLite库是否开启了tracing mode。如果开启了，那么在每次跟踪回调的时候都会输出P4的内容(一个UTF8字符串)。你可以使用<code>sqlite3_trace</code>API方法开启跟踪。</li>\n<li>Goto: 无条件跳转到P2所指定的地址。VM执行的下一条指令将是距程序开始偏移为P2的指令。</li>\n<li>OpenRead: 打开一个B&#x2F;B+树的只读的游标。这个树的root page由P2指定。（如果P5不为0，那么就是寄存器P2包含了这个page号，而不是P2的内容）数据库文件由P3操作数指定–0表示主数据库，1表示临时数据库，大于1表示附加连接的数据库。P1操作数(一个非负的整数)将会是新的游标的标识。P4的值是一个整数或者一个指向KeyInfo结构体的指针。如果光标在B树（SQL索引）上打开，则KeyInfo结构定义了 内容和排序 的顺序。如果P4是一个整型的值，则代表了表列的数量。</li>\n</ol>\n<p>如果在只读游标打开的时候，数据库没有上锁，那么在这个指令指向的时候，会请求一个共享锁。如果它无法获取一个共享锁，虚拟机会终止字节码的执行，并且返回一个SQLITE_BUSY错误码。（这个可以看后端的实现逻辑）<br>4. Rewind：重置游标P1。这个游标将会指向表或者索引的第一项，对应树中最小的一项。如果树是空的，并且P2 &gt; 0,那么就会立刻跳转到P2对应的地址。否则，遵循以下说明。<br>5. Column: 获取P1游标指向的记录中，P2对应的列的值。(这里会把P1指向的记录解析为一个数据结构，而这个数据结构是由MakeRecord指令构建的，可以看下面的MakeRecord指令)，如果记录中的字段个数少于P2个，那么提取的值就会变成NULL；如果P4的数据类型是一个P4_MEM,那么就会使用P4的值作为结果。返回的值会存储在P3寄存器内。<br>6. MakeRecord：将从寄存器P1开始的P2个寄存器合并转换为一个可以用作数据库表中的记录项，或者转换为一个索引的key。也就是说P1包含了第一个数据项目，P1+1是第二个数据项目，以此类推。<br>7. ResultRow: 寄存器P1到P1+P2-1包含一个单行记录。在上层应用执行<code>sqlite_step</code>方法的时候这个指令就会执行。并且这个方法执行返回SQLITE_ROW。<br>8. Next: 推进P1游标，这样它就可以指向树上的下一项。如果树上面没有下一项了，那么就会遵循以下说明。否则就会立刻跳转到P2地址。<br>9. Close: 关闭先前打开的P1游标。如果P1游标没有打开，那么这个指令就无操作。<br>10. Halt: 在关闭所有已打开的游标、FIFOs（又名RowSet对象）后立刻退出。P1是<code>sqlite3_exec</code>,<code>sqlite3_reset</code>,<code>sqlite3_finalize</code>三个API返回的结果值。对于通常的结束来说，返回的结果值都是SQLITE_OK(&#x3D;0)。如果出现了错误，那么这个错误码就是其他值了。如果P1!&#x3D;0，那么P2就决定了当前的事务是否需要做一个回滚。当P2&#x3D;OE_Fail的时候就无需回滚；当P2&#x3D;OE_Rollback的时候就需要回滚；当P2&#x3D;OE_Abort的时候，撤消此执行过程中发生的所有更改，但不回滚事务。P4指向的是一个错误信息。</p>\n<p><code>Halt 0 0 0 0 0</code>是一个默认的终止指令，会被插入到每一个字节码程序的最后面。因此，跳过程序的最后一条指令与执行终止指令是一样的。<br>11. Transaction: 开启一个新的事务。P1是标识了开启事务的数据库文件类型。0代表主数据库文件，1代表临时数据库，大于1的时候代表附加连接的数据库。如果P2是0，表示数据库文件上会获取一个共享读锁。如果P2非零，就会开始一个写事务，数据库上会获取一个保留锁。如果P2是2或者更大，那么就会获取一个排它锁。开启写事务的时候也需要创建一个回滚文件。<br>12. VerifyCookie: 检查全局数据库参数号0的值(schema版本的cookie)，并且保证这个值和P2的值是一致的，并且在本地模式解析中的迭代计数器和P3的值是一致的(?)。P1是标识了数据库文件类型与上面一致。（你可以回想一下，每当数据库模式更改时，cookie值都会更改）这个验证的操作是用来检测，当cookie发生便跟的时候，当前的进程需要重新去读取schema。在执行此操作码之前，要么需要启动事务，要么需要执行OpenRead &#x2F; Open Write（至少在数据库上建立共享锁）。<br>13. TableLock: 在数据库P1上获取根page为P2的表的锁。如果P3为0，那么加读锁，如果P3为1，加写锁。P4包含了一个指向这个表名的指针。</p>\n<p>在下面两个小节中，将会表述SQL insert 和join处理的VM执行逻辑。这样可以给出更加清晰的描述来显示如何为一个SQL语句生成一个字节码程序的。</p>\n<h3 id=\"插入逻辑\"><a href=\"#插入逻辑\" class=\"headerlink\" title=\"插入逻辑\"></a>插入逻辑</h3><p>假设，有一个包含两列的表T1。这两列分别是c1 text和c2 integer;这个表没有任何的索引。如果你执行<code>insert into T1 values(&#39;Hello,Wold!&#39;, 2000)</code>的语句，VM会根据下面的算法步骤来执行:</p>\n<ol>\n<li>在主数据库上打开一个写事务。</li>\n<li>检查数据库的schema版本，保证在这个语句的字节码生成期间没有被别人修改过。</li>\n<li>在表”T1”的B+树上，打开一个写游标。</li>\n<li>创建一个新的rowid，并且将’Hello,Wold!’和2000合并创建一个记录项。</li>\n<li>通过打开的游标，将这个记录项插入到B+树中。</li>\n<li>关闭游标。</li>\n<li>给调用者返回执行结果。</li>\n</ol>\n<p>如果在T1上还有索引，在第三步的时候，VM会在每一个索引表上打开一个写游标，并且分别在第四步和第五步的时候准备和插入一个记录项。</p>\n<h3 id=\"连接逻辑\"><a href=\"#连接逻辑\" class=\"headerlink\" title=\"连接逻辑\"></a>连接逻辑</h3><p>在连接操作中，会合并两个或者多个表来创建一个结果表。结果表包含要连接的表中所有可能的行组合。实现连接的最简单，最自然的方法是使用嵌套循环。SQLite仅执行循环联接，而不执行合并联接。在FROM语句中的最左侧的表构成最外侧的循环，最右侧的表构成了最内侧的循环。</p>\n<p>考虑以下SQL 查询语句: <code>select * from t1, t2 where ...</code>，假设这两个表上都没有索引。那么这个查询语句的伪代码，就类似于下面这样。</p>\n<ol>\n<li>在主数据库上打开一个读事务。</li>\n<li>同样的检查schema版本。</li>\n<li>打开两个游标，一个是T1的，一个是t2的。</li>\n<li><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> each record in T1, <span class=\"keyword\">do</span>:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each record in T2, <span class=\"keyword\">do</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> WHERE语句为TRUE</span><br><span class=\"line\">            计算当前行的所有结果列</span><br><span class=\"line\">            为当前结果行调用默认回调函数的</span><br><span class=\"line\">            </span><br></pre></td></tr></table></figure></li>\n<li>关闭两个游标。</li>\n</ol>\n<h3 id=\"程序的执行\"><a href=\"#程序的执行\" class=\"headerlink\" title=\"程序的执行\"></a>程序的执行</h3><p>VM从序号为0的指令开始执行一个字节码程序，直到它(1)处理一个停止指令或者(2)遇到一个错误，或者(2)程序计数器超过了最后一条指令。当程序终止的时候，它会释放所有已经分配的内存，并且关闭所有打开的游标。如果执行因为错误而终止了，后续的事务就会终止，并且回滚引起的数据库变更。</p>\n<p>下面用C语言给出了这个VM解释器的结构。解释器（带Vdbe对象指针的sqlite3VdbeExec函数）是一个简单的for循环，其中包含了一个大量case的Switch语句。每一个case的语句实现了一个字节码指令（在源代码中，操作码名称以OP_prefix开头。操作码名称的数字值不是静态编号的。它们是在SQLite源代码编译时分配的。数字可能因一个SQLite版本而异。）在每一次迭代中，VM从程序中拉取下一次的字节码指令。例如：从aOp数组中以pc作为下标(这两个都是Vdbe对象的成员变量)索引获取下一个字节码指令。它会解码并执行指令指定的操作。一般来说，程序的执行会从一个字节码执行到下一个(pc++)，但是pc可以由跳转指令变更。这个for循环会一直执行，一直到VM处理了一个终止指令或者循环的条件不成立了(也就是pc计数超过了指令个数)，那么我们就说字节码程序已经终止了。这个是一个正常的终止。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (; pc &lt; nOp &amp;&amp; rc == SQLITE_OK; pc++)&#123; </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (aOp[pc].opcode)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Add:</span><br><span class=\"line\">        <span class=\"comment\">/* Implementation of the ADD operation here */</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Goto:</span><br><span class=\"line\">        pc = op[pc].p2<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    <span class=\"keyword\">case</span> OP_Halt:</span><br><span class=\"line\">        pc = nOp;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* other cases for other opcodes */</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>sqlite3_prepare</code>API方法返回了<code>sqlite3_stmt</code>对象指针。而这个对象实际上指向的是Vbe对象(它代表了虚拟数据库引擎)。这个对象包含了完整的VM状态。下面展示了这个对象的一些组件。<code>aOp</code>数组包含了所有的操作码。这个程序执行需要的所有内存均位于大小为<code>nMem</code>的<code>aMem</code>数组中。</p>\n<table>\n<thead>\n<tr>\n<th>成员变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>db</td>\n<td>sqlite3数据库连接对象</td>\n</tr>\n<tr>\n<td>aOp</td>\n<td>VM程序</td>\n</tr>\n<tr>\n<td>nOp</td>\n<td>aOp的数量</td>\n</tr>\n<tr>\n<td>apCsr</td>\n<td>打开的游标数组</td>\n</tr>\n<tr>\n<td>nCursor</td>\n<td>apCsr的大小</td>\n</tr>\n<tr>\n<td>aMem</td>\n<td>程序执行需要的内存</td>\n</tr>\n<tr>\n<td>nMem</td>\n<td>aMem的大小</td>\n</tr>\n<tr>\n<td>rc</td>\n<td>需要返回的值</td>\n</tr>\n<tr>\n<td>pc</td>\n<td>程序计数器</td>\n</tr>\n<tr>\n<td>…</td>\n<td>其他变量</td>\n</tr>\n</tbody></table>\n<p>VM使用游标来访问数据库(这些游标和在Tree模块使用的<code>BtCursors</code>不一样)。在数据库上可能有几个已经打开游标的数据库。每一个游标都是指向数据库中表和索引的树。游标可以通过一个key指向到任何一个项或者遍历树中的所有项。VM可以在游标指向的当前项创建新的或者检索key&#x2F;value值，或者删除项。</p>\n<p>在同一个索引或者表的树上可以同时有多个游标。尽管在同一个索引或者表上可以有多个游标，但是它们都是独立操作的。在VM中，一个VdbeCursor对象代表了一个打开的游标。下面的表格展示了VdbeCursor的结构体。字节码程序的质量可以创建一个新的游标（通过操作码OP_OpenRead或者OP_OpenWrite），从游标中读取数据（通过操作码OP_Column），然后在表或者树上推进游标到下一项（通过操作码OP_Next）以及其他的一些操作。在VM终止执行字节码程序的时候，所有的游标都会自动关闭。</p>\n<table>\n<thead>\n<tr>\n<th>成员变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pCursor</td>\n<td>后端的(BtCursor)游标结构体</td>\n</tr>\n<tr>\n<td>iDb</td>\n<td>游标所在的数据库</td>\n</tr>\n<tr>\n<td>pBt</td>\n<td>这个游标的临时文件的临时表</td>\n</tr>\n<tr>\n<td>pKeyInfo</td>\n<td>索引表的游标需要索引的key的一些信息</td>\n</tr>\n<tr>\n<td>aType</td>\n<td>在记录里所有项的类型值</td>\n</tr>\n<tr>\n<td>aOffset</td>\n<td>每一列数据缓存的从起始点开始的偏移</td>\n</tr>\n<tr>\n<td>aRow</td>\n<td>当前行的数据(如果所有的数据都在一页page内)</td>\n</tr>\n<tr>\n<td>…</td>\n<td>其他变量</td>\n</tr>\n</tbody></table>\n<h2 id=\"内部的数据类型\"><a href=\"#内部的数据类型\" class=\"headerlink\" title=\"内部的数据类型\"></a>内部的数据类型</h2><p>VM使用任意数量的编号内存位置来保存所有中间结果。每一个内存地址存储了一个数据值。VM处理的每个值是一下五种数据类型之一:</p>\n<ol>\n<li>INTEGER: 一个有符号的整型数字；</li>\n<li>REAL: 一个有符号的浮点型数字；</li>\n<li>TEXT: 一个字符串值；</li>\n<li>BLOB: 一个字节块；</li>\n<li>NULL: 一个SQL NULL值；</li>\n</ol>\n<p>VM只支持5种原始的数据类型。这个类型决定了一个数据在实际物理存储的时候应该如何表示。每一个存储在内存或者本地数据库文件中的数据类型都必须是这几种数据类型之一。有些值可能具有多种数据类型。举个例子，123可以是一个整型，一个浮点型，也可以是一个字符串。BLOB和NULL的值没有多种含义。在必要的情况下，SQLite会做一些数据转换。你可以使用SQLite内置的方法<code>typeof</code>来获取一个值的类型–<code>select a,typeof(a) from t1</code>将会返回a字段的值以及他们对应的存储类型。在使用<code>sqlite3_step</code>方法返回一行记录的时候，API<code>sqlite3_column_type</code>会返回某列字段值的存储类型。</p>\n<p>在VM内部，所有的操作对象几乎都是Mem对象。每一个Mem对象可能会缓存数据的多个存储类型。而一个值(也就是Mem对象)有如下的属性: 每个值恰好是以上提到的五种存储类型之一。(每个Vbe.aMem数组元素就是一个aMem对象。)</p>\n<table>\n<thead>\n<tr>\n<th>成员</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>type</td>\n<td>这个Mem对象锁代表的值的类型</td>\n</tr>\n<tr>\n<td>i</td>\n<td>整型值</td>\n</tr>\n<tr>\n<td>r</td>\n<td>浮点型值</td>\n</tr>\n<tr>\n<td>z</td>\n<td>字符串或者字节块值</td>\n</tr>\n<tr>\n<td>n</td>\n<td>z的大小</td>\n</tr>\n<tr>\n<td>enc</td>\n<td>如果z是一个字符串的话，这个字符串的UTF编码类型</td>\n</tr>\n<tr>\n<td>…</td>\n<td>其他变量</td>\n</tr>\n</tbody></table>\n<h2 id=\"记录格式\"><a href=\"#记录格式\" class=\"headerlink\" title=\"记录格式\"></a>记录格式</h2><p>VM会把数据组合为一条记录存储在他们对应的B树或者B+树内。每一个记录都包含key和一个可选的value。VM仅负责维护键和值的内部结构(尽管，Tree模块可能会把一条记录拆分为叶子节点，内部节点或者多个溢出页，VM把整条记录视为一个连续的字节串)。VM使用了两个相似但是也略有不同的结构来描述表和索引记录。</p>\n<p>有两种格式来格式化data&#x2F;key记录：固定长度和可变长度。对于固定的长度来说，对于表或者索引的所有记录都是使用了相同大小的空间；在表或者索引的创建的时候就已经知道每一个字段的大小了。对于可变长度的格式来说，每一个字段的空间大小可能根据不同的记录而不一样。SQLite使用可变的变量长度来格式化记录，因为它有几个优势。数据库因为没有空间的浪费而变得更小。同样也会让整个系统跑得更快，因为在内存和磁盘之间需要同步的bytes数量更小。另外，使用可变长度的记录可以允许SQLite可以使用清单类型而不是静态类型。接下来两节先讨论一下这个清单类型。</p>\n<h3 id=\"清单类型\"><a href=\"#清单类型\" class=\"headerlink\" title=\"清单类型\"></a>清单类型</h3><p>不论是存储在内存中还是在文件中，每一个原始的数据都有一个数据类型与之关联。这个数据类型称之为存储类型。大部分SQL数据库使用静态类型:一个表内的每列关联了一个数据类型，并且只允许存储每列关联的数据类型。这样非常死板，也有它自己的优缺点。SQLite通过使用清单类型解除了这一个限制。在这个方法下，数据的类型是数据本身的一个属性，而不是数据存储列的。这样，每一列就允许你存储任何变量，任何类型的数据，并且不会丢失这个数据的类型。SQLite会将数据的类型作为数据的一部分存储。它允许你在列内存储任何类型的数据，而不用关心每一列声明的数据类型。(在这里有一个例外，就是一个声明了<code>integer primary key</code>的列只能存储[-2^63, 2^63-1]的整型值)。</p>\n<h3 id=\"类型编码\"><a href=\"#类型编码\" class=\"headerlink\" title=\"类型编码\"></a>类型编码</h3><p>存储类型会被编码为整型。这个整型值的编码关系在下表给出了。这种编码的好处在于类型编码也会包含数据长度。NULL类型代表了SQL NULL类型。对于INTEGER类型，数据的值是一个有符号的整型数字，由(1,2,3,4,6或8个字节)组成。具体的长度取决于值的大小。对于REAL类型，数据值是一个浮点小数，根据IEEE的浮点数标准，存储在8个字节内。8，9两个数据类型，分别代表了整型常量0和1.对于TEXT类型，数据值就是一个文本字符串，使用默认编码(UTF-8, UTF-16BE, or UTF-16-LE)格式存储文本。对于后两者来说，字节顺序分别是大端或者小端。（每个数据库文件只会用一种UTF编码）对于BLOB类型，数据值是一个字节流，完全和用户输入的字节流一致。</p>\n<p>**布尔值:**布尔值就使用8，9两个常量类型来表述。</p>\n<table>\n<thead>\n<tr>\n<th>类型值</th>\n<th>含义</th>\n<th>数据长度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>NULL</td>\n<td>0</td>\n</tr>\n<tr>\n<td>N in {1..4}</td>\n<td>有符号整数</td>\n<td>N</td>\n</tr>\n<tr>\n<td>5</td>\n<td>有符号整数</td>\n<td>6</td>\n</tr>\n<tr>\n<td>6</td>\n<td>有符号整数</td>\n<td>8</td>\n</tr>\n<tr>\n<td>7</td>\n<td>IEEE 浮点</td>\n<td>8</td>\n</tr>\n<tr>\n<td>8</td>\n<td>常数 0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>9</td>\n<td>常数 1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>10、11</td>\n<td>扩展保留</td>\n<td>N&#x2F;A</td>\n</tr>\n<tr>\n<td>N&gt;&#x3D;12 偶数</td>\n<td>字节流</td>\n<td>(N-12)&#x2F;2</td>\n</tr>\n<tr>\n<td>N&gt;&#x3D;12 奇数</td>\n<td>纯文本</td>\n<td>(N-13)&#x2F;2</td>\n</tr>\n</tbody></table>\n<h3 id=\"表记录格式\"><a href=\"#表记录格式\" class=\"headerlink\" title=\"表记录格式\"></a>表记录格式</h3><p>下表中描述了一个表记录的格式。由两部分组成：头部和记录内容。头部由一个size字段开始，后面跟着字段的类型。头部后面跟着记录的数据项。(SQLite不会修改在创建语句中声明的字段顺序。建议表结构的设计者在设计早期，把小而使用频率高的列放在记录中，从而尽可能避免触发溢出的规则。)</p>\n<table>\n<tr>\n        <th style=\"color:grey\" colspan=\"5\">头部</th>\n        <th style=\"color:grey\" colspan=\"4\">记录内容</th>\n    </tr>\n    <tr>\n        <th>Header size</th>\n        <th>Type 1</th>\n        <th>Type 2</th>\n        <th>...</th>\n        <th>Type N</th>\n        <th>Data 1</th>\n        <th>Data 2</th>\n        <th>...</th>\n        <th>Data N</th>\n    </tr>\n</table>\n\n<p>Header size是Data1之前的字节数。这个大小是一个哈夫曼编码的64位的可变长度的integer值，并且它包含了它自身所占用的大小。这个大小也可以被用作Data1项的指针。在header size大小之后紧跟着的是数据类型字段，每一个数据值都按照它在字段中出现的顺序排列。每一个类型字段Type i是一个可变长的无符号整型（最大是2^64），对应编码了数据字段Data i的存储类型。</p>\n<p>**零长度的数据:**对于类型值为0，8，9，12和13来说，数据的长度是0，因此数据不会存储在记录中。</p>\n<h3 id=\"表key的格式\"><a href=\"#表key的格式\" class=\"headerlink\" title=\"表key的格式\"></a>表key的格式</h3><p>在SQLite中，每一个B+-Tree必须有一个唯一的key。尽管一个定义好的关系型表不包含相同的行，但是实际上用户是可以在关系表中存储重复的行的。但是数据库系统必须有办法来区分这些相同的行。该系统必须能够关联其他信息以实现差异化目的。这也就意味着，系统需要为这个关系提供一个新的唯一的属性。因此，在内部，每个表都有唯一的主键，并且该键由表的创建者或SQLite来定义。主键是一个名为rowid的整型值。</p>\n<h4 id=\"Rowid列\"><a href=\"#Rowid列\" class=\"headerlink\" title=\"Rowid列\"></a>Rowid列</h4><p>在每一个SQL表里，SQLite会指定一列作为rowid(也称为oid或_rowid_)。这一列中的值在表内的每一行都是唯一定义的。这列将会是表的隐式主键，也是表B+树的唯一搜索关键字。如果表内的任何一列被声明为 integer primary key，那么这列就会被当做这个表的rowid（作为别名）。否则的话，SQLite会创建一个独立的名为rowid作为唯一主键列。(如果表中已经存在了相同的这三个名字(rowid,oid,<em>rowid</em>),那么名称将引用这些列，而不是内部rowid列)因此，每一个表不论是否声明了 integer primary key列，都有一个唯一的整型key，命名为rowid。对于后一种情况，rowid本身在内部被视为表的整数主键。无论哪种情况，rowid都是[-2^63, 2^63-1]范围内的有符号整数值(在编译器有宏可以限制这个rowid为32位)。在表的B+树上的排序顺序是按照整型的大小，并且无法用其他的排序顺序。这些B+树是表的主要索引。rowid作为表B+树的逆向指针存储在二级索引里。</p>\n<h4 id=\"Rowid值\"><a href=\"#Rowid值\" class=\"headerlink\" title=\"Rowid值\"></a>Rowid值</h4><p>如果rowid是一个别名列(例如声明了INTEGER PRIMARY KEY),数据库的使用者是知道这个列的。如果SQLite插入了一列rowid，那么他们是不知道这列的存在的。无论哪种情况，用户都可以定义rowid值，或者SQLite可以为用户定义值。它保证了他们的唯一性。当有一条记录插入到表中而没有指定rowid值的时候，SQLite会访问B+树，为rowid获取到一个未使用的整型数字。通常来说，这个值都是比表格内最大的值要大。但是，如果已经到了最大值，那么SQLite就随机选一个未使用的值。如果找不到，那么就会返回SQLITE_FULL错误码。</p>\n<h4 id=\"Rowid的含义\"><a href=\"#Rowid的含义\" class=\"headerlink\" title=\"Rowid的含义\"></a>Rowid的含义</h4><p>Rowid的含义取决于是谁创建的。如果rowid列是由SQLite创建的，那么表记录中就不包含它。否则，将在每个表记录中存储一个NULL（类型值0）。SQLite通过key来获取到真正的值。这个值是可变长的哈夫曼编码。可以允许负值的rowid，但是这样的话，它们就会占据9个字节，所以不鼓励这样做。如果rowid是由SQLite生成的，那么它们一定不会是负数，尽管你可以指定一个负整数。</p>\n<h3 id=\"索引key的格式\"><a href=\"#索引key的格式\" class=\"headerlink\" title=\"索引key的格式\"></a>索引key的格式</h3><p>在前两节中你可以看到，每一个表的B+树都是一个整型key，然后这个表格的一行就是一个数据记录。索引与之相反。对于一个索引项，key是存储在索引表内的一行所有索引列值的一个组合。而数据才是这一行的rowid。为了通过一个索引列的指定数据来访问某一行，VM首先搜索索引表来找到对应的rowid，然后使用这个整型来找到表B+树内完整的记录。尽管许多人认为通过主键来指向每一行，开销太大，但是SQLite简单起见。</p>\n<p>SQLite通过创建一个存储在一个单独的B树内的单独的’索引表’来实现表内的每一个索引。每一个索引B树映射了搜索的关键字和rowid。索引B树有自己的关键字比较器，来排序索引项。VM会提供给Tree模块一个合适的关键字比较函数指针。</p>\n<p>SQLite会为create语句中的每一个<code>UNIQUE</code>唯一列创建一个索引，包括<code>PRIMARY KEY</code>列。你不能单独删除这些索引。你可以在一个非目录表上使用<code>CREATE INDEX</code>为指定列创建索引。你也可以单独删除这些索引。当一个表被删除的时候，这个表对应的所有的索引都被删除了。还有一些其他方法在SQLite中创建索引。以下是在表T1(a,b,c)上的a,b列创建索引的例子。</p>\n<ol>\n<li>直接声明创建索引</li>\n</ol>\n<ul>\n<li><code>CREATE TABLE T1(a,b,c)</code></li>\n<li><code>CREATE INDEX idx1 ON T1(a,b)</code></li>\n</ul>\n<ol start=\"2\">\n<li>声明列唯一</li>\n</ol>\n<ul>\n<li><code>CREATE TABLE T1(a,b,c,UNIQUE(a,b))</code></li>\n</ul>\n<ol start=\"3\">\n<li>声明列为主键</li>\n</ol>\n<ul>\n<li><code>CREATE TABLE T1(a,b,c,PRIMARY KEY(a,b))</code></li>\n</ul>\n<p><strong>注意:</strong><code>INTEGER PRIMARY KEY</code>比较特殊，它不会生成一个单独的索引。表的B+树由这个别名为rowid的列来排序。</p>\n<p>SQLite可以在一列上同时创建多个索引，思考一下下面这个例子<br><code>CREATE TABLE T2(x VARCHAR(5) UNIQUE PRIMARY KEY , y BLOB);</code><br><code>CREATE INDEX idx2 ON T2(x);</code></p>\n<p>上面的例子中，SQLite在x列上创建了三个索引，一个是<code>PRIMARY KEY</code>,一个是<code>UNIQUE</code>，一个是指定创建的索引。索引会减慢<code>INSERT</code>,<code>UPDATE</code>和<code>DELETE</code>的执行，并且加大了数据库文件的大小。</p>\n<table>\n<thead>\n<tr>\n<th>Header size</th>\n<th>Type 1</th>\n<th>Type 2</th>\n<th>···</th>\n<th>Data1</th>\n<th>Data2</th>\n<th>rowid</th>\n</tr>\n</thead>\n</table>\n<p>正如上面提及的，SQLite会把索引当做一个表，然后在它自己的B树中存储。它把关键字隐射到了rowid上。下面描述了一个索引记录的格式。整个记录都当做了B-Tree的key；没有数据部分。索引记录的编码和数据表的记录的一样，除了后面跟了一个rowid，并且rowid的数据类型，没有在记录头部显式声明。因为rowid的类型只能是有符号整数并且是用哈夫曼编码表示的（不是内部的整型类型）。（其它数据的值和数据的存储类型都从索引表内拷贝）在x列上的内容索引，如下所示.</p>\n<table>\n<thead>\n<tr>\n<th>x</th>\n<th>rowid</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NULL</td>\n<td>54321</td>\n</tr>\n<tr>\n<td>456</td>\n<td>2</td>\n</tr>\n<tr>\n<td>abc</td>\n<td>-5</td>\n</tr>\n<tr>\n<td>abc</td>\n<td>1</td>\n</tr>\n<tr>\n<td>hello</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>索引主要是用来加速数据库搜索的。两次B+树搜索时间一般都会远小于一个全表扫描搜索。</p>\n<p>**临时索引:**SQLite可以在执行SQL语句时使用order by或group by子句，或在聚合查询中进行except，或使用union或intersect进行复合选择，从而动态创建临时索引。临时索引会存储在临时文件中。</p>\n<h2 id=\"数据类型管理\"><a href=\"#数据类型管理\" class=\"headerlink\" title=\"数据类型管理\"></a>数据类型管理</h2><p>SQLite的数据处理是发生在VM模块的，这个模块驱动了后端在数据库中存储，检索数据。VM是数据库内存储的数据的唯一操作者；所有事情都是通过字节码的执行来控制的。它决定了在某个地方存储什么数据，以及在某个地方检索什么数据。给合适的数据分配合适的数据类型，并且做必要的数据转换都是VM的主要任务。有三个数据交换的地方可能会触发数据转换：从SQLite应用到引擎，从引擎到SQLite应用，从引擎到引擎。对于前两个情况，VM为用户数据分配数据类型，VM会尽可能将用户提供的数据转换为在列上声明的数据类型，反之亦然。对于后一种情况，表达式转换会引起数据转换。在下面三个小节中，我们讨论一下这三种数据转换。</p>\n<h3 id=\"指派类型给用户数据\"><a href=\"#指派类型给用户数据\" class=\"headerlink\" title=\"指派类型给用户数据\"></a>指派类型给用户数据</h3><p>之前已经讨论过表记录和索引记录的存储格式了。每一个记录的字段都有一个存储类型。应用层传递字段值给SQLite有两种方式:(1)嵌入在SQL语句中,(2)通过预处理绑定值。(VM也是通过执行表达式语句来分派字段值。)在VM执行预处理语句之前，它会给每一个输入的值分配一个存储类型。这个存储类型是用来将输入的数据编码为一个合适的屋里存储格式。</p>\n<p>VM通过三个步骤来决定一个输入值的存储类型：它首先确定输入数据的存储类型，然后确定列的声明的SQL类型，最后，如果需要，它再进行类型转换。在后面章节的讲述中，SQLite可能会在数字存储类型（INTEGER和REAL）与TEXT之间转换数据。(你可能注意到了，SQL标准里没有提供关于数据编码的指南，除了一些日期，时间和时间戳。)这些会在下面的章节中讨论。</p>\n<h4 id=\"决定存储类型\"><a href=\"#决定存储类型\" class=\"headerlink\" title=\"决定存储类型\"></a>决定存储类型</h4><p>SQLite是‘无类型’的，例如，没有预约束。(SQLite开发者团队希望一直是无类型的。)无类型允许在任何表里面存储任何数据类型，而不用在意那一列声明的是什么数据类型。(除了声明了INTEGER PRIMARY KEY的，这一列只能存储整型，其他类型的VM都会拒绝。)SQLite允许在创建语句中无SQL类型声明。例如<code>create table T1(a,b,c)</code>在SQLite中其实是一个有效的SQL语句。那现在的问题是，VM是如何在一个值存入指定列的时候为它分配具体的数据类型的呢？</p>\n<p>VM按照如下的步骤来给用户输入的数据分配一个初始化的存储类型。正如前面提到的，有两种方法给SQLite提供输入数据。</p>\n<ol>\n<li><p>如果一个值是嵌入SQL语句中提供的，那么会被指派为一下数据类型之一:</p>\n<ul>\n<li>如果值被单双引号包含，那么指派为TEXT</li>\n<li>如果值是不带小数点或指数的，不带引号的数字，那么指派为INTEGER</li>\n<li>如果值是带小数点或指数的不带引号的数字，那么指派为REAL</li>\n<li>如果值是字符串NULL，且周围没有引号，那么指派为NULL</li>\n<li>如果使用X’ABCD’标记指定值，那么指派为BLOB(ABCD是十六进制数字)</li>\n</ul>\n<p> 否则输入的值将会被VM拒绝，并且查询将会失败。</p>\n</li>\n<li><p><code>sqlite3_bind_*</code>API方法中提供的SQL参数值将会指派为与原生类型最接近的数据类型。例如，<code>sqlite3_bind_blob</code>绑定了一个存储类型为BLOB的值。</p>\n</li>\n</ol>\n<p>SQL标量运算符结果的值的存储类型取决于表达式的最外层运算符。用户定义的函数可以返回任何存储类型的值。通常在SQL语句的预处理阶段无法确定表达式结果的类型。VM在运行时一获取值就会分配存储类型。</p>\n<h4 id=\"决定列的相似关联性\"><a href=\"#决定列的相似关联性\" class=\"headerlink\" title=\"决定列的相似关联性\"></a>决定列的相似关联性</h4><p>SQLite允许在任何一列存储任一类型的数据。因此数据类型和数据值存在一起。其他SQL数据库引擎使用限制性更强的静态类型，其中类型与容器关联，而不与值关联。SQLite更具有灵活性。为了最大程度地提高SQLite与其他数据库引擎之间的兼容性，SQLite支持在列上使用类型相似性的概念。每一个输入的值可能具有SQL语句声明的类型的一个相关联的类型。对于该列中存储的值，建议使用列类型的相似类型：”建议使用，不是必需的”。</p>\n<p>某一个列优先使用的值的类型，称之为这个列的关联类型。列的关联类型和列的声明类型是不一样的，尽管前者还是由后者派生而来。每一个列有以下5种相似类型的其中一个:TEXT,NUMERIC,INTEGER,REAL和NONE。根据<code>CREATE TABLE</code>语句中声明的SQL类型，SQLite遵循以下的规则，来决定某个列的关联类型。</p>\n<ol>\n<li>如果SQL类型包含子字符串INT，则该列具有INTEGER关联。</li>\n<li>如果SQL类型包含任何子字符串CHAR，BLOB或TEXT，则该列具有TEXT关联性。 （SQL类型VARCHAR包含字符串CHAR，因此也具有TEXT关联性。）</li>\n<li>如果SQL类型包含子字符串BLOB，或者未指定类型，则列具有NONE关联。</li>\n<li>如果SQL类型包含任何子串REAL，FLOA或DOUB，则列具有REAL关联。</li>\n<li>除此之外, 列具有NUMERIC关联。</li>\n</ol>\n<p>VM会按照上面给出的顺序来评估这个规则。模式匹配不区分大小写。例如，如果声明的列的SQL类型为BLOBINT，则关联性为INTEGER，而不是NONE。</p>\n<p>**注意:**如果使用<code>create table table1 as select ...</code>语句创建了SQL表，每列的声明类型由create table语句的select部分中相应表达式的相关联类型确定。如果一个表达式的关联类型是text, numeric, integer, real, 或 none，那么声明的类型分别就是text, num, int, real, 或 “”。每个此类列的默认值为SQL NULL。隐式rowid的类型始终是整数，不能为NULL。</p>\n<h4 id=\"数据转换\"><a href=\"#数据转换\" class=\"headerlink\" title=\"数据转换\"></a>数据转换</h4><p>SQLite在关联类型和存储类型之间定义了一种关系。如果用户给某一列提供的数据不满足这个关系，那么这个值就会拒绝或者转换为一个合适的格式。当一个值即将被插入到一列的时候，VM首先会给这个值指派一个最合适的存储类型，然后来决定存入的这个列的关联类型，最后再尝试将这个初始的存储类型转换为这个列的关联类型。它会按照如下规则转换:</p>\n<ol>\n<li>具有TEXT关联关系的列可以存储所有NULL,TEXT,BLOB存储类型的数据。如果一个数字类型的(整型或者浮点型)被插入的时候，这个数字会被转换为文本类型，那么它的最终存储类型就会变成TEXT。</li>\n<li>一个具有NUMERIC关联类型的列可以存储所有的5种类型。当一个文本类型的数据插入到这一列的时候，VM会尝试把这个文本转换为整型或者浮点型。如果这个转换是成功的(无损且可逆)，那么这个转换的值就会相应的使用整型和浮点型的存储类型。如果这个转换无法执行的话，那么这个值就会以TEXT的存储类型来存储。VM不会尝试转换NULL或者BLOB值。</li>\n<li>一个具有INTEGER关联类型的列和上面的NUMERIC的行为一致，除了一种情况:当一个没有小数部分的浮点型值或者一个文本值，VM会把这个值转换为整型并且存储的最终存储类型为INTEGER。</li>\n<li>一个具有REAL关联类型的列和上面的NUMERIC的行为一致，除了一种情况:他会强制转换一个整型的值为一个浮点数。(但是，SQLite会做一个优化，只在磁盘上存储整数，等待读出数据的时候才会转换为浮点数)</li>\n<li>一个具有NONE关联类型的列可以存储所有的5种类型，并且不会转换任何类型。</li>\n</ol>\n<p>**注意:**所有的SQL数据库引擎都会转换数据类型。这些数据库都是类型强要求的，但SQLite可以是不是强要求的。举个例子，如果你有个表的列声明了SQL类型为整型的并且尝试插入一个字符串(“123”或”abc”),那么VM会分析这个字符串看看是否像一个数字。如果看起来像是一个数字，那么它就会被转换为一个数字(如果没有小数部分，会被转换为一个整型)。如果不是一个数字的格式，那么就会以TEXT的数据类型存储。一个具有TEXT关联类型的会尝试把输入数字以ASCII编码的形式存储。</p>\n<h4 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h4><p>从一个简单的例子来看存储类型，关联类型和类型转换。下面是一个典型的字段无类型的图表。假设你在这个表内执行了一个插入的语句。表格里也同样描述了插入到T1表B+树的记录。输入值(a,b,c)初始化的存储类型分别是整型，NULL和文本。所有列的关联类型都是NONE，并且VM不会转换初始化存储类型。在图里，这个记录(头+数据项)包含了11个字节。(记录里所有的数字都是以十六进制给出的。上面提及到SQLite不会重排序每列的位置:和创建语句中的顺序保持一致。)</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/07/KZKZlm.png\"></p>\n<ol>\n<li>头部有四个字节:第一个字节是头部的大小，加上三个字节分别是每一个值的类型。</li>\n<li>类型1的数字是2，代表2个字节的有符号整型。</li>\n<li>类型2的数字是0，代表NULL。</li>\n<li>类型3的数字是22，代表(22-12)&#x2F;2&#x3D;5个字节的字符串。</li>\n<li>数据1是2个字节的整型00B1,值是177。(一个字节是无法表示177的，因为B1的值是-79)</li>\n<li>数据2是NULL，不占据数据段的任何空间。</li>\n<li>数据3是5个字节的字符串 68 65 6C 6C 6F。忽略了终止符。</li>\n</ol>\n<h4 id=\"列关联性的例子\"><a href=\"#列关联性的例子\" class=\"headerlink\" title=\"列关联性的例子\"></a>列关联性的例子</h4><p>考虑下面的场景：有SQL语句<code>create table T1(t TEXT,n NUMERIC,i INTEGER, r REAL,b BLOB)</code>创建了一个表。假设执行如下的SQL语句：<code>insert into T1 values(&#39;1.0&#39;, &#39;1.0&#39;, &#39;1.0&#39;, &#39;1.0&#39;, &#39;1.0&#39;)</code>。所有值的初始化存储类型都是TEXT，因为他们都是有单引号的。基于之前给出的规则，列t,n,i,r,b的关联类型分别是TEXT，NUMERIC，INTEGER，REAL 和 NONE。那t,n,i,r,b几个列的最终的存储类型是TEXT，INTEGER，INTEGER，REAL 和 TEXT。对于NUMERIC关联类型，’1.0’看起来像是一个整型1，因此它的最终存储类型就是整型。而关联性为NONE的列不会做任何的数据类型转换，因此，依旧会把初始化类型存入。假设再执行<code>insert into T1 values(1.0, 1.0, 1.0, 1.0, 1.0)</code>。所有值的初始化存储类型都是REAL，并且最终的存储类型分别是TEXT，INTEGER，INTEGER，REAL 和 REAL。对于TEXT列，1.0会被转换为文本”1.0”作为TEXT存储类型。假设再执行<code>insert into T1 values(1, 1, 1, 1, 1)</code>。所有值的初始化存储类型都是INTEGER，并且最终的存储类型分别是TEXT, INTEGER, INTEGER, REAL 和 INTEGER。你可以在<a href=\"http://www.sqlite.org/datatype3.html.\">这个网站上</a>找到更多关于列关联性类型的例子。</p>\n<h4 id=\"其他相似关联性的模式\"><a href=\"#其他相似关联性的模式\" class=\"headerlink\" title=\"其他相似关联性的模式\"></a>其他相似关联性的模式</h4><p>上面小节中讨论的是数据库引擎在’通常’和默认关联模式下的数据库操作。SQLite支持另外两种关联性模式相关的特性。</p>\n<ul>\n<li><strong>严格关联模式</strong> 在和这个模式下，如果需要在初始存储类型和关联类型之间进行转换，引擎就会返回一个错误，并且当前的语句执行就会失败。</li>\n<li><strong>无关联模式</strong> 在这个模式下，VM不会做任何的存储类型的转换。</li>\n</ul>\n<h3 id=\"给应用层转换引擎的数据\"><a href=\"#给应用层转换引擎的数据\" class=\"headerlink\" title=\"给应用层转换引擎的数据\"></a>给应用层转换引擎的数据</h3><p>应用层可以通过调用<code>sqlite3_column_*</code>API方法来从SQLite引擎中读取数据。这些方法在合适的地方会尝试转换数据值。举个例子，如果内部的表示是REAL，但是通过API<code>sqlite3_column_text</code>方法请求了一个字符串值，VM会使用sprintf()库方法内部做一个转换，并且把值返回给应用层。下面的表展示了VM应用在内部数据的转换规则。</p>\n<table>\n<thead>\n<tr>\n<th>内部类型</th>\n<th>请求类型</th>\n<th>转换</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NULL</td>\n<td>INTEGER</td>\n<td>返回结果为0</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>FLOAT</td>\n<td>返回结果为0</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>TEXT</td>\n<td>返回结果是NULL指针</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>BLOB</td>\n<td>返回结果是NULL指针</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>FLOAT</td>\n<td>从整型转换为浮点型</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>TEXT</td>\n<td>通过ASCII码转换</td>\n</tr>\n<tr>\n<td>INTEGER</td>\n<td>BLOB</td>\n<td>和上面一样</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>INTEGER</td>\n<td>从浮点型转换为整型</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>TEXT</td>\n<td>通过ASCII转换</td>\n</tr>\n<tr>\n<td>FLOAT</td>\n<td>BLOB</td>\n<td>和上面一样</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>INTEGER</td>\n<td>使用atoi()</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>FLOAT</td>\n<td>使用atof()</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>BLOB</td>\n<td>没有变更</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>INTEGER</td>\n<td>先转换为TEXT然后使用atoi()</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>FLOAT</td>\n<td>先转换为TEXT然后使用atof()</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>TEXT</td>\n<td>如果需要的话在后面增加一个\\000</td>\n</tr>\n</tbody></table>\n<h3 id=\"为表达式指派数据类型\"><a href=\"#为表达式指派数据类型\" class=\"headerlink\" title=\"为表达式指派数据类型\"></a>为表达式指派数据类型</h3><p>VM可能先转换内部数据，然后再将内部数据与另一个内部数据进行比较或者评估表达式，在后面的章节中，我们将讨论VM是如何处理内部数据的。</p>\n<h4 id=\"处理SQL-NULL值\"><a href=\"#处理SQL-NULL值\" class=\"headerlink\" title=\"处理SQL NULL值\"></a>处理SQL NULL值</h4><p>SQL NULL值可以在任何一个表列使用，除了主键列。NULL值的存储类型是NULL。无论它们的存储类型是什么，NULL值与这个列的所有其他有效值都不同。SQL标准对于如何处理表达式中列的NULL值不是很具体。根据标准还尚不清楚在各种情况下应如何正确处理NULL值。例如，我们如何比较NULL和其他值？SQLite以许多其他RDBMS一样的方式处理NULL。在SELECT DISTINCT语句，使用UNION操作符的SELECT的组合语句，和GROUP BY语句中NULL是一样的。但是，NULL在UNIQUE列中却是不同的。NULL由SQL标准指定的内置SUM函数处理。对NULL进行算术运算的结果始终是NULL。</p>\n<h4 id=\"表达式中的类型\"><a href=\"#表达式中的类型\" class=\"headerlink\" title=\"表达式中的类型\"></a>表达式中的类型</h4><p>SQLite支持四种比较操作符：</p>\n<ul>\n<li>二元比较运算符 &#x3D;, &#x3D;&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, &lt;&gt;, 和 !&#x3D;</li>\n<li>三元比较运算符 ‘BETWEEN’</li>\n<li>成员运算符 ‘IN’ 和 ‘NOT IN’</li>\n<li>判空操作符 ‘IS NULL’ 和 ‘IS NOT NULL’</li>\n</ul>\n<p>**注意:**判空操作符’IS NULL’和’IS NOT NULL’分别和’&#x3D;’和’!&#x3D;’操作符一样。</p>\n<p>根据以下规则，比较的结果取决于要比较的两个值的存储类型：</p>\n<ol>\n<li>如果运算符左侧的值是NULL，那么这个NULL一般都会认为比其他的小。（如果其他的值中有NULL，也是认为左侧的小）</li>\n<li>INTEGER或REAL比TEXT或BLOB值小。</li>\n<li>如果INTEGER或REAL和另一个INTEGER或REAL比较，那么就是常规的数字比较了。</li>\n<li>TEXT值比BLOB值小。</li>\n<li>如果两个TEXT值比较，那么就是使用标准C库的memcmp函数来比较。但是这个函数是可以被用户自定义的函数重写的。</li>\n<li>当两个BLOB比较的时候，始终使用memcmp函数比较。</li>\n</ol>\n<p>在应用这些规则之前，VM的首要任务是确定比较运算符的操作数的存储类型。它首先确定操作数的初步存储类型，然后（如有必要）根据它们的列的关联性转换类型。最后，它使用以上四个规则进行比较。</p>\n<p>如果一个表达式是某个列，或者是使用别名指向的某个列，或者是一个子查询返回的一个列，或者是rowid，那么这个这个表达式的关联性就会使用列的关联性。否则，这个表达式没有SQL类型，并且它的关联性是NONE。SQLite会尝试在比较运算之前，在（INTEGER和REAL）和TEXT之间做转换。对于二元比较，会在下列情况下完成(可以看expr.c文件中的sqlite3CompareAffinity方法)。这里说的表达式，是除了列值以外的任何SQL标量表达式或者纯文本。</p>\n<ul>\n<li>当两个列的值比较的时候，如果其中任何一列有NUMERIC关联性，那么这两个值会优先使用这个关联性。也就是说，VM尝试在比较之前转换其他列的值。</li>\n<li>当将列值与表达式的结果进行比较时，在进行比较之前，会将列的关联性同样应用于这个表达式的结果。</li>\n<li>比较两个表达式的值时，将不进行任何转换。按照上述标准规则比较这些值。例如，如果将字符串与数字进行比较，则数字将始终小于字符串。</li>\n</ul>\n<p>在SQLite中表达式<code>a BETWEEN b AND c</code>等价于<code>a &gt;= b AND a &lt;= c</code>，但是在两次的比较中，a列的关联性会不一样。</p>\n<p>对于表达式<code>a IN (SELECT b ...)</code>来说，就会使用上面提到的 &#x3D; 号的二元操作符的规则来处理(例如,a&#x3D;b)。举个例子，如果b是一个列的值，a是一个表达式，那么在比较之前b的关联性就会被应用到a上。SQLite处理表达式<code>a IN (x,y,z)</code>和处理<code>a = x OR a = y OR a = z</code>是一样的，但是a的关联性是不一样的。</p>\n<p>有些简单的例子，你可以在<a href=\"http://www.sqlite.org/datatype3.html\">这个网站</a>上找到更多例子。假设，你有一个通过<code>CREATE TABLE t1(a TEXT,b NUMERIC, c BLOB, d)</code>语句创建的表。你可以通过执行<code>INSERT INTO t1 VALUES(‘500’，‘500’，‘500’, 500)</code>插入一条记录。那么最终，a,b,c三列的存储类型就会变成TEXT，INTEGER，TEXT 和 INTEGER。</p>\n<ul>\n<li><code>SELECT a &lt; 600, a &lt; 60, a &lt; 40 FROM t1</code>，会把600,60和40转换为”600”,”60”和”40”，因为a列具有TEXT关联性，值就会被当做TEXT来比较。并且整个语句返回<code>1|1|0</code>作为输出，因为”500”比”600”和”60”小，但是比”40”大。</li>\n<li><code>SELECT b &lt; 40, b &lt; 60, b &lt; 600 FROM t1</code>不会转换任何值，会被当做普通的数字比较，那么就会返回<code>0|0|1</code></li>\n<li><code>SELECT c &lt; 40, c &lt; 60, c &lt; 600 FROM t1</code>不会转换任何值，因为c列是NONE关联类型。三个值(存储类型为NUMERIC)都比”500”小(存储类型为TEXT)，所以返回值为<code>0|0|0</code></li>\n<li><code>SELECT d &lt; 40, d &lt; 60, d &lt; 600 FROM t1</code>不会转换值，因为d的关联性是NUMERIC。返回<code>0|0|1</code>，因为存储的值都是整型比较。</li>\n</ul>\n<h4 id=\"操作符中的类型\"><a href=\"#操作符中的类型\" class=\"headerlink\" title=\"操作符中的类型\"></a>操作符中的类型</h4><p>所有的数学运算符(除了 || 串联运算符以外)都将NUMERIC关联到所有的操作数上，并求值。如果所有操作数都无法转换为NUMERIC，那么运算结果为NULL。对于串联运算符来说，TEXT将关联到两个操作数上。如果任何一个操作数都无法转换为TEXT(NULL或者BLOB)，那么串联的结果为NULL。</p>\n<h4 id=\"order-by中的类型\"><a href=\"#order-by中的类型\" class=\"headerlink\" title=\"order by中的类型\"></a>order by中的类型</h4><p>当值被ORDER BY语句排序的时候，在排序之前不会有存储类型的转换。遵循先前规定的标准比较规则：NULL在最前面，然后是按值大小的INTEGER和REAL，再然后是TEXT，最后是BLOB，后面两个通常是memcmp()排序顺序。同样的文本排序方法可以被用户定义的函数重写。</p>\n<h4 id=\"group-by中的类型\"><a href=\"#group-by中的类型\" class=\"headerlink\" title=\"group by中的类型\"></a>group by中的类型</h4><p>当值被GROUP BY语句分组的时候，在分组之前不会有存储类型的转换。具有不同存储类型的值被认为是不同的，但INTEGER和REAL值除外，如果它们在数值上相等，则被视为相等。GROUP BY语句的结果中也不会做任何的存储类型的转换。</p>\n<h4 id=\"组合SELECTs中的类型\"><a href=\"#组合SELECTs中的类型\" class=\"headerlink\" title=\"组合SELECTs中的类型\"></a>组合SELECTs中的类型</h4><p>复合SELECT操作符(UNION，INTERSECT和EXCEPT)，在值之间进行隐式比较。在比较之前，VM不会执行任何关联类型转换。它们就按照原始值进行比较。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>VM模块是后端数据库引擎。数据操作逻辑就在这个模块内。它会执行一个使用特殊的字节码语言编写的程序。（类似于其他汇编语言）一个字节码程序实际上就是字节码指令的线性组合。一个字节码指令可以有一个操作码和最多5个操作数或者持有操作数的寄存器组成。</p>\n<p>一个<code>Vdbe</code>对象代表了一个由前端生成的字节码程序(在内部是一个<code>sqlite3_stmt</code>指针)。应用层可以在这个对象上执行SQLite API方法。举个例子，当应用层执行<code>sqlite3_step</code>API方法的时候，它会循环迭代执行这个程序，一直执行遇到终止或者遇到一个可以输出的结果记录。</p>\n<p>VM支持五种数据类型：integer,real,text,blob和SQL NULL。在数据库文件或者内存中的数据必须是这五种之一。这个类型称之为存储类型。当需要的时候，VM会做类型的转换。应用程序可以使用typeof SQL函数来确定值的数据类型。</p>\n<p>VM是数据的唯一操作者。它维护表和索引树中的记录。这两者的记录格式很相似。SQLite使用一个可变长度的记录格式。它使用清单类型来表示记录中的单个值。这个清单类型是指，每一个数据的存储类型信息都被存在记录中了。此方案允许在任何列中存储任何存储类型的值，而与该列的声明的SQL类型无关，但有一个例外，即整数主键列仅存储整数值。值的存储类型被编码为整数，并且该整数还编码该值的（字节）长度。每个表记录均以头部大小（即可变长度的霍夫曼代码）开头，然后是数据值的清单类型，然后是各个数据值。</p>\n<p>数据类型管理在SQLite中有点复杂。SQLite根据声明的SQL类型为列分配关联类型。首先尝试将输入数据值转换为关联类型。如果转换失败，则原始值仍将存储在该列中。 SQLite进行类似的数据转换来评估表达式和函数。</p>"},{"title":"oc中@synchronized的性能瓶颈","date":"2019-12-19T16:00:00.000Z","top":400,"_content":"\n## @synchronized是什么？\n\n一般来说OC上的语法糖，都可以使用 `clang --rewrite-objc code.m` 让clang 编译为 c 或 c++ ，由此可以窥探这些语法糖的具体实现(但是实际上XCode在编译的时候，并不会有rewrite的这个过程)。例如，[oc的block](https://caio.ink/oc-block-imp/)，@autoreleasepool，@synchronized等等\n\n<!-- more -->\n\n写一个简单的例子:\n```c\nint main(int argc, const char * argv[]) {\n    NSObject *o = [NSObject new];\n    @synchronized (o) {\n        NSLog(@\"helloworld\");\n    }\n}\n```\n\nclang 重写后:\n```c\nint main(int argc, const char * argv[]) {\n    NSObject *o = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"new\"));\n    {\n        id _rethrow = 0;\n        id _sync_obj = (id)o;\n\t\t\n        objc_sync_enter(_sync_obj);\n\t\t\n        try {\n            struct _SYNC_EXIT {\n                _SYNC_EXIT(id arg) : sync_exit(arg) {}\n                ~_SYNC_EXIT()\n                {\n                    objc_sync_exit(sync_exit);\n                }\n                id sync_exit;\n            } _sync_exit(_sync_obj);\n\n            NSLog((NSString *)&__NSConstantStringImpl__var_folders_vt_qgsk8yps0js52hgrjtwg9ch80000gn_T_main2_73ab4e_mi_0);\n        } catch (id e) {\n            _rethrow = e;\n        }\n\t\t\n        {\n            struct _FIN {\n                _FIN(id reth) : rethrow(reth) {}\n                ~_FIN() {\n                    if (rethrow)\n                        objc_exception_throw(rethrow);\n                }\n                id rethrow;\n            } _fin_force_rethow(_rethrow);\n        }\n    }\n}\n```\n\n代码比较清晰：\n1. `@synchronized` 整个代码块都被try包裹。\n2. 执行try的之前调用 `objc_sync_enter(_sync_obj)` 进行加锁。\n3. try代码块内先构建一个C++对象，C++对象的构造器内会传入\"被加锁\"的对象，并且被这个C++对象持有。\n4. try代码块结束的时候，也就是C++对象析构的时候，会调用`objc_sync_exit(sync_exit)`，解锁这个\"被加锁\"的对象。\n5. 最终在`@synchronized` 代码块结束的时候，如果catch了异常就再原样把异常抛出去。\n\n> 上面描述的时候，对`被加锁`三个字加了引号。OC对象可以被加锁么？先暂且这么说，后文再对此进行解释。\n\n那么现在问题就转变为：\n1. objc_sync_enter(obj); 加锁\n2. objc_sync_exit(obj); 解锁\n\n### objc_sync_enter 和 objc_sync_exit\n\n在`libobjc.A.dylib`(就是俗称的Runtime)中，有一个 objc-sync.h/.m 文件 实现了这两个函数。\n\n```c\nint objc_sync_enter(id obj)\n{\n    int result = OBJC_SYNC_SUCCESS;\n\n    if (obj) {\n        SyncData* data = id2data(obj, ACQUIRE);\n        data->mutex.lock();\n    } else {\n        // @synchronized(nil) does nothing\n    }\n\n    return result;\n}\n\nint objc_sync_exit(id obj)\n{\n    int result = OBJC_SYNC_SUCCESS;\n    \n    if (obj) {\n        SyncData* data = id2data(obj, RELEASE); \n        if (!data) {\n            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;\n        } else {\n            bool okay = data->mutex.tryUnlock();\n            if (!okay) {\n                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;\n            }\n        }\n    } else {\n        // @synchronized(nil) does nothing\n    }\n\t\n    return result;\n}\n```\n\n这个代码也很容易理解，通过`id2data`,取到与 obj 对应的 `SyncData`,然后对这个数据结构中的 mutex 进行加解锁操作。也就是说`@synchronized`加锁的对象是与oc对象绑定的一个mutex锁？\n\n## id2data\n\n在描述具体实现之前，需要了解以下几个结构体：\n#### SyncData\n```c\ntypedef struct alignas(CacheLineSize) SyncData {\n    struct SyncData* nextData;\n    DisguisedPtr<objc_object> object;\n    int32_t threadCount;  // number of THREADS using this block\n    recursive_mutex_t mutex;\n} SyncData;\n```\n1. SyncData是用来描述每一个\"被加锁\"的对象。\n2. SyncData是一个链表，由nextData指向下一个节点。\n3. object指向这个\"被加锁\"的对象。\n4. threadCount记录了正在使用这个节点对象的线程（当没有线程使用这个节点的时候，它才会被释放）。这里的使用是指已经加锁，或者正在等待锁。\n5. mutex 递归锁(os_unfair_recursive_lock),真正加锁、解锁的锁对象。\n\n#### SyncCache\n```c\ntypedef struct SyncCache {\n    unsigned int allocated;\n    unsigned int used;\n    SyncCacheItem list[0];\n} SyncCache;\n```\n1. SyncCache 是存储在TLS(本地线程存储)中的，用来记录当前线程所有已经持有锁的`SyncData`。（排除TLS中快速缓存的那一个，下文会具体说）\n2. list是一个`SyncCacheItem`数组,`SyncCacheItem`里就只有两个东西，一个是`SyncData`，另一个就是lockCount，lockCount记录了当前线程对这个对象加锁次数。（@synchronized是一个可重入的递归锁）\n3. allocated是已分配的cache大小，used是已使用大小。默认情况下，每个线程首次创建的时候会有4个size的容量。当每次插槽不够的时候会指数级扩大这个大小。\n\n\nid2data的代码比较长，简单来说这个方法的目的就是，获取到这个id对象所对应(绑定)的SyncData,然后...调用syncData.mutex.lock()\n\n**那么这个SyncData在哪呢？应该怎么去取它呢？**\n\n简单概括一下：\n1. `TLS`:大部分情况下，开发者在某一个线程对某一个对象的同步锁中，再嵌套其他对象的同步锁的概率，要远低于只用一个同步锁。（**其实有多个锁嵌套的时候，这时候是不是应该要考虑代码结构有问题了**）所以苹果在设计这个锁的时候，会优先在`TLS`中预留一个`SyncData`。即优先向`TLS`中读取或者写入，注释上称它为fast cache。\n2. `SyncCache`中:上面已经提及，对于每一个线程已经获得的锁，都会在`TLS`中存储的`SyncCache`结构体中。`SyncCache`中的数组存储的就是当前线程已经获取的锁对应的`SyncData`了。\n3. 全局数据中： 如果在1，2中都没有找到，那么说明当前线程尚未对这个对象持有锁。`static StripedMap<SyncList> sDataLists`这个全局数据结构记录了进程内所有已经被持有同步锁或者曾经被持有过的对象。`sDataList`是个重写的Map，key是同步锁对象，value是`SyncList`。\n\n说明一下这个 aDataLists：\n- StripedMap通过对key(id对象)的地址做一了一系列偏移和对mapsize的求模操作，把对象散列在64个（iPhone上是8个）插槽中。每个插槽内是一个`SyncData`链表，即`SyncList`结构体。`SyncList`内有一个`spinlock_t`,也就是对这个链表进行操作的时候的锁。\n- 另外如果在StripedMap没有找到这个对象，那么会从SyncList中找一个已经释放的`SyncData`(threadCount==0，即既没有线程持有，也没有线程在等待)来复用\n\n\n最后总结一下`id2data`这个函数的操作步骤：\n1. 通过 `SYNC_DATA_DIRECT_KEY`和`SYNC_COUNT_DIRECT_KEY`这两个key优先从TLS中查询`SyncData`,根据操作类型（加、解）分别修改TLS中的值，返回`SyncData`。\n2. 通过遍历TLS中的`SyncCache`数组，找到该对象的`SyncData`，根据操作类型（加、解）分别修改`SyncCacheItem`中的lockCount，返回`SyncData`。\n3. 1，2都没有，那么去找其他线程已经持有或者曾经被持有过同步锁的`SyncData`对象：从`sDataLists`中找到当前需要加同步锁对象对应散列的插槽`SyncList`，从`SyncList`中找到这个对象对应的或者复用的`SyncData`。\n4. 如果第3步都没有找到（说明是整个进程内第一次加锁），那就创建一个`SyncData`。并且加到`SyncList`的队首。\n5. 如果`TLS`中`SYNC_DATA_DIRECT_KEY`是空的，那么优先保存。**否则**保存到`SyncCache`中\n\n注:\n1，2两步骤中在lockCount减小到0的时候，也就是当前线程需要释放SyncData（实际并不会释放）的时候。会同时修改`SyncData`中的threadCount,这个操作必须是原子操作。因为前者操作必然是在当前线程，但是后者操作可能是多线程的。（以及3步骤中，在持有并返回其他线程已经加同步锁的`SyncData`对象。）\n\n### @synchronized的性能到底差在哪？？\n\n很多文章在对比各种锁的性能，都提到了@synchronized性能是最差的。那么到底差在哪呢？\n\n上文已经具体分析了@synchronized的所有实现逻辑了，但是可能并没有一个概念，到底差在哪？\n\n怀疑以下的两个点：\n1. `id2data`即在`TLS`,`SyncCache`,`sDataLists`寻找对应同步锁对象的过程\n2. `SyncData`中的锁。\n\n先做一个实验对比一下同步锁有多慢。\n\n**以下实验只是为了做一个定性的分析，所有数据只提供一个参考。**\n\n```c\nvoid main(){\n\t\tNSObject *t = [NSObject new];\n\t\tuint64_t pre = mach_absolute_time();\n        int count = 0;\n        for (int index = 0; index < 10000000; index++) {\n            @synchronized (t) {\n                count ++;\n            }\n        }\n        uint64_t now = mach_absolute_time();\n        uint64_t deltaA = now-pre;\n        NSLog(@\"synchronized count:%d time:%llu\", count, deltaA/1000000);\n\t\n        uint64_t pre1 = mach_absolute_time();\n        count = 0;\n        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n        for (int index = 0; index < 10000000; index++) {\n            pthread_mutex_lock(&mutex);\n            count ++;\n            pthread_mutex_unlock(&mutex);\n        }\n\t\n        uint64_t now1 = mach_absolute_time();\n\t\n        uint64_t deltaB = now1-pre1;\n        NSLog(@\"count:%d time:%llu\", count, deltaB/1000000);\n}\n```\n分别对 pthread_mutex 和 synchronized 加锁 一百万次。\npthread_mutex:200ms\nsynchronized:6800ms\n\n似乎...em...差了不是一点点呢...\n\n因为上面的测试代码中，同步锁，每一次循环都会执行一遍`加锁..存入TLS..释放..从TLS移除`。我们试试在最外层套一个同步锁,这样每次都会在`TLS`中命中。\n\n```c\nvoid main(){\n\t\tNSObject *t = [NSObject new];\n\t@synchronized(t){\n\t\tuint64_t pre = mach_absolute_time();\n        int count = 0;\n        for (int index = 0; index < 10000000; index++) {\n            @synchronized (t) {\n                count ++;\n            }\n        }\n        uint64_t now = mach_absolute_time();\n        uint64_t deltaA = now-pre;\n        NSLog(@\"synchronized count:%d time:%llu\", count, deltaA/1000000);\n\t\n        uint64_t pre1 = mach_absolute_time();\n        count = 0;\n        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n        for (int index = 0; index < 10000000; index++) {\n            pthread_mutex_lock(&mutex);\n            count ++;\n            pthread_mutex_unlock(&mutex);\n        }\n\t\n        uint64_t now1 = mach_absolute_time();\n\t\n        uint64_t deltaB = now1-pre1;\n        NSLog(@\"count:%d time:%llu\", count, deltaB/1000000);\n\t}\n}\n```\npthread_mutex:200ms\nsynchronized:2700ms\n\n似乎..快了..不少呢..\n\n但是这样测试下去，没法获得准确的结果。我们直接调试Runtime的源码，通过修改源码来“控制变量”。\n\n----\n这里有一个小插曲:\n\n在尝试通过修改源码的来实验的时候，`synchronized`的执行时间总是出奇的长。于是我把objc-sync.mm中 `objc_sync_enter` 和 `objc_sync_exit`方法改为空操作，直接返回。\n\n结果，synchronized的执行时间居然还维持在1000ms+。\n\n汇编代码显示，还有一个objc_retain方法。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/1ff8b0b7aa6cc03e763e5e3c693c19bf.png)\n\n也就是说，编译器在synchronized代码块中还会自动插入代码，持有这个同步锁对象。\n\n因为测试代码不涉及到多线程间对象的持有和释放，所有我们直接把它改为mrc。\n\n执行时间变为 40ms+，objc_retain也确实没有了。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/6c4e55e070f1d49f795e3a440fc2cffd.png)\n\n也就是说，引用计数占了1000ms+。以下实验均在mrc下\n\n#### 同步锁对象寻找过程\n\n修改源码，让 `objc_sync_enter` 和 `objc_sync_exit`方法只执行查询操作，不执行锁操作。\n\n整个查询过程的执行时间在 900ms+\n\n#### 锁过程\n\n同步锁最终还是使用的`SyncData`中的`os_unfair_recursive_lock`实现的递归锁。\n\n这个锁是苹果用来代替已废弃的 OSPinLock 的，OSPinLock让CPU空转，而不会让出时间片，在GCD的线程优先级上会出现饥饿或者死锁问题。具体的可以看[这篇文章](https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/)。\n\n`os_unfair_lock`锁的线程会处于休眠状态，从用户态切换到内核态，而并非忙等\n![](https://caio.ink/wp-content/uploads/2019/12/e9b18665440cf264a15213547cfc6860.png)\n\n直接测试一下，递归锁的加锁解锁效率。\n```c\ntypedef struct os_unfair_recursive_lock_s {\n    os_unfair_lock ourl_lock;\n    uint32_t ourl_count;\n} os_unfair_recursive_lock;\n```\n``` c\n        os_unfair_recursive_lock lock = ((os_unfair_recursive_lock){OS_UNFAIR_LOCK_INIT, 0});\n        os_unfair_recursive_lock *mlock = &lock;\n        for (int index = 0; index < 10000000; index++) {\n            os_unfair_recursive_lock_lock_with_options(&lock, 0x00000000);\n                count ++;\n            os_unfair_recursive_lock_tryunlock4objc(&lock);\n        }\n```\n\n如果只是锁的话，执行时间只有200ms。`os_unfair_lock`的执行效率比`pthread_mutex`略高。而且当执行次数越多，这个差距稳定在10%\n\n引用计数 1000ms+同步锁对象查询900ms+递归锁200ms = 2100ms\n\n距离第二次的实验还差500ms左右。500ms花费在哪？\n\nobjc-os.h有一个LOCKDEBUG的宏，在debug期间会有一些耗时判断，把宏关闭之后，上面的第二次实验的时间就从2900ms -> 2100ms左右，与上面的计算就对应上了。\n\n> 总结一下:\n1.synchronized同步锁使用的 os_unfair_lock 本身性能是不差的，甚至优于pthread_mutex。\n2.synchronized的性能，主要是花费在实现这个语法糖上。引用计数的管理和查找与对象绑定的同步锁消耗了绝大部分的时间。而且上面的实验我们还只是在TLS内操作了，如果一个线程内持有的同步锁个数越多，那么将花费在Cache上和全局数据内的查询时间也会更多。","source":"_posts/2019-12-20_synchronized.md","raw":"---\ntitle: oc中@synchronized的性能瓶颈\ndate: 2019-12-20\ntags: [object-c,锁]\ntop: 400\ncategories: 语法糖\n---\n\n## @synchronized是什么？\n\n一般来说OC上的语法糖，都可以使用 `clang --rewrite-objc code.m` 让clang 编译为 c 或 c++ ，由此可以窥探这些语法糖的具体实现(但是实际上XCode在编译的时候，并不会有rewrite的这个过程)。例如，[oc的block](https://caio.ink/oc-block-imp/)，@autoreleasepool，@synchronized等等\n\n<!-- more -->\n\n写一个简单的例子:\n```c\nint main(int argc, const char * argv[]) {\n    NSObject *o = [NSObject new];\n    @synchronized (o) {\n        NSLog(@\"helloworld\");\n    }\n}\n```\n\nclang 重写后:\n```c\nint main(int argc, const char * argv[]) {\n    NSObject *o = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"new\"));\n    {\n        id _rethrow = 0;\n        id _sync_obj = (id)o;\n\t\t\n        objc_sync_enter(_sync_obj);\n\t\t\n        try {\n            struct _SYNC_EXIT {\n                _SYNC_EXIT(id arg) : sync_exit(arg) {}\n                ~_SYNC_EXIT()\n                {\n                    objc_sync_exit(sync_exit);\n                }\n                id sync_exit;\n            } _sync_exit(_sync_obj);\n\n            NSLog((NSString *)&__NSConstantStringImpl__var_folders_vt_qgsk8yps0js52hgrjtwg9ch80000gn_T_main2_73ab4e_mi_0);\n        } catch (id e) {\n            _rethrow = e;\n        }\n\t\t\n        {\n            struct _FIN {\n                _FIN(id reth) : rethrow(reth) {}\n                ~_FIN() {\n                    if (rethrow)\n                        objc_exception_throw(rethrow);\n                }\n                id rethrow;\n            } _fin_force_rethow(_rethrow);\n        }\n    }\n}\n```\n\n代码比较清晰：\n1. `@synchronized` 整个代码块都被try包裹。\n2. 执行try的之前调用 `objc_sync_enter(_sync_obj)` 进行加锁。\n3. try代码块内先构建一个C++对象，C++对象的构造器内会传入\"被加锁\"的对象，并且被这个C++对象持有。\n4. try代码块结束的时候，也就是C++对象析构的时候，会调用`objc_sync_exit(sync_exit)`，解锁这个\"被加锁\"的对象。\n5. 最终在`@synchronized` 代码块结束的时候，如果catch了异常就再原样把异常抛出去。\n\n> 上面描述的时候，对`被加锁`三个字加了引号。OC对象可以被加锁么？先暂且这么说，后文再对此进行解释。\n\n那么现在问题就转变为：\n1. objc_sync_enter(obj); 加锁\n2. objc_sync_exit(obj); 解锁\n\n### objc_sync_enter 和 objc_sync_exit\n\n在`libobjc.A.dylib`(就是俗称的Runtime)中，有一个 objc-sync.h/.m 文件 实现了这两个函数。\n\n```c\nint objc_sync_enter(id obj)\n{\n    int result = OBJC_SYNC_SUCCESS;\n\n    if (obj) {\n        SyncData* data = id2data(obj, ACQUIRE);\n        data->mutex.lock();\n    } else {\n        // @synchronized(nil) does nothing\n    }\n\n    return result;\n}\n\nint objc_sync_exit(id obj)\n{\n    int result = OBJC_SYNC_SUCCESS;\n    \n    if (obj) {\n        SyncData* data = id2data(obj, RELEASE); \n        if (!data) {\n            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;\n        } else {\n            bool okay = data->mutex.tryUnlock();\n            if (!okay) {\n                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;\n            }\n        }\n    } else {\n        // @synchronized(nil) does nothing\n    }\n\t\n    return result;\n}\n```\n\n这个代码也很容易理解，通过`id2data`,取到与 obj 对应的 `SyncData`,然后对这个数据结构中的 mutex 进行加解锁操作。也就是说`@synchronized`加锁的对象是与oc对象绑定的一个mutex锁？\n\n## id2data\n\n在描述具体实现之前，需要了解以下几个结构体：\n#### SyncData\n```c\ntypedef struct alignas(CacheLineSize) SyncData {\n    struct SyncData* nextData;\n    DisguisedPtr<objc_object> object;\n    int32_t threadCount;  // number of THREADS using this block\n    recursive_mutex_t mutex;\n} SyncData;\n```\n1. SyncData是用来描述每一个\"被加锁\"的对象。\n2. SyncData是一个链表，由nextData指向下一个节点。\n3. object指向这个\"被加锁\"的对象。\n4. threadCount记录了正在使用这个节点对象的线程（当没有线程使用这个节点的时候，它才会被释放）。这里的使用是指已经加锁，或者正在等待锁。\n5. mutex 递归锁(os_unfair_recursive_lock),真正加锁、解锁的锁对象。\n\n#### SyncCache\n```c\ntypedef struct SyncCache {\n    unsigned int allocated;\n    unsigned int used;\n    SyncCacheItem list[0];\n} SyncCache;\n```\n1. SyncCache 是存储在TLS(本地线程存储)中的，用来记录当前线程所有已经持有锁的`SyncData`。（排除TLS中快速缓存的那一个，下文会具体说）\n2. list是一个`SyncCacheItem`数组,`SyncCacheItem`里就只有两个东西，一个是`SyncData`，另一个就是lockCount，lockCount记录了当前线程对这个对象加锁次数。（@synchronized是一个可重入的递归锁）\n3. allocated是已分配的cache大小，used是已使用大小。默认情况下，每个线程首次创建的时候会有4个size的容量。当每次插槽不够的时候会指数级扩大这个大小。\n\n\nid2data的代码比较长，简单来说这个方法的目的就是，获取到这个id对象所对应(绑定)的SyncData,然后...调用syncData.mutex.lock()\n\n**那么这个SyncData在哪呢？应该怎么去取它呢？**\n\n简单概括一下：\n1. `TLS`:大部分情况下，开发者在某一个线程对某一个对象的同步锁中，再嵌套其他对象的同步锁的概率，要远低于只用一个同步锁。（**其实有多个锁嵌套的时候，这时候是不是应该要考虑代码结构有问题了**）所以苹果在设计这个锁的时候，会优先在`TLS`中预留一个`SyncData`。即优先向`TLS`中读取或者写入，注释上称它为fast cache。\n2. `SyncCache`中:上面已经提及，对于每一个线程已经获得的锁，都会在`TLS`中存储的`SyncCache`结构体中。`SyncCache`中的数组存储的就是当前线程已经获取的锁对应的`SyncData`了。\n3. 全局数据中： 如果在1，2中都没有找到，那么说明当前线程尚未对这个对象持有锁。`static StripedMap<SyncList> sDataLists`这个全局数据结构记录了进程内所有已经被持有同步锁或者曾经被持有过的对象。`sDataList`是个重写的Map，key是同步锁对象，value是`SyncList`。\n\n说明一下这个 aDataLists：\n- StripedMap通过对key(id对象)的地址做一了一系列偏移和对mapsize的求模操作，把对象散列在64个（iPhone上是8个）插槽中。每个插槽内是一个`SyncData`链表，即`SyncList`结构体。`SyncList`内有一个`spinlock_t`,也就是对这个链表进行操作的时候的锁。\n- 另外如果在StripedMap没有找到这个对象，那么会从SyncList中找一个已经释放的`SyncData`(threadCount==0，即既没有线程持有，也没有线程在等待)来复用\n\n\n最后总结一下`id2data`这个函数的操作步骤：\n1. 通过 `SYNC_DATA_DIRECT_KEY`和`SYNC_COUNT_DIRECT_KEY`这两个key优先从TLS中查询`SyncData`,根据操作类型（加、解）分别修改TLS中的值，返回`SyncData`。\n2. 通过遍历TLS中的`SyncCache`数组，找到该对象的`SyncData`，根据操作类型（加、解）分别修改`SyncCacheItem`中的lockCount，返回`SyncData`。\n3. 1，2都没有，那么去找其他线程已经持有或者曾经被持有过同步锁的`SyncData`对象：从`sDataLists`中找到当前需要加同步锁对象对应散列的插槽`SyncList`，从`SyncList`中找到这个对象对应的或者复用的`SyncData`。\n4. 如果第3步都没有找到（说明是整个进程内第一次加锁），那就创建一个`SyncData`。并且加到`SyncList`的队首。\n5. 如果`TLS`中`SYNC_DATA_DIRECT_KEY`是空的，那么优先保存。**否则**保存到`SyncCache`中\n\n注:\n1，2两步骤中在lockCount减小到0的时候，也就是当前线程需要释放SyncData（实际并不会释放）的时候。会同时修改`SyncData`中的threadCount,这个操作必须是原子操作。因为前者操作必然是在当前线程，但是后者操作可能是多线程的。（以及3步骤中，在持有并返回其他线程已经加同步锁的`SyncData`对象。）\n\n### @synchronized的性能到底差在哪？？\n\n很多文章在对比各种锁的性能，都提到了@synchronized性能是最差的。那么到底差在哪呢？\n\n上文已经具体分析了@synchronized的所有实现逻辑了，但是可能并没有一个概念，到底差在哪？\n\n怀疑以下的两个点：\n1. `id2data`即在`TLS`,`SyncCache`,`sDataLists`寻找对应同步锁对象的过程\n2. `SyncData`中的锁。\n\n先做一个实验对比一下同步锁有多慢。\n\n**以下实验只是为了做一个定性的分析，所有数据只提供一个参考。**\n\n```c\nvoid main(){\n\t\tNSObject *t = [NSObject new];\n\t\tuint64_t pre = mach_absolute_time();\n        int count = 0;\n        for (int index = 0; index < 10000000; index++) {\n            @synchronized (t) {\n                count ++;\n            }\n        }\n        uint64_t now = mach_absolute_time();\n        uint64_t deltaA = now-pre;\n        NSLog(@\"synchronized count:%d time:%llu\", count, deltaA/1000000);\n\t\n        uint64_t pre1 = mach_absolute_time();\n        count = 0;\n        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n        for (int index = 0; index < 10000000; index++) {\n            pthread_mutex_lock(&mutex);\n            count ++;\n            pthread_mutex_unlock(&mutex);\n        }\n\t\n        uint64_t now1 = mach_absolute_time();\n\t\n        uint64_t deltaB = now1-pre1;\n        NSLog(@\"count:%d time:%llu\", count, deltaB/1000000);\n}\n```\n分别对 pthread_mutex 和 synchronized 加锁 一百万次。\npthread_mutex:200ms\nsynchronized:6800ms\n\n似乎...em...差了不是一点点呢...\n\n因为上面的测试代码中，同步锁，每一次循环都会执行一遍`加锁..存入TLS..释放..从TLS移除`。我们试试在最外层套一个同步锁,这样每次都会在`TLS`中命中。\n\n```c\nvoid main(){\n\t\tNSObject *t = [NSObject new];\n\t@synchronized(t){\n\t\tuint64_t pre = mach_absolute_time();\n        int count = 0;\n        for (int index = 0; index < 10000000; index++) {\n            @synchronized (t) {\n                count ++;\n            }\n        }\n        uint64_t now = mach_absolute_time();\n        uint64_t deltaA = now-pre;\n        NSLog(@\"synchronized count:%d time:%llu\", count, deltaA/1000000);\n\t\n        uint64_t pre1 = mach_absolute_time();\n        count = 0;\n        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n        for (int index = 0; index < 10000000; index++) {\n            pthread_mutex_lock(&mutex);\n            count ++;\n            pthread_mutex_unlock(&mutex);\n        }\n\t\n        uint64_t now1 = mach_absolute_time();\n\t\n        uint64_t deltaB = now1-pre1;\n        NSLog(@\"count:%d time:%llu\", count, deltaB/1000000);\n\t}\n}\n```\npthread_mutex:200ms\nsynchronized:2700ms\n\n似乎..快了..不少呢..\n\n但是这样测试下去，没法获得准确的结果。我们直接调试Runtime的源码，通过修改源码来“控制变量”。\n\n----\n这里有一个小插曲:\n\n在尝试通过修改源码的来实验的时候，`synchronized`的执行时间总是出奇的长。于是我把objc-sync.mm中 `objc_sync_enter` 和 `objc_sync_exit`方法改为空操作，直接返回。\n\n结果，synchronized的执行时间居然还维持在1000ms+。\n\n汇编代码显示，还有一个objc_retain方法。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/1ff8b0b7aa6cc03e763e5e3c693c19bf.png)\n\n也就是说，编译器在synchronized代码块中还会自动插入代码，持有这个同步锁对象。\n\n因为测试代码不涉及到多线程间对象的持有和释放，所有我们直接把它改为mrc。\n\n执行时间变为 40ms+，objc_retain也确实没有了。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/6c4e55e070f1d49f795e3a440fc2cffd.png)\n\n也就是说，引用计数占了1000ms+。以下实验均在mrc下\n\n#### 同步锁对象寻找过程\n\n修改源码，让 `objc_sync_enter` 和 `objc_sync_exit`方法只执行查询操作，不执行锁操作。\n\n整个查询过程的执行时间在 900ms+\n\n#### 锁过程\n\n同步锁最终还是使用的`SyncData`中的`os_unfair_recursive_lock`实现的递归锁。\n\n这个锁是苹果用来代替已废弃的 OSPinLock 的，OSPinLock让CPU空转，而不会让出时间片，在GCD的线程优先级上会出现饥饿或者死锁问题。具体的可以看[这篇文章](https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/)。\n\n`os_unfair_lock`锁的线程会处于休眠状态，从用户态切换到内核态，而并非忙等\n![](https://caio.ink/wp-content/uploads/2019/12/e9b18665440cf264a15213547cfc6860.png)\n\n直接测试一下，递归锁的加锁解锁效率。\n```c\ntypedef struct os_unfair_recursive_lock_s {\n    os_unfair_lock ourl_lock;\n    uint32_t ourl_count;\n} os_unfair_recursive_lock;\n```\n``` c\n        os_unfair_recursive_lock lock = ((os_unfair_recursive_lock){OS_UNFAIR_LOCK_INIT, 0});\n        os_unfair_recursive_lock *mlock = &lock;\n        for (int index = 0; index < 10000000; index++) {\n            os_unfair_recursive_lock_lock_with_options(&lock, 0x00000000);\n                count ++;\n            os_unfair_recursive_lock_tryunlock4objc(&lock);\n        }\n```\n\n如果只是锁的话，执行时间只有200ms。`os_unfair_lock`的执行效率比`pthread_mutex`略高。而且当执行次数越多，这个差距稳定在10%\n\n引用计数 1000ms+同步锁对象查询900ms+递归锁200ms = 2100ms\n\n距离第二次的实验还差500ms左右。500ms花费在哪？\n\nobjc-os.h有一个LOCKDEBUG的宏，在debug期间会有一些耗时判断，把宏关闭之后，上面的第二次实验的时间就从2900ms -> 2100ms左右，与上面的计算就对应上了。\n\n> 总结一下:\n1.synchronized同步锁使用的 os_unfair_lock 本身性能是不差的，甚至优于pthread_mutex。\n2.synchronized的性能，主要是花费在实现这个语法糖上。引用计数的管理和查找与对象绑定的同步锁消耗了绝大部分的时间。而且上面的实验我们还只是在TLS内操作了，如果一个线程内持有的同步锁个数越多，那么将花费在Cache上和全局数据内的查询时间也会更多。","slug":"2019-12-20_synchronized","published":1,"updated":"2022-07-28T13:38:40.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwoa0017p9c9a6a91ay3","content":"<h2 id=\"synchronized是什么？\"><a href=\"#synchronized是什么？\" class=\"headerlink\" title=\"@synchronized是什么？\"></a>@synchronized是什么？</h2><p>一般来说OC上的语法糖，都可以使用 <code>clang --rewrite-objc code.m</code> 让clang 编译为 c 或 c++ ，由此可以窥探这些语法糖的具体实现(但是实际上XCode在编译的时候，并不会有rewrite的这个过程)。例如，<a href=\"https://caio.ink/oc-block-imp/\">oc的block</a>，@autoreleasepool，@synchronized等等</p>\n<span id=\"more\"></span>\n\n<p>写一个简单的例子:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> * argv[])</span> &#123;</span><br><span class=\"line\">    NSObject *o = [NSObject new];</span><br><span class=\"line\">    @synchronized (o) &#123;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;helloworld&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>clang 重写后:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> * argv[])</span> &#123;</span><br><span class=\"line\">    NSObject *o = ((NSObject *(*)(id, SEL))(<span class=\"type\">void</span> *)objc_msgSend)((id)objc_getClass(<span class=\"string\">&quot;NSObject&quot;</span>), sel_registerName(<span class=\"string\">&quot;new&quot;</span>));</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id _rethrow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        id _sync_obj = (id)o;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        objc_sync_enter(_sync_obj);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">SYNC_EXIT</span> &#123;</span></span><br><span class=\"line\">                _SYNC_EXIT(id arg) : sync_exit(arg) &#123;&#125;</span><br><span class=\"line\">                ~_SYNC_EXIT()</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    objc_sync_exit(sync_exit);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                id sync_exit;</span><br><span class=\"line\">            &#125; _sync_exit(_sync_obj);</span><br><span class=\"line\"></span><br><span class=\"line\">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_vt_qgsk8yps0js52hgrjtwg9ch80000gn_T_main2_73ab4e_mi_0);</span><br><span class=\"line\">        &#125; catch (id e) &#123;</span><br><span class=\"line\">            _rethrow = e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">FIN</span> &#123;</span></span><br><span class=\"line\">                _FIN(id reth) : rethrow(reth) &#123;&#125;</span><br><span class=\"line\">                ~_FIN() &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (rethrow)</span><br><span class=\"line\">                        objc_exception_throw(rethrow);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                id rethrow;</span><br><span class=\"line\">            &#125; _fin_force_rethow(_rethrow);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码比较清晰：</p>\n<ol>\n<li><code>@synchronized</code> 整个代码块都被try包裹。</li>\n<li>执行try的之前调用 <code>objc_sync_enter(_sync_obj)</code> 进行加锁。</li>\n<li>try代码块内先构建一个C++对象，C++对象的构造器内会传入”被加锁”的对象，并且被这个C++对象持有。</li>\n<li>try代码块结束的时候，也就是C++对象析构的时候，会调用<code>objc_sync_exit(sync_exit)</code>，解锁这个”被加锁”的对象。</li>\n<li>最终在<code>@synchronized</code> 代码块结束的时候，如果catch了异常就再原样把异常抛出去。</li>\n</ol>\n<blockquote>\n<p>上面描述的时候，对<code>被加锁</code>三个字加了引号。OC对象可以被加锁么？先暂且这么说，后文再对此进行解释。</p>\n</blockquote>\n<p>那么现在问题就转变为：</p>\n<ol>\n<li>objc_sync_enter(obj); 加锁</li>\n<li>objc_sync_exit(obj); 解锁</li>\n</ol>\n<h3 id=\"objc-sync-enter-和-objc-sync-exit\"><a href=\"#objc-sync-enter-和-objc-sync-exit\" class=\"headerlink\" title=\"objc_sync_enter 和 objc_sync_exit\"></a>objc_sync_enter 和 objc_sync_exit</h3><p>在<code>libobjc.A.dylib</code>(就是俗称的Runtime)中，有一个 objc-sync.h&#x2F;.m 文件 实现了这两个函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">objc_sync_enter</span><span class=\"params\">(id obj)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class=\"line\">        data-&gt;mutex.lock();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// @synchronized(nil) does nothing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">objc_sync_exit</span><span class=\"params\">(id obj)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        SyncData* data = id2data(obj, RELEASE); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data) &#123;</span><br><span class=\"line\">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!okay) &#123;</span><br><span class=\"line\">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// @synchronized(nil) does nothing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个代码也很容易理解，通过<code>id2data</code>,取到与 obj 对应的 <code>SyncData</code>,然后对这个数据结构中的 mutex 进行加解锁操作。也就是说<code>@synchronized</code>加锁的对象是与oc对象绑定的一个mutex锁？</p>\n<h2 id=\"id2data\"><a href=\"#id2data\" class=\"headerlink\" title=\"id2data\"></a>id2data</h2><p>在描述具体实现之前，需要了解以下几个结构体：</p>\n<h4 id=\"SyncData\"><a href=\"#SyncData\" class=\"headerlink\" title=\"SyncData\"></a>SyncData</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title function_\">alignas</span><span class=\"params\">(CacheLineSize)</span> SyncData &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SyncData</span>* <span class=\"title\">nextData</span>;</span></span><br><span class=\"line\">    DisguisedPtr&lt;objc_object&gt; object;</span><br><span class=\"line\">    <span class=\"type\">int32_t</span> threadCount;  <span class=\"comment\">// number of THREADS using this block</span></span><br><span class=\"line\">    <span class=\"type\">recursive_mutex_t</span> mutex;</span><br><span class=\"line\">&#125; SyncData;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>SyncData是用来描述每一个”被加锁”的对象。</li>\n<li>SyncData是一个链表，由nextData指向下一个节点。</li>\n<li>object指向这个”被加锁”的对象。</li>\n<li>threadCount记录了正在使用这个节点对象的线程（当没有线程使用这个节点的时候，它才会被释放）。这里的使用是指已经加锁，或者正在等待锁。</li>\n<li>mutex 递归锁(os_unfair_recursive_lock),真正加锁、解锁的锁对象。</li>\n</ol>\n<h4 id=\"SyncCache\"><a href=\"#SyncCache\" class=\"headerlink\" title=\"SyncCache\"></a>SyncCache</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SyncCache</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> allocated;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> used;</span><br><span class=\"line\">    SyncCacheItem <span class=\"built_in\">list</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125; SyncCache;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>SyncCache 是存储在TLS(本地线程存储)中的，用来记录当前线程所有已经持有锁的<code>SyncData</code>。（排除TLS中快速缓存的那一个，下文会具体说）</li>\n<li>list是一个<code>SyncCacheItem</code>数组,<code>SyncCacheItem</code>里就只有两个东西，一个是<code>SyncData</code>，另一个就是lockCount，lockCount记录了当前线程对这个对象加锁次数。（@synchronized是一个可重入的递归锁）</li>\n<li>allocated是已分配的cache大小，used是已使用大小。默认情况下，每个线程首次创建的时候会有4个size的容量。当每次插槽不够的时候会指数级扩大这个大小。</li>\n</ol>\n<p>id2data的代码比较长，简单来说这个方法的目的就是，获取到这个id对象所对应(绑定)的SyncData,然后…调用syncData.mutex.lock()</p>\n<p><strong>那么这个SyncData在哪呢？应该怎么去取它呢？</strong></p>\n<p>简单概括一下：</p>\n<ol>\n<li><code>TLS</code>:大部分情况下，开发者在某一个线程对某一个对象的同步锁中，再嵌套其他对象的同步锁的概率，要远低于只用一个同步锁。（<strong>其实有多个锁嵌套的时候，这时候是不是应该要考虑代码结构有问题了</strong>）所以苹果在设计这个锁的时候，会优先在<code>TLS</code>中预留一个<code>SyncData</code>。即优先向<code>TLS</code>中读取或者写入，注释上称它为fast cache。</li>\n<li><code>SyncCache</code>中:上面已经提及，对于每一个线程已经获得的锁，都会在<code>TLS</code>中存储的<code>SyncCache</code>结构体中。<code>SyncCache</code>中的数组存储的就是当前线程已经获取的锁对应的<code>SyncData</code>了。</li>\n<li>全局数据中： 如果在1，2中都没有找到，那么说明当前线程尚未对这个对象持有锁。<code>static StripedMap&lt;SyncList&gt; sDataLists</code>这个全局数据结构记录了进程内所有已经被持有同步锁或者曾经被持有过的对象。<code>sDataList</code>是个重写的Map，key是同步锁对象，value是<code>SyncList</code>。</li>\n</ol>\n<p>说明一下这个 aDataLists：</p>\n<ul>\n<li>StripedMap通过对key(id对象)的地址做一了一系列偏移和对mapsize的求模操作，把对象散列在64个（iPhone上是8个）插槽中。每个插槽内是一个<code>SyncData</code>链表，即<code>SyncList</code>结构体。<code>SyncList</code>内有一个<code>spinlock_t</code>,也就是对这个链表进行操作的时候的锁。</li>\n<li>另外如果在StripedMap没有找到这个对象，那么会从SyncList中找一个已经释放的<code>SyncData</code>(threadCount&#x3D;&#x3D;0，即既没有线程持有，也没有线程在等待)来复用</li>\n</ul>\n<p>最后总结一下<code>id2data</code>这个函数的操作步骤：</p>\n<ol>\n<li>通过 <code>SYNC_DATA_DIRECT_KEY</code>和<code>SYNC_COUNT_DIRECT_KEY</code>这两个key优先从TLS中查询<code>SyncData</code>,根据操作类型（加、解）分别修改TLS中的值，返回<code>SyncData</code>。</li>\n<li>通过遍历TLS中的<code>SyncCache</code>数组，找到该对象的<code>SyncData</code>，根据操作类型（加、解）分别修改<code>SyncCacheItem</code>中的lockCount，返回<code>SyncData</code>。</li>\n<li>1，2都没有，那么去找其他线程已经持有或者曾经被持有过同步锁的<code>SyncData</code>对象：从<code>sDataLists</code>中找到当前需要加同步锁对象对应散列的插槽<code>SyncList</code>，从<code>SyncList</code>中找到这个对象对应的或者复用的<code>SyncData</code>。</li>\n<li>如果第3步都没有找到（说明是整个进程内第一次加锁），那就创建一个<code>SyncData</code>。并且加到<code>SyncList</code>的队首。</li>\n<li>如果<code>TLS</code>中<code>SYNC_DATA_DIRECT_KEY</code>是空的，那么优先保存。<strong>否则</strong>保存到<code>SyncCache</code>中</li>\n</ol>\n<p>注:<br>1，2两步骤中在lockCount减小到0的时候，也就是当前线程需要释放SyncData（实际并不会释放）的时候。会同时修改<code>SyncData</code>中的threadCount,这个操作必须是原子操作。因为前者操作必然是在当前线程，但是后者操作可能是多线程的。（以及3步骤中，在持有并返回其他线程已经加同步锁的<code>SyncData</code>对象。）</p>\n<h3 id=\"synchronized的性能到底差在哪？？\"><a href=\"#synchronized的性能到底差在哪？？\" class=\"headerlink\" title=\"@synchronized的性能到底差在哪？？\"></a>@synchronized的性能到底差在哪？？</h3><p>很多文章在对比各种锁的性能，都提到了@synchronized性能是最差的。那么到底差在哪呢？</p>\n<p>上文已经具体分析了@synchronized的所有实现逻辑了，但是可能并没有一个概念，到底差在哪？</p>\n<p>怀疑以下的两个点：</p>\n<ol>\n<li><code>id2data</code>即在<code>TLS</code>,<code>SyncCache</code>,<code>sDataLists</code>寻找对应同步锁对象的过程</li>\n<li><code>SyncData</code>中的锁。</li>\n</ol>\n<p>先做一个实验对比一下同步锁有多慢。</p>\n<p><strong>以下实验只是为了做一个定性的分析，所有数据只提供一个参考。</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tNSObject *t = [NSObject new];</span><br><span class=\"line\">\t\t<span class=\"type\">uint64_t</span> pre = mach_absolute_time();</span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; <span class=\"number\">10000000</span>; index++) &#123;</span><br><span class=\"line\">            @synchronized (t) &#123;</span><br><span class=\"line\">                count ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> now = mach_absolute_time();</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> deltaA = now-pre;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;synchronized count:%d time:%llu&quot;</span>, count, deltaA/<span class=\"number\">1000000</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> pre1 = mach_absolute_time();</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; <span class=\"number\">10000000</span>; index++) &#123;</span><br><span class=\"line\">            pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">            count ++;</span><br><span class=\"line\">            pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> now1 = mach_absolute_time();</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> deltaB = now1-pre1;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;count:%d time:%llu&quot;</span>, count, deltaB/<span class=\"number\">1000000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分别对 pthread_mutex 和 synchronized 加锁 一百万次。<br>pthread_mutex:200ms<br>synchronized:6800ms</p>\n<p>似乎…em…差了不是一点点呢…</p>\n<p>因为上面的测试代码中，同步锁，每一次循环都会执行一遍<code>加锁..存入TLS..释放..从TLS移除</code>。我们试试在最外层套一个同步锁,这样每次都会在<code>TLS</code>中命中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tNSObject *t = [NSObject new];</span><br><span class=\"line\">\t@synchronized(t)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">uint64_t</span> pre = mach_absolute_time();</span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; <span class=\"number\">10000000</span>; index++) &#123;</span><br><span class=\"line\">            @synchronized (t) &#123;</span><br><span class=\"line\">                count ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> now = mach_absolute_time();</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> deltaA = now-pre;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;synchronized count:%d time:%llu&quot;</span>, count, deltaA/<span class=\"number\">1000000</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> pre1 = mach_absolute_time();</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; <span class=\"number\">10000000</span>; index++) &#123;</span><br><span class=\"line\">            pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">            count ++;</span><br><span class=\"line\">            pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> now1 = mach_absolute_time();</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> deltaB = now1-pre1;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;count:%d time:%llu&quot;</span>, count, deltaB/<span class=\"number\">1000000</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>pthread_mutex:200ms<br>synchronized:2700ms</p>\n<p>似乎..快了..不少呢..</p>\n<p>但是这样测试下去，没法获得准确的结果。我们直接调试Runtime的源码，通过修改源码来“控制变量”。</p>\n<hr>\n<p>这里有一个小插曲:</p>\n<p>在尝试通过修改源码的来实验的时候，<code>synchronized</code>的执行时间总是出奇的长。于是我把objc-sync.mm中 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code>方法改为空操作，直接返回。</p>\n<p>结果，synchronized的执行时间居然还维持在1000ms+。</p>\n<p>汇编代码显示，还有一个objc_retain方法。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/1ff8b0b7aa6cc03e763e5e3c693c19bf.png\"></p>\n<p>也就是说，编译器在synchronized代码块中还会自动插入代码，持有这个同步锁对象。</p>\n<p>因为测试代码不涉及到多线程间对象的持有和释放，所有我们直接把它改为mrc。</p>\n<p>执行时间变为 40ms+，objc_retain也确实没有了。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/6c4e55e070f1d49f795e3a440fc2cffd.png\"></p>\n<p>也就是说，引用计数占了1000ms+。以下实验均在mrc下</p>\n<h4 id=\"同步锁对象寻找过程\"><a href=\"#同步锁对象寻找过程\" class=\"headerlink\" title=\"同步锁对象寻找过程\"></a>同步锁对象寻找过程</h4><p>修改源码，让 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code>方法只执行查询操作，不执行锁操作。</p>\n<p>整个查询过程的执行时间在 900ms+</p>\n<h4 id=\"锁过程\"><a href=\"#锁过程\" class=\"headerlink\" title=\"锁过程\"></a>锁过程</h4><p>同步锁最终还是使用的<code>SyncData</code>中的<code>os_unfair_recursive_lock</code>实现的递归锁。</p>\n<p>这个锁是苹果用来代替已废弃的 OSPinLock 的，OSPinLock让CPU空转，而不会让出时间片，在GCD的线程优先级上会出现饥饿或者死锁问题。具体的可以看<a href=\"https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/\">这篇文章</a>。</p>\n<p><code>os_unfair_lock</code>锁的线程会处于休眠状态，从用户态切换到内核态，而并非忙等<br><img src=\"https://caio.ink/wp-content/uploads/2019/12/e9b18665440cf264a15213547cfc6860.png\"></p>\n<p>直接测试一下，递归锁的加锁解锁效率。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">os_unfair_recursive_lock_s</span> &#123;</span></span><br><span class=\"line\">    os_unfair_lock ourl_lock;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> ourl_count;</span><br><span class=\"line\">&#125; os_unfair_recursive_lock;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os_unfair_recursive_lock lock = ((os_unfair_recursive_lock)&#123;OS_UNFAIR_LOCK_INIT, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">os_unfair_recursive_lock *mlock = &amp;lock;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; <span class=\"number\">10000000</span>; index++) &#123;</span><br><span class=\"line\">    os_unfair_recursive_lock_lock_with_options(&amp;lock, <span class=\"number\">0x00000000</span>);</span><br><span class=\"line\">        count ++;</span><br><span class=\"line\">    os_unfair_recursive_lock_tryunlock4objc(&amp;lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果只是锁的话，执行时间只有200ms。<code>os_unfair_lock</code>的执行效率比<code>pthread_mutex</code>略高。而且当执行次数越多，这个差距稳定在10%</p>\n<p>引用计数 1000ms+同步锁对象查询900ms+递归锁200ms &#x3D; 2100ms</p>\n<p>距离第二次的实验还差500ms左右。500ms花费在哪？</p>\n<p>objc-os.h有一个LOCKDEBUG的宏，在debug期间会有一些耗时判断，把宏关闭之后，上面的第二次实验的时间就从2900ms -&gt; 2100ms左右，与上面的计算就对应上了。</p>\n<blockquote>\n<p>总结一下:<br>1.synchronized同步锁使用的 os_unfair_lock 本身性能是不差的，甚至优于pthread_mutex。<br>2.synchronized的性能，主要是花费在实现这个语法糖上。引用计数的管理和查找与对象绑定的同步锁消耗了绝大部分的时间。而且上面的实验我们还只是在TLS内操作了，如果一个线程内持有的同步锁个数越多，那么将花费在Cache上和全局数据内的查询时间也会更多。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"synchronized是什么？\"><a href=\"#synchronized是什么？\" class=\"headerlink\" title=\"@synchronized是什么？\"></a>@synchronized是什么？</h2><p>一般来说OC上的语法糖，都可以使用 <code>clang --rewrite-objc code.m</code> 让clang 编译为 c 或 c++ ，由此可以窥探这些语法糖的具体实现(但是实际上XCode在编译的时候，并不会有rewrite的这个过程)。例如，<a href=\"https://caio.ink/oc-block-imp/\">oc的block</a>，@autoreleasepool，@synchronized等等</p>","more":"<p>写一个简单的例子:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> * argv[])</span> &#123;</span><br><span class=\"line\">    NSObject *o = [NSObject new];</span><br><span class=\"line\">    @synchronized (o) &#123;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;helloworld&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>clang 重写后:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> * argv[])</span> &#123;</span><br><span class=\"line\">    NSObject *o = ((NSObject *(*)(id, SEL))(<span class=\"type\">void</span> *)objc_msgSend)((id)objc_getClass(<span class=\"string\">&quot;NSObject&quot;</span>), sel_registerName(<span class=\"string\">&quot;new&quot;</span>));</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id _rethrow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        id _sync_obj = (id)o;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        objc_sync_enter(_sync_obj);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">SYNC_EXIT</span> &#123;</span></span><br><span class=\"line\">                _SYNC_EXIT(id arg) : sync_exit(arg) &#123;&#125;</span><br><span class=\"line\">                ~_SYNC_EXIT()</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    objc_sync_exit(sync_exit);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                id sync_exit;</span><br><span class=\"line\">            &#125; _sync_exit(_sync_obj);</span><br><span class=\"line\"></span><br><span class=\"line\">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_vt_qgsk8yps0js52hgrjtwg9ch80000gn_T_main2_73ab4e_mi_0);</span><br><span class=\"line\">        &#125; catch (id e) &#123;</span><br><span class=\"line\">            _rethrow = e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">FIN</span> &#123;</span></span><br><span class=\"line\">                _FIN(id reth) : rethrow(reth) &#123;&#125;</span><br><span class=\"line\">                ~_FIN() &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (rethrow)</span><br><span class=\"line\">                        objc_exception_throw(rethrow);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                id rethrow;</span><br><span class=\"line\">            &#125; _fin_force_rethow(_rethrow);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码比较清晰：</p>\n<ol>\n<li><code>@synchronized</code> 整个代码块都被try包裹。</li>\n<li>执行try的之前调用 <code>objc_sync_enter(_sync_obj)</code> 进行加锁。</li>\n<li>try代码块内先构建一个C++对象，C++对象的构造器内会传入”被加锁”的对象，并且被这个C++对象持有。</li>\n<li>try代码块结束的时候，也就是C++对象析构的时候，会调用<code>objc_sync_exit(sync_exit)</code>，解锁这个”被加锁”的对象。</li>\n<li>最终在<code>@synchronized</code> 代码块结束的时候，如果catch了异常就再原样把异常抛出去。</li>\n</ol>\n<blockquote>\n<p>上面描述的时候，对<code>被加锁</code>三个字加了引号。OC对象可以被加锁么？先暂且这么说，后文再对此进行解释。</p>\n</blockquote>\n<p>那么现在问题就转变为：</p>\n<ol>\n<li>objc_sync_enter(obj); 加锁</li>\n<li>objc_sync_exit(obj); 解锁</li>\n</ol>\n<h3 id=\"objc-sync-enter-和-objc-sync-exit\"><a href=\"#objc-sync-enter-和-objc-sync-exit\" class=\"headerlink\" title=\"objc_sync_enter 和 objc_sync_exit\"></a>objc_sync_enter 和 objc_sync_exit</h3><p>在<code>libobjc.A.dylib</code>(就是俗称的Runtime)中，有一个 objc-sync.h&#x2F;.m 文件 实现了这两个函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">objc_sync_enter</span><span class=\"params\">(id obj)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class=\"line\">        data-&gt;mutex.lock();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// @synchronized(nil) does nothing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">objc_sync_exit</span><span class=\"params\">(id obj)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        SyncData* data = id2data(obj, RELEASE); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data) &#123;</span><br><span class=\"line\">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!okay) &#123;</span><br><span class=\"line\">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// @synchronized(nil) does nothing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个代码也很容易理解，通过<code>id2data</code>,取到与 obj 对应的 <code>SyncData</code>,然后对这个数据结构中的 mutex 进行加解锁操作。也就是说<code>@synchronized</code>加锁的对象是与oc对象绑定的一个mutex锁？</p>\n<h2 id=\"id2data\"><a href=\"#id2data\" class=\"headerlink\" title=\"id2data\"></a>id2data</h2><p>在描述具体实现之前，需要了解以下几个结构体：</p>\n<h4 id=\"SyncData\"><a href=\"#SyncData\" class=\"headerlink\" title=\"SyncData\"></a>SyncData</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title function_\">alignas</span><span class=\"params\">(CacheLineSize)</span> SyncData &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SyncData</span>* <span class=\"title\">nextData</span>;</span></span><br><span class=\"line\">    DisguisedPtr&lt;objc_object&gt; object;</span><br><span class=\"line\">    <span class=\"type\">int32_t</span> threadCount;  <span class=\"comment\">// number of THREADS using this block</span></span><br><span class=\"line\">    <span class=\"type\">recursive_mutex_t</span> mutex;</span><br><span class=\"line\">&#125; SyncData;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>SyncData是用来描述每一个”被加锁”的对象。</li>\n<li>SyncData是一个链表，由nextData指向下一个节点。</li>\n<li>object指向这个”被加锁”的对象。</li>\n<li>threadCount记录了正在使用这个节点对象的线程（当没有线程使用这个节点的时候，它才会被释放）。这里的使用是指已经加锁，或者正在等待锁。</li>\n<li>mutex 递归锁(os_unfair_recursive_lock),真正加锁、解锁的锁对象。</li>\n</ol>\n<h4 id=\"SyncCache\"><a href=\"#SyncCache\" class=\"headerlink\" title=\"SyncCache\"></a>SyncCache</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SyncCache</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> allocated;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> used;</span><br><span class=\"line\">    SyncCacheItem <span class=\"built_in\">list</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125; SyncCache;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>SyncCache 是存储在TLS(本地线程存储)中的，用来记录当前线程所有已经持有锁的<code>SyncData</code>。（排除TLS中快速缓存的那一个，下文会具体说）</li>\n<li>list是一个<code>SyncCacheItem</code>数组,<code>SyncCacheItem</code>里就只有两个东西，一个是<code>SyncData</code>，另一个就是lockCount，lockCount记录了当前线程对这个对象加锁次数。（@synchronized是一个可重入的递归锁）</li>\n<li>allocated是已分配的cache大小，used是已使用大小。默认情况下，每个线程首次创建的时候会有4个size的容量。当每次插槽不够的时候会指数级扩大这个大小。</li>\n</ol>\n<p>id2data的代码比较长，简单来说这个方法的目的就是，获取到这个id对象所对应(绑定)的SyncData,然后…调用syncData.mutex.lock()</p>\n<p><strong>那么这个SyncData在哪呢？应该怎么去取它呢？</strong></p>\n<p>简单概括一下：</p>\n<ol>\n<li><code>TLS</code>:大部分情况下，开发者在某一个线程对某一个对象的同步锁中，再嵌套其他对象的同步锁的概率，要远低于只用一个同步锁。（<strong>其实有多个锁嵌套的时候，这时候是不是应该要考虑代码结构有问题了</strong>）所以苹果在设计这个锁的时候，会优先在<code>TLS</code>中预留一个<code>SyncData</code>。即优先向<code>TLS</code>中读取或者写入，注释上称它为fast cache。</li>\n<li><code>SyncCache</code>中:上面已经提及，对于每一个线程已经获得的锁，都会在<code>TLS</code>中存储的<code>SyncCache</code>结构体中。<code>SyncCache</code>中的数组存储的就是当前线程已经获取的锁对应的<code>SyncData</code>了。</li>\n<li>全局数据中： 如果在1，2中都没有找到，那么说明当前线程尚未对这个对象持有锁。<code>static StripedMap&lt;SyncList&gt; sDataLists</code>这个全局数据结构记录了进程内所有已经被持有同步锁或者曾经被持有过的对象。<code>sDataList</code>是个重写的Map，key是同步锁对象，value是<code>SyncList</code>。</li>\n</ol>\n<p>说明一下这个 aDataLists：</p>\n<ul>\n<li>StripedMap通过对key(id对象)的地址做一了一系列偏移和对mapsize的求模操作，把对象散列在64个（iPhone上是8个）插槽中。每个插槽内是一个<code>SyncData</code>链表，即<code>SyncList</code>结构体。<code>SyncList</code>内有一个<code>spinlock_t</code>,也就是对这个链表进行操作的时候的锁。</li>\n<li>另外如果在StripedMap没有找到这个对象，那么会从SyncList中找一个已经释放的<code>SyncData</code>(threadCount&#x3D;&#x3D;0，即既没有线程持有，也没有线程在等待)来复用</li>\n</ul>\n<p>最后总结一下<code>id2data</code>这个函数的操作步骤：</p>\n<ol>\n<li>通过 <code>SYNC_DATA_DIRECT_KEY</code>和<code>SYNC_COUNT_DIRECT_KEY</code>这两个key优先从TLS中查询<code>SyncData</code>,根据操作类型（加、解）分别修改TLS中的值，返回<code>SyncData</code>。</li>\n<li>通过遍历TLS中的<code>SyncCache</code>数组，找到该对象的<code>SyncData</code>，根据操作类型（加、解）分别修改<code>SyncCacheItem</code>中的lockCount，返回<code>SyncData</code>。</li>\n<li>1，2都没有，那么去找其他线程已经持有或者曾经被持有过同步锁的<code>SyncData</code>对象：从<code>sDataLists</code>中找到当前需要加同步锁对象对应散列的插槽<code>SyncList</code>，从<code>SyncList</code>中找到这个对象对应的或者复用的<code>SyncData</code>。</li>\n<li>如果第3步都没有找到（说明是整个进程内第一次加锁），那就创建一个<code>SyncData</code>。并且加到<code>SyncList</code>的队首。</li>\n<li>如果<code>TLS</code>中<code>SYNC_DATA_DIRECT_KEY</code>是空的，那么优先保存。<strong>否则</strong>保存到<code>SyncCache</code>中</li>\n</ol>\n<p>注:<br>1，2两步骤中在lockCount减小到0的时候，也就是当前线程需要释放SyncData（实际并不会释放）的时候。会同时修改<code>SyncData</code>中的threadCount,这个操作必须是原子操作。因为前者操作必然是在当前线程，但是后者操作可能是多线程的。（以及3步骤中，在持有并返回其他线程已经加同步锁的<code>SyncData</code>对象。）</p>\n<h3 id=\"synchronized的性能到底差在哪？？\"><a href=\"#synchronized的性能到底差在哪？？\" class=\"headerlink\" title=\"@synchronized的性能到底差在哪？？\"></a>@synchronized的性能到底差在哪？？</h3><p>很多文章在对比各种锁的性能，都提到了@synchronized性能是最差的。那么到底差在哪呢？</p>\n<p>上文已经具体分析了@synchronized的所有实现逻辑了，但是可能并没有一个概念，到底差在哪？</p>\n<p>怀疑以下的两个点：</p>\n<ol>\n<li><code>id2data</code>即在<code>TLS</code>,<code>SyncCache</code>,<code>sDataLists</code>寻找对应同步锁对象的过程</li>\n<li><code>SyncData</code>中的锁。</li>\n</ol>\n<p>先做一个实验对比一下同步锁有多慢。</p>\n<p><strong>以下实验只是为了做一个定性的分析，所有数据只提供一个参考。</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tNSObject *t = [NSObject new];</span><br><span class=\"line\">\t\t<span class=\"type\">uint64_t</span> pre = mach_absolute_time();</span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; <span class=\"number\">10000000</span>; index++) &#123;</span><br><span class=\"line\">            @synchronized (t) &#123;</span><br><span class=\"line\">                count ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> now = mach_absolute_time();</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> deltaA = now-pre;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;synchronized count:%d time:%llu&quot;</span>, count, deltaA/<span class=\"number\">1000000</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> pre1 = mach_absolute_time();</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; <span class=\"number\">10000000</span>; index++) &#123;</span><br><span class=\"line\">            pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">            count ++;</span><br><span class=\"line\">            pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> now1 = mach_absolute_time();</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> deltaB = now1-pre1;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;count:%d time:%llu&quot;</span>, count, deltaB/<span class=\"number\">1000000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分别对 pthread_mutex 和 synchronized 加锁 一百万次。<br>pthread_mutex:200ms<br>synchronized:6800ms</p>\n<p>似乎…em…差了不是一点点呢…</p>\n<p>因为上面的测试代码中，同步锁，每一次循环都会执行一遍<code>加锁..存入TLS..释放..从TLS移除</code>。我们试试在最外层套一个同步锁,这样每次都会在<code>TLS</code>中命中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tNSObject *t = [NSObject new];</span><br><span class=\"line\">\t@synchronized(t)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">uint64_t</span> pre = mach_absolute_time();</span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; <span class=\"number\">10000000</span>; index++) &#123;</span><br><span class=\"line\">            @synchronized (t) &#123;</span><br><span class=\"line\">                count ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> now = mach_absolute_time();</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> deltaA = now-pre;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;synchronized count:%d time:%llu&quot;</span>, count, deltaA/<span class=\"number\">1000000</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> pre1 = mach_absolute_time();</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; <span class=\"number\">10000000</span>; index++) &#123;</span><br><span class=\"line\">            pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">            count ++;</span><br><span class=\"line\">            pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> now1 = mach_absolute_time();</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> deltaB = now1-pre1;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;count:%d time:%llu&quot;</span>, count, deltaB/<span class=\"number\">1000000</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>pthread_mutex:200ms<br>synchronized:2700ms</p>\n<p>似乎..快了..不少呢..</p>\n<p>但是这样测试下去，没法获得准确的结果。我们直接调试Runtime的源码，通过修改源码来“控制变量”。</p>\n<hr>\n<p>这里有一个小插曲:</p>\n<p>在尝试通过修改源码的来实验的时候，<code>synchronized</code>的执行时间总是出奇的长。于是我把objc-sync.mm中 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code>方法改为空操作，直接返回。</p>\n<p>结果，synchronized的执行时间居然还维持在1000ms+。</p>\n<p>汇编代码显示，还有一个objc_retain方法。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/1ff8b0b7aa6cc03e763e5e3c693c19bf.png\"></p>\n<p>也就是说，编译器在synchronized代码块中还会自动插入代码，持有这个同步锁对象。</p>\n<p>因为测试代码不涉及到多线程间对象的持有和释放，所有我们直接把它改为mrc。</p>\n<p>执行时间变为 40ms+，objc_retain也确实没有了。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/6c4e55e070f1d49f795e3a440fc2cffd.png\"></p>\n<p>也就是说，引用计数占了1000ms+。以下实验均在mrc下</p>\n<h4 id=\"同步锁对象寻找过程\"><a href=\"#同步锁对象寻找过程\" class=\"headerlink\" title=\"同步锁对象寻找过程\"></a>同步锁对象寻找过程</h4><p>修改源码，让 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code>方法只执行查询操作，不执行锁操作。</p>\n<p>整个查询过程的执行时间在 900ms+</p>\n<h4 id=\"锁过程\"><a href=\"#锁过程\" class=\"headerlink\" title=\"锁过程\"></a>锁过程</h4><p>同步锁最终还是使用的<code>SyncData</code>中的<code>os_unfair_recursive_lock</code>实现的递归锁。</p>\n<p>这个锁是苹果用来代替已废弃的 OSPinLock 的，OSPinLock让CPU空转，而不会让出时间片，在GCD的线程优先级上会出现饥饿或者死锁问题。具体的可以看<a href=\"https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/\">这篇文章</a>。</p>\n<p><code>os_unfair_lock</code>锁的线程会处于休眠状态，从用户态切换到内核态，而并非忙等<br><img src=\"https://caio.ink/wp-content/uploads/2019/12/e9b18665440cf264a15213547cfc6860.png\"></p>\n<p>直接测试一下，递归锁的加锁解锁效率。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">os_unfair_recursive_lock_s</span> &#123;</span></span><br><span class=\"line\">    os_unfair_lock ourl_lock;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> ourl_count;</span><br><span class=\"line\">&#125; os_unfair_recursive_lock;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os_unfair_recursive_lock lock = ((os_unfair_recursive_lock)&#123;OS_UNFAIR_LOCK_INIT, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">os_unfair_recursive_lock *mlock = &amp;lock;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; <span class=\"number\">10000000</span>; index++) &#123;</span><br><span class=\"line\">    os_unfair_recursive_lock_lock_with_options(&amp;lock, <span class=\"number\">0x00000000</span>);</span><br><span class=\"line\">        count ++;</span><br><span class=\"line\">    os_unfair_recursive_lock_tryunlock4objc(&amp;lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果只是锁的话，执行时间只有200ms。<code>os_unfair_lock</code>的执行效率比<code>pthread_mutex</code>略高。而且当执行次数越多，这个差距稳定在10%</p>\n<p>引用计数 1000ms+同步锁对象查询900ms+递归锁200ms &#x3D; 2100ms</p>\n<p>距离第二次的实验还差500ms左右。500ms花费在哪？</p>\n<p>objc-os.h有一个LOCKDEBUG的宏，在debug期间会有一些耗时判断，把宏关闭之后，上面的第二次实验的时间就从2900ms -&gt; 2100ms左右，与上面的计算就对应上了。</p>\n<blockquote>\n<p>总结一下:<br>1.synchronized同步锁使用的 os_unfair_lock 本身性能是不差的，甚至优于pthread_mutex。<br>2.synchronized的性能，主要是花费在实现这个语法糖上。引用计数的管理和查找与对象绑定的同步锁消耗了绝大部分的时间。而且上面的实验我们还只是在TLS内操作了，如果一个线程内持有的同步锁个数越多，那么将花费在Cache上和全局数据内的查询时间也会更多。</p>\n</blockquote>"},{"title":"Transaction Management","date":"2020-08-20T16:00:00.000Z","top":300,"_content":"\n> 数据库管理系统的主要任务就是帮助用户在数据库上操作和存储数据。另外，DBMS还需要在用户的并发调用下保护数据库，以及在应用的崩溃，系统崩溃，系统掉电的情况下保持数据库的一致性。出于这些目的，DBMS在一个抽象的事务中执行所有的数据库操作。对于保持数据库的一致性来说，事务管理非常关键。SQLite依赖原生的文件锁，并且实现了页面日志来实现ACID。SQLite只支持一级事务，也就是说不支持事务嵌套。本文讨论了SQLite是如何实现了事务的ACID，从而更新单个和多个数据库。`Pager`那一篇文章会解释SQLite事务管理器pager的内部工作原理。\n\n<!-- more -->\n\n# 事务类型\n几乎所有的DBMS使用锁机制来处理并发控制，并使用日志来保存恢复信息。在一个事务修改数据库项之前，一个DBMS就会将一条包含恢复信息(例如，更新的新旧数据)的日志记录写入日志文件。在DBMS修改数据库文件之前，DBMS需要确保日志记录已经完全存储在磁盘内了。在事务事件终止或者失败的时候，DBMS就会在日志文件中获取足够的信息，来回滚数据库到一个可接受的具有一致性的状态，并且不影响其他的事务。在恢复数据库的时候，DBMS就会撤销数据库中终止的事务带来的影响，并且重做数据库上已经提交的数据。在SQLite里，锁和日志的活动依赖事务的类型，本小节就会讨论这个。\n\n## 系统事务\nSQLite每一个SQL语句的执行都会在事务内。它同时支持读事务和写事务。(在SQLite文档中，事务这个词本身就有点抽象。一个事务可能是一个读事务，也能是一个写事务。如果需要的话，后文均会特别指出。)应用要想读取数据库的任何数据，必须要在一个读或者写事务内，要想写数据，必须要在一个写事务内。应用无需特别指出要求SQLite将每一个SQL语句单独置于一个事务内，SQLite会自动这样处理；这是默认行为，系统默认就会在一个自动提交模式。这些事务称之为系统事务或者自动提交事务或者隐式事务。对于一个SELECT语句，SQLite会创建一个读事务来执行语句。对于非SELECT语句，SQLite会先创建一个读事务，然后将它转换为写事务。每一个读写事务都会在事务结束的时候自动提交。应用层并不知道系统事务。他们只需要向SQLite提交语句，剩下的事情就由SQLite完成。\n\n一个应用可以在同一个数据库连接上启动SELECT读事务的并发执行，但是在一个数据库连接上只能执行一个非SELECT的写事务。这意味着在数据库连接上，不能有两个并发的写事务，但可以有一个并发的写事务和多个读事务。\n\n非select语句的执行是原子的，SQLite当它执行一个非select语句的时候，会获取一个锁，并且在语句执行完成的时候会释放这个锁。另一方面，一个select语句不是原子的；它会在语句开始的时候获取一个锁，但是会在结果的每一行都会暂停和释放锁。所以一个select语句的执行，可以运行到它结果的第一行，这时候其它select语句可以运行，以此类推。因此在select语句的各个执行阶段可以有很多个其他select语句。在暂停的过程中，甚至可以执行一个非select语句。稍后会解释，读事务和写事务不能同时操作同一张表。因此，读取事务与并发写入事务是隔离的。\n\n## 用户事务\n对于一些应用，尤其是那些写入敏感的来说，自动提交模式的代价可能比较昂贵，因为数据库可能会为每一个非select语句，频繁的打开，写入，和关闭日志文件。另外，在每一个SQL语句执行的时候，还会有一些并发控制的代价，因为应用需要在数据库文件上请求和释放文件锁。这些代价会给一些性能向的应用(尤其是大型应用)带来性能问题，只能通过将一个用户级的事务包含一些SQL语句来减少因此带来的性能影响。应用可以在`BEGIN TRANSACTION`和(`COMMIT TRANACTION`或`ROLLBACKTRANACTION`)这两个命令之间包含一系列的SQL语句。一个`begin-commit`或`begin-rolback`语句可以包含任意数量的select或者非select语句。\n\n应用可以在一个数据库连接上通过显式执行`BEGIN`命令来手动开启一个事务。而这个事务就被称之为用户级事务或者显式事务或者简单的说用户事务。当这一类事务开启的时候，SQLite就会离开默认自动提交模式，在每一个SQL语句执行过程期，它都不会调用提交或者终止。一个执行成功的非select语句是这个用户事务的一部分，但是select语句将会被看做一个独立的读事务。你可以把用户事务看做全都是的写事务。当应用执行`COMMIT`或者`ROLLBACK`的时候，SQLite就会提交或者回滚事务。用户事务提交时，写事务已经提交，但是所有的读事务依旧保持激活。但是如果用户事务终止的时候，写事务会回滚，并且一些读取已经被修改的表的读事务也会被终止。SQLite会在写事务完成之后将模式切换为自动提交模式。读事务在对应的读语句执行完成的时候就会被单独提交。\n\nSQLite只支持一级事务，即不支持在事务开始之后，再开启一个事务。也不支持在一个数据库连接上同时开启两个事务。\n\n## 保存点\nSQLite支持在用户事务中开启保存点。应用在事务内外均可以执行保存点的命令。对于在事务外开启保存点的情况，SQLite会首先打开一个用户事务，然后执行保存点命令，当应用释放保存点的时候，提交事务。所谓保存点就是事务执行过程中应用建立的一个点。建立了一个应用认为在此时的数据库状态是OK的一个点。一个事务中可以有很多个保存点。之后，它可以回滚到保存点中的任意一个，然后重新建立保存点时的数据库状态。\n\n## 语句子事务\n一个用户事务不仅仅是一个平坦的一级事务。所有执行成功的非select语句都在这个事务中。其中的每一个语句都会在一个单独的语句级的子事务中。在任何时候，在用户事务中最多只有一个子事务。事实上SQLite是使用隐式匿名的保存点来执行子事务，在这个子事务结束的时候释放保存点。这个过程也就会一直持续到事务完成，即执行COMMIT或者ABORT命令。如果当前的子语句执行失败了，SQLite不会立刻终止整个事务，除非事务的冲突解决是调用回滚(看本节后文)。而是将数据库恢复到语句执行开始之前的状态（通过还原匿名保存点）;用户事务也就从那个保存点开始继续执行。失败的语句不会更改其他先前执行的SQL语句或新语句的结果，除非主用户事务中止自身。下面看一个简单的SQLite事务例子:\n\n```\nBEGIN TRANSACTION;\n    INSERT INTO table1 VALUES(100);\n    INSERT INTO table2 VALUES(20,100);\n    UPDATE table1 SET x=x+1 WHERE y > 10;\n    INSERT INTO table3 VALUES(1,2,3);\nCOMMIT TRANSACTION;\n```\n\n假设数据库有三个表分别是table1，table2和table3。应用会通过执行一个`begin transaction`来打开一个事务。上面的四个语句都会在一个单独的子事务中执行，按照书写的顺序，一个接一个执行。举个例子，如果在中间的UPDATE语句执行的时候，发生了一个约束错误，那么这个更新语句所带来的行更新都会恢复，但是其他的三个INSERT语句的变更就会在应用执行`COMMIT TRANSACTIOIN`语句的时候被提交到数据库。\n\n**冲突解决**:当执行insert或者update违反约束的时候，一个语句有5种方法来解决冲突。`Rollback`:终止整个事务。`Abort`:停止并取消当前语句子事务的发生的变更；整个事务仍然有效。这是默认解决方法。`Fail`:接受当前语句子事务发生的变更，但是不再继续当前的语句；整个事务仍然有效。`Ignore`:导致约束违反的那些数据行不会发生变更;这个语句子事务仍然有效，并且会继续执行。`Replace`:导致约束违反的那些数据行都会被移除;这个语句子事务仍然有效，并且会继续执行。\n<!---\n# 锁管理\n//TODO:\n## 锁的类型以及它们的职责\n////TODO:\n## 锁的请求策略\n////TODO:\n## 显式的锁\n////TODO:\n## 死锁和饥饿\n////TODO:\n## Linux锁原语\n////TODO:\n## SQLite锁的实现\n////TODO:\n### SQLite锁与原生文件锁的转换\n//////TODO:\n### 原生锁的工程问题\n//////TODO:\n### Linux系统问题\n//////TODO:\n### 多线程应用\n//////TODO:\n## 锁的API\n////TODO:\n### sqlite3OsLock\n//////TODO:\n### sqlite3OsUnlock\n//////TODO:\n--->\n# 日志管理\n日志即数据恢复文件，在发生事务或子语句级事务终止，或者系统问题的时候用来恢复数据库数据。SQLite为每一个数据库使用单个的日志文件(对于内存数据库来说，不会使用日志文件)。它仅确保事务的回滚（撤消，而不是重做），并且日志文件通常称为回滚日志。日志文件总是和数据库文件在同一个目录下，并且使用同样的名字，只不过后面跟随‘-journal’。\n\n**临时日志vs持久化日志文件**:SQLite在同一时间同一个数据库文件上只允许最多只有一个写事务。在默认的操作模式下，它会为每一个写事务动态地创建日志文件，以及在事务完成的时候删除文件。当然，可以通过`journal mode`事件指令来裁剪，或者文件头部无效化，内存化或者关闭日志文件(还有wal模式)。默认的是删除。如果应用使用独占锁模式(`pragma locking_mode=exclusive`)。SQLite会在独占锁的模式下创建日志文件，并且日志文件会一直持续存在，直到离开这个模式。在这种情况下，在事务过程中，日志文件是会被截断或其标头为零。内存化的选项就是使数据库的日志文件完全存放在内存中，关闭的话就是不使用日志文件。\n\n当前写事务导致的更新操作会在日志文件中产生一条日志记录。当事务想要对数据库发生变更的时候，SQLite就会在回滚日志中写入足够的信息，以便为了可以在后续将数据库文件恢复到事务开始的时候。在目前的数据库社区中有很多数据库的日志结构；它们依赖于存在日志记录中的重做/撤销信息。SQLite则是使用最简单，尽管不是最高效的方法。它在页面级粒度上使用旧值日志记录技术。(SQLite不会再恢复数据库上使用重做逻辑。总之，它不会在日志文件中存储新的值。)因此，在一个事务首次修改任何一个页面的时候，SQLite都会将页面的原始数据包括页面号作为新的日志记录的一部分，存储在回滚日志中。\n\n一旦一个页面数据被拷贝进回滚日志的时候，这个页面就不会再次以新日志记录的形势添加进去了，尽管后面可能对这个页面发生了多次的变更。这个页面级撤消日志记录的一个不错的特性是:可以通过将内容从日记文件盲目复制到数据库文件中来还原页面，并且撤消操作是幂等(可重复执行)的。这个撤销操作不会产生任何的补偿日志。SQLite不会在日志文件中存储一个新的页面，因为新页面没有旧数据。相反，日志会在日志头部记录下在日志文件创建时的数据库原始大小。如果数据库文件因为事务被扩展了，文件就会被缩减到之前的原始大小。\n\n**跟踪已经记录的日志页面**:SQLite在内存中使用一个map数据结构来持续跟踪那些在当前事务中已经被日志文件记录的页面。因此内存空间的开销，和发生变更的页面数量成正比。对于小型数据库来说，这些开销可以忽略不计。\n\n**日志优化**:已释放的叶子节点的页面内容被当做可以回收的垃圾。当这个页面被使用的时候，page就不会被记录日志，因为它没有任何有用的信息。\n\n如果一个事务使用并且修改了多个数据库文件，那么每一个数据库都有它自己的回滚日志文件。他们是独立的回滚日志文件，互相都不知道对方的存在。为了建立相互的关系，SQLite额外维护了一个独立的交叉日志称为主日志文件。这个主日志文件一般都和主数据库文件在同一个目录下。这是一个临时文件。在事务准备提交的时候创建，在提交进程处理完成的时候删除。它不包含任何用来回滚的页面信息，而是包含了在这个事务内相关的所有独立的日志文件名。每一个数据库文件独立的日志文件，同样的包含这个主数据库的名字。如果没有attach的数据库(或者在当前事务中没有涉及attach的数据库的数据修改)，那么就不会创建这个主日志文件，并且各自独立的日志文件也不会包含任何关于主日志文件的信息。后面会讨论日志协议和提交协议。\n\n**不要对数据库文件起别名**:对同一个数据库文件不能使用不同的名字(硬链接或者软连接)。如果不同的应用对同一个数据库使用了不同的名字来访问数据库，那么在同一个数据库下就会产生不同名字的回滚日志文件，那么有可能会导致这些回滚日志被忽略，从而引起数据库的不一致。同样的，也不能修改数据库名而不修改日志文件。但即使这样，这个日志文件也有可能被主日志文件所引用。这样操作会有风险！\n\n## 日志记录协议\nSQLite遵循WAL的日志协议来确保数据库的一致性。SQLite实现了，在修改数据库的之前，先把原始的数据库分页写入到日志文件中。在日志文件中写入日志记录是延迟执行的:SQLite不会立刻在文件中刷入日志。在将页面写入到数据库文件之前，才会真正的刷新日志文件。日志刷新就是保证所有的日志记录以及真真正正地都落地到磁盘了。因为在落地前任何的变更都有可能会让数据库存在不一致的风险。\n\n## 提交协议\n默认的提交逻辑是，提交时刷新日志和释放时刷新数据库。当一个应用提交事务的时候，SQLite保证所有的日志记录都已经落到磁盘上了。在提交之后，日志文件就会被销毁，事务就完成了。在完成之前，如果发生了系统错误，那么事务提交就是失败，后面就会在数据库首次被读取的时候恢复数据库。然而，在释放回滚日志文件之前，所有的数据库文件变更都会被flush到磁盘上。这样就可以保证在释放日志文件之前，所有的变更也落地了。\n\n**异步事务和懒提交**:默认的事务都是同步事务。SQLite严格遵守上面说道的日志记录协议，和日志提交协议。仅管不推荐，但是SQLite还是允许事务允许在懒提交模式。这些被称之为异步事务。通过设置宏来实现。对于异步事务，SQLite不会再事务提交或者任何时间点，执行日志的flush和数据库的flush。因此，数据库写入和提交都会非常快。但是，会有风险。一旦出现了失败，数据库可能就不会存储一个完整的一致的状态。对于临时数据库来说，默认的事务就是异步模式，因为我们不需要关心临时数据库的数据库恢复。\n\n# 子事务管理\n一个语句级的子事务会通过用户事务请求锁。所有的锁都会通过事务来持有，一直到事务被提交或者被终止。但是SQLite的语句子事务会使用单独的一个日志文件来记录存储日志记录。语句级日志是一个临时文件，但是在事务因为终止等被要求恢复数据库的时候，是不会使用该文件的。SQLite会在语句级日志文件和一些主回滚日志文件中均写入一些日志记录。当且仅当对应的页面在子事务开始之前或者页面已经被前一个子事务添加进数据库的时候，页面已经被写入回滚日志文件的时候，日志记录才会被写入语句级文件。\n","source":"_posts/2020-08-21_db-system-design-imp(Transaction).md","raw":"---\ntitle: Transaction Management\ndate: 2020-08-21\ntags: [sqlite3]\ntop: 300\ncategories: sqlite3\n---\n\n> 数据库管理系统的主要任务就是帮助用户在数据库上操作和存储数据。另外，DBMS还需要在用户的并发调用下保护数据库，以及在应用的崩溃，系统崩溃，系统掉电的情况下保持数据库的一致性。出于这些目的，DBMS在一个抽象的事务中执行所有的数据库操作。对于保持数据库的一致性来说，事务管理非常关键。SQLite依赖原生的文件锁，并且实现了页面日志来实现ACID。SQLite只支持一级事务，也就是说不支持事务嵌套。本文讨论了SQLite是如何实现了事务的ACID，从而更新单个和多个数据库。`Pager`那一篇文章会解释SQLite事务管理器pager的内部工作原理。\n\n<!-- more -->\n\n# 事务类型\n几乎所有的DBMS使用锁机制来处理并发控制，并使用日志来保存恢复信息。在一个事务修改数据库项之前，一个DBMS就会将一条包含恢复信息(例如，更新的新旧数据)的日志记录写入日志文件。在DBMS修改数据库文件之前，DBMS需要确保日志记录已经完全存储在磁盘内了。在事务事件终止或者失败的时候，DBMS就会在日志文件中获取足够的信息，来回滚数据库到一个可接受的具有一致性的状态，并且不影响其他的事务。在恢复数据库的时候，DBMS就会撤销数据库中终止的事务带来的影响，并且重做数据库上已经提交的数据。在SQLite里，锁和日志的活动依赖事务的类型，本小节就会讨论这个。\n\n## 系统事务\nSQLite每一个SQL语句的执行都会在事务内。它同时支持读事务和写事务。(在SQLite文档中，事务这个词本身就有点抽象。一个事务可能是一个读事务，也能是一个写事务。如果需要的话，后文均会特别指出。)应用要想读取数据库的任何数据，必须要在一个读或者写事务内，要想写数据，必须要在一个写事务内。应用无需特别指出要求SQLite将每一个SQL语句单独置于一个事务内，SQLite会自动这样处理；这是默认行为，系统默认就会在一个自动提交模式。这些事务称之为系统事务或者自动提交事务或者隐式事务。对于一个SELECT语句，SQLite会创建一个读事务来执行语句。对于非SELECT语句，SQLite会先创建一个读事务，然后将它转换为写事务。每一个读写事务都会在事务结束的时候自动提交。应用层并不知道系统事务。他们只需要向SQLite提交语句，剩下的事情就由SQLite完成。\n\n一个应用可以在同一个数据库连接上启动SELECT读事务的并发执行，但是在一个数据库连接上只能执行一个非SELECT的写事务。这意味着在数据库连接上，不能有两个并发的写事务，但可以有一个并发的写事务和多个读事务。\n\n非select语句的执行是原子的，SQLite当它执行一个非select语句的时候，会获取一个锁，并且在语句执行完成的时候会释放这个锁。另一方面，一个select语句不是原子的；它会在语句开始的时候获取一个锁，但是会在结果的每一行都会暂停和释放锁。所以一个select语句的执行，可以运行到它结果的第一行，这时候其它select语句可以运行，以此类推。因此在select语句的各个执行阶段可以有很多个其他select语句。在暂停的过程中，甚至可以执行一个非select语句。稍后会解释，读事务和写事务不能同时操作同一张表。因此，读取事务与并发写入事务是隔离的。\n\n## 用户事务\n对于一些应用，尤其是那些写入敏感的来说，自动提交模式的代价可能比较昂贵，因为数据库可能会为每一个非select语句，频繁的打开，写入，和关闭日志文件。另外，在每一个SQL语句执行的时候，还会有一些并发控制的代价，因为应用需要在数据库文件上请求和释放文件锁。这些代价会给一些性能向的应用(尤其是大型应用)带来性能问题，只能通过将一个用户级的事务包含一些SQL语句来减少因此带来的性能影响。应用可以在`BEGIN TRANSACTION`和(`COMMIT TRANACTION`或`ROLLBACKTRANACTION`)这两个命令之间包含一系列的SQL语句。一个`begin-commit`或`begin-rolback`语句可以包含任意数量的select或者非select语句。\n\n应用可以在一个数据库连接上通过显式执行`BEGIN`命令来手动开启一个事务。而这个事务就被称之为用户级事务或者显式事务或者简单的说用户事务。当这一类事务开启的时候，SQLite就会离开默认自动提交模式，在每一个SQL语句执行过程期，它都不会调用提交或者终止。一个执行成功的非select语句是这个用户事务的一部分，但是select语句将会被看做一个独立的读事务。你可以把用户事务看做全都是的写事务。当应用执行`COMMIT`或者`ROLLBACK`的时候，SQLite就会提交或者回滚事务。用户事务提交时，写事务已经提交，但是所有的读事务依旧保持激活。但是如果用户事务终止的时候，写事务会回滚，并且一些读取已经被修改的表的读事务也会被终止。SQLite会在写事务完成之后将模式切换为自动提交模式。读事务在对应的读语句执行完成的时候就会被单独提交。\n\nSQLite只支持一级事务，即不支持在事务开始之后，再开启一个事务。也不支持在一个数据库连接上同时开启两个事务。\n\n## 保存点\nSQLite支持在用户事务中开启保存点。应用在事务内外均可以执行保存点的命令。对于在事务外开启保存点的情况，SQLite会首先打开一个用户事务，然后执行保存点命令，当应用释放保存点的时候，提交事务。所谓保存点就是事务执行过程中应用建立的一个点。建立了一个应用认为在此时的数据库状态是OK的一个点。一个事务中可以有很多个保存点。之后，它可以回滚到保存点中的任意一个，然后重新建立保存点时的数据库状态。\n\n## 语句子事务\n一个用户事务不仅仅是一个平坦的一级事务。所有执行成功的非select语句都在这个事务中。其中的每一个语句都会在一个单独的语句级的子事务中。在任何时候，在用户事务中最多只有一个子事务。事实上SQLite是使用隐式匿名的保存点来执行子事务，在这个子事务结束的时候释放保存点。这个过程也就会一直持续到事务完成，即执行COMMIT或者ABORT命令。如果当前的子语句执行失败了，SQLite不会立刻终止整个事务，除非事务的冲突解决是调用回滚(看本节后文)。而是将数据库恢复到语句执行开始之前的状态（通过还原匿名保存点）;用户事务也就从那个保存点开始继续执行。失败的语句不会更改其他先前执行的SQL语句或新语句的结果，除非主用户事务中止自身。下面看一个简单的SQLite事务例子:\n\n```\nBEGIN TRANSACTION;\n    INSERT INTO table1 VALUES(100);\n    INSERT INTO table2 VALUES(20,100);\n    UPDATE table1 SET x=x+1 WHERE y > 10;\n    INSERT INTO table3 VALUES(1,2,3);\nCOMMIT TRANSACTION;\n```\n\n假设数据库有三个表分别是table1，table2和table3。应用会通过执行一个`begin transaction`来打开一个事务。上面的四个语句都会在一个单独的子事务中执行，按照书写的顺序，一个接一个执行。举个例子，如果在中间的UPDATE语句执行的时候，发生了一个约束错误，那么这个更新语句所带来的行更新都会恢复，但是其他的三个INSERT语句的变更就会在应用执行`COMMIT TRANSACTIOIN`语句的时候被提交到数据库。\n\n**冲突解决**:当执行insert或者update违反约束的时候，一个语句有5种方法来解决冲突。`Rollback`:终止整个事务。`Abort`:停止并取消当前语句子事务的发生的变更；整个事务仍然有效。这是默认解决方法。`Fail`:接受当前语句子事务发生的变更，但是不再继续当前的语句；整个事务仍然有效。`Ignore`:导致约束违反的那些数据行不会发生变更;这个语句子事务仍然有效，并且会继续执行。`Replace`:导致约束违反的那些数据行都会被移除;这个语句子事务仍然有效，并且会继续执行。\n<!---\n# 锁管理\n//TODO:\n## 锁的类型以及它们的职责\n////TODO:\n## 锁的请求策略\n////TODO:\n## 显式的锁\n////TODO:\n## 死锁和饥饿\n////TODO:\n## Linux锁原语\n////TODO:\n## SQLite锁的实现\n////TODO:\n### SQLite锁与原生文件锁的转换\n//////TODO:\n### 原生锁的工程问题\n//////TODO:\n### Linux系统问题\n//////TODO:\n### 多线程应用\n//////TODO:\n## 锁的API\n////TODO:\n### sqlite3OsLock\n//////TODO:\n### sqlite3OsUnlock\n//////TODO:\n--->\n# 日志管理\n日志即数据恢复文件，在发生事务或子语句级事务终止，或者系统问题的时候用来恢复数据库数据。SQLite为每一个数据库使用单个的日志文件(对于内存数据库来说，不会使用日志文件)。它仅确保事务的回滚（撤消，而不是重做），并且日志文件通常称为回滚日志。日志文件总是和数据库文件在同一个目录下，并且使用同样的名字，只不过后面跟随‘-journal’。\n\n**临时日志vs持久化日志文件**:SQLite在同一时间同一个数据库文件上只允许最多只有一个写事务。在默认的操作模式下，它会为每一个写事务动态地创建日志文件，以及在事务完成的时候删除文件。当然，可以通过`journal mode`事件指令来裁剪，或者文件头部无效化，内存化或者关闭日志文件(还有wal模式)。默认的是删除。如果应用使用独占锁模式(`pragma locking_mode=exclusive`)。SQLite会在独占锁的模式下创建日志文件，并且日志文件会一直持续存在，直到离开这个模式。在这种情况下，在事务过程中，日志文件是会被截断或其标头为零。内存化的选项就是使数据库的日志文件完全存放在内存中，关闭的话就是不使用日志文件。\n\n当前写事务导致的更新操作会在日志文件中产生一条日志记录。当事务想要对数据库发生变更的时候，SQLite就会在回滚日志中写入足够的信息，以便为了可以在后续将数据库文件恢复到事务开始的时候。在目前的数据库社区中有很多数据库的日志结构；它们依赖于存在日志记录中的重做/撤销信息。SQLite则是使用最简单，尽管不是最高效的方法。它在页面级粒度上使用旧值日志记录技术。(SQLite不会再恢复数据库上使用重做逻辑。总之，它不会在日志文件中存储新的值。)因此，在一个事务首次修改任何一个页面的时候，SQLite都会将页面的原始数据包括页面号作为新的日志记录的一部分，存储在回滚日志中。\n\n一旦一个页面数据被拷贝进回滚日志的时候，这个页面就不会再次以新日志记录的形势添加进去了，尽管后面可能对这个页面发生了多次的变更。这个页面级撤消日志记录的一个不错的特性是:可以通过将内容从日记文件盲目复制到数据库文件中来还原页面，并且撤消操作是幂等(可重复执行)的。这个撤销操作不会产生任何的补偿日志。SQLite不会在日志文件中存储一个新的页面，因为新页面没有旧数据。相反，日志会在日志头部记录下在日志文件创建时的数据库原始大小。如果数据库文件因为事务被扩展了，文件就会被缩减到之前的原始大小。\n\n**跟踪已经记录的日志页面**:SQLite在内存中使用一个map数据结构来持续跟踪那些在当前事务中已经被日志文件记录的页面。因此内存空间的开销，和发生变更的页面数量成正比。对于小型数据库来说，这些开销可以忽略不计。\n\n**日志优化**:已释放的叶子节点的页面内容被当做可以回收的垃圾。当这个页面被使用的时候，page就不会被记录日志，因为它没有任何有用的信息。\n\n如果一个事务使用并且修改了多个数据库文件，那么每一个数据库都有它自己的回滚日志文件。他们是独立的回滚日志文件，互相都不知道对方的存在。为了建立相互的关系，SQLite额外维护了一个独立的交叉日志称为主日志文件。这个主日志文件一般都和主数据库文件在同一个目录下。这是一个临时文件。在事务准备提交的时候创建，在提交进程处理完成的时候删除。它不包含任何用来回滚的页面信息，而是包含了在这个事务内相关的所有独立的日志文件名。每一个数据库文件独立的日志文件，同样的包含这个主数据库的名字。如果没有attach的数据库(或者在当前事务中没有涉及attach的数据库的数据修改)，那么就不会创建这个主日志文件，并且各自独立的日志文件也不会包含任何关于主日志文件的信息。后面会讨论日志协议和提交协议。\n\n**不要对数据库文件起别名**:对同一个数据库文件不能使用不同的名字(硬链接或者软连接)。如果不同的应用对同一个数据库使用了不同的名字来访问数据库，那么在同一个数据库下就会产生不同名字的回滚日志文件，那么有可能会导致这些回滚日志被忽略，从而引起数据库的不一致。同样的，也不能修改数据库名而不修改日志文件。但即使这样，这个日志文件也有可能被主日志文件所引用。这样操作会有风险！\n\n## 日志记录协议\nSQLite遵循WAL的日志协议来确保数据库的一致性。SQLite实现了，在修改数据库的之前，先把原始的数据库分页写入到日志文件中。在日志文件中写入日志记录是延迟执行的:SQLite不会立刻在文件中刷入日志。在将页面写入到数据库文件之前，才会真正的刷新日志文件。日志刷新就是保证所有的日志记录以及真真正正地都落地到磁盘了。因为在落地前任何的变更都有可能会让数据库存在不一致的风险。\n\n## 提交协议\n默认的提交逻辑是，提交时刷新日志和释放时刷新数据库。当一个应用提交事务的时候，SQLite保证所有的日志记录都已经落到磁盘上了。在提交之后，日志文件就会被销毁，事务就完成了。在完成之前，如果发生了系统错误，那么事务提交就是失败，后面就会在数据库首次被读取的时候恢复数据库。然而，在释放回滚日志文件之前，所有的数据库文件变更都会被flush到磁盘上。这样就可以保证在释放日志文件之前，所有的变更也落地了。\n\n**异步事务和懒提交**:默认的事务都是同步事务。SQLite严格遵守上面说道的日志记录协议，和日志提交协议。仅管不推荐，但是SQLite还是允许事务允许在懒提交模式。这些被称之为异步事务。通过设置宏来实现。对于异步事务，SQLite不会再事务提交或者任何时间点，执行日志的flush和数据库的flush。因此，数据库写入和提交都会非常快。但是，会有风险。一旦出现了失败，数据库可能就不会存储一个完整的一致的状态。对于临时数据库来说，默认的事务就是异步模式，因为我们不需要关心临时数据库的数据库恢复。\n\n# 子事务管理\n一个语句级的子事务会通过用户事务请求锁。所有的锁都会通过事务来持有，一直到事务被提交或者被终止。但是SQLite的语句子事务会使用单独的一个日志文件来记录存储日志记录。语句级日志是一个临时文件，但是在事务因为终止等被要求恢复数据库的时候，是不会使用该文件的。SQLite会在语句级日志文件和一些主回滚日志文件中均写入一些日志记录。当且仅当对应的页面在子事务开始之前或者页面已经被前一个子事务添加进数据库的时候，页面已经被写入回滚日志文件的时候，日志记录才会被写入语句级文件。\n","slug":"2020-08-21_db-system-design-imp(Transaction)","published":1,"updated":"2022-07-28T13:38:40.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwoa001ap9c9gmet47ly","content":"<blockquote>\n<p>数据库管理系统的主要任务就是帮助用户在数据库上操作和存储数据。另外，DBMS还需要在用户的并发调用下保护数据库，以及在应用的崩溃，系统崩溃，系统掉电的情况下保持数据库的一致性。出于这些目的，DBMS在一个抽象的事务中执行所有的数据库操作。对于保持数据库的一致性来说，事务管理非常关键。SQLite依赖原生的文件锁，并且实现了页面日志来实现ACID。SQLite只支持一级事务，也就是说不支持事务嵌套。本文讨论了SQLite是如何实现了事务的ACID，从而更新单个和多个数据库。<code>Pager</code>那一篇文章会解释SQLite事务管理器pager的内部工作原理。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"事务类型\"><a href=\"#事务类型\" class=\"headerlink\" title=\"事务类型\"></a>事务类型</h1><p>几乎所有的DBMS使用锁机制来处理并发控制，并使用日志来保存恢复信息。在一个事务修改数据库项之前，一个DBMS就会将一条包含恢复信息(例如，更新的新旧数据)的日志记录写入日志文件。在DBMS修改数据库文件之前，DBMS需要确保日志记录已经完全存储在磁盘内了。在事务事件终止或者失败的时候，DBMS就会在日志文件中获取足够的信息，来回滚数据库到一个可接受的具有一致性的状态，并且不影响其他的事务。在恢复数据库的时候，DBMS就会撤销数据库中终止的事务带来的影响，并且重做数据库上已经提交的数据。在SQLite里，锁和日志的活动依赖事务的类型，本小节就会讨论这个。</p>\n<h2 id=\"系统事务\"><a href=\"#系统事务\" class=\"headerlink\" title=\"系统事务\"></a>系统事务</h2><p>SQLite每一个SQL语句的执行都会在事务内。它同时支持读事务和写事务。(在SQLite文档中，事务这个词本身就有点抽象。一个事务可能是一个读事务，也能是一个写事务。如果需要的话，后文均会特别指出。)应用要想读取数据库的任何数据，必须要在一个读或者写事务内，要想写数据，必须要在一个写事务内。应用无需特别指出要求SQLite将每一个SQL语句单独置于一个事务内，SQLite会自动这样处理；这是默认行为，系统默认就会在一个自动提交模式。这些事务称之为系统事务或者自动提交事务或者隐式事务。对于一个SELECT语句，SQLite会创建一个读事务来执行语句。对于非SELECT语句，SQLite会先创建一个读事务，然后将它转换为写事务。每一个读写事务都会在事务结束的时候自动提交。应用层并不知道系统事务。他们只需要向SQLite提交语句，剩下的事情就由SQLite完成。</p>\n<p>一个应用可以在同一个数据库连接上启动SELECT读事务的并发执行，但是在一个数据库连接上只能执行一个非SELECT的写事务。这意味着在数据库连接上，不能有两个并发的写事务，但可以有一个并发的写事务和多个读事务。</p>\n<p>非select语句的执行是原子的，SQLite当它执行一个非select语句的时候，会获取一个锁，并且在语句执行完成的时候会释放这个锁。另一方面，一个select语句不是原子的；它会在语句开始的时候获取一个锁，但是会在结果的每一行都会暂停和释放锁。所以一个select语句的执行，可以运行到它结果的第一行，这时候其它select语句可以运行，以此类推。因此在select语句的各个执行阶段可以有很多个其他select语句。在暂停的过程中，甚至可以执行一个非select语句。稍后会解释，读事务和写事务不能同时操作同一张表。因此，读取事务与并发写入事务是隔离的。</p>\n<h2 id=\"用户事务\"><a href=\"#用户事务\" class=\"headerlink\" title=\"用户事务\"></a>用户事务</h2><p>对于一些应用，尤其是那些写入敏感的来说，自动提交模式的代价可能比较昂贵，因为数据库可能会为每一个非select语句，频繁的打开，写入，和关闭日志文件。另外，在每一个SQL语句执行的时候，还会有一些并发控制的代价，因为应用需要在数据库文件上请求和释放文件锁。这些代价会给一些性能向的应用(尤其是大型应用)带来性能问题，只能通过将一个用户级的事务包含一些SQL语句来减少因此带来的性能影响。应用可以在<code>BEGIN TRANSACTION</code>和(<code>COMMIT TRANACTION</code>或<code>ROLLBACKTRANACTION</code>)这两个命令之间包含一系列的SQL语句。一个<code>begin-commit</code>或<code>begin-rolback</code>语句可以包含任意数量的select或者非select语句。</p>\n<p>应用可以在一个数据库连接上通过显式执行<code>BEGIN</code>命令来手动开启一个事务。而这个事务就被称之为用户级事务或者显式事务或者简单的说用户事务。当这一类事务开启的时候，SQLite就会离开默认自动提交模式，在每一个SQL语句执行过程期，它都不会调用提交或者终止。一个执行成功的非select语句是这个用户事务的一部分，但是select语句将会被看做一个独立的读事务。你可以把用户事务看做全都是的写事务。当应用执行<code>COMMIT</code>或者<code>ROLLBACK</code>的时候，SQLite就会提交或者回滚事务。用户事务提交时，写事务已经提交，但是所有的读事务依旧保持激活。但是如果用户事务终止的时候，写事务会回滚，并且一些读取已经被修改的表的读事务也会被终止。SQLite会在写事务完成之后将模式切换为自动提交模式。读事务在对应的读语句执行完成的时候就会被单独提交。</p>\n<p>SQLite只支持一级事务，即不支持在事务开始之后，再开启一个事务。也不支持在一个数据库连接上同时开启两个事务。</p>\n<h2 id=\"保存点\"><a href=\"#保存点\" class=\"headerlink\" title=\"保存点\"></a>保存点</h2><p>SQLite支持在用户事务中开启保存点。应用在事务内外均可以执行保存点的命令。对于在事务外开启保存点的情况，SQLite会首先打开一个用户事务，然后执行保存点命令，当应用释放保存点的时候，提交事务。所谓保存点就是事务执行过程中应用建立的一个点。建立了一个应用认为在此时的数据库状态是OK的一个点。一个事务中可以有很多个保存点。之后，它可以回滚到保存点中的任意一个，然后重新建立保存点时的数据库状态。</p>\n<h2 id=\"语句子事务\"><a href=\"#语句子事务\" class=\"headerlink\" title=\"语句子事务\"></a>语句子事务</h2><p>一个用户事务不仅仅是一个平坦的一级事务。所有执行成功的非select语句都在这个事务中。其中的每一个语句都会在一个单独的语句级的子事务中。在任何时候，在用户事务中最多只有一个子事务。事实上SQLite是使用隐式匿名的保存点来执行子事务，在这个子事务结束的时候释放保存点。这个过程也就会一直持续到事务完成，即执行COMMIT或者ABORT命令。如果当前的子语句执行失败了，SQLite不会立刻终止整个事务，除非事务的冲突解决是调用回滚(看本节后文)。而是将数据库恢复到语句执行开始之前的状态（通过还原匿名保存点）;用户事务也就从那个保存点开始继续执行。失败的语句不会更改其他先前执行的SQL语句或新语句的结果，除非主用户事务中止自身。下面看一个简单的SQLite事务例子:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BEGIN TRANSACTION;</span><br><span class=\"line\">    INSERT INTO table1 VALUES(100);</span><br><span class=\"line\">    INSERT INTO table2 VALUES(20,100);</span><br><span class=\"line\">    UPDATE table1 SET x=x+1 WHERE y &gt; 10;</span><br><span class=\"line\">    INSERT INTO table3 VALUES(1,2,3);</span><br><span class=\"line\">COMMIT TRANSACTION;</span><br></pre></td></tr></table></figure>\n\n<p>假设数据库有三个表分别是table1，table2和table3。应用会通过执行一个<code>begin transaction</code>来打开一个事务。上面的四个语句都会在一个单独的子事务中执行，按照书写的顺序，一个接一个执行。举个例子，如果在中间的UPDATE语句执行的时候，发生了一个约束错误，那么这个更新语句所带来的行更新都会恢复，但是其他的三个INSERT语句的变更就会在应用执行<code>COMMIT TRANSACTIOIN</code>语句的时候被提交到数据库。</p>\n<p><strong>冲突解决</strong>:当执行insert或者update违反约束的时候，一个语句有5种方法来解决冲突。<code>Rollback</code>:终止整个事务。<code>Abort</code>:停止并取消当前语句子事务的发生的变更；整个事务仍然有效。这是默认解决方法。<code>Fail</code>:接受当前语句子事务发生的变更，但是不再继续当前的语句；整个事务仍然有效。<code>Ignore</code>:导致约束违反的那些数据行不会发生变更;这个语句子事务仍然有效，并且会继续执行。<code>Replace</code>:导致约束违反的那些数据行都会被移除;这个语句子事务仍然有效，并且会继续执行。</p>\n<!---\n# 锁管理\n//TODO:\n## 锁的类型以及它们的职责\n////TODO:\n## 锁的请求策略\n////TODO:\n## 显式的锁\n////TODO:\n## 死锁和饥饿\n////TODO:\n## Linux锁原语\n////TODO:\n## SQLite锁的实现\n////TODO:\n### SQLite锁与原生文件锁的转换\n//////TODO:\n### 原生锁的工程问题\n//////TODO:\n### Linux系统问题\n//////TODO:\n### 多线程应用\n//////TODO:\n## 锁的API\n////TODO:\n### sqlite3OsLock\n//////TODO:\n### sqlite3OsUnlock\n//////TODO:\n--->\n<h1 id=\"日志管理\"><a href=\"#日志管理\" class=\"headerlink\" title=\"日志管理\"></a>日志管理</h1><p>日志即数据恢复文件，在发生事务或子语句级事务终止，或者系统问题的时候用来恢复数据库数据。SQLite为每一个数据库使用单个的日志文件(对于内存数据库来说，不会使用日志文件)。它仅确保事务的回滚（撤消，而不是重做），并且日志文件通常称为回滚日志。日志文件总是和数据库文件在同一个目录下，并且使用同样的名字，只不过后面跟随‘-journal’。</p>\n<p><strong>临时日志vs持久化日志文件</strong>:SQLite在同一时间同一个数据库文件上只允许最多只有一个写事务。在默认的操作模式下，它会为每一个写事务动态地创建日志文件，以及在事务完成的时候删除文件。当然，可以通过<code>journal mode</code>事件指令来裁剪，或者文件头部无效化，内存化或者关闭日志文件(还有wal模式)。默认的是删除。如果应用使用独占锁模式(<code>pragma locking_mode=exclusive</code>)。SQLite会在独占锁的模式下创建日志文件，并且日志文件会一直持续存在，直到离开这个模式。在这种情况下，在事务过程中，日志文件是会被截断或其标头为零。内存化的选项就是使数据库的日志文件完全存放在内存中，关闭的话就是不使用日志文件。</p>\n<p>当前写事务导致的更新操作会在日志文件中产生一条日志记录。当事务想要对数据库发生变更的时候，SQLite就会在回滚日志中写入足够的信息，以便为了可以在后续将数据库文件恢复到事务开始的时候。在目前的数据库社区中有很多数据库的日志结构；它们依赖于存在日志记录中的重做&#x2F;撤销信息。SQLite则是使用最简单，尽管不是最高效的方法。它在页面级粒度上使用旧值日志记录技术。(SQLite不会再恢复数据库上使用重做逻辑。总之，它不会在日志文件中存储新的值。)因此，在一个事务首次修改任何一个页面的时候，SQLite都会将页面的原始数据包括页面号作为新的日志记录的一部分，存储在回滚日志中。</p>\n<p>一旦一个页面数据被拷贝进回滚日志的时候，这个页面就不会再次以新日志记录的形势添加进去了，尽管后面可能对这个页面发生了多次的变更。这个页面级撤消日志记录的一个不错的特性是:可以通过将内容从日记文件盲目复制到数据库文件中来还原页面，并且撤消操作是幂等(可重复执行)的。这个撤销操作不会产生任何的补偿日志。SQLite不会在日志文件中存储一个新的页面，因为新页面没有旧数据。相反，日志会在日志头部记录下在日志文件创建时的数据库原始大小。如果数据库文件因为事务被扩展了，文件就会被缩减到之前的原始大小。</p>\n<p><strong>跟踪已经记录的日志页面</strong>:SQLite在内存中使用一个map数据结构来持续跟踪那些在当前事务中已经被日志文件记录的页面。因此内存空间的开销，和发生变更的页面数量成正比。对于小型数据库来说，这些开销可以忽略不计。</p>\n<p><strong>日志优化</strong>:已释放的叶子节点的页面内容被当做可以回收的垃圾。当这个页面被使用的时候，page就不会被记录日志，因为它没有任何有用的信息。</p>\n<p>如果一个事务使用并且修改了多个数据库文件，那么每一个数据库都有它自己的回滚日志文件。他们是独立的回滚日志文件，互相都不知道对方的存在。为了建立相互的关系，SQLite额外维护了一个独立的交叉日志称为主日志文件。这个主日志文件一般都和主数据库文件在同一个目录下。这是一个临时文件。在事务准备提交的时候创建，在提交进程处理完成的时候删除。它不包含任何用来回滚的页面信息，而是包含了在这个事务内相关的所有独立的日志文件名。每一个数据库文件独立的日志文件，同样的包含这个主数据库的名字。如果没有attach的数据库(或者在当前事务中没有涉及attach的数据库的数据修改)，那么就不会创建这个主日志文件，并且各自独立的日志文件也不会包含任何关于主日志文件的信息。后面会讨论日志协议和提交协议。</p>\n<p><strong>不要对数据库文件起别名</strong>:对同一个数据库文件不能使用不同的名字(硬链接或者软连接)。如果不同的应用对同一个数据库使用了不同的名字来访问数据库，那么在同一个数据库下就会产生不同名字的回滚日志文件，那么有可能会导致这些回滚日志被忽略，从而引起数据库的不一致。同样的，也不能修改数据库名而不修改日志文件。但即使这样，这个日志文件也有可能被主日志文件所引用。这样操作会有风险！</p>\n<h2 id=\"日志记录协议\"><a href=\"#日志记录协议\" class=\"headerlink\" title=\"日志记录协议\"></a>日志记录协议</h2><p>SQLite遵循WAL的日志协议来确保数据库的一致性。SQLite实现了，在修改数据库的之前，先把原始的数据库分页写入到日志文件中。在日志文件中写入日志记录是延迟执行的:SQLite不会立刻在文件中刷入日志。在将页面写入到数据库文件之前，才会真正的刷新日志文件。日志刷新就是保证所有的日志记录以及真真正正地都落地到磁盘了。因为在落地前任何的变更都有可能会让数据库存在不一致的风险。</p>\n<h2 id=\"提交协议\"><a href=\"#提交协议\" class=\"headerlink\" title=\"提交协议\"></a>提交协议</h2><p>默认的提交逻辑是，提交时刷新日志和释放时刷新数据库。当一个应用提交事务的时候，SQLite保证所有的日志记录都已经落到磁盘上了。在提交之后，日志文件就会被销毁，事务就完成了。在完成之前，如果发生了系统错误，那么事务提交就是失败，后面就会在数据库首次被读取的时候恢复数据库。然而，在释放回滚日志文件之前，所有的数据库文件变更都会被flush到磁盘上。这样就可以保证在释放日志文件之前，所有的变更也落地了。</p>\n<p><strong>异步事务和懒提交</strong>:默认的事务都是同步事务。SQLite严格遵守上面说道的日志记录协议，和日志提交协议。仅管不推荐，但是SQLite还是允许事务允许在懒提交模式。这些被称之为异步事务。通过设置宏来实现。对于异步事务，SQLite不会再事务提交或者任何时间点，执行日志的flush和数据库的flush。因此，数据库写入和提交都会非常快。但是，会有风险。一旦出现了失败，数据库可能就不会存储一个完整的一致的状态。对于临时数据库来说，默认的事务就是异步模式，因为我们不需要关心临时数据库的数据库恢复。</p>\n<h1 id=\"子事务管理\"><a href=\"#子事务管理\" class=\"headerlink\" title=\"子事务管理\"></a>子事务管理</h1><p>一个语句级的子事务会通过用户事务请求锁。所有的锁都会通过事务来持有，一直到事务被提交或者被终止。但是SQLite的语句子事务会使用单独的一个日志文件来记录存储日志记录。语句级日志是一个临时文件，但是在事务因为终止等被要求恢复数据库的时候，是不会使用该文件的。SQLite会在语句级日志文件和一些主回滚日志文件中均写入一些日志记录。当且仅当对应的页面在子事务开始之前或者页面已经被前一个子事务添加进数据库的时候，页面已经被写入回滚日志文件的时候，日志记录才会被写入语句级文件。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>数据库管理系统的主要任务就是帮助用户在数据库上操作和存储数据。另外，DBMS还需要在用户的并发调用下保护数据库，以及在应用的崩溃，系统崩溃，系统掉电的情况下保持数据库的一致性。出于这些目的，DBMS在一个抽象的事务中执行所有的数据库操作。对于保持数据库的一致性来说，事务管理非常关键。SQLite依赖原生的文件锁，并且实现了页面日志来实现ACID。SQLite只支持一级事务，也就是说不支持事务嵌套。本文讨论了SQLite是如何实现了事务的ACID，从而更新单个和多个数据库。<code>Pager</code>那一篇文章会解释SQLite事务管理器pager的内部工作原理。</p>\n</blockquote>","more":"<h1 id=\"事务类型\"><a href=\"#事务类型\" class=\"headerlink\" title=\"事务类型\"></a>事务类型</h1><p>几乎所有的DBMS使用锁机制来处理并发控制，并使用日志来保存恢复信息。在一个事务修改数据库项之前，一个DBMS就会将一条包含恢复信息(例如，更新的新旧数据)的日志记录写入日志文件。在DBMS修改数据库文件之前，DBMS需要确保日志记录已经完全存储在磁盘内了。在事务事件终止或者失败的时候，DBMS就会在日志文件中获取足够的信息，来回滚数据库到一个可接受的具有一致性的状态，并且不影响其他的事务。在恢复数据库的时候，DBMS就会撤销数据库中终止的事务带来的影响，并且重做数据库上已经提交的数据。在SQLite里，锁和日志的活动依赖事务的类型，本小节就会讨论这个。</p>\n<h2 id=\"系统事务\"><a href=\"#系统事务\" class=\"headerlink\" title=\"系统事务\"></a>系统事务</h2><p>SQLite每一个SQL语句的执行都会在事务内。它同时支持读事务和写事务。(在SQLite文档中，事务这个词本身就有点抽象。一个事务可能是一个读事务，也能是一个写事务。如果需要的话，后文均会特别指出。)应用要想读取数据库的任何数据，必须要在一个读或者写事务内，要想写数据，必须要在一个写事务内。应用无需特别指出要求SQLite将每一个SQL语句单独置于一个事务内，SQLite会自动这样处理；这是默认行为，系统默认就会在一个自动提交模式。这些事务称之为系统事务或者自动提交事务或者隐式事务。对于一个SELECT语句，SQLite会创建一个读事务来执行语句。对于非SELECT语句，SQLite会先创建一个读事务，然后将它转换为写事务。每一个读写事务都会在事务结束的时候自动提交。应用层并不知道系统事务。他们只需要向SQLite提交语句，剩下的事情就由SQLite完成。</p>\n<p>一个应用可以在同一个数据库连接上启动SELECT读事务的并发执行，但是在一个数据库连接上只能执行一个非SELECT的写事务。这意味着在数据库连接上，不能有两个并发的写事务，但可以有一个并发的写事务和多个读事务。</p>\n<p>非select语句的执行是原子的，SQLite当它执行一个非select语句的时候，会获取一个锁，并且在语句执行完成的时候会释放这个锁。另一方面，一个select语句不是原子的；它会在语句开始的时候获取一个锁，但是会在结果的每一行都会暂停和释放锁。所以一个select语句的执行，可以运行到它结果的第一行，这时候其它select语句可以运行，以此类推。因此在select语句的各个执行阶段可以有很多个其他select语句。在暂停的过程中，甚至可以执行一个非select语句。稍后会解释，读事务和写事务不能同时操作同一张表。因此，读取事务与并发写入事务是隔离的。</p>\n<h2 id=\"用户事务\"><a href=\"#用户事务\" class=\"headerlink\" title=\"用户事务\"></a>用户事务</h2><p>对于一些应用，尤其是那些写入敏感的来说，自动提交模式的代价可能比较昂贵，因为数据库可能会为每一个非select语句，频繁的打开，写入，和关闭日志文件。另外，在每一个SQL语句执行的时候，还会有一些并发控制的代价，因为应用需要在数据库文件上请求和释放文件锁。这些代价会给一些性能向的应用(尤其是大型应用)带来性能问题，只能通过将一个用户级的事务包含一些SQL语句来减少因此带来的性能影响。应用可以在<code>BEGIN TRANSACTION</code>和(<code>COMMIT TRANACTION</code>或<code>ROLLBACKTRANACTION</code>)这两个命令之间包含一系列的SQL语句。一个<code>begin-commit</code>或<code>begin-rolback</code>语句可以包含任意数量的select或者非select语句。</p>\n<p>应用可以在一个数据库连接上通过显式执行<code>BEGIN</code>命令来手动开启一个事务。而这个事务就被称之为用户级事务或者显式事务或者简单的说用户事务。当这一类事务开启的时候，SQLite就会离开默认自动提交模式，在每一个SQL语句执行过程期，它都不会调用提交或者终止。一个执行成功的非select语句是这个用户事务的一部分，但是select语句将会被看做一个独立的读事务。你可以把用户事务看做全都是的写事务。当应用执行<code>COMMIT</code>或者<code>ROLLBACK</code>的时候，SQLite就会提交或者回滚事务。用户事务提交时，写事务已经提交，但是所有的读事务依旧保持激活。但是如果用户事务终止的时候，写事务会回滚，并且一些读取已经被修改的表的读事务也会被终止。SQLite会在写事务完成之后将模式切换为自动提交模式。读事务在对应的读语句执行完成的时候就会被单独提交。</p>\n<p>SQLite只支持一级事务，即不支持在事务开始之后，再开启一个事务。也不支持在一个数据库连接上同时开启两个事务。</p>\n<h2 id=\"保存点\"><a href=\"#保存点\" class=\"headerlink\" title=\"保存点\"></a>保存点</h2><p>SQLite支持在用户事务中开启保存点。应用在事务内外均可以执行保存点的命令。对于在事务外开启保存点的情况，SQLite会首先打开一个用户事务，然后执行保存点命令，当应用释放保存点的时候，提交事务。所谓保存点就是事务执行过程中应用建立的一个点。建立了一个应用认为在此时的数据库状态是OK的一个点。一个事务中可以有很多个保存点。之后，它可以回滚到保存点中的任意一个，然后重新建立保存点时的数据库状态。</p>\n<h2 id=\"语句子事务\"><a href=\"#语句子事务\" class=\"headerlink\" title=\"语句子事务\"></a>语句子事务</h2><p>一个用户事务不仅仅是一个平坦的一级事务。所有执行成功的非select语句都在这个事务中。其中的每一个语句都会在一个单独的语句级的子事务中。在任何时候，在用户事务中最多只有一个子事务。事实上SQLite是使用隐式匿名的保存点来执行子事务，在这个子事务结束的时候释放保存点。这个过程也就会一直持续到事务完成，即执行COMMIT或者ABORT命令。如果当前的子语句执行失败了，SQLite不会立刻终止整个事务，除非事务的冲突解决是调用回滚(看本节后文)。而是将数据库恢复到语句执行开始之前的状态（通过还原匿名保存点）;用户事务也就从那个保存点开始继续执行。失败的语句不会更改其他先前执行的SQL语句或新语句的结果，除非主用户事务中止自身。下面看一个简单的SQLite事务例子:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BEGIN TRANSACTION;</span><br><span class=\"line\">    INSERT INTO table1 VALUES(100);</span><br><span class=\"line\">    INSERT INTO table2 VALUES(20,100);</span><br><span class=\"line\">    UPDATE table1 SET x=x+1 WHERE y &gt; 10;</span><br><span class=\"line\">    INSERT INTO table3 VALUES(1,2,3);</span><br><span class=\"line\">COMMIT TRANSACTION;</span><br></pre></td></tr></table></figure>\n\n<p>假设数据库有三个表分别是table1，table2和table3。应用会通过执行一个<code>begin transaction</code>来打开一个事务。上面的四个语句都会在一个单独的子事务中执行，按照书写的顺序，一个接一个执行。举个例子，如果在中间的UPDATE语句执行的时候，发生了一个约束错误，那么这个更新语句所带来的行更新都会恢复，但是其他的三个INSERT语句的变更就会在应用执行<code>COMMIT TRANSACTIOIN</code>语句的时候被提交到数据库。</p>\n<p><strong>冲突解决</strong>:当执行insert或者update违反约束的时候，一个语句有5种方法来解决冲突。<code>Rollback</code>:终止整个事务。<code>Abort</code>:停止并取消当前语句子事务的发生的变更；整个事务仍然有效。这是默认解决方法。<code>Fail</code>:接受当前语句子事务发生的变更，但是不再继续当前的语句；整个事务仍然有效。<code>Ignore</code>:导致约束违反的那些数据行不会发生变更;这个语句子事务仍然有效，并且会继续执行。<code>Replace</code>:导致约束违反的那些数据行都会被移除;这个语句子事务仍然有效，并且会继续执行。</p>\n<!---\n# 锁管理\n//TODO:\n## 锁的类型以及它们的职责\n////TODO:\n## 锁的请求策略\n////TODO:\n## 显式的锁\n////TODO:\n## 死锁和饥饿\n////TODO:\n## Linux锁原语\n////TODO:\n## SQLite锁的实现\n////TODO:\n### SQLite锁与原生文件锁的转换\n//////TODO:\n### 原生锁的工程问题\n//////TODO:\n### Linux系统问题\n//////TODO:\n### 多线程应用\n//////TODO:\n## 锁的API\n////TODO:\n### sqlite3OsLock\n//////TODO:\n### sqlite3OsUnlock\n//////TODO:\n--->\n<h1 id=\"日志管理\"><a href=\"#日志管理\" class=\"headerlink\" title=\"日志管理\"></a>日志管理</h1><p>日志即数据恢复文件，在发生事务或子语句级事务终止，或者系统问题的时候用来恢复数据库数据。SQLite为每一个数据库使用单个的日志文件(对于内存数据库来说，不会使用日志文件)。它仅确保事务的回滚（撤消，而不是重做），并且日志文件通常称为回滚日志。日志文件总是和数据库文件在同一个目录下，并且使用同样的名字，只不过后面跟随‘-journal’。</p>\n<p><strong>临时日志vs持久化日志文件</strong>:SQLite在同一时间同一个数据库文件上只允许最多只有一个写事务。在默认的操作模式下，它会为每一个写事务动态地创建日志文件，以及在事务完成的时候删除文件。当然，可以通过<code>journal mode</code>事件指令来裁剪，或者文件头部无效化，内存化或者关闭日志文件(还有wal模式)。默认的是删除。如果应用使用独占锁模式(<code>pragma locking_mode=exclusive</code>)。SQLite会在独占锁的模式下创建日志文件，并且日志文件会一直持续存在，直到离开这个模式。在这种情况下，在事务过程中，日志文件是会被截断或其标头为零。内存化的选项就是使数据库的日志文件完全存放在内存中，关闭的话就是不使用日志文件。</p>\n<p>当前写事务导致的更新操作会在日志文件中产生一条日志记录。当事务想要对数据库发生变更的时候，SQLite就会在回滚日志中写入足够的信息，以便为了可以在后续将数据库文件恢复到事务开始的时候。在目前的数据库社区中有很多数据库的日志结构；它们依赖于存在日志记录中的重做&#x2F;撤销信息。SQLite则是使用最简单，尽管不是最高效的方法。它在页面级粒度上使用旧值日志记录技术。(SQLite不会再恢复数据库上使用重做逻辑。总之，它不会在日志文件中存储新的值。)因此，在一个事务首次修改任何一个页面的时候，SQLite都会将页面的原始数据包括页面号作为新的日志记录的一部分，存储在回滚日志中。</p>\n<p>一旦一个页面数据被拷贝进回滚日志的时候，这个页面就不会再次以新日志记录的形势添加进去了，尽管后面可能对这个页面发生了多次的变更。这个页面级撤消日志记录的一个不错的特性是:可以通过将内容从日记文件盲目复制到数据库文件中来还原页面，并且撤消操作是幂等(可重复执行)的。这个撤销操作不会产生任何的补偿日志。SQLite不会在日志文件中存储一个新的页面，因为新页面没有旧数据。相反，日志会在日志头部记录下在日志文件创建时的数据库原始大小。如果数据库文件因为事务被扩展了，文件就会被缩减到之前的原始大小。</p>\n<p><strong>跟踪已经记录的日志页面</strong>:SQLite在内存中使用一个map数据结构来持续跟踪那些在当前事务中已经被日志文件记录的页面。因此内存空间的开销，和发生变更的页面数量成正比。对于小型数据库来说，这些开销可以忽略不计。</p>\n<p><strong>日志优化</strong>:已释放的叶子节点的页面内容被当做可以回收的垃圾。当这个页面被使用的时候，page就不会被记录日志，因为它没有任何有用的信息。</p>\n<p>如果一个事务使用并且修改了多个数据库文件，那么每一个数据库都有它自己的回滚日志文件。他们是独立的回滚日志文件，互相都不知道对方的存在。为了建立相互的关系，SQLite额外维护了一个独立的交叉日志称为主日志文件。这个主日志文件一般都和主数据库文件在同一个目录下。这是一个临时文件。在事务准备提交的时候创建，在提交进程处理完成的时候删除。它不包含任何用来回滚的页面信息，而是包含了在这个事务内相关的所有独立的日志文件名。每一个数据库文件独立的日志文件，同样的包含这个主数据库的名字。如果没有attach的数据库(或者在当前事务中没有涉及attach的数据库的数据修改)，那么就不会创建这个主日志文件，并且各自独立的日志文件也不会包含任何关于主日志文件的信息。后面会讨论日志协议和提交协议。</p>\n<p><strong>不要对数据库文件起别名</strong>:对同一个数据库文件不能使用不同的名字(硬链接或者软连接)。如果不同的应用对同一个数据库使用了不同的名字来访问数据库，那么在同一个数据库下就会产生不同名字的回滚日志文件，那么有可能会导致这些回滚日志被忽略，从而引起数据库的不一致。同样的，也不能修改数据库名而不修改日志文件。但即使这样，这个日志文件也有可能被主日志文件所引用。这样操作会有风险！</p>\n<h2 id=\"日志记录协议\"><a href=\"#日志记录协议\" class=\"headerlink\" title=\"日志记录协议\"></a>日志记录协议</h2><p>SQLite遵循WAL的日志协议来确保数据库的一致性。SQLite实现了，在修改数据库的之前，先把原始的数据库分页写入到日志文件中。在日志文件中写入日志记录是延迟执行的:SQLite不会立刻在文件中刷入日志。在将页面写入到数据库文件之前，才会真正的刷新日志文件。日志刷新就是保证所有的日志记录以及真真正正地都落地到磁盘了。因为在落地前任何的变更都有可能会让数据库存在不一致的风险。</p>\n<h2 id=\"提交协议\"><a href=\"#提交协议\" class=\"headerlink\" title=\"提交协议\"></a>提交协议</h2><p>默认的提交逻辑是，提交时刷新日志和释放时刷新数据库。当一个应用提交事务的时候，SQLite保证所有的日志记录都已经落到磁盘上了。在提交之后，日志文件就会被销毁，事务就完成了。在完成之前，如果发生了系统错误，那么事务提交就是失败，后面就会在数据库首次被读取的时候恢复数据库。然而，在释放回滚日志文件之前，所有的数据库文件变更都会被flush到磁盘上。这样就可以保证在释放日志文件之前，所有的变更也落地了。</p>\n<p><strong>异步事务和懒提交</strong>:默认的事务都是同步事务。SQLite严格遵守上面说道的日志记录协议，和日志提交协议。仅管不推荐，但是SQLite还是允许事务允许在懒提交模式。这些被称之为异步事务。通过设置宏来实现。对于异步事务，SQLite不会再事务提交或者任何时间点，执行日志的flush和数据库的flush。因此，数据库写入和提交都会非常快。但是，会有风险。一旦出现了失败，数据库可能就不会存储一个完整的一致的状态。对于临时数据库来说，默认的事务就是异步模式，因为我们不需要关心临时数据库的数据库恢复。</p>\n<h1 id=\"子事务管理\"><a href=\"#子事务管理\" class=\"headerlink\" title=\"子事务管理\"></a>子事务管理</h1><p>一个语句级的子事务会通过用户事务请求锁。所有的锁都会通过事务来持有，一直到事务被提交或者被终止。但是SQLite的语句子事务会使用单独的一个日志文件来记录存储日志记录。语句级日志是一个临时文件，但是在事务因为终止等被要求恢复数据库的时候，是不会使用该文件的。SQLite会在语句级日志文件和一些主回滚日志文件中均写入一些日志记录。当且仅当对应的页面在子事务开始之前或者页面已经被前一个子事务添加进数据库的时候，页面已经被写入回滚日志文件的时候，日志记录才会被写入语句级文件。</p>"},{"title":"Storage","date":"2020-08-24T16:00:00.000Z","top":300,"_content":"\n> 本文讨论了SQLite如何在最底层，组织数据库内容和日志文件内容。它定义了这些文件的格式。将一整个数据库文件划分为固定大小的页面，这些页面用来存储B/B+树页面，空闲页面，和其他页面。在默认的日志模式下，日志文件将数据库页面的镜像前内容存储为日志记录；但是，在WAL日志模式式下，日志文件存储了数据库页面的更新后的镜像内容。\n\n<!-- more -->\n\n<!---\n# 数据库命名规范\n--->\n\n# 数据库文件结构\n除了内存数据库，SQLite将整个数据库存储在单个数据库文件中。在其生命周期中，数据库文件会增长和收缩。原生的文件系统就把这个文件当做一个普通的原始文件。它不会干涉文件的内容；它把文件内容看做字节串。它实现了读/写的原语，以从任意偏移位置开始读/写文件中的任意字节数。它同样也支持文件的同步(flush)操作。\n\n## 页面抽象化\n为了简化空间管理以及从数据库文件读取/写入数据，SQLite将每一个数据库文件(包括内存数据库)划分为固定大小的区域，称之为数据库页面或页面。因此，数据库文件的大小永远是页面的整数倍。页面编号从1开始线性增长。第一个页面为页面1，第二个页面为页面2，以此类推。页面0会被当做空页面，这个页面物理上也不存在。从文件偏移量0开始，第1页及其之后的页面依次线性地存储到数据库文件中，如图所示。可以把一个数据库文件看做固定大小页面的数组集合。页面号可以被用来当做访问页面的索引。(事实上Pager模块就是在原生文件系统上抽象出了一层。)\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/XLYFMb.png)\n\n## 页面大小\n默认的页面大小是1024个字节，但这是一个编译期的自定义参数，可以在编译前修改这个值。页面大小必须是2的次幂，并且范围在[512(=2^9),65536(=2^16)]。其中最大值的限制是2个字节的无符号整型可以表示的最大的数。一个数据库文件最多可以有(2^31-1)个页面，这个数字是被硬编码在pager.c源码的`PAGER_MAX_PGNO`宏内的。因此，一个数据库可以最大有140个TB字节，当然，这个也受到原生文件系统的限制。\n\n**改变页面大小**:一旦一个数据库文件被创建了，SQLite就会使用编译器设定的默认页面大小。但是你可以通过执行pragma命令，在创建第一个数据库表之前修改这个值。SQLite会把这个值存储在数据库文件的元数据内，后续就会使用这个值作为数据库的页面大小了。即使以后使用针对其他默认页面大小定制的其他SQLite库，该数据库文件也可以正常工作。\n\n## 页面类型\n不论这些页面是否正在使用，SQLite会持续跟踪所有分配给数据库文件的页面。它会在文件中存储所有的跟踪信息。(在SQLite中没有垃圾回收的机制。)基于这些用途，这些页面分为4种类型:空闲页面，树页面，指针映射页面(用于autovacuum和incremental vacuum特性)，锁页面。而树页面又分为几个子类型:叶子节点页面，内部节点页面，溢出页面。空闲页面是非活跃页面，即当前不被使用；其它的就是活动页面，并且除了指针映射页面和锁页面之外都属于B树或者B+树。B+树的内部节点页面包含搜索树的搜索导航信息。(B树的内部节点同时包含搜索信息和数据。)B+树的叶子节点存储了真正的数据(例如表中的行)。如果一行的数据太大不足以放在单个页面内，那么一部分数据存储在页面内，剩下的就会放在若干个溢出页面。\n\n## 数据库元数据\nSQLite可以使用任何页面类型来表示任何一个数据库页面。1号页面是一个独例，它是B+树的内部页面，存储了`sqlite_master`或者`sqlite_temp_master`表的根节点。这个页面包含了100字节的文件头记录，从文件偏移0开始。\n\n文件头信息描述了数据库文件的结构。它定义了一些数据库的设置参数，又称元数据。SQLite会在创建文件的时候初始化这个头部。下面是这个文件头的格式，前两列都是以字节为单位。\n\n| 偏移 | 大小 | 描述 |\n| ---- | ---- | ---- |\n| 0 | 16 | 头魔数\"SQLite format 3\" |\n| 16 | 2 | 页面的大小 |\n| 18 | 1 | 写入的文件格式版本 |\n| 19 | 1 | 读取的文件格式版本 |\n| 20 | 1 | 每一个页面尾部的保留字节数 |\n| 21 | 1 | 最大内嵌载体占比 |\n| 22 | 1 | 最小内嵌载体占比 |\n| 23 | 1 | 最小叶子节点的载体占比 |\n| 24 | 4 | 文件变更计数器 |\n| 28 | 4 | 数据库文件的页面数量 |\n| 32 | 4 | 空闲页面链表的第一个 |\n| 36 | 4 | 文件中的空闲页面的数量 |\n| 40 | 4 | 结构缓存值 |\n| 44 | 56 | 传递给上层的14个4字节的元数据 |\n\n* **头部字符串**:一个16字节的UTF-8字符串\"SQLite format 3\"\n* **页面大小**:数据库中页面的大小。这个值必须是2的n次幂，并在[512，32768]之间，或者用1表示65536。正如上面所提到的，SQLite在操作这个文件的时候就会使用这个页面大小。(对于同一个数据库连接，可以在同一个时间对不同的数据库文件使用不同的页面大小。)\n* **文件格式**:在偏移为18，19的位置有两个字节，用来表示文件格式的版本。在当前版本的SQLite中，它们都必须为1或2，否则将出错且无法访问数据库。值为1则对应旧版本的回滚日志(早于SQLite3.7.0)，值为2则对应WAL日志(在SQLite3.7.0版本之后)。后续有新特性，这个值会继续增加。\n* **保留空间**:SQLite会在每个页面的最后保留一个固定的小于255字节的空间，用用于一些其他目的。这个值会被存在偏移为20的地方，默认值是0。当数据库使用SQLite的内置（专有）加密技术时，该值不为零。每页末尾的额外字节存储一个随机数，该随机数供该页面的加密算法使用。页面的前半部分（页面大小减去保留空间大小）是存储数据库内容的可用空间，该空间必须至少为480个字节。\n* **内嵌载体**:最大内嵌载体占比（在偏移量21处）是页面中的可用空间总量，该空间可由标准B/B+树内部节点的单个条目（称为单元或记录）使用。值255表示100%。<br/>该值为64（即25％):该值是为了限制最大单元大小，以便在一个节点上至少容纳四个单元。如果某个单元的有效载体大于最大值，则部分载体内容会溢出到溢出页面中。一旦SQLite分配了溢出页，它将尽可能多的字节移入溢出页，但是不会让单元大小降至最小内嵌载体占比值以下（偏移量22）。这个值为32(即12.5%)。<br/>最小叶子节点的载体占比(在偏移量23处)和最小内嵌载体占比相似，但它仅适用于B+树叶子页。该值为32(即12.5%)。叶节点的最大内嵌载体占比始终为100％（或255），因此未在头部中指定。（另外B树中没有专用叶节点。）\n* **文件变更计数器**:这个计数器在事务中会被使用。初始化的值是0。这个计数值，在每次被写事务写入数据库数据的时候都会递增。此值用来表示数据库何时被更改，以便pager可以清除其页面缓存。(当在文件格式使用WAL日志的时候，计数器不会被使用。)\n* **数据库大小**:数据库页面的数量存储在偏移量为28的位置。\n* **空闲链表**:数据库文件头部偏移为32的地方存储了空闲页面链表。偏移量为36的地方存储了空闲页面的总数。下一小节会细说这个空闲链表。\n* **数据库结构缓存**:在偏移量为40的地方存储了一个4字节的整型值，初始化为0。当数据库结构变更的时候这个值就会递增，并且在语句预处理的时候，会做一些有效性测试检查(例如表是否存在等等)。\n* **其他元数据变量**:在偏移量为44的地方，有14个字节的整型值，保留给Tree模块和VM模块。它们表示许多元变量的值，包括偏移量44处的结构值。（建议）页面高速缓存大小为48，自动清理的相关信息为52（0为无自动清理，否则为数据库文件中最远的根页面的页号），文本编码为56（值1表示UTF-8、2代表UTF-16 LE，3代表UTF-16 BE），用户版本号为60（不给SQLite使用，但给用户使用），增量清理模式为64（无清理为0，其他为清理值），以及版本号在偏移量92和96处；其余字节保留供将来使用，并且必须清零。\n\n**增量清理 vs. 自动清理**:如果在偏移值为52处的4字节整型和在偏移值为64处的4字节整型为0；数据库文件上则没有自动清理。用户可以通过执行`vacuum`命令来手动清理。如果前者是非零，后者是零，则自动清理是打开的；否则自动清理关闭并且增量清理打开。\n\n如上所述，在1号页面中的文件头后面跟着一个B+树的内部节点。这个节点就是主目录表的根节点，名为`sqlite_master`或`sqlite_temp_master`。这个表内存储了当前数据库内的所有其他根页面页面号。因此1号页面帮助SQLite来跟踪其他的树页面或者移除页面，这也是最重要的一个页面。\n\n## 空闲链表的结构\n数据库文件头部偏移量为32出标明了空闲页面链表。而偏移量为36处则存储了空闲链表的总数。空闲列表组织在有根的主干中，如图所示。空闲链表页面有两种类型，主干页面和叶子页面。文件头指向主干页链接列表中的第一个。每一个主干页面都指向了多个叶子页面。(叶子页面的内容是不确定的，可能是垃圾。)\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/obFGdI.png)\n\n主干页面会如下结构化，从页面的最初起点开始:(1)一个4字节的页面号指向下一个主干页面(如果没有下一个就会是0)。(2)一个四字节的整型用来标明存储在这个页面上的叶子页面数量。(3)若干个四字节字节的叶子页面号。\n\n当一个页面变成非活跃状态的时候，SQLite就会将它加入到空闲链表，并且不会将它释放归还给原生文件系统。当需要添加新的信息到数据库的时候，SQLite会占据空闲链表中的页面来存储新信息。(因此说新的数据可能会存储在数据库中的任何一个地方。)如果空闲链表是空的，那么SQLite会从原生文件系统中请求新的页面，并且添加到数据库文件的尾部。\n\n在有些情况下，可能需要关心当空闲的数据库页面数量过高的时候。可以运行`VACUUM`命令来清理空闲链表，并且缩减数据库文件大小，将一些不使用的页面归还给文件系统。数据库在`autovacuum`模式下创建的话会在每一个事务提交的时候都会自动缩减数据库。虽然在事务提交之前会建立空闲页面链表，但是在事务后这个链表依旧会保持空。\n\n**空闲链表的清理**当通过执行`vacuum`命令来清理空闲链表的时候，命令会将数据库复制到一个临时文件中。然后将这个临时数据库覆盖原始数据库，但整个过程都会在一个事务锁的保护下。\n\n# 日志文件结构\nSQLite使用三种类型的日志文件，分别是回滚日志文件，语句级日志文件，和主日志文件。(这些都被称为传统日志。在SQLite3.7.0的版本中，SQLite开发着团队介绍了WAL日志结构。一个数据库文件要么是传统日志模式，要么是WAL日志模式。)接下来就会讨论传统日志的日志记录结构。\n\n## 回滚日志文件\n对于每一个数据库，SQLite都会维护一个回滚日志文件。(内存数据库不需要使用日志文件。它们会使用内存来存储日志信息。)回滚日志文件一般都存在和原始数据库文件的同级目录下。在默认模式下，日志文件是一个临时文件。SQLite在每一个写事务开始的时候创建日志文件，并在事务完成的时候删除文件。\n\nSQLite将每一个回滚日志文件分割为几个可变大小的日志片段，如下图所示。每个日志片段有一个片段头部，后面跟着几个日志记录。后面会详细讨论这个。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/gRdkE3.png)\n\n### 片段头部结构\n下图展示了日志片段头部的结构。日志头部以8个字节开头:0xD9, 0xD5, 0x05, 0xF9, 0x20, 0xAl, 0x63, 0xD7, 也就是文件头的魔数。日志记录的数量(4字节的短整型 `nRec`)记录了当前日志片段中一共有多少个有效的日志记录。`nRec`的值对于异步事务的初始化值为-1，对于同步事务的初始化值为0。随机值部分用来计算单个日志记录的“校验和”。初始化的页面数记录记录了在当前日志开始的时候原始数据库内有多少页面数。扇区大小是数据库文件所在磁盘的磁盘扇区大小。一个片段头部的大小占据了一个完整的扇区大小。也就是说，整个片段头部大小等于在头部中记录的这个扇区大小值。页面大小就是数据库分页时的页面大小。未使用的空间为保留空间。所有整数值都是大端值。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/4IGQSO.png)\n\n**决定扇区大小**:SQLite查询底层文件系统以获取扇区大小。（如果系统没有提供，使用512作为默认值。）SQLite假定文件系统不允许更改某个扇区上的单个字节，而是按照扇区的大小一次性读写。\n\n一个回滚日志文件通常包含单个记录片段。但是在某些场景下，它会是多个记录片段的文件，并且SQLite会在文件中多次写入片段头部。(可以看pager文章的**缓存刷新**一节)每次片段头部记录写入的时候，都是以扇区大小为单位。在多片段的日志文件中，任何一个片段头部的`nRec`字段都不可能是-1。\n\n**日志维护**:在偏移为0的位置如果存在一个有效的片段头部，那么这个回滚日志也是有效的。如果文件大小是0或者包含了一个无效的片段头部，那么这个日志文件就不会用来做事务的回滚。\n\n**异步日志**:SQLite支持异步事务，比通常的同步事务快很多。异步事务不会在任何时候刷新日志文件或者数据库文件，日志文件只有一个日志片段，`nRec`永远是-1，实际值是从文件大小中得出的。SQLite不建议使用异步事务，但是你依旧可以使用`pragma`命令来开启异步事务。这个模式一般用在开发阶段，用来减少开发调试时间的。同时也满足测试应用，因为一些应用无需测试数据恢复的case。\n\n### 日志记录结构\n当前事务的非select的语句会产生日志记录。SQLite在页面的粒度上，使用旧值记录技术。在首次修改任何一个页面的时候，就会将原始的页面数据，包括页面号，作为一个新的日志记录写入日志文件。下图描述了一个单独的日志记录的结构。日志记录还包含了一个4字节32位的校验和。校验和覆盖了页面号和页面数据镜像。在日志片段头部的4字节32位的随机数，用来作为校验和的秘钥。随机数很重要，因为出现在日志末尾的垃圾数据很可能是曾经存在于其他文件中的数据，而这些文件现在已被删除。如果垃圾数据来自过时的日志文件，校验和也有可能是正确的。但是，针对不同日志文件通过将校验和初始化为不同的随机值，SQLite可以最大程度地降低这种风险。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/hhJK3N.png)\n\n**校验和的位置**:可以注意到，页面号存储在日志记录的头部，而校验和存储在日志记录的尾部。这个设定很重要。SQLite的开发者假定了文件中的数据作为字节字符串按扇区线性写入。所以如果日志文件因为断电发生了不一致错误，那么大概率场景是后面的校验和不一致。几乎不可能会出现两头一致，中间不一致的情况。因此，这个校验和的结构，仅管简单粗暴，但是已经涵盖了大部分的场景。\n\n## 语句级日志\n在一个用户事务中，SQLite为每一个最新的写操作语句的维护了一个语句级的子日志，而这些语句有可能会修改多行数据，也有可能会导致约束冲突，或者在触发器内抛出异常。日志文件会在这些语句执行过程中被用来恢复数据库。语句日志是一个单独的，原始的回滚日志文件。它是一个任意命名的临时文件（以etilqs_为前缀）。它位于用于临时文件的本地目录中。崩溃恢复操作不需要该文件；仅在语句中止时才需要。当语句执行完成的时候，这个文件就会被SQLite删除。这个日志文件没有片段头部记录。语句执行开始时，`nRec`（日志记录数）值保留在内存数据结构中，数据库文件大小也会被保留。这些日志记录没有校验和。\n\n**语句级日志的持久化**:语句执行结束时，将删除语句日志文件。但是，为了要实现SAVEPOINT，SQLite会保留语句日志，直到释放保存点或提交用户事务为止。\n\n## 多数据库事务日志，主日志文件\n一个应用可以通过执行`ATTACH`命令，打开多个额外的数据库。在这个场景下，SQLite允许用户事务读和修改多个数据库。如果事务修改了多个数据库，那么这些数据库会有自己的回滚日志文件。它们将会是独立的回滚日志文件，并且相互透明。这一类事务会对每一个更新的数据库单独提交事务。因此这个事务可能就不是全局原子的。为了让一个多数据库事务全局原子，SQLite额外的维护了一个单独的交叉日志，称之为主日志文件。这个日志文件不是用来回滚数据的。相反，它包含了参与事务的所有UTF-8格式的独立回滚日志的名字。(在本节上下文内，回滚日志被称为子回滚日志。)子回滚日志的名字是全路径名，并且被空字符相隔开。主数据库日志文件，会和主数据库文件在同一个目录下，并且后面会跟随'-mj'，以及8个随机的16进制数。这是一个临时文件，在事务开始尝试提交的时候创建，在事务完成的时候删除。事务中止不会创建主日志文件。\n\n每一个子日志文件同样也包含主日志文件的全路径名(看下图)。正如图中所示，主回滚日志记录跟在子日志记录的最后，这会在事务完成的时候写入。这个记录也会对齐扇区大小。校验和字段存储了主回滚日志文件名的校验和。长度字段指定了这个主回滚日志文件名的长度。主回滚日志文件名会以UTF-8的编码格式存储，包含了最后的终止符。禁用页号，是包含锁的字节偏移数。SQLite不会使用这个页面，它是保留用来兼容windows和类POSIX的问题(这个可以看原生锁相关部分)。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/82fzFb.png)","source":"_posts/2020-08-25_db-system-design-im(storage).md","raw":"---\ntitle: Storage\ndate: 2020-08-25\ntags: [sqlite3]\ntop: 300\ncategories: sqlite3\n---\n\n> 本文讨论了SQLite如何在最底层，组织数据库内容和日志文件内容。它定义了这些文件的格式。将一整个数据库文件划分为固定大小的页面，这些页面用来存储B/B+树页面，空闲页面，和其他页面。在默认的日志模式下，日志文件将数据库页面的镜像前内容存储为日志记录；但是，在WAL日志模式式下，日志文件存储了数据库页面的更新后的镜像内容。\n\n<!-- more -->\n\n<!---\n# 数据库命名规范\n--->\n\n# 数据库文件结构\n除了内存数据库，SQLite将整个数据库存储在单个数据库文件中。在其生命周期中，数据库文件会增长和收缩。原生的文件系统就把这个文件当做一个普通的原始文件。它不会干涉文件的内容；它把文件内容看做字节串。它实现了读/写的原语，以从任意偏移位置开始读/写文件中的任意字节数。它同样也支持文件的同步(flush)操作。\n\n## 页面抽象化\n为了简化空间管理以及从数据库文件读取/写入数据，SQLite将每一个数据库文件(包括内存数据库)划分为固定大小的区域，称之为数据库页面或页面。因此，数据库文件的大小永远是页面的整数倍。页面编号从1开始线性增长。第一个页面为页面1，第二个页面为页面2，以此类推。页面0会被当做空页面，这个页面物理上也不存在。从文件偏移量0开始，第1页及其之后的页面依次线性地存储到数据库文件中，如图所示。可以把一个数据库文件看做固定大小页面的数组集合。页面号可以被用来当做访问页面的索引。(事实上Pager模块就是在原生文件系统上抽象出了一层。)\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/XLYFMb.png)\n\n## 页面大小\n默认的页面大小是1024个字节，但这是一个编译期的自定义参数，可以在编译前修改这个值。页面大小必须是2的次幂，并且范围在[512(=2^9),65536(=2^16)]。其中最大值的限制是2个字节的无符号整型可以表示的最大的数。一个数据库文件最多可以有(2^31-1)个页面，这个数字是被硬编码在pager.c源码的`PAGER_MAX_PGNO`宏内的。因此，一个数据库可以最大有140个TB字节，当然，这个也受到原生文件系统的限制。\n\n**改变页面大小**:一旦一个数据库文件被创建了，SQLite就会使用编译器设定的默认页面大小。但是你可以通过执行pragma命令，在创建第一个数据库表之前修改这个值。SQLite会把这个值存储在数据库文件的元数据内，后续就会使用这个值作为数据库的页面大小了。即使以后使用针对其他默认页面大小定制的其他SQLite库，该数据库文件也可以正常工作。\n\n## 页面类型\n不论这些页面是否正在使用，SQLite会持续跟踪所有分配给数据库文件的页面。它会在文件中存储所有的跟踪信息。(在SQLite中没有垃圾回收的机制。)基于这些用途，这些页面分为4种类型:空闲页面，树页面，指针映射页面(用于autovacuum和incremental vacuum特性)，锁页面。而树页面又分为几个子类型:叶子节点页面，内部节点页面，溢出页面。空闲页面是非活跃页面，即当前不被使用；其它的就是活动页面，并且除了指针映射页面和锁页面之外都属于B树或者B+树。B+树的内部节点页面包含搜索树的搜索导航信息。(B树的内部节点同时包含搜索信息和数据。)B+树的叶子节点存储了真正的数据(例如表中的行)。如果一行的数据太大不足以放在单个页面内，那么一部分数据存储在页面内，剩下的就会放在若干个溢出页面。\n\n## 数据库元数据\nSQLite可以使用任何页面类型来表示任何一个数据库页面。1号页面是一个独例，它是B+树的内部页面，存储了`sqlite_master`或者`sqlite_temp_master`表的根节点。这个页面包含了100字节的文件头记录，从文件偏移0开始。\n\n文件头信息描述了数据库文件的结构。它定义了一些数据库的设置参数，又称元数据。SQLite会在创建文件的时候初始化这个头部。下面是这个文件头的格式，前两列都是以字节为单位。\n\n| 偏移 | 大小 | 描述 |\n| ---- | ---- | ---- |\n| 0 | 16 | 头魔数\"SQLite format 3\" |\n| 16 | 2 | 页面的大小 |\n| 18 | 1 | 写入的文件格式版本 |\n| 19 | 1 | 读取的文件格式版本 |\n| 20 | 1 | 每一个页面尾部的保留字节数 |\n| 21 | 1 | 最大内嵌载体占比 |\n| 22 | 1 | 最小内嵌载体占比 |\n| 23 | 1 | 最小叶子节点的载体占比 |\n| 24 | 4 | 文件变更计数器 |\n| 28 | 4 | 数据库文件的页面数量 |\n| 32 | 4 | 空闲页面链表的第一个 |\n| 36 | 4 | 文件中的空闲页面的数量 |\n| 40 | 4 | 结构缓存值 |\n| 44 | 56 | 传递给上层的14个4字节的元数据 |\n\n* **头部字符串**:一个16字节的UTF-8字符串\"SQLite format 3\"\n* **页面大小**:数据库中页面的大小。这个值必须是2的n次幂，并在[512，32768]之间，或者用1表示65536。正如上面所提到的，SQLite在操作这个文件的时候就会使用这个页面大小。(对于同一个数据库连接，可以在同一个时间对不同的数据库文件使用不同的页面大小。)\n* **文件格式**:在偏移为18，19的位置有两个字节，用来表示文件格式的版本。在当前版本的SQLite中，它们都必须为1或2，否则将出错且无法访问数据库。值为1则对应旧版本的回滚日志(早于SQLite3.7.0)，值为2则对应WAL日志(在SQLite3.7.0版本之后)。后续有新特性，这个值会继续增加。\n* **保留空间**:SQLite会在每个页面的最后保留一个固定的小于255字节的空间，用用于一些其他目的。这个值会被存在偏移为20的地方，默认值是0。当数据库使用SQLite的内置（专有）加密技术时，该值不为零。每页末尾的额外字节存储一个随机数，该随机数供该页面的加密算法使用。页面的前半部分（页面大小减去保留空间大小）是存储数据库内容的可用空间，该空间必须至少为480个字节。\n* **内嵌载体**:最大内嵌载体占比（在偏移量21处）是页面中的可用空间总量，该空间可由标准B/B+树内部节点的单个条目（称为单元或记录）使用。值255表示100%。<br/>该值为64（即25％):该值是为了限制最大单元大小，以便在一个节点上至少容纳四个单元。如果某个单元的有效载体大于最大值，则部分载体内容会溢出到溢出页面中。一旦SQLite分配了溢出页，它将尽可能多的字节移入溢出页，但是不会让单元大小降至最小内嵌载体占比值以下（偏移量22）。这个值为32(即12.5%)。<br/>最小叶子节点的载体占比(在偏移量23处)和最小内嵌载体占比相似，但它仅适用于B+树叶子页。该值为32(即12.5%)。叶节点的最大内嵌载体占比始终为100％（或255），因此未在头部中指定。（另外B树中没有专用叶节点。）\n* **文件变更计数器**:这个计数器在事务中会被使用。初始化的值是0。这个计数值，在每次被写事务写入数据库数据的时候都会递增。此值用来表示数据库何时被更改，以便pager可以清除其页面缓存。(当在文件格式使用WAL日志的时候，计数器不会被使用。)\n* **数据库大小**:数据库页面的数量存储在偏移量为28的位置。\n* **空闲链表**:数据库文件头部偏移为32的地方存储了空闲页面链表。偏移量为36的地方存储了空闲页面的总数。下一小节会细说这个空闲链表。\n* **数据库结构缓存**:在偏移量为40的地方存储了一个4字节的整型值，初始化为0。当数据库结构变更的时候这个值就会递增，并且在语句预处理的时候，会做一些有效性测试检查(例如表是否存在等等)。\n* **其他元数据变量**:在偏移量为44的地方，有14个字节的整型值，保留给Tree模块和VM模块。它们表示许多元变量的值，包括偏移量44处的结构值。（建议）页面高速缓存大小为48，自动清理的相关信息为52（0为无自动清理，否则为数据库文件中最远的根页面的页号），文本编码为56（值1表示UTF-8、2代表UTF-16 LE，3代表UTF-16 BE），用户版本号为60（不给SQLite使用，但给用户使用），增量清理模式为64（无清理为0，其他为清理值），以及版本号在偏移量92和96处；其余字节保留供将来使用，并且必须清零。\n\n**增量清理 vs. 自动清理**:如果在偏移值为52处的4字节整型和在偏移值为64处的4字节整型为0；数据库文件上则没有自动清理。用户可以通过执行`vacuum`命令来手动清理。如果前者是非零，后者是零，则自动清理是打开的；否则自动清理关闭并且增量清理打开。\n\n如上所述，在1号页面中的文件头后面跟着一个B+树的内部节点。这个节点就是主目录表的根节点，名为`sqlite_master`或`sqlite_temp_master`。这个表内存储了当前数据库内的所有其他根页面页面号。因此1号页面帮助SQLite来跟踪其他的树页面或者移除页面，这也是最重要的一个页面。\n\n## 空闲链表的结构\n数据库文件头部偏移量为32出标明了空闲页面链表。而偏移量为36处则存储了空闲链表的总数。空闲列表组织在有根的主干中，如图所示。空闲链表页面有两种类型，主干页面和叶子页面。文件头指向主干页链接列表中的第一个。每一个主干页面都指向了多个叶子页面。(叶子页面的内容是不确定的，可能是垃圾。)\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/obFGdI.png)\n\n主干页面会如下结构化，从页面的最初起点开始:(1)一个4字节的页面号指向下一个主干页面(如果没有下一个就会是0)。(2)一个四字节的整型用来标明存储在这个页面上的叶子页面数量。(3)若干个四字节字节的叶子页面号。\n\n当一个页面变成非活跃状态的时候，SQLite就会将它加入到空闲链表，并且不会将它释放归还给原生文件系统。当需要添加新的信息到数据库的时候，SQLite会占据空闲链表中的页面来存储新信息。(因此说新的数据可能会存储在数据库中的任何一个地方。)如果空闲链表是空的，那么SQLite会从原生文件系统中请求新的页面，并且添加到数据库文件的尾部。\n\n在有些情况下，可能需要关心当空闲的数据库页面数量过高的时候。可以运行`VACUUM`命令来清理空闲链表，并且缩减数据库文件大小，将一些不使用的页面归还给文件系统。数据库在`autovacuum`模式下创建的话会在每一个事务提交的时候都会自动缩减数据库。虽然在事务提交之前会建立空闲页面链表，但是在事务后这个链表依旧会保持空。\n\n**空闲链表的清理**当通过执行`vacuum`命令来清理空闲链表的时候，命令会将数据库复制到一个临时文件中。然后将这个临时数据库覆盖原始数据库，但整个过程都会在一个事务锁的保护下。\n\n# 日志文件结构\nSQLite使用三种类型的日志文件，分别是回滚日志文件，语句级日志文件，和主日志文件。(这些都被称为传统日志。在SQLite3.7.0的版本中，SQLite开发着团队介绍了WAL日志结构。一个数据库文件要么是传统日志模式，要么是WAL日志模式。)接下来就会讨论传统日志的日志记录结构。\n\n## 回滚日志文件\n对于每一个数据库，SQLite都会维护一个回滚日志文件。(内存数据库不需要使用日志文件。它们会使用内存来存储日志信息。)回滚日志文件一般都存在和原始数据库文件的同级目录下。在默认模式下，日志文件是一个临时文件。SQLite在每一个写事务开始的时候创建日志文件，并在事务完成的时候删除文件。\n\nSQLite将每一个回滚日志文件分割为几个可变大小的日志片段，如下图所示。每个日志片段有一个片段头部，后面跟着几个日志记录。后面会详细讨论这个。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/gRdkE3.png)\n\n### 片段头部结构\n下图展示了日志片段头部的结构。日志头部以8个字节开头:0xD9, 0xD5, 0x05, 0xF9, 0x20, 0xAl, 0x63, 0xD7, 也就是文件头的魔数。日志记录的数量(4字节的短整型 `nRec`)记录了当前日志片段中一共有多少个有效的日志记录。`nRec`的值对于异步事务的初始化值为-1，对于同步事务的初始化值为0。随机值部分用来计算单个日志记录的“校验和”。初始化的页面数记录记录了在当前日志开始的时候原始数据库内有多少页面数。扇区大小是数据库文件所在磁盘的磁盘扇区大小。一个片段头部的大小占据了一个完整的扇区大小。也就是说，整个片段头部大小等于在头部中记录的这个扇区大小值。页面大小就是数据库分页时的页面大小。未使用的空间为保留空间。所有整数值都是大端值。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/4IGQSO.png)\n\n**决定扇区大小**:SQLite查询底层文件系统以获取扇区大小。（如果系统没有提供，使用512作为默认值。）SQLite假定文件系统不允许更改某个扇区上的单个字节，而是按照扇区的大小一次性读写。\n\n一个回滚日志文件通常包含单个记录片段。但是在某些场景下，它会是多个记录片段的文件，并且SQLite会在文件中多次写入片段头部。(可以看pager文章的**缓存刷新**一节)每次片段头部记录写入的时候，都是以扇区大小为单位。在多片段的日志文件中，任何一个片段头部的`nRec`字段都不可能是-1。\n\n**日志维护**:在偏移为0的位置如果存在一个有效的片段头部，那么这个回滚日志也是有效的。如果文件大小是0或者包含了一个无效的片段头部，那么这个日志文件就不会用来做事务的回滚。\n\n**异步日志**:SQLite支持异步事务，比通常的同步事务快很多。异步事务不会在任何时候刷新日志文件或者数据库文件，日志文件只有一个日志片段，`nRec`永远是-1，实际值是从文件大小中得出的。SQLite不建议使用异步事务，但是你依旧可以使用`pragma`命令来开启异步事务。这个模式一般用在开发阶段，用来减少开发调试时间的。同时也满足测试应用，因为一些应用无需测试数据恢复的case。\n\n### 日志记录结构\n当前事务的非select的语句会产生日志记录。SQLite在页面的粒度上，使用旧值记录技术。在首次修改任何一个页面的时候，就会将原始的页面数据，包括页面号，作为一个新的日志记录写入日志文件。下图描述了一个单独的日志记录的结构。日志记录还包含了一个4字节32位的校验和。校验和覆盖了页面号和页面数据镜像。在日志片段头部的4字节32位的随机数，用来作为校验和的秘钥。随机数很重要，因为出现在日志末尾的垃圾数据很可能是曾经存在于其他文件中的数据，而这些文件现在已被删除。如果垃圾数据来自过时的日志文件，校验和也有可能是正确的。但是，针对不同日志文件通过将校验和初始化为不同的随机值，SQLite可以最大程度地降低这种风险。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/hhJK3N.png)\n\n**校验和的位置**:可以注意到，页面号存储在日志记录的头部，而校验和存储在日志记录的尾部。这个设定很重要。SQLite的开发者假定了文件中的数据作为字节字符串按扇区线性写入。所以如果日志文件因为断电发生了不一致错误，那么大概率场景是后面的校验和不一致。几乎不可能会出现两头一致，中间不一致的情况。因此，这个校验和的结构，仅管简单粗暴，但是已经涵盖了大部分的场景。\n\n## 语句级日志\n在一个用户事务中，SQLite为每一个最新的写操作语句的维护了一个语句级的子日志，而这些语句有可能会修改多行数据，也有可能会导致约束冲突，或者在触发器内抛出异常。日志文件会在这些语句执行过程中被用来恢复数据库。语句日志是一个单独的，原始的回滚日志文件。它是一个任意命名的临时文件（以etilqs_为前缀）。它位于用于临时文件的本地目录中。崩溃恢复操作不需要该文件；仅在语句中止时才需要。当语句执行完成的时候，这个文件就会被SQLite删除。这个日志文件没有片段头部记录。语句执行开始时，`nRec`（日志记录数）值保留在内存数据结构中，数据库文件大小也会被保留。这些日志记录没有校验和。\n\n**语句级日志的持久化**:语句执行结束时，将删除语句日志文件。但是，为了要实现SAVEPOINT，SQLite会保留语句日志，直到释放保存点或提交用户事务为止。\n\n## 多数据库事务日志，主日志文件\n一个应用可以通过执行`ATTACH`命令，打开多个额外的数据库。在这个场景下，SQLite允许用户事务读和修改多个数据库。如果事务修改了多个数据库，那么这些数据库会有自己的回滚日志文件。它们将会是独立的回滚日志文件，并且相互透明。这一类事务会对每一个更新的数据库单独提交事务。因此这个事务可能就不是全局原子的。为了让一个多数据库事务全局原子，SQLite额外的维护了一个单独的交叉日志，称之为主日志文件。这个日志文件不是用来回滚数据的。相反，它包含了参与事务的所有UTF-8格式的独立回滚日志的名字。(在本节上下文内，回滚日志被称为子回滚日志。)子回滚日志的名字是全路径名，并且被空字符相隔开。主数据库日志文件，会和主数据库文件在同一个目录下，并且后面会跟随'-mj'，以及8个随机的16进制数。这是一个临时文件，在事务开始尝试提交的时候创建，在事务完成的时候删除。事务中止不会创建主日志文件。\n\n每一个子日志文件同样也包含主日志文件的全路径名(看下图)。正如图中所示，主回滚日志记录跟在子日志记录的最后，这会在事务完成的时候写入。这个记录也会对齐扇区大小。校验和字段存储了主回滚日志文件名的校验和。长度字段指定了这个主回滚日志文件名的长度。主回滚日志文件名会以UTF-8的编码格式存储，包含了最后的终止符。禁用页号，是包含锁的字节偏移数。SQLite不会使用这个页面，它是保留用来兼容windows和类POSIX的问题(这个可以看原生锁相关部分)。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/82fzFb.png)","slug":"2020-08-25_db-system-design-im(storage)","published":1,"updated":"2022-07-28T13:38:40.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwob001fp9c99kg08lta","content":"<blockquote>\n<p>本文讨论了SQLite如何在最底层，组织数据库内容和日志文件内容。它定义了这些文件的格式。将一整个数据库文件划分为固定大小的页面，这些页面用来存储B&#x2F;B+树页面，空闲页面，和其他页面。在默认的日志模式下，日志文件将数据库页面的镜像前内容存储为日志记录；但是，在WAL日志模式式下，日志文件存储了数据库页面的更新后的镜像内容。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<!---\n# 数据库命名规范\n--->\n\n<h1 id=\"数据库文件结构\"><a href=\"#数据库文件结构\" class=\"headerlink\" title=\"数据库文件结构\"></a>数据库文件结构</h1><p>除了内存数据库，SQLite将整个数据库存储在单个数据库文件中。在其生命周期中，数据库文件会增长和收缩。原生的文件系统就把这个文件当做一个普通的原始文件。它不会干涉文件的内容；它把文件内容看做字节串。它实现了读&#x2F;写的原语，以从任意偏移位置开始读&#x2F;写文件中的任意字节数。它同样也支持文件的同步(flush)操作。</p>\n<h2 id=\"页面抽象化\"><a href=\"#页面抽象化\" class=\"headerlink\" title=\"页面抽象化\"></a>页面抽象化</h2><p>为了简化空间管理以及从数据库文件读取&#x2F;写入数据，SQLite将每一个数据库文件(包括内存数据库)划分为固定大小的区域，称之为数据库页面或页面。因此，数据库文件的大小永远是页面的整数倍。页面编号从1开始线性增长。第一个页面为页面1，第二个页面为页面2，以此类推。页面0会被当做空页面，这个页面物理上也不存在。从文件偏移量0开始，第1页及其之后的页面依次线性地存储到数据库文件中，如图所示。可以把一个数据库文件看做固定大小页面的数组集合。页面号可以被用来当做访问页面的索引。(事实上Pager模块就是在原生文件系统上抽象出了一层。)</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/XLYFMb.png\"></p>\n<h2 id=\"页面大小\"><a href=\"#页面大小\" class=\"headerlink\" title=\"页面大小\"></a>页面大小</h2><p>默认的页面大小是1024个字节，但这是一个编译期的自定义参数，可以在编译前修改这个值。页面大小必须是2的次幂，并且范围在[512(&#x3D;2^9),65536(&#x3D;2^16)]。其中最大值的限制是2个字节的无符号整型可以表示的最大的数。一个数据库文件最多可以有(2^31-1)个页面，这个数字是被硬编码在pager.c源码的<code>PAGER_MAX_PGNO</code>宏内的。因此，一个数据库可以最大有140个TB字节，当然，这个也受到原生文件系统的限制。</p>\n<p><strong>改变页面大小</strong>:一旦一个数据库文件被创建了，SQLite就会使用编译器设定的默认页面大小。但是你可以通过执行pragma命令，在创建第一个数据库表之前修改这个值。SQLite会把这个值存储在数据库文件的元数据内，后续就会使用这个值作为数据库的页面大小了。即使以后使用针对其他默认页面大小定制的其他SQLite库，该数据库文件也可以正常工作。</p>\n<h2 id=\"页面类型\"><a href=\"#页面类型\" class=\"headerlink\" title=\"页面类型\"></a>页面类型</h2><p>不论这些页面是否正在使用，SQLite会持续跟踪所有分配给数据库文件的页面。它会在文件中存储所有的跟踪信息。(在SQLite中没有垃圾回收的机制。)基于这些用途，这些页面分为4种类型:空闲页面，树页面，指针映射页面(用于autovacuum和incremental vacuum特性)，锁页面。而树页面又分为几个子类型:叶子节点页面，内部节点页面，溢出页面。空闲页面是非活跃页面，即当前不被使用；其它的就是活动页面，并且除了指针映射页面和锁页面之外都属于B树或者B+树。B+树的内部节点页面包含搜索树的搜索导航信息。(B树的内部节点同时包含搜索信息和数据。)B+树的叶子节点存储了真正的数据(例如表中的行)。如果一行的数据太大不足以放在单个页面内，那么一部分数据存储在页面内，剩下的就会放在若干个溢出页面。</p>\n<h2 id=\"数据库元数据\"><a href=\"#数据库元数据\" class=\"headerlink\" title=\"数据库元数据\"></a>数据库元数据</h2><p>SQLite可以使用任何页面类型来表示任何一个数据库页面。1号页面是一个独例，它是B+树的内部页面，存储了<code>sqlite_master</code>或者<code>sqlite_temp_master</code>表的根节点。这个页面包含了100字节的文件头记录，从文件偏移0开始。</p>\n<p>文件头信息描述了数据库文件的结构。它定义了一些数据库的设置参数，又称元数据。SQLite会在创建文件的时候初始化这个头部。下面是这个文件头的格式，前两列都是以字节为单位。</p>\n<table>\n<thead>\n<tr>\n<th>偏移</th>\n<th>大小</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>16</td>\n<td>头魔数”SQLite format 3”</td>\n</tr>\n<tr>\n<td>16</td>\n<td>2</td>\n<td>页面的大小</td>\n</tr>\n<tr>\n<td>18</td>\n<td>1</td>\n<td>写入的文件格式版本</td>\n</tr>\n<tr>\n<td>19</td>\n<td>1</td>\n<td>读取的文件格式版本</td>\n</tr>\n<tr>\n<td>20</td>\n<td>1</td>\n<td>每一个页面尾部的保留字节数</td>\n</tr>\n<tr>\n<td>21</td>\n<td>1</td>\n<td>最大内嵌载体占比</td>\n</tr>\n<tr>\n<td>22</td>\n<td>1</td>\n<td>最小内嵌载体占比</td>\n</tr>\n<tr>\n<td>23</td>\n<td>1</td>\n<td>最小叶子节点的载体占比</td>\n</tr>\n<tr>\n<td>24</td>\n<td>4</td>\n<td>文件变更计数器</td>\n</tr>\n<tr>\n<td>28</td>\n<td>4</td>\n<td>数据库文件的页面数量</td>\n</tr>\n<tr>\n<td>32</td>\n<td>4</td>\n<td>空闲页面链表的第一个</td>\n</tr>\n<tr>\n<td>36</td>\n<td>4</td>\n<td>文件中的空闲页面的数量</td>\n</tr>\n<tr>\n<td>40</td>\n<td>4</td>\n<td>结构缓存值</td>\n</tr>\n<tr>\n<td>44</td>\n<td>56</td>\n<td>传递给上层的14个4字节的元数据</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>头部字符串</strong>:一个16字节的UTF-8字符串”SQLite format 3”</li>\n<li><strong>页面大小</strong>:数据库中页面的大小。这个值必须是2的n次幂，并在[512，32768]之间，或者用1表示65536。正如上面所提到的，SQLite在操作这个文件的时候就会使用这个页面大小。(对于同一个数据库连接，可以在同一个时间对不同的数据库文件使用不同的页面大小。)</li>\n<li><strong>文件格式</strong>:在偏移为18，19的位置有两个字节，用来表示文件格式的版本。在当前版本的SQLite中，它们都必须为1或2，否则将出错且无法访问数据库。值为1则对应旧版本的回滚日志(早于SQLite3.7.0)，值为2则对应WAL日志(在SQLite3.7.0版本之后)。后续有新特性，这个值会继续增加。</li>\n<li><strong>保留空间</strong>:SQLite会在每个页面的最后保留一个固定的小于255字节的空间，用用于一些其他目的。这个值会被存在偏移为20的地方，默认值是0。当数据库使用SQLite的内置（专有）加密技术时，该值不为零。每页末尾的额外字节存储一个随机数，该随机数供该页面的加密算法使用。页面的前半部分（页面大小减去保留空间大小）是存储数据库内容的可用空间，该空间必须至少为480个字节。</li>\n<li><strong>内嵌载体</strong>:最大内嵌载体占比（在偏移量21处）是页面中的可用空间总量，该空间可由标准B&#x2F;B+树内部节点的单个条目（称为单元或记录）使用。值255表示100%。<br/>该值为64（即25％):该值是为了限制最大单元大小，以便在一个节点上至少容纳四个单元。如果某个单元的有效载体大于最大值，则部分载体内容会溢出到溢出页面中。一旦SQLite分配了溢出页，它将尽可能多的字节移入溢出页，但是不会让单元大小降至最小内嵌载体占比值以下（偏移量22）。这个值为32(即12.5%)。<br/>最小叶子节点的载体占比(在偏移量23处)和最小内嵌载体占比相似，但它仅适用于B+树叶子页。该值为32(即12.5%)。叶节点的最大内嵌载体占比始终为100％（或255），因此未在头部中指定。（另外B树中没有专用叶节点。）</li>\n<li><strong>文件变更计数器</strong>:这个计数器在事务中会被使用。初始化的值是0。这个计数值，在每次被写事务写入数据库数据的时候都会递增。此值用来表示数据库何时被更改，以便pager可以清除其页面缓存。(当在文件格式使用WAL日志的时候，计数器不会被使用。)</li>\n<li><strong>数据库大小</strong>:数据库页面的数量存储在偏移量为28的位置。</li>\n<li><strong>空闲链表</strong>:数据库文件头部偏移为32的地方存储了空闲页面链表。偏移量为36的地方存储了空闲页面的总数。下一小节会细说这个空闲链表。</li>\n<li><strong>数据库结构缓存</strong>:在偏移量为40的地方存储了一个4字节的整型值，初始化为0。当数据库结构变更的时候这个值就会递增，并且在语句预处理的时候，会做一些有效性测试检查(例如表是否存在等等)。</li>\n<li><strong>其他元数据变量</strong>:在偏移量为44的地方，有14个字节的整型值，保留给Tree模块和VM模块。它们表示许多元变量的值，包括偏移量44处的结构值。（建议）页面高速缓存大小为48，自动清理的相关信息为52（0为无自动清理，否则为数据库文件中最远的根页面的页号），文本编码为56（值1表示UTF-8、2代表UTF-16 LE，3代表UTF-16 BE），用户版本号为60（不给SQLite使用，但给用户使用），增量清理模式为64（无清理为0，其他为清理值），以及版本号在偏移量92和96处；其余字节保留供将来使用，并且必须清零。</li>\n</ul>\n<p><strong>增量清理 vs. 自动清理</strong>:如果在偏移值为52处的4字节整型和在偏移值为64处的4字节整型为0；数据库文件上则没有自动清理。用户可以通过执行<code>vacuum</code>命令来手动清理。如果前者是非零，后者是零，则自动清理是打开的；否则自动清理关闭并且增量清理打开。</p>\n<p>如上所述，在1号页面中的文件头后面跟着一个B+树的内部节点。这个节点就是主目录表的根节点，名为<code>sqlite_master</code>或<code>sqlite_temp_master</code>。这个表内存储了当前数据库内的所有其他根页面页面号。因此1号页面帮助SQLite来跟踪其他的树页面或者移除页面，这也是最重要的一个页面。</p>\n<h2 id=\"空闲链表的结构\"><a href=\"#空闲链表的结构\" class=\"headerlink\" title=\"空闲链表的结构\"></a>空闲链表的结构</h2><p>数据库文件头部偏移量为32出标明了空闲页面链表。而偏移量为36处则存储了空闲链表的总数。空闲列表组织在有根的主干中，如图所示。空闲链表页面有两种类型，主干页面和叶子页面。文件头指向主干页链接列表中的第一个。每一个主干页面都指向了多个叶子页面。(叶子页面的内容是不确定的，可能是垃圾。)</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/obFGdI.png\"></p>\n<p>主干页面会如下结构化，从页面的最初起点开始:(1)一个4字节的页面号指向下一个主干页面(如果没有下一个就会是0)。(2)一个四字节的整型用来标明存储在这个页面上的叶子页面数量。(3)若干个四字节字节的叶子页面号。</p>\n<p>当一个页面变成非活跃状态的时候，SQLite就会将它加入到空闲链表，并且不会将它释放归还给原生文件系统。当需要添加新的信息到数据库的时候，SQLite会占据空闲链表中的页面来存储新信息。(因此说新的数据可能会存储在数据库中的任何一个地方。)如果空闲链表是空的，那么SQLite会从原生文件系统中请求新的页面，并且添加到数据库文件的尾部。</p>\n<p>在有些情况下，可能需要关心当空闲的数据库页面数量过高的时候。可以运行<code>VACUUM</code>命令来清理空闲链表，并且缩减数据库文件大小，将一些不使用的页面归还给文件系统。数据库在<code>autovacuum</code>模式下创建的话会在每一个事务提交的时候都会自动缩减数据库。虽然在事务提交之前会建立空闲页面链表，但是在事务后这个链表依旧会保持空。</p>\n<p><strong>空闲链表的清理</strong>当通过执行<code>vacuum</code>命令来清理空闲链表的时候，命令会将数据库复制到一个临时文件中。然后将这个临时数据库覆盖原始数据库，但整个过程都会在一个事务锁的保护下。</p>\n<h1 id=\"日志文件结构\"><a href=\"#日志文件结构\" class=\"headerlink\" title=\"日志文件结构\"></a>日志文件结构</h1><p>SQLite使用三种类型的日志文件，分别是回滚日志文件，语句级日志文件，和主日志文件。(这些都被称为传统日志。在SQLite3.7.0的版本中，SQLite开发着团队介绍了WAL日志结构。一个数据库文件要么是传统日志模式，要么是WAL日志模式。)接下来就会讨论传统日志的日志记录结构。</p>\n<h2 id=\"回滚日志文件\"><a href=\"#回滚日志文件\" class=\"headerlink\" title=\"回滚日志文件\"></a>回滚日志文件</h2><p>对于每一个数据库，SQLite都会维护一个回滚日志文件。(内存数据库不需要使用日志文件。它们会使用内存来存储日志信息。)回滚日志文件一般都存在和原始数据库文件的同级目录下。在默认模式下，日志文件是一个临时文件。SQLite在每一个写事务开始的时候创建日志文件，并在事务完成的时候删除文件。</p>\n<p>SQLite将每一个回滚日志文件分割为几个可变大小的日志片段，如下图所示。每个日志片段有一个片段头部，后面跟着几个日志记录。后面会详细讨论这个。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/gRdkE3.png\"></p>\n<h3 id=\"片段头部结构\"><a href=\"#片段头部结构\" class=\"headerlink\" title=\"片段头部结构\"></a>片段头部结构</h3><p>下图展示了日志片段头部的结构。日志头部以8个字节开头:0xD9, 0xD5, 0x05, 0xF9, 0x20, 0xAl, 0x63, 0xD7, 也就是文件头的魔数。日志记录的数量(4字节的短整型 <code>nRec</code>)记录了当前日志片段中一共有多少个有效的日志记录。<code>nRec</code>的值对于异步事务的初始化值为-1，对于同步事务的初始化值为0。随机值部分用来计算单个日志记录的“校验和”。初始化的页面数记录记录了在当前日志开始的时候原始数据库内有多少页面数。扇区大小是数据库文件所在磁盘的磁盘扇区大小。一个片段头部的大小占据了一个完整的扇区大小。也就是说，整个片段头部大小等于在头部中记录的这个扇区大小值。页面大小就是数据库分页时的页面大小。未使用的空间为保留空间。所有整数值都是大端值。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/4IGQSO.png\"></p>\n<p><strong>决定扇区大小</strong>:SQLite查询底层文件系统以获取扇区大小。（如果系统没有提供，使用512作为默认值。）SQLite假定文件系统不允许更改某个扇区上的单个字节，而是按照扇区的大小一次性读写。</p>\n<p>一个回滚日志文件通常包含单个记录片段。但是在某些场景下，它会是多个记录片段的文件，并且SQLite会在文件中多次写入片段头部。(可以看pager文章的<strong>缓存刷新</strong>一节)每次片段头部记录写入的时候，都是以扇区大小为单位。在多片段的日志文件中，任何一个片段头部的<code>nRec</code>字段都不可能是-1。</p>\n<p><strong>日志维护</strong>:在偏移为0的位置如果存在一个有效的片段头部，那么这个回滚日志也是有效的。如果文件大小是0或者包含了一个无效的片段头部，那么这个日志文件就不会用来做事务的回滚。</p>\n<p><strong>异步日志</strong>:SQLite支持异步事务，比通常的同步事务快很多。异步事务不会在任何时候刷新日志文件或者数据库文件，日志文件只有一个日志片段，<code>nRec</code>永远是-1，实际值是从文件大小中得出的。SQLite不建议使用异步事务，但是你依旧可以使用<code>pragma</code>命令来开启异步事务。这个模式一般用在开发阶段，用来减少开发调试时间的。同时也满足测试应用，因为一些应用无需测试数据恢复的case。</p>\n<h3 id=\"日志记录结构\"><a href=\"#日志记录结构\" class=\"headerlink\" title=\"日志记录结构\"></a>日志记录结构</h3><p>当前事务的非select的语句会产生日志记录。SQLite在页面的粒度上，使用旧值记录技术。在首次修改任何一个页面的时候，就会将原始的页面数据，包括页面号，作为一个新的日志记录写入日志文件。下图描述了一个单独的日志记录的结构。日志记录还包含了一个4字节32位的校验和。校验和覆盖了页面号和页面数据镜像。在日志片段头部的4字节32位的随机数，用来作为校验和的秘钥。随机数很重要，因为出现在日志末尾的垃圾数据很可能是曾经存在于其他文件中的数据，而这些文件现在已被删除。如果垃圾数据来自过时的日志文件，校验和也有可能是正确的。但是，针对不同日志文件通过将校验和初始化为不同的随机值，SQLite可以最大程度地降低这种风险。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/hhJK3N.png\"></p>\n<p><strong>校验和的位置</strong>:可以注意到，页面号存储在日志记录的头部，而校验和存储在日志记录的尾部。这个设定很重要。SQLite的开发者假定了文件中的数据作为字节字符串按扇区线性写入。所以如果日志文件因为断电发生了不一致错误，那么大概率场景是后面的校验和不一致。几乎不可能会出现两头一致，中间不一致的情况。因此，这个校验和的结构，仅管简单粗暴，但是已经涵盖了大部分的场景。</p>\n<h2 id=\"语句级日志\"><a href=\"#语句级日志\" class=\"headerlink\" title=\"语句级日志\"></a>语句级日志</h2><p>在一个用户事务中，SQLite为每一个最新的写操作语句的维护了一个语句级的子日志，而这些语句有可能会修改多行数据，也有可能会导致约束冲突，或者在触发器内抛出异常。日志文件会在这些语句执行过程中被用来恢复数据库。语句日志是一个单独的，原始的回滚日志文件。它是一个任意命名的临时文件（以etilqs_为前缀）。它位于用于临时文件的本地目录中。崩溃恢复操作不需要该文件；仅在语句中止时才需要。当语句执行完成的时候，这个文件就会被SQLite删除。这个日志文件没有片段头部记录。语句执行开始时，<code>nRec</code>（日志记录数）值保留在内存数据结构中，数据库文件大小也会被保留。这些日志记录没有校验和。</p>\n<p><strong>语句级日志的持久化</strong>:语句执行结束时，将删除语句日志文件。但是，为了要实现SAVEPOINT，SQLite会保留语句日志，直到释放保存点或提交用户事务为止。</p>\n<h2 id=\"多数据库事务日志，主日志文件\"><a href=\"#多数据库事务日志，主日志文件\" class=\"headerlink\" title=\"多数据库事务日志，主日志文件\"></a>多数据库事务日志，主日志文件</h2><p>一个应用可以通过执行<code>ATTACH</code>命令，打开多个额外的数据库。在这个场景下，SQLite允许用户事务读和修改多个数据库。如果事务修改了多个数据库，那么这些数据库会有自己的回滚日志文件。它们将会是独立的回滚日志文件，并且相互透明。这一类事务会对每一个更新的数据库单独提交事务。因此这个事务可能就不是全局原子的。为了让一个多数据库事务全局原子，SQLite额外的维护了一个单独的交叉日志，称之为主日志文件。这个日志文件不是用来回滚数据的。相反，它包含了参与事务的所有UTF-8格式的独立回滚日志的名字。(在本节上下文内，回滚日志被称为子回滚日志。)子回滚日志的名字是全路径名，并且被空字符相隔开。主数据库日志文件，会和主数据库文件在同一个目录下，并且后面会跟随’-mj’，以及8个随机的16进制数。这是一个临时文件，在事务开始尝试提交的时候创建，在事务完成的时候删除。事务中止不会创建主日志文件。</p>\n<p>每一个子日志文件同样也包含主日志文件的全路径名(看下图)。正如图中所示，主回滚日志记录跟在子日志记录的最后，这会在事务完成的时候写入。这个记录也会对齐扇区大小。校验和字段存储了主回滚日志文件名的校验和。长度字段指定了这个主回滚日志文件名的长度。主回滚日志文件名会以UTF-8的编码格式存储，包含了最后的终止符。禁用页号，是包含锁的字节偏移数。SQLite不会使用这个页面，它是保留用来兼容windows和类POSIX的问题(这个可以看原生锁相关部分)。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/82fzFb.png\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文讨论了SQLite如何在最底层，组织数据库内容和日志文件内容。它定义了这些文件的格式。将一整个数据库文件划分为固定大小的页面，这些页面用来存储B&#x2F;B+树页面，空闲页面，和其他页面。在默认的日志模式下，日志文件将数据库页面的镜像前内容存储为日志记录；但是，在WAL日志模式式下，日志文件存储了数据库页面的更新后的镜像内容。</p>\n</blockquote>","more":"<!---\n# 数据库命名规范\n--->\n\n<h1 id=\"数据库文件结构\"><a href=\"#数据库文件结构\" class=\"headerlink\" title=\"数据库文件结构\"></a>数据库文件结构</h1><p>除了内存数据库，SQLite将整个数据库存储在单个数据库文件中。在其生命周期中，数据库文件会增长和收缩。原生的文件系统就把这个文件当做一个普通的原始文件。它不会干涉文件的内容；它把文件内容看做字节串。它实现了读&#x2F;写的原语，以从任意偏移位置开始读&#x2F;写文件中的任意字节数。它同样也支持文件的同步(flush)操作。</p>\n<h2 id=\"页面抽象化\"><a href=\"#页面抽象化\" class=\"headerlink\" title=\"页面抽象化\"></a>页面抽象化</h2><p>为了简化空间管理以及从数据库文件读取&#x2F;写入数据，SQLite将每一个数据库文件(包括内存数据库)划分为固定大小的区域，称之为数据库页面或页面。因此，数据库文件的大小永远是页面的整数倍。页面编号从1开始线性增长。第一个页面为页面1，第二个页面为页面2，以此类推。页面0会被当做空页面，这个页面物理上也不存在。从文件偏移量0开始，第1页及其之后的页面依次线性地存储到数据库文件中，如图所示。可以把一个数据库文件看做固定大小页面的数组集合。页面号可以被用来当做访问页面的索引。(事实上Pager模块就是在原生文件系统上抽象出了一层。)</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/XLYFMb.png\"></p>\n<h2 id=\"页面大小\"><a href=\"#页面大小\" class=\"headerlink\" title=\"页面大小\"></a>页面大小</h2><p>默认的页面大小是1024个字节，但这是一个编译期的自定义参数，可以在编译前修改这个值。页面大小必须是2的次幂，并且范围在[512(&#x3D;2^9),65536(&#x3D;2^16)]。其中最大值的限制是2个字节的无符号整型可以表示的最大的数。一个数据库文件最多可以有(2^31-1)个页面，这个数字是被硬编码在pager.c源码的<code>PAGER_MAX_PGNO</code>宏内的。因此，一个数据库可以最大有140个TB字节，当然，这个也受到原生文件系统的限制。</p>\n<p><strong>改变页面大小</strong>:一旦一个数据库文件被创建了，SQLite就会使用编译器设定的默认页面大小。但是你可以通过执行pragma命令，在创建第一个数据库表之前修改这个值。SQLite会把这个值存储在数据库文件的元数据内，后续就会使用这个值作为数据库的页面大小了。即使以后使用针对其他默认页面大小定制的其他SQLite库，该数据库文件也可以正常工作。</p>\n<h2 id=\"页面类型\"><a href=\"#页面类型\" class=\"headerlink\" title=\"页面类型\"></a>页面类型</h2><p>不论这些页面是否正在使用，SQLite会持续跟踪所有分配给数据库文件的页面。它会在文件中存储所有的跟踪信息。(在SQLite中没有垃圾回收的机制。)基于这些用途，这些页面分为4种类型:空闲页面，树页面，指针映射页面(用于autovacuum和incremental vacuum特性)，锁页面。而树页面又分为几个子类型:叶子节点页面，内部节点页面，溢出页面。空闲页面是非活跃页面，即当前不被使用；其它的就是活动页面，并且除了指针映射页面和锁页面之外都属于B树或者B+树。B+树的内部节点页面包含搜索树的搜索导航信息。(B树的内部节点同时包含搜索信息和数据。)B+树的叶子节点存储了真正的数据(例如表中的行)。如果一行的数据太大不足以放在单个页面内，那么一部分数据存储在页面内，剩下的就会放在若干个溢出页面。</p>\n<h2 id=\"数据库元数据\"><a href=\"#数据库元数据\" class=\"headerlink\" title=\"数据库元数据\"></a>数据库元数据</h2><p>SQLite可以使用任何页面类型来表示任何一个数据库页面。1号页面是一个独例，它是B+树的内部页面，存储了<code>sqlite_master</code>或者<code>sqlite_temp_master</code>表的根节点。这个页面包含了100字节的文件头记录，从文件偏移0开始。</p>\n<p>文件头信息描述了数据库文件的结构。它定义了一些数据库的设置参数，又称元数据。SQLite会在创建文件的时候初始化这个头部。下面是这个文件头的格式，前两列都是以字节为单位。</p>\n<table>\n<thead>\n<tr>\n<th>偏移</th>\n<th>大小</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>16</td>\n<td>头魔数”SQLite format 3”</td>\n</tr>\n<tr>\n<td>16</td>\n<td>2</td>\n<td>页面的大小</td>\n</tr>\n<tr>\n<td>18</td>\n<td>1</td>\n<td>写入的文件格式版本</td>\n</tr>\n<tr>\n<td>19</td>\n<td>1</td>\n<td>读取的文件格式版本</td>\n</tr>\n<tr>\n<td>20</td>\n<td>1</td>\n<td>每一个页面尾部的保留字节数</td>\n</tr>\n<tr>\n<td>21</td>\n<td>1</td>\n<td>最大内嵌载体占比</td>\n</tr>\n<tr>\n<td>22</td>\n<td>1</td>\n<td>最小内嵌载体占比</td>\n</tr>\n<tr>\n<td>23</td>\n<td>1</td>\n<td>最小叶子节点的载体占比</td>\n</tr>\n<tr>\n<td>24</td>\n<td>4</td>\n<td>文件变更计数器</td>\n</tr>\n<tr>\n<td>28</td>\n<td>4</td>\n<td>数据库文件的页面数量</td>\n</tr>\n<tr>\n<td>32</td>\n<td>4</td>\n<td>空闲页面链表的第一个</td>\n</tr>\n<tr>\n<td>36</td>\n<td>4</td>\n<td>文件中的空闲页面的数量</td>\n</tr>\n<tr>\n<td>40</td>\n<td>4</td>\n<td>结构缓存值</td>\n</tr>\n<tr>\n<td>44</td>\n<td>56</td>\n<td>传递给上层的14个4字节的元数据</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>头部字符串</strong>:一个16字节的UTF-8字符串”SQLite format 3”</li>\n<li><strong>页面大小</strong>:数据库中页面的大小。这个值必须是2的n次幂，并在[512，32768]之间，或者用1表示65536。正如上面所提到的，SQLite在操作这个文件的时候就会使用这个页面大小。(对于同一个数据库连接，可以在同一个时间对不同的数据库文件使用不同的页面大小。)</li>\n<li><strong>文件格式</strong>:在偏移为18，19的位置有两个字节，用来表示文件格式的版本。在当前版本的SQLite中，它们都必须为1或2，否则将出错且无法访问数据库。值为1则对应旧版本的回滚日志(早于SQLite3.7.0)，值为2则对应WAL日志(在SQLite3.7.0版本之后)。后续有新特性，这个值会继续增加。</li>\n<li><strong>保留空间</strong>:SQLite会在每个页面的最后保留一个固定的小于255字节的空间，用用于一些其他目的。这个值会被存在偏移为20的地方，默认值是0。当数据库使用SQLite的内置（专有）加密技术时，该值不为零。每页末尾的额外字节存储一个随机数，该随机数供该页面的加密算法使用。页面的前半部分（页面大小减去保留空间大小）是存储数据库内容的可用空间，该空间必须至少为480个字节。</li>\n<li><strong>内嵌载体</strong>:最大内嵌载体占比（在偏移量21处）是页面中的可用空间总量，该空间可由标准B&#x2F;B+树内部节点的单个条目（称为单元或记录）使用。值255表示100%。<br/>该值为64（即25％):该值是为了限制最大单元大小，以便在一个节点上至少容纳四个单元。如果某个单元的有效载体大于最大值，则部分载体内容会溢出到溢出页面中。一旦SQLite分配了溢出页，它将尽可能多的字节移入溢出页，但是不会让单元大小降至最小内嵌载体占比值以下（偏移量22）。这个值为32(即12.5%)。<br/>最小叶子节点的载体占比(在偏移量23处)和最小内嵌载体占比相似，但它仅适用于B+树叶子页。该值为32(即12.5%)。叶节点的最大内嵌载体占比始终为100％（或255），因此未在头部中指定。（另外B树中没有专用叶节点。）</li>\n<li><strong>文件变更计数器</strong>:这个计数器在事务中会被使用。初始化的值是0。这个计数值，在每次被写事务写入数据库数据的时候都会递增。此值用来表示数据库何时被更改，以便pager可以清除其页面缓存。(当在文件格式使用WAL日志的时候，计数器不会被使用。)</li>\n<li><strong>数据库大小</strong>:数据库页面的数量存储在偏移量为28的位置。</li>\n<li><strong>空闲链表</strong>:数据库文件头部偏移为32的地方存储了空闲页面链表。偏移量为36的地方存储了空闲页面的总数。下一小节会细说这个空闲链表。</li>\n<li><strong>数据库结构缓存</strong>:在偏移量为40的地方存储了一个4字节的整型值，初始化为0。当数据库结构变更的时候这个值就会递增，并且在语句预处理的时候，会做一些有效性测试检查(例如表是否存在等等)。</li>\n<li><strong>其他元数据变量</strong>:在偏移量为44的地方，有14个字节的整型值，保留给Tree模块和VM模块。它们表示许多元变量的值，包括偏移量44处的结构值。（建议）页面高速缓存大小为48，自动清理的相关信息为52（0为无自动清理，否则为数据库文件中最远的根页面的页号），文本编码为56（值1表示UTF-8、2代表UTF-16 LE，3代表UTF-16 BE），用户版本号为60（不给SQLite使用，但给用户使用），增量清理模式为64（无清理为0，其他为清理值），以及版本号在偏移量92和96处；其余字节保留供将来使用，并且必须清零。</li>\n</ul>\n<p><strong>增量清理 vs. 自动清理</strong>:如果在偏移值为52处的4字节整型和在偏移值为64处的4字节整型为0；数据库文件上则没有自动清理。用户可以通过执行<code>vacuum</code>命令来手动清理。如果前者是非零，后者是零，则自动清理是打开的；否则自动清理关闭并且增量清理打开。</p>\n<p>如上所述，在1号页面中的文件头后面跟着一个B+树的内部节点。这个节点就是主目录表的根节点，名为<code>sqlite_master</code>或<code>sqlite_temp_master</code>。这个表内存储了当前数据库内的所有其他根页面页面号。因此1号页面帮助SQLite来跟踪其他的树页面或者移除页面，这也是最重要的一个页面。</p>\n<h2 id=\"空闲链表的结构\"><a href=\"#空闲链表的结构\" class=\"headerlink\" title=\"空闲链表的结构\"></a>空闲链表的结构</h2><p>数据库文件头部偏移量为32出标明了空闲页面链表。而偏移量为36处则存储了空闲链表的总数。空闲列表组织在有根的主干中，如图所示。空闲链表页面有两种类型，主干页面和叶子页面。文件头指向主干页链接列表中的第一个。每一个主干页面都指向了多个叶子页面。(叶子页面的内容是不确定的，可能是垃圾。)</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/obFGdI.png\"></p>\n<p>主干页面会如下结构化，从页面的最初起点开始:(1)一个4字节的页面号指向下一个主干页面(如果没有下一个就会是0)。(2)一个四字节的整型用来标明存储在这个页面上的叶子页面数量。(3)若干个四字节字节的叶子页面号。</p>\n<p>当一个页面变成非活跃状态的时候，SQLite就会将它加入到空闲链表，并且不会将它释放归还给原生文件系统。当需要添加新的信息到数据库的时候，SQLite会占据空闲链表中的页面来存储新信息。(因此说新的数据可能会存储在数据库中的任何一个地方。)如果空闲链表是空的，那么SQLite会从原生文件系统中请求新的页面，并且添加到数据库文件的尾部。</p>\n<p>在有些情况下，可能需要关心当空闲的数据库页面数量过高的时候。可以运行<code>VACUUM</code>命令来清理空闲链表，并且缩减数据库文件大小，将一些不使用的页面归还给文件系统。数据库在<code>autovacuum</code>模式下创建的话会在每一个事务提交的时候都会自动缩减数据库。虽然在事务提交之前会建立空闲页面链表，但是在事务后这个链表依旧会保持空。</p>\n<p><strong>空闲链表的清理</strong>当通过执行<code>vacuum</code>命令来清理空闲链表的时候，命令会将数据库复制到一个临时文件中。然后将这个临时数据库覆盖原始数据库，但整个过程都会在一个事务锁的保护下。</p>\n<h1 id=\"日志文件结构\"><a href=\"#日志文件结构\" class=\"headerlink\" title=\"日志文件结构\"></a>日志文件结构</h1><p>SQLite使用三种类型的日志文件，分别是回滚日志文件，语句级日志文件，和主日志文件。(这些都被称为传统日志。在SQLite3.7.0的版本中，SQLite开发着团队介绍了WAL日志结构。一个数据库文件要么是传统日志模式，要么是WAL日志模式。)接下来就会讨论传统日志的日志记录结构。</p>\n<h2 id=\"回滚日志文件\"><a href=\"#回滚日志文件\" class=\"headerlink\" title=\"回滚日志文件\"></a>回滚日志文件</h2><p>对于每一个数据库，SQLite都会维护一个回滚日志文件。(内存数据库不需要使用日志文件。它们会使用内存来存储日志信息。)回滚日志文件一般都存在和原始数据库文件的同级目录下。在默认模式下，日志文件是一个临时文件。SQLite在每一个写事务开始的时候创建日志文件，并在事务完成的时候删除文件。</p>\n<p>SQLite将每一个回滚日志文件分割为几个可变大小的日志片段，如下图所示。每个日志片段有一个片段头部，后面跟着几个日志记录。后面会详细讨论这个。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/gRdkE3.png\"></p>\n<h3 id=\"片段头部结构\"><a href=\"#片段头部结构\" class=\"headerlink\" title=\"片段头部结构\"></a>片段头部结构</h3><p>下图展示了日志片段头部的结构。日志头部以8个字节开头:0xD9, 0xD5, 0x05, 0xF9, 0x20, 0xAl, 0x63, 0xD7, 也就是文件头的魔数。日志记录的数量(4字节的短整型 <code>nRec</code>)记录了当前日志片段中一共有多少个有效的日志记录。<code>nRec</code>的值对于异步事务的初始化值为-1，对于同步事务的初始化值为0。随机值部分用来计算单个日志记录的“校验和”。初始化的页面数记录记录了在当前日志开始的时候原始数据库内有多少页面数。扇区大小是数据库文件所在磁盘的磁盘扇区大小。一个片段头部的大小占据了一个完整的扇区大小。也就是说，整个片段头部大小等于在头部中记录的这个扇区大小值。页面大小就是数据库分页时的页面大小。未使用的空间为保留空间。所有整数值都是大端值。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/4IGQSO.png\"></p>\n<p><strong>决定扇区大小</strong>:SQLite查询底层文件系统以获取扇区大小。（如果系统没有提供，使用512作为默认值。）SQLite假定文件系统不允许更改某个扇区上的单个字节，而是按照扇区的大小一次性读写。</p>\n<p>一个回滚日志文件通常包含单个记录片段。但是在某些场景下，它会是多个记录片段的文件，并且SQLite会在文件中多次写入片段头部。(可以看pager文章的<strong>缓存刷新</strong>一节)每次片段头部记录写入的时候，都是以扇区大小为单位。在多片段的日志文件中，任何一个片段头部的<code>nRec</code>字段都不可能是-1。</p>\n<p><strong>日志维护</strong>:在偏移为0的位置如果存在一个有效的片段头部，那么这个回滚日志也是有效的。如果文件大小是0或者包含了一个无效的片段头部，那么这个日志文件就不会用来做事务的回滚。</p>\n<p><strong>异步日志</strong>:SQLite支持异步事务，比通常的同步事务快很多。异步事务不会在任何时候刷新日志文件或者数据库文件，日志文件只有一个日志片段，<code>nRec</code>永远是-1，实际值是从文件大小中得出的。SQLite不建议使用异步事务，但是你依旧可以使用<code>pragma</code>命令来开启异步事务。这个模式一般用在开发阶段，用来减少开发调试时间的。同时也满足测试应用，因为一些应用无需测试数据恢复的case。</p>\n<h3 id=\"日志记录结构\"><a href=\"#日志记录结构\" class=\"headerlink\" title=\"日志记录结构\"></a>日志记录结构</h3><p>当前事务的非select的语句会产生日志记录。SQLite在页面的粒度上，使用旧值记录技术。在首次修改任何一个页面的时候，就会将原始的页面数据，包括页面号，作为一个新的日志记录写入日志文件。下图描述了一个单独的日志记录的结构。日志记录还包含了一个4字节32位的校验和。校验和覆盖了页面号和页面数据镜像。在日志片段头部的4字节32位的随机数，用来作为校验和的秘钥。随机数很重要，因为出现在日志末尾的垃圾数据很可能是曾经存在于其他文件中的数据，而这些文件现在已被删除。如果垃圾数据来自过时的日志文件，校验和也有可能是正确的。但是，针对不同日志文件通过将校验和初始化为不同的随机值，SQLite可以最大程度地降低这种风险。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/hhJK3N.png\"></p>\n<p><strong>校验和的位置</strong>:可以注意到，页面号存储在日志记录的头部，而校验和存储在日志记录的尾部。这个设定很重要。SQLite的开发者假定了文件中的数据作为字节字符串按扇区线性写入。所以如果日志文件因为断电发生了不一致错误，那么大概率场景是后面的校验和不一致。几乎不可能会出现两头一致，中间不一致的情况。因此，这个校验和的结构，仅管简单粗暴，但是已经涵盖了大部分的场景。</p>\n<h2 id=\"语句级日志\"><a href=\"#语句级日志\" class=\"headerlink\" title=\"语句级日志\"></a>语句级日志</h2><p>在一个用户事务中，SQLite为每一个最新的写操作语句的维护了一个语句级的子日志，而这些语句有可能会修改多行数据，也有可能会导致约束冲突，或者在触发器内抛出异常。日志文件会在这些语句执行过程中被用来恢复数据库。语句日志是一个单独的，原始的回滚日志文件。它是一个任意命名的临时文件（以etilqs_为前缀）。它位于用于临时文件的本地目录中。崩溃恢复操作不需要该文件；仅在语句中止时才需要。当语句执行完成的时候，这个文件就会被SQLite删除。这个日志文件没有片段头部记录。语句执行开始时，<code>nRec</code>（日志记录数）值保留在内存数据结构中，数据库文件大小也会被保留。这些日志记录没有校验和。</p>\n<p><strong>语句级日志的持久化</strong>:语句执行结束时，将删除语句日志文件。但是，为了要实现SAVEPOINT，SQLite会保留语句日志，直到释放保存点或提交用户事务为止。</p>\n<h2 id=\"多数据库事务日志，主日志文件\"><a href=\"#多数据库事务日志，主日志文件\" class=\"headerlink\" title=\"多数据库事务日志，主日志文件\"></a>多数据库事务日志，主日志文件</h2><p>一个应用可以通过执行<code>ATTACH</code>命令，打开多个额外的数据库。在这个场景下，SQLite允许用户事务读和修改多个数据库。如果事务修改了多个数据库，那么这些数据库会有自己的回滚日志文件。它们将会是独立的回滚日志文件，并且相互透明。这一类事务会对每一个更新的数据库单独提交事务。因此这个事务可能就不是全局原子的。为了让一个多数据库事务全局原子，SQLite额外的维护了一个单独的交叉日志，称之为主日志文件。这个日志文件不是用来回滚数据的。相反，它包含了参与事务的所有UTF-8格式的独立回滚日志的名字。(在本节上下文内，回滚日志被称为子回滚日志。)子回滚日志的名字是全路径名，并且被空字符相隔开。主数据库日志文件，会和主数据库文件在同一个目录下，并且后面会跟随’-mj’，以及8个随机的16进制数。这是一个临时文件，在事务开始尝试提交的时候创建，在事务完成的时候删除。事务中止不会创建主日志文件。</p>\n<p>每一个子日志文件同样也包含主日志文件的全路径名(看下图)。正如图中所示，主回滚日志记录跟在子日志记录的最后，这会在事务完成的时候写入。这个记录也会对齐扇区大小。校验和字段存储了主回滚日志文件名的校验和。长度字段指定了这个主回滚日志文件名的长度。主回滚日志文件名会以UTF-8的编码格式存储，包含了最后的终止符。禁用页号，是包含锁的字节偏移数。SQLite不会使用这个页面，它是保留用来兼容windows和类POSIX的问题(这个可以看原生锁相关部分)。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/82fzFb.png\"></p>"},{"title":"The Pager Module","date":"2020-08-16T16:00:00.000Z","top":300,"_content":"\n> 本文讨论的是SQLite的Pager模块。本模块在原生操作系统的基础上实现了一个抽象的基于页面的数据库文件系统。它按照固定大小的页面来管理数据，并且定义了一些接口从数据库文件中来操作这些页面。它提供了一个数据库页面的内存缓存，来帮助BTree模块加速操作数据库页面。它不仅仅是一个缓存的管理中心，同样也是实现ACID的事务管理中，以及事务回滚管理。并发控制和回滚机制对于上层模块来说是完全透明的。他可以理解为一个传统数据库管理系统的持久化层。\n\n<!-- more -->\n\n# Pager模块\n除了内存数据库以外，数据库都是以原生文件的形式落在磁盘上的。SQLite无法高效的直接读取和操作磁盘上的文件。当需要数据项的时候，它会从数据库文件中读取数据到主内存中，然后在内存中操作数据，在有必要的时候，还会回写到磁盘文件中去。相对于紧凑的主内存来说，一般情况下数据库文件都会很大。因为内存有限，所以一般内存中只会保留一小部分来存储的数据，而这部分内存通常就被叫做数据库缓存或者数据缓存;在SQLite的术语中，它被称为page cache。而这个缓存是在应用进程的地址空间内，而不是操作系统的地址空间。(操作系统有它自己的数据缓存。)\n\npage缓存管理器在SQLite的世界里就是Pager。它面对的是可随机访问的原生字节流的文件，并且需要将他们转换为可以随机访问的高级别的分页式的文件，而这个页面的大小是固定的。不同的数据库文件可以有不同的页面大小。区别于原生操作系统，Pager提供了一个简单可用的接口来访问数据库文件的页面。Tree模块将会使用Pager提供的接口来操作，而不会直接操作原生的数据库或者日志文件。Tree模块看到的数据库逻辑上是一个页面的数组，并且通过他们数组的下标索引来获取页面。\n\nSQLite对于每一个打开的数据库文件(或者说数据库连接)，都会有一个单独的页面缓存。当一个应用进程打开一个数据库文件的时候，Pager就会为它创建和初始化一个新的页面缓存。如果进程多次打开同一个数据库文件的时候，在默认模式下，Pager会单独为这个文件创建和初始化页面缓存多次。(SQLite提供一个高级特性，那就是所有打开同一个数据库文件的数据库连接可以共享一个页面缓存。)在使用内存数据库的时候，不会访问任何外部存储设备。但是它们也会被当做原生的数据库文件来处理，并且会被整个存储到缓存中。因此Tree模块可以使用相同的接口来操作这两类数据库。\n\n在SQLite中Pager属于最底层的模块。这是唯一的一个通过直接调用操作系统提供的I/O API来访问原生文件的模块。它会直接读写数据库文件或者日志文件。它不会理解数据库是如何组织数据结构的。它也不会去干涉数据库的内容，或者自己去修改内容。它只需要保证存在数据库文件中的数据可以被重复地无任何修改地检索。从这个角度上来说，Pager是一个被动的模块。(它有可能会修改一些数据库文件头部记录中的信息，例如文件修改计数器file change counter。)\n\n对于每一个数据文件来说，Pager在文件和内存缓存之间转移页面内容是作为一个缓存管理器的基本功能。而这个转移对于Tree模块和一些高层模块来说是透明的。Pager就是原生系统文件和高层之间的一个媒介。它还要协调页面回写到数据库文件中去。\n\n除了缓存管理的工作之外，pager也承担了一个典型的DBMS的其他功能。它提供一个典型的事务处理系统的核心服务:事务管理，数据管理，日志管理，和锁管理。作为一个事务管理者，它通过接管并发控制和数据恢复，来实现了事务的ACID属性。它也负责原子性提交和事务的回滚。作为一个数据管理者，它通过缓存和一些文件空间管理来协调数据库文件页面的读写。作为日志管理者，它决定了在日志文件中的日志写入。作为一个锁管理者，它可以确保在操作数据库页面之前，在数据库文件上已经有了一个合理的锁。\n\n# Pager接口\n在这一小节中，我将会给出一些Pager模块导出的接口，这些接口将会给Tree模块使用。在此之前，我们先讨论一下Pager和Tree模块之间的交互协议。\n\n## Pager-client调用交互协议\n在Pager之上的模块是完全隔离了低级别的锁和日志管理机制。事实上，它们并不知道锁和日志的存在的。Tree模块把所有的事情都看做一个事务，并且它不关心事务的ACID是如何实现的。而Pager模块则把一个事务的所有活动拆分为锁、日志、以及读写数据库文件。Tree模块以页面号来向Pager中请求一个页面数据。反过来，Pager会返回一个已经加载到页面缓存中的页面数据的指针地址。在修改一个页面之前，Tree模块需要先通知Pager模块。这样Pager模块可以在日志文件中存放足够的信息来防止之后要做数据恢复，以及提前在数据库文件上加上合适的锁。在它使用完页面之后，还要通知Pager，这样如果页面数据发生改变的时候，Pager还会将数据回写到数据库文件中。\n\n### Pager接口结构\nPager模块实现了一个数据结构叫`Pager`。每一个数据库文件都是通过单独的`Pager`对象来管理的，并且每一个`Pager`也只会关联到有且仅有一个数据库文件上。(在Pager模块层中，这个对象就等同于数据库文件。)在Tree模块中，如果需要使用一个数据库文件，那么需要先创建一个Pager对象，然后在这个对象上使用一些页面操作函数。Pager模块可以使用这个对象来追溯关于文件的锁，日志文件，和数据库的状态，日志文件的状态等等。一个进程在同一个数据库文件上可以有多个`Pager`对象与之对应，每一个对象都隶属于一个数据库连接。这些对象都是被独立处理的，互不相关。(对于共享缓存的模式来说，对每一个数据库文件，只有一个`Pager`对象，所有数据库文件共享这个对象。)内存数据库也是使用这个对象作为操作句柄。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/lLkn3u.png)\n\n后面会给出一个`Pager`对象的一些成员变量。在这个对象的后面会紧跟着一片内存空间，这个空间会用来存储页面缓存、数据库文件句柄、日志文件句柄、和数据库文件名、日志文件名。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/hWBtgL.png)\n\n正如之前提到的，SQlite在一个用户事务中，执行每一个更新(insert,delete,update)操作的时候都会放在一个savepoint保存点内。同样的，应用也可以设置自己的保存点。可以同时存在多个保存点，存储在aSavepoint数组内。这个保存点的数据结构后面也有。当SQLite创建了一个保存点savepoint的时候，它就会把`iHdrOffset`这个变量置0。但是如果在某个savepoint已经激活的时候，它打开了回滚日志文件并且在文件中写入了一条记录头，那么它就会把`iHdrOffset`改为在写入回滚日志之前的最后一条记录的字节偏移。当`PagerSavepoint`对象创建的时候,`iOffset`会被设置为回滚日志的起始偏移。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/1ijSOI.png)\n\n### Pager接口函数\nPager模块实现了一系列给Tree模块使用的接口方法。为了便于后面的理解，下面先列举一些重要的接口方法，这些接口方法都是以`sqlite3Pager`开头，所有的方法都仅限SQLite内部使用。\n\n1. sqlite3PagerOpen:方法创建一个新的`Pager`对象，打开给定的数据库文件，创建和初始化一个空的页面缓存，并且把这个缓存的指针返还给`Pager`对象。它会根据给定的数据库名，创建/打开一个合适的文件。数据库文件在此时并不会上锁，既没有创建日志文件，也没有执行数据库恢复操作。(数据库的恢复是会被延迟到首次从数据库中读取一个页面的时候)\n\n2. sqlite3PagerClose:方法销毁一个`Pager`对象，并且关闭关联的已经打开的数据库文件。如果它是一个临时文件，pager还会删除掉和这个文件。如果它不是一个临时文件并且在这个方法被调用的时候，这个文件还有一个事务存在，那么这个事务就会被强制终止，并且把它的变更全部回滚。所有内存中的缓存都会失效，从用户进程地址空间内释放。在这个方法调用之后再去访问缓存都会导致崩溃。换句话说，所有的资源都被释放了。\n\n3. sqlite3PagerGet:这个方法会给调用者从数据库文件中复制到内存中一份可用的数据页面。调用者指定了请求页面的页面号。方法返回一个拷贝到内存缓存中的页面地址。因此，缓存空间不被回收的话，它就会固定下这个拷贝的页面。在调用这个方法最开始它就会在数据库上获取一个共享锁。此时它会决定是否需要清理现有的页面缓存--如果数据库的文件变更计数器(在文件头部第24字节开始的4个字节整型)和当前缓存中的之前获取到的这个值不一样，它就会开始清理缓存。另外如果有必要的话(存在一个回滚日志文件)，数据库就会从日志文件中回滚(后面的章节会讨论日志的回滚)。如果请求的页面不在缓存中，pager就会加载请求的页面到缓存中。但是，如果目前的数据库文件小于请求的页面号，那么实际也不会触发文件读，但是内存中会依旧分配一个页面，并且全部初始化为0.(当然对于内存数据库来说，不会触发任何的文件操作。)\n\n4. sqlite3PagerWrite:这个方法可以将请求的数据库页面对调用者是可写的。(注意这里是可写不是写入数据。)这个方法必须在Tree模块修改缓存数据之前调用，否则的话Pager并不知道某一个缓存的页面被修改了。(处于性能考虑，SQLite避免了从Tree模块到Pager模块互相拷贝数据，而是让Tree模块直接修改Pager缓存的数据。)Pager还会在数据库文件上获取一个保留锁，并且创建一个回滚日志文件。也就是说它创建了一个隐式的写事务。如果当前页面还不在日志文件中，那么它就会拷贝这个页面中的原始数据到回滚日志中去。如果这个原始的页面已经在日志文件中了，那么SQLite只会标记这个页面为写脏。如果当前的事务是在一个用户事务中，并且当前页面也已经在主回滚日志中了，那么这个方法也还会在状态日志中写入一条状态记录。\n\n5. sqlite3PagerLookup:这个方法返回在已经请求在内存缓存中的页面。如果不在，则返回NULL。对前者来说，它会固定这个页面。\n\n6. sqlite3PagerRef:方法给指定页面的引用计数+1。我们称这个页面被调用者固定了。如果页面在缓存的已释放链表中，这个方法会从这个已释放列表中移除该页面。\n\n7. sqlite3PagerUnref:方法给指定页面的引用计数-1。当这个页面的引用计数降低到0的时候，我们称这个页面已经被解除固定，并且被释放了。(被释放的页面依旧存在内存中，它会存储在已释放的链表内。）当所有的页面都被解除固定了的时候，在数据库上的共享锁就会被释放，`Pager`对象就会被重置。\n\n8. sqlite3PagerBegin:方法在相关联的数据库文件上开启一个显式的写事务。如果数据库不是一个临时数据库，它也会打开一个回滚日志文件。(对于临时数据库，回滚日志的打开会一直推迟到真正写入回滚日志的时候。)从前面可以知道隐式的写事务是由`sqlite3PagerWrite`开启的。因此，如果数据库已经保留用来准备写入了，那么这个方法就不会做任何操作。否则的话，它会首先在数据库文件上持有一个保留锁，并且如果在参数指明的情况下，它还会立刻在数据库文件上获取一个排它锁，而不是真正等到Tree模块尝试写入数据的时候。\n\n9. sqlite3PagerCommitPhaseOne:方法在数据库文件上提交当前的事务:文件变更计数器+1，同步日志文件，把所有的变更(例如页面缓存中的脏页)同步到数据库文件中\n\n10. sqlite3PagerCommitPhaseTwo:方法释放(包括删除、无效化、或者裁剪)日志文件。\n\n11. sqlite3PagerRollback:方法在数据库文件上放弃当前的事务:回滚事务给数据库文件带来的所有变更，并且把数据库的锁降级到共享锁。所有的缓存页面转变为它们的原始数据内容。日志文件被释放。\n\n12. sqlite3PagerOpenSavepoint:方法创建一个新的保存点句柄对象，为当前的数据库状态建立一个保存点。\n\n13. sqlite3PagerSavepoint:方法释放或者回滚一个保存点。对于释放操作来说，它会释放和销毁指定的一个保存点句柄对象。对于回滚操作来说，它回滚数据库上在此保存点建立之后的所有变更，并且后面所有的保存点都会被删除。\n\n# 页面缓存\n页面缓存存在于应用进程的地址空间内。（对于同一个页面来说，原生操作系统可能也会对它做一次缓存，当应用从某个文件中读取一段数据的时候，操作系统一般都会给自己拷贝一份，再给应用拷贝一份。我们不关心操作系统是如何管理它的缓存的。SQLite的缓存组织和管理独立于那些原生操作系统。）下图描述了一个典型的情况。在图中，两个进程(其中有一个是多线程的)在访问同一个数据库文件。他们有自己的缓存。甚至于同一个线程在默认操作模式下，多次打开了同一个数据库。SQLite为这些数据库连接分配了独立的缓存。通过它们自己不同的`Pager`对象来访问这些缓存。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/It7kz3.png)\n\n## 缓存状态\n页面缓存的状态(在上图中`Pager`对象中有对应的变量)决定了Pager模块可以对缓存做什么。两个变量`eState`和`eLock`控制了Pager的行为。页面缓存的总是以下7种状态之一(`Pager.eState`成员变量的值)。下图是这7种状态值的转换图。\n\n1. **PAGER_OPEN**:当一个`Pager`对象创建的时候，这是它的初始状态。此时pager无法通过`Pager`对象来读或者写数据库文件。当前内存中可能没有页面缓存，缓存是空的。数据库文件上应该也没有锁，在当前数据库上没有事务。\n\n2. **PAGER_READER**:在这个状态的时候，当前数据库连接上至少有一个读事务，pager可以读取对应数据库文件的页面。(但是，在排他锁的模式下，读事务可能并不会打开。)\n\n3. **PAGER_WRITER_LOCKED**:当一个`Pager`对象在这个状态的时候，当前数据库连接上已经打开了一个写事务。pager可以在对应的数据库文件上读页面数据，但是它还没有在数据库文件或者缓存页面中做任何的变更。\n\n4. **PAGER_WRITER_CACHEMOD**:当一个`Pager`对象在这个状态的时候，pager给与Tree模块权限来更新缓存的页面数据，并且Tree模块可能已经对它做出了一些变更。\n\n5. **PAGER_WRITER_DBMOD**:当一个`Pager`对象在这个状态的时候，pager可能已经开始写数据库文件了。\n\n6. **PAGER_WRITER_FINISHED**:当一个`Pager`对象在这个状态的时候，pager已经完成将当前写事务中发生的所有变更的页面写入到数据库文件了。写事务已经不能再做任何的变更了，此时已经在准备提交了。\n\n7. **PAGER_ERROR**:出错的状态，例如I/O失败，磁盘空间不足，内存不足等等。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/yUn3tG.png)\n\n根据`eLock`变量的值，一个`Pager`对象可以是如下4中状态之一。\n\n1. **NO_LOCK**:当前不在读写任何事务。\n\n2. **SHARED_LOCK**:Pager已经从数据库文件中读了页面数据了。在同一个时间，同一个文件上可以有多个读事务，这些读事务可以各自通过他们的`Pager`对象来访问数据库文件。此时不允许修改缓存的页面。\n\n3. **RESERVED_LOCK**:pager已为写入数据保留了数据库文件，但是还没有做出任何的变更。在同一时间只有一个pager可以保留指定的数据库文件。因为原始的数据库文件还没有被修改，其它的Pager依旧可以读。\n\n4. **EXCLUSIVE_LOCK**:pager已经把缓存页面回写到数据库文件了。此时的文件访问是独占的。当这个pager在写入的时候，没有其他的pager可以读写这个文件。\n\n页面缓存开始于NO_LOCK的状态。当Tree模块首次调用`sqlite3PagerGet`方法读取任何一个页面的时候，pager就会转换到SHARED_LOCK状态。当Tree模块通过执行`sqlite3PagerUnref`方法释放所有页面的时候，pager就会转换回NO_LOCK状态。(这个时候，它应该不会清理页面缓存。)当Tree模块首次调用`sqlite3PagerWrite`方法的时候，pager就会转换到RESERVED_LOCK状态。(`sqlite3PagerWrite`方法只有在pager已经就绪读的时候才可以被调用)。pager在真正写入第一个页面到数据库文件的时候，就会转换到EXCLUSIVE_LOCK状态。在`sqlite3PagerRollback`或者`sqlite3PagerCommitPhasTwo`两个方法的执行过程中，pager会转换回NO_LOCK状态。\n\n* 对于内存数据库或者临时数据库来说，`Pager.eLock`永远是EXCLUSICE_LOCK，因为它始终是独占的。\n\n## 缓存的组织结构\n\n每一个页面缓存都是由一个`PCache`句柄对象来管理。pager持有了这个`PCache`对象的引用(可以看上面pager的结构图)。下图描述了一个`PCache`对象的一些成员变量。SQLite支持插件化的缓存结构，用户可以自己提供一个缓存结构。它提供了它自己的插件缓存模块(由pcache1.c源码实现)，后面会讨论这个缓存实现。这个也将会是默认的缓存管理，除非用户自己提供一个。`PCache`对象的最后一个成员就是pCache,持有了这个可插件化的缓存模块。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/EWLiFD.png)\n\n通常情况下，为了加速查询一个缓存，当前持有的缓存项都会被较好的组织好。缓存空间会被分割为一个个存储槽来持有数据项。SQLite使用一个哈希表来组织已缓存的页面，并且使用页面槽来持有表中的页面。缓存是完全关联的，因此任何一个存储槽都可以存储任何页面。哈希表初始化为空。随着页面需求的增长，pager会创建新的存储槽，然后将它们插入到哈希表内。`PCache.nMax`值决定了一个缓存可以持有的最大存储槽的数量。主数据库和其他attach连接上的数据库默认值是2000，临时数据库是500。内存数据库没有这个限制，根据物理内存的大小，有多少用多少。\n\nSQLite使用一个`PgHdr`类型的对象来标识缓存中的每一个页面对象。尽管一个可插件化的缓存可以有它自己的页面头部对象，但是pager也依旧可以理解这个对象。下图描述了SQLite自己的可插件化的缓存，由`PCache1`对象表示。在哈希表中的每一个插槽都由一个类型为`PgHdr1`的头部对象表示。这个插件化的组件是可以理解这个类型的，pager对此也不透明。插槽数据就存储在`PgHdr1`对象的正前方；这个插槽的数据大小由`PCache1.szSize`变量决定。这个插槽数据持有了一个`PgHdr`对象，一个数据库页面数据，和一些私有数据，这些私有数据区域是Tree模块用来保存页面特有的内存中的控制信息。(内存数据库没有日志文件，所以它的回滚信息也记录在内存对象中。那些对象就跟随在这个私有数据区域之后:这些指针只会被pager所使用。)当pager将页面数据写入缓存的时候，这些额外的非页面数据空间会被初始化为0。缓存中的所有页面通过`PCache1.aphash`哈希数组来访问；数组大小存储在`PCache1.nHash`变量内；这个数组也会根据需要调整大小。每一个数组元素都指向一个槽桶(bucket)；桶内的所有槽都会被组织在一个无序的单向链表内。\n\n`PgHdr`对象只对pager模块可见，对Tree以及更高的模块不可见。头部有很多控制变量。`pgno`代表了数据库页面的页号。`needSync`标记位表示在回写这个页面到数据库文件的时候，日志文件是否需要flush一下。`dirty`标记位表示页面是否已经被修改过了，并且新的数据还没有回写到数据库文件内。`nRef`变量是这个页面的引用计数。如果`nRef`大于0，那么这个分页就还在使用中，我们说这个页面是被固定了，否则这个页面就是非固定的，并是被释放的。`pDirtyNext`和`pDirtyPrev`指针用来将所有的脏页面链接到一起。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/zIdkXn.png)\n\n**缓存组**:SQLite有一个选项，可以将所有`PCache1`对象放在一个组中。当这些高速缓存受到内存压力的影响时，它们可以回收彼此未固定的页面槽。\n\n## 缓存的读取\n缓存的使用者无法通过地址寻址方式来访问一个缓存元素。事实上，它们甚至不知道一个页面的拷贝存储在哪个位置，当然也就不知道它们的地址了。缓存的内容是可寻址的，可以通过页号来搜索到一个页面。在管理数据的时候，它会使用`PCache1.apHash`哈希数组来讲页面号转换为一个合适的缓存存储槽。一开始，页面缓存是空的，但是随着需求的增加，页面会被主键添加到缓存中去。正如之前所提到的，为了读一个分页，调用者(Tree模块)需要调用`sqlite3PagerGet`方法，并且给定页号。这个方法将会由以下几步来请求一个页面P。\n\n1. 搜索缓存空间。\n    * 在页号P上应用一个非常简单的哈希算法，来计算获取`apHash`的索引号:算法就是用分页号模`apHash`数组大小\n    * 在`apHash`数组上使用这个索引获取到哈希桶。\n    * 通过遍历`pNext`指针来搜索这个桶。如果P页面在这里找到了，那么我们就说这个缓存命中了，它会固定一个页面(也就是将页面`PgHdr.nRef`的值+1)。并且会给调用者返回页面的内存地址。\n\n2. 如果页面P在缓存中没有找到，那么就认为是缓存缺失。方法就会去寻找一个空闲的插槽来加载请求的页面。(如果缓存尚未达到最大限制`PCache.nMax`，它就会创建一个新的空间的插槽。)\n\n3. 如果目前找不到一个可以使用的空闲的插槽或者也不能创建新的，它会决定某个页面是否可以释放用来给P页面复用插槽。这个称为替换插槽。(后面的小节我们会讨论这个)\n\n4. 如果这个被替换的插槽或者空闲插槽已经被标记为脏页面了，那么它就会将这个页面回写到数据库文件中去。(遵循预写日志（WAL）协议，它也会刷新日志文件)\n\n5. 两种情况。(a)如果这个P页面是小于等于文件中当前的最大页面数的，它就会从数据库文件中向空闲的插槽中读取页面P，然后固定这个页面(设置`PgHdr.nRef`为1)，然后返回页面地址给调用者。(b)如果P比当前的最大页面数量还要大，它不再读取页面，而是把整个页面初始化为0。在两种情况中，它都会把页面底部的私有区域初始化为0，不论这个页面是否是从数据库文件中读的。也都会把(`PgHdr.nRef`设为1。)\n\nSQLite严格按照按需加载请求页面的策略，使得页面拉取变得非常简单。(关于这个后续还会细说。)\n\n当在缓存中的页面地址返回给调用者(Tree模块)的时候，pager并不知道调用者什么时候会对页面内容进行操作。因此对于每一个页面，SQLite有如下的一个标准协议:调用者请求(固定)一个页面，使用页面，然后释放页面。已经固定的页面是正在活跃使用中的，缓存管理器不能回收这个页面。为了避免出现所有缓存页面都被固定的场景，SQLite在缓存中需要有一个最小数量的页面，这样它就始终可以有缓存插槽来回收了，在3.7.8版本的时候这个值是10。\n\n## 缓存的更新\n在获取到一个页面之后，调用者可以直接修改这个页面的内容。但是正如之前所提到的，在做出修改之前，它必须调用`sqlite3PagerWrite`方法。在方法返回之后，调用者就可以随意更新页面内容了。\n\n在首次调用`sqlite3PagerWrite`方法的时候，pager会将原始的页面内容作为一个日志记录的一部分写到回滚日志文件中，并且设置`PgHdr.needSync`标记。在此之后，当日志记录刷新到磁盘的时候，pager就会清除这个标记位。(SQLite遵循SQL协议:它直到这个页面对应的`needSync`标记位清除的时候才会将一个已修改的页面写入到数据库文件中去。)每次调用`sqlite3PagerWrite`方法的时候`PgHdr.dirty`都会被置位；只有当这个页面的内容被回写到数据库文件的时候这个标记位才会被清除。因为调用者什么时候改页面内容，pager是不知道的。数据库文件也不能实时反映页面内容的更新。因此pager遵循延迟回写数据库文件的策略。仅当pager执行缓存刷新或有选择地回收脏页时，更新才会反映到数据库文件。\n\n延迟的数据库文件更新会导致事务的内存使用增长，当内存使用到达上限的时候，缓存管理器就会执行缓存替换。\n\n## 缓存拉取策略\n缓存拉取策略决定了什么时候将一个页面加载进缓存。按需拉取的策略只会在请求页面的时候才会将页面加载进缓存。在调用者请求页面的时候，调用者此时是阻塞的，一直到页面从数据库文件中读取完成。很多缓存系统使用了很复杂的预拉取技术提前将页面写入缓存，这样可以减少阻塞的频率。SQLite从文件中一次读一个页面，严格按照按需加载的策略，保持逻辑简单。\n\n## 缓存管理\n通常情况下，一个页面缓存的大小是有限的。除非数据库非常小，否则它一般只能持有数据库一小部分的页面。在不同的时间点，缓存需要回收掉一些页面来持有不同的页面。因此，缓存的页面需要非常小心的管理来获取性能的最大化。基本想法就是，在缓存中保留那些立刻会被请求的页面。在设计一个缓存策略的时候，我们需要考虑三件事情:\n\n1. 每当缓存中有一个页面的时候，在数据库文件中也有这个页面的一个主副本。每当这个缓存被更新的时候，这个主副本也需要被更新。\n\n2. 对于不在缓存中的请求页面，将引用主副本，并从主副本中创建新的缓存副本\n\n3. 如果缓存已经满了，并且一个新的页面需要被放入缓存，会有一个替换算法来决定从缓存中移除掉一些旧的页面来给新的页面腾出空间。\n\n因为缓存空间大小有限，我们需要回收一些缓存控件来适应将一个大的页面集合映射到一个小型的缓存插槽内(见下图)。在图里，26个主页面需要通过回收插槽的方式来映射到5个缓存插槽内。缓存管理在缓存性能和整体性能上都非常关键。在还有剩余空间的时候，对于缓存来说没什么难的。它的挑战就在于缓存已满的时候。它的职责就是哪些页面可以保留，哪些页面可以被替换出去。我们需要一个高命中率的缓存。因此对于缓存替换来说，最关键的地方就是决定那个页面可以保留。接下来我们就讨论缓存替换\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/UK0ZuX.png)\n\n### 缓存替换\n缓存替换发生在缓存已经满的时候，旧的页面需要被移出去来给新的页面腾出空间。在前面提到，在页面都满了的时候，当一个请求的页面不在缓存中并且也没有可用的空闲的插槽的时候，其中的一个页面需要牺牲以被替换掉。而这个页面的选择不是一个简单的决定。之前也说过，页面的缓存是完全关联的，任何一个插槽都可以给这个新页面。由于考虑使用多个插槽进行替换，因此所选的插槽由缓存替换策略决定。替换策略的主要目标是将那些页面保留在缓存中，以便可以在不引用主副本页的情况下从缓存中满足大部​​分请求。因此缓存命中率需要非常高。如果命中率很低，那么这个缓存也不值得用来加速页面访问了。\n\n我们并不知道未来可能引用哪些页面。所以，缓存管理器通过一些启发式的或者优先的访问历史来决定替换页面。因此，通常在实践中使用的替换方案有时会在选择被替换页面时造成“错误”，当调用者立即召回被替换页面时，这种替换很快就会被撤销。如果一个页面P在被替换出去之后，又立刻被引用了，或者在再次被引用期间，其他页面一个都没有被引用，那么这个决定是比较差的。替换策略的目标是最大程度地减少错误，并最大程度地提高缓存未命中之间的时间间隔。缓存之间的主要差别就在于替换策略。在硬件和软件开发中，先进先出，最近最少使用，最少使用，时钟策略已广泛遵循高速缓存替换策略。SQLite则使用一种最近最少使用替换策略(LRU)。\n\n### LRU缓存替换\nLRU是一个非常流行的替换策略。它及其变体已在软件和硬件缓存开发的许多领域中成功实现。它利用对页面引用的时间局部性。(时间局部性是指在短时间内很有可能重复访问同一页面。)也就是说，一个页面在现在被访问了，那么它很有可能将会被再次访问。一个页面很长时间没有被访问了，那么它很有可能近期不会被再次访问。选择的被替换者，就是最长时间没有被访问的那一个。\n\n### SQLite的缓存替换\nSQLite把一些不活跃的页面放在一个逻辑队列中。当一个页面被取消固定的时候，pager就会将这个页面放在队列的尾部。(队列末尾的页面始终是最近访问的页面，而队列头部的页面则是最早访问过的页面。)被替换的那个页面一般都会选择队列头部的，但不一定像纯LRU方案那样总是队列的头元素。SQLite尝试从队列的开头开始找到一个插槽，以便回收该插槽不会涉及刷新日志文件。因为回收一个页面如果导致文件刷新的话，那么会减慢速度。如果能找到这么一个替换页面，那最前面的那个就会被回收。否则，SQLite就会刷新日志文件，然后回收头部的那个插槽。如果这个页面是脏页面，还会会写到数据库中。\n\n# 事务管理\n在SQLite中Pager也是一个事务管理器，它会通过管理数据库文件上的锁，以及管理日志文件中的日志记录来确保事务的ACID。尽管SQLite锁管理器负责获取并释放文件上的锁，但pager会决定锁的模式以及获取和释放锁的时间点。它会严格遵循以下两个锁阶段，来创建一个事务的线性执行。它也决定了日志记录的内容以及何时写入日志文件。\n\n和DBMS一样，SQLite的事务管理有两个组件:1.正常处理和 2.恢复处理。在正常处理过程中，pager会在日志文件中保存一些回滚需要的信息，然后在发起回滚的时候，使用这些数据来确保回滚。下面两个小节将会讲述这两个组件。事务管理的一些细节会有单独的文章，而这里我将会从整体的角度上来看。\n\n## 正常处理流程\n正常的处理流程包含了从数据库文件读页面和写页面到数据库文件，提交事务，结算子事务，设置和释放保存点。另外，pager回收插槽的选择和刷新页面缓存也是正常处理流程中的一部分。\n\n### 读操作\n为了在一个数据库页面上操作，调用者(Tree模块)需要调用`sqlite3PagerGet`方法。即使页面不在数据库内，也需要调用这个方法:因为新的页面会由pager创建。方法会在数据库文件上获取一个共享锁。如果获取共享锁失败，那么说明此时数据库上已经有一个与之冲突的锁，方法会返回SQLITE_BUSY给调用者。否则，它就执行缓存读，然后将页面的指针地址返回给调用者。前面提到，这个操作会固定住一个页面。\n\n从前文的图中可以看到，每一个内存页面中，后面跟了一块私有空间。这个额外的空间在从数据库文件加载或者全新创建的时候都会被初始化为0。这个空间之后会由Tree模块来再次初始化。\n\npager首次从数据文件获取一个共享锁的时候，它可以决定文件是否需要恢复。他会寻找一个日志文件(后面会讨论文件的恢复和失败恢复)。如果这个日志文件确实存在，那么说明在之前的事务执行过程中出现了一次失败，并且pager在调用`sqlite3PagerGet`返回之前，会回滚那次失败的事务，并且释放这个日志文件。\n\n如上所述，一个已经请求过的页面可能并不会在页面缓存中。在那个情况下，pager找到一个空闲的缓存插槽并且从数据库文件中加载页面，整个过程对用户是透明的。获取一个空闲的缓存插销也可能会导致一次数据库文件的写入，即缓存的刷新。\n\n### 写操作\n在修改一个页面之前，调用者(Tree模块)必须先固定住这个页面(通过调用`sqlite3PagerGet`方法)。然后在通过`sqlite3PagerWrite`方法，让对应的页面变得可写。一旦变成可写状态，调用者就可以随意更改内容，且不用通知pager。写入一个页面并不会导致缓存的刷新。尽管pager可能需要在数据库上请求一个保留锁。首次调用`sqlite3PagerWrite`方法的时候，pager就会在数据库文件上获取一个保留锁。这个保留锁的意思就是即将要写入数据库了。同时只能有一个事务可以持有一个保留锁。如果pager无法获取这个锁，那就意味着在文件上有其他的事务获取了同级或者更高级的锁。在这个情况下，pager就会返回SQLITE_BUSY给调用者。\n\npager首次请求保留锁的时候，我们称之为读事务升级为写事务。(对用户事务或者系统事务来说都一样。)在这个时间点，pager创建并打开一个回滚日志文件。(回滚日志文件也在与数据库的同级目录下，只不过后面会增加'-journal'。)它会初始化第一个分片的记录头(具体可以看日志相关的)，记录下数据库文件的原始大小，然后把记录写入日志文件。如果数据库文件大小因为事务而扩大了，那么只需要按照这个原始大小裁剪就可以了，因为新的页面都是往数据库后面添加的。\n\n为了让一个页面可写，pager会把这个页面的原始内容写到回滚日志文件中。新创建的分页不会记录log，因为它本身就没有旧的数据。一个页面最多写入一次回滚日志文件。对数据库的变更不会立刻写入数据库文件。这些变更会先在内存中持有。数据库文件中依旧是未改变的，也就意味着，其他事务还能继续从文件中读。\n\n**扇区记录**:如果存储设备中的扇区可以存储超过一个数据库页面，SQLite会log整个扇区，而不是仅仅只有被改变的页面。\n\n**页面log策略**:一旦当有一个页面额镜像数据被拷贝到回滚日志中，尽管当前的事务再去多次调用`sqlite3PagerWrite`方法，页面也不会出现在后续新的日志记录中了。这个日志记录方式有一个好处就是，一个页面可以无脑的从日志文件的数据区中恢复出来。因此撤销操作是幂等的，并且它不会产生任何补偿日志记录。\n\n### 缓存刷新\n缓存刷新是pager模块的一个内部操作，调用者(Tree模块)不能直接调用缓存刷新。有两种场景pager想要把缓存刷新到内存之外(即磁盘上):1.缓存已经满了，并且需要做一次缓存替换。2.事务依旧准备好去提交它的变更了。pager会将一些或者所有已经变更的页面写入到数据库文件中去。在写入之前，pager必须保证没有其他事务正在读数据库事务了。SQLite遵循WAL协议写入数据库。也就意味着，在写入到数据库文件之前还需要刷新写入日志回滚的记录。pager遵循下面的步骤:\n\n1. 它先判断决定是否有必要刷新日志文件。如果事务是同步的，并且已经把新数据写入到日志文件了，并且数据库文件不是一个临时文件(因为对于临时数据库我们不需要考虑断电恢复)，那么pager就需要做一次日志文件的flush刷新。在这个场景下，只需要在日志文件上执行`fsync`系统调用来确保所有的日志文件的写入已经落到磁盘上了。此时，pager没有将在日志片段头部中日志记录的数量(`nRec`)的值写入到文件中。(`nRec`值是回滚操作的关键资源。当这个片段头部构建的时候，这个值会被同步事务设置为0，被异步事务设置为-1。)在日志文件被刷新到磁盘上之后，pager就会将`nRec`值写入，然后再做一次`fsync`。因为磁盘的写入不是原子的，它不会再重写`nRec`字段。pager会为新的日志记录创建一个新的日志片段。在这些情况下，SQLite使用多段日志文件。\n\n2. 它会尝试在数据库文件上获取一个排它锁。(pager不会无条件的等待锁。他会尝试在非阻塞条件下尝试获取锁。如果其他事务还在持有共享锁，那么这个锁就会失败，然后返回SQLITE_BUSY，事务不会被终止。)\n\n3. 将所有已经修改的页面(在页面缓存中持有的)或者选中的一些回写到数据库文件中。页面写入就地完成。他它会清空缓存中这些页面的脏标记位。(此时不会立刻刷新数据库文件到磁盘。)\n\n如果写入数据库文件的原因是因为缓存满了，那么pager还不会立刻提交事务。相反的，此时事务可能会继续对数据库页面做一些修改。后续的数据库写入依旧是重复这三个步骤。\n\n**注意**:排他锁会一直持有直至数据库的事务最终完成。这也就意味着说，从第一次页面写入到数据库一直到事务提交或者终止，进程内的其他数据库连接或者其他进程内的数据库连接都无法对当前数据库发起读写事务。对于一些较短的写事务来说，数据更新都会在缓存中持有，以及排它锁只会在事务最终提交的时候才会请求。但是一个较长的写事务会导致其他读事务的性能下降。\n\n### 提交操作\n根据提交事务是修改单个数据库还是多个数据库，SQLite遵循的提交协议略有不同。\n\n**单个数据库场景**:当Tree模块准备提交一个事务额时候，它会先调用`sqlite3PagerCommitPhaseOne`，然后调用`sqlite3PagerCommitPhaseTwo`。提交读事务简单。pager从数据库文件上释放共享锁，然后返回到NO_LOCK状态。他它也不需要去清理页面缓存。(下一个事务开始的时候，页面缓存已经有一个\"预热\"了。)为了提交一个写事务，pager按照如下的步骤有序执行:\n\n1. 在数据库文件上获取一个排他锁。(如果锁获取失败了，就会给`sqlite3PagerCommitPhaseOne`方法的调用者返回SQLITE_BUSY。它此时不能提交事务，因为此时还有其他读事务。)然后它会将数据库的metadata的文件变更计数器上+1。将缓存中所有已经发生变更的数据回写到数据库文件内。(按照上面**缓存刷新**小节中的1-3步骤)\n\n2. 很多操作系统例如Linux，会将这些文件写入缓存到系统内存空间中，并且不会立刻将数据回写到本地磁盘。为了避免这个场景，pager会调用`fsync`系统调用来刷新到磁盘上。这样做是为了消除系统重新启动时的重做逻辑。\n\n3. 然后，它完成（即删除，截断或使之无效）日志文件。\n\n4. 最终它会释放数据库文件上的排它锁。如果同时执行选择操作（即读取事务），它将返回SHARED_LOCK状态；否则，返回NO_LOCK状态。它也没必要去清除页面缓存。\n\n单个数据库的提交点是在于他完成日志文件的时候。\n\n**多个数据库场景**:这个提交协议涉及的更多，它类似于分布式数据库系统中的事务提交。VM模块（`VdbeCommit`函数）实际上驱动提交协议作为提交协调器。每个数据库的pager执行自己“本地”的提交操作。如果一个读事务或者写事务，只修改了单个数据库(临时数据库不算)，那么这个协议就和普通提交一样。如果修改了多个，那么就按照下面步骤执行:\n\n1. 释放事务没有更新的那些数据库上的共享锁。(如果当前线程内的其他读事务也不再激活了。)\n\n2. 在那些发生更新的数据库文件上请求排它锁。增加数据库文件的 文件变更计数器。\n\n3. 创建一个新的主日志文件。(这个主日志文件和主数据库同级目录，同名，但是后续跟着'-mj',以及8个十六进制的随机数。即使主数据库文件没有发生数据变更，也是如此。)在主日志文件中填充所有各个独立的回滚日志文件的名字，然后将主日志文件和日志文件目录flush到磁盘上。(临时数据库文件不包含在内。)\n\n4. 将主日志文件的名字写到各个独立的回滚日志中的主日志记录中。并且flush回滚日志到磁盘。(pager可能一直到提交事务的时候它才会知道它只是多数据库事务的一部分。)\n\n5. flush各自的数据库文件。\n\n6. 删除主日志文件，并且flush日志文件目录。\n\n7. 完成（即删除，截断或使之无效）各自的日志文件\n\n8. 释放所有数据库文件上的排它锁。所有pager会返回到SHARED_LOCK或者NO_LOCK状态。pager无需清除页面缓存。\n\n多数据库的提交点是在于他删除了主日志文件。\n\n**关于完成日志文件**:当journal_mode持久存在时，日志文件将被截断为零大小，而不是使日志头无效。\n\n**注意**:如果主数据库是个临时数据库或者内存数据库，SQLite是不保证多数据库事务的提交的原子性的。也就是说，全局恢复可能会有问题。它不会创建主日志文件。VM会依次挨个在每个数据库上做单独的提交。因此这个事务对于每一个数据库来说是原子的，但是期间一旦出现掉电之类的问题，可能会导致一部分数据库会执行恢复，而另一部分不会。\n\n**提交失败**:用户事务是应用通过执行COMMIT命令自己提交的，然后SQLite尝试结束这个事务。正如之前提到的，尝试提交的事务可能会因为锁的冲突导致失败，并且返回SQLITE_BUSY。因为此时数据库上可能还有其他的读事务，如果是因为这个导致的失败，事务依旧保持激活状态，应用可以在之后再次发起尝试。SQLite不会自动做重试，需要应用自己去做。\n\n### 语句级操作\n语句级子事务被实现为在子事务结束时释放的匿名保存点。在语句子事务级别的一般操作有读，写和提交。下面我们将讨论这些。\n\n**读操作**:语句子事务通过包含的用户事务读取页面。用户事务遵循所有规则。\n\n**写操作**:在写事务中有两个部分:锁和日志。一个语句级的子事务通过包含的用户事务来请求锁。但是语句级的日志有一点点的不同，并且是由单独的临时语句级日志文件处理。(语句级的日志文件名是任意命名的，以`etilqs_`开头，临时文件。）pager会在语句级日志文件中写入一部分日志记录，还会在主回滚日志中写入一部分。当子事务尝试通过`sqlite3PagerWrite`操作使页面可写时，它将执行以下两个替代操作之一：\n\n1. 如果页面不在回滚日志中，pager就会将新的日志记录添加进回滚日志中。(但是后续新的页面就不会加入log了。)\n\n2. 如果页面不在这个语句级的日志文件中，那么pager会把新的日志记录加入其中。(当语句级子事务在文件中写入第一条log记录的时候，pager就会创建语句级的日志文件。)\n\npager从来都不会flush语句级日志，因为这个从来都不需要失败恢复。如果出现了一个系统失败或掉电，主回滚日志将会负责数据库恢复。可以注意到，当一个页面即是回滚日志文件，又是语句级日志文件的时候，回滚日志文件中持有最旧版本的页面数据。\n\n**提交操作**:语句提交非常简单，pager删除语句日志文件。(但是，看以下两个小节。)\n\n### 设置保存点\n当一个用户事务建立一个保存点的时候，SQLite就会进入保存点模式。在这个模式下，SQLite在语句提交的时候，不会删除语句级的日志。它会持有日志文件，直至事务释放了所有的保存点，或者提交事务，或者终止事务。在保存点模式下，日志记录有一点点区别:如果页面已经被前一个语句加入日志文件，那么这个页面将会被当前语句再次加入日志文件中。因此，语句级的日志对同一个数据库分页可以有多条记录。\n\n### 释放保存点\n当应用执行`release sp`命令的时候，SQLite会销毁对应的`PagerSavepoint`对象，以及那些在`sp`保存点之后建立的保存点。应用也无法再次引用那些保存点。\n\n## 恢复处理流程\n大部分的事务和语句子事务都是自己提交。但是偶尔情况下，一些事务和语句会自己终止。在很少的情况下，会出现一些应用和系统失败。无论哪种情况，SQLite都可能需要通过执行一些回滚操作将数据库恢复到可接受的一致状态。在前两种情况下(终止语句和事务)，恢复时会提供内存中的可靠信息。在后两种情况下(失败),数据库可能会出错，并且没有内存信息。在事务过程中，事务将还原到先前的保存点。在后面的小节内，将讨论这4个场景。\n\n### 事务终止\n在SQLite里，从终止中恢复是很简单的。pager可能会，也可能不会从数据库文件中移除事务所带来的的影响。如果事务只持有了数据库文件上的保留锁或未决锁，那么它可以保证文件不被修改；pager完成释放日志文件，并且丢弃在页面缓存中所有的脏页面。否则，事务将会在数据库文件上持有一个排他锁，并且一些页面可能已经被事务回写到数据库文件了，pager就会执行下面的回滚操作。\n\npager从回滚日志中一条一条读取日志记录，然后从日志记录中恢复页面数据。因此，在扫描日志文件的最后，数据库已经恢复到事务开始时的最初始状态了。如果事务已经将数据库扩展了，那么pager还会将数据库文件裁剪到原始的大小。pager会先flush数据库文件，然后接下来会完成释放回滚日志文件。它会释放排他锁，并且清空页面缓存。\n\n### 语句级子事务终止\n正如之前所提到的，一个语句级的子事务可能同时会在回滚日志和语句级日志中添加日志记录。SQLite需要从语句级日志，以及一些主回滚日志中回滚所有的日志记录。每一个语句都会被当做一个匿名的保存点。所以一个语句的终止，就等同于恢复一个匿名保存点。我们在下面的章节中讨论这个。\n\n### 回滚到保存点\n在之前提到，当在保存点模式的时候，事务是不会删除语句级日志的。当事务执行了一个`roll to sp`命令的时候，SQLite同样会回滚在`sp`保存点之后建立的所有保存点。`PagerSavepoint`对象对应的三个成员变量起着至关重要的作用：`iOffset`，`iHdrOffset`和`iSubRec`。它首先回滚主回滚日志中的所有日志记录，从iOffset处开始直到日志文件结束。然后，它将回滚从`iSubRec`开始的语句日志中的所有日志记录，直到文件末尾来还原保存点。然而，在前一个情况下，如果`iHdrOffset`是非零，那么从主回滚日志中回滚日志记录会分为以下两步:(1)从`iOffset`到`iHdrOffset`以及(2)所有后续的日志段。在恢复的过程中，pager记下了哪些页面被回滚了，并确保页面不会被回滚超过一次。`Pager.dbSize`也会被回滚到保存点之前的大小(即PagerSavepoint.nOrig)。如果是恢复整个事务，那么只需要用到主回滚日志就行。SQLite会销毁所有在`sp`保存点之后创建的所有`PagerSavepoint`对象，但不包括`sp`自己。这些保存点对应用来说也都不可访问了。\n\n### 失败恢复\n在进程崩溃或者系统出错的时候，数据库文件中可能会遗留一些不一致的数据。当没有应用在更新数据库，并且存在回滚日志文件的时候，这就意味着之前的事务可能已经存在失败情况了，并且SQLite可能需要从失败带来的影响中恢复数据库。如果对应的数据库文件是未上锁或者只有共享锁的情况下，那么这个回滚日志文件可以说是激活状态的。但是如果日志文件是有多数据库事务创建的，并且没有主日志文件，那么这个日志文件并不是激活的。\n\n**判定日志是否激活**:有两种情况:(1)如果不涉及多数据库的主日志，也就是说日志文件中没有出现主日志文件记录。如果日志文件存在，并且是有效的(有一个按格式化的日志头部并且不为0)，并且数据库文件上没有保留锁或者高于保留锁的锁，并且数据库不是空的，那么这个日志文件就是激活状态。(2)如果主数据库日志名出现在回滚日志文件中，并且主回滚日志存在，并且日志中引用了回滚日志文件，并且在对应的数据库文件上没有保留锁或者更高的锁，那么这个日志文件就是激活的。\n\n**警告**:如果当前的应用是以只读的权限打开数据库文件，并且对文件或者对目录没有写权限，那么恢复就会失败，并且SQLite会返回特定的错误码。\n\npager在想从数据库文件中第一次读取页面的时候，它会按照如下的恢复顺序来执行。\n\n1. 它先在数据库文件上获取一个共享锁。(如果无法获取到这个锁，它就会返回给应用SQLITE_BUSY错误码。)\n\n2. 检查数据库上是否有一个激活的日志文件。如果数据库没有激活的日志文件，那么恢复操作就到此为止了。如果存在一个激活的日志文件，那么日志文件就会按照如下的步骤来回滚。\n\n3. 在数据库文件上获取一个排它锁。(pager不会在数据库上获取保留锁，因为这样会让其他的pager认为日志文件已经不再是激活状态了，然后它们就会直接读数据库。最后它是需要在数据库上获取一个排他锁，因为写入数据库是恢复工作的一部分。) 如果获取锁失败，那么就意味着此时有另一个pager正在尝试回滚。在那种情况下，它会释放所有的锁并且返回SQLITE_BUSY错误码给应用层。\n\n4. 从日志回滚文件中读取所有的日志记录，并且撤销这些日志(回滚)。这个操作会将数据库恢复到发生崩溃的事务开始时候的状态。并且数据库此时就在一致的状态了。如果需要的话，数据库文件还会被缩减到事务开始之前的大小。\n\n5. flush刷新数据库文件。如果发生另一次电源故障或崩溃，这可以保护数据库的完整性。\n\n6. 释放(包括删除、无效化、或者裁剪)日志文件。\n\n7. 如果安全的话，删除主日志文件。\n\n8. 把锁降级到共享锁。(因为pager是在`sqlite3PagerGet`方法的内部执行的恢复。)\n\n在以上的算法策略成功的执行之后，数据库文件此时就已经保证恢复到之前的状态了。此时再读取文件的时候就是安全的了。\n\n**过时的主日志文件**:如果没有独立的回滚日志引用主日志文件，那么这个主日志文件就可以认为是过时的。pager会先读主日志文件，然后获取所有回滚日志文件的名字。然后，它分别检查每个回滚日记文件。如果每一个日志文件都存在，并且指向主日志文件，那么这个主日志文件就不是过时的。如果所有的回滚日志文件都不存在，或者他们指向了其他的主日志文件，或者没有指向主日志文件，那么这个主日志文件就是过时的，并且pager会删除掉这个主日志文件。没有要求说这个过时的主日志文件需要被删除。这样做的唯一原因就是为了释放磁盘空间。\n\n## 其他的管理问题\n### 检查点\n大部分数据库系统为了减小数据库失败的恢复压力，在固定的时间点都会有一个检查点。因为SQLite在同一个时间点同一个数据库上最多只会有一个写事务。日志文件中也只有当前事务的日志记录。SQLite会在事务完成的时候，处理掉日志文件。最终SQLite就不会有日志的积压，也不会需要去执行一个检查点，日志中也不会有检查点的逻辑。当事务提交的时候，数据库会保证在处理日志文件之前，将数据库的更新已经都写入数据库中了。(在SQLite3.7.0中，SQLite的开发者介绍了WAL日志特性。在这个日志模式下，会执行检查点。后续会讨论这个日志模式。)\n\n### 空间约束\n在某些DBMS中，最麻烦的问题是日志空间不足。换句话树，就是文件系统没有足够的空间来给日志文件继续扩大写入新的日志记录。在某些DBMS中，中止事务会生成（补偿）日志记录，同时撤消某些更新，从而使情况进一步恶化。日志空间的不足可能会在那些系统中产生事务中止和系统重启的问题。但是SQLite不会，因为事务的终止不会产生任何新的日志记录。系统重启尽管也会有问题，但是只会在一些极端的场景下:事务会收缩数据库文件，并且释放的空间已经由本机文件系统分配用于其他目的。在这个情况下，恢复可能失败，因为SQLite已经无法将数据库文件恢复到原始的大小了。此时数据库就会被阻塞，直到所需的空间可用于数据库文件恢复到原始大小为止。\n\n还有一个其他的相关的问题:数据库文件没有足够的空间可以增长了。在这个场景下，pager会返回SQLITE_FULL错误码给应用，这有可能会终止事务。所以这也有可能会在SQLite中导致问题。","source":"_posts/2020-08-17_db-system-design-imp(Pager).md","raw":"---\ntitle: The Pager Module\ndate: 2020-08-17\ntags: [sqlite3]\ntop: 300\ncategories: sqlite3\n---\n\n> 本文讨论的是SQLite的Pager模块。本模块在原生操作系统的基础上实现了一个抽象的基于页面的数据库文件系统。它按照固定大小的页面来管理数据，并且定义了一些接口从数据库文件中来操作这些页面。它提供了一个数据库页面的内存缓存，来帮助BTree模块加速操作数据库页面。它不仅仅是一个缓存的管理中心，同样也是实现ACID的事务管理中，以及事务回滚管理。并发控制和回滚机制对于上层模块来说是完全透明的。他可以理解为一个传统数据库管理系统的持久化层。\n\n<!-- more -->\n\n# Pager模块\n除了内存数据库以外，数据库都是以原生文件的形式落在磁盘上的。SQLite无法高效的直接读取和操作磁盘上的文件。当需要数据项的时候，它会从数据库文件中读取数据到主内存中，然后在内存中操作数据，在有必要的时候，还会回写到磁盘文件中去。相对于紧凑的主内存来说，一般情况下数据库文件都会很大。因为内存有限，所以一般内存中只会保留一小部分来存储的数据，而这部分内存通常就被叫做数据库缓存或者数据缓存;在SQLite的术语中，它被称为page cache。而这个缓存是在应用进程的地址空间内，而不是操作系统的地址空间。(操作系统有它自己的数据缓存。)\n\npage缓存管理器在SQLite的世界里就是Pager。它面对的是可随机访问的原生字节流的文件，并且需要将他们转换为可以随机访问的高级别的分页式的文件，而这个页面的大小是固定的。不同的数据库文件可以有不同的页面大小。区别于原生操作系统，Pager提供了一个简单可用的接口来访问数据库文件的页面。Tree模块将会使用Pager提供的接口来操作，而不会直接操作原生的数据库或者日志文件。Tree模块看到的数据库逻辑上是一个页面的数组，并且通过他们数组的下标索引来获取页面。\n\nSQLite对于每一个打开的数据库文件(或者说数据库连接)，都会有一个单独的页面缓存。当一个应用进程打开一个数据库文件的时候，Pager就会为它创建和初始化一个新的页面缓存。如果进程多次打开同一个数据库文件的时候，在默认模式下，Pager会单独为这个文件创建和初始化页面缓存多次。(SQLite提供一个高级特性，那就是所有打开同一个数据库文件的数据库连接可以共享一个页面缓存。)在使用内存数据库的时候，不会访问任何外部存储设备。但是它们也会被当做原生的数据库文件来处理，并且会被整个存储到缓存中。因此Tree模块可以使用相同的接口来操作这两类数据库。\n\n在SQLite中Pager属于最底层的模块。这是唯一的一个通过直接调用操作系统提供的I/O API来访问原生文件的模块。它会直接读写数据库文件或者日志文件。它不会理解数据库是如何组织数据结构的。它也不会去干涉数据库的内容，或者自己去修改内容。它只需要保证存在数据库文件中的数据可以被重复地无任何修改地检索。从这个角度上来说，Pager是一个被动的模块。(它有可能会修改一些数据库文件头部记录中的信息，例如文件修改计数器file change counter。)\n\n对于每一个数据文件来说，Pager在文件和内存缓存之间转移页面内容是作为一个缓存管理器的基本功能。而这个转移对于Tree模块和一些高层模块来说是透明的。Pager就是原生系统文件和高层之间的一个媒介。它还要协调页面回写到数据库文件中去。\n\n除了缓存管理的工作之外，pager也承担了一个典型的DBMS的其他功能。它提供一个典型的事务处理系统的核心服务:事务管理，数据管理，日志管理，和锁管理。作为一个事务管理者，它通过接管并发控制和数据恢复，来实现了事务的ACID属性。它也负责原子性提交和事务的回滚。作为一个数据管理者，它通过缓存和一些文件空间管理来协调数据库文件页面的读写。作为日志管理者，它决定了在日志文件中的日志写入。作为一个锁管理者，它可以确保在操作数据库页面之前，在数据库文件上已经有了一个合理的锁。\n\n# Pager接口\n在这一小节中，我将会给出一些Pager模块导出的接口，这些接口将会给Tree模块使用。在此之前，我们先讨论一下Pager和Tree模块之间的交互协议。\n\n## Pager-client调用交互协议\n在Pager之上的模块是完全隔离了低级别的锁和日志管理机制。事实上，它们并不知道锁和日志的存在的。Tree模块把所有的事情都看做一个事务，并且它不关心事务的ACID是如何实现的。而Pager模块则把一个事务的所有活动拆分为锁、日志、以及读写数据库文件。Tree模块以页面号来向Pager中请求一个页面数据。反过来，Pager会返回一个已经加载到页面缓存中的页面数据的指针地址。在修改一个页面之前，Tree模块需要先通知Pager模块。这样Pager模块可以在日志文件中存放足够的信息来防止之后要做数据恢复，以及提前在数据库文件上加上合适的锁。在它使用完页面之后，还要通知Pager，这样如果页面数据发生改变的时候，Pager还会将数据回写到数据库文件中。\n\n### Pager接口结构\nPager模块实现了一个数据结构叫`Pager`。每一个数据库文件都是通过单独的`Pager`对象来管理的，并且每一个`Pager`也只会关联到有且仅有一个数据库文件上。(在Pager模块层中，这个对象就等同于数据库文件。)在Tree模块中，如果需要使用一个数据库文件，那么需要先创建一个Pager对象，然后在这个对象上使用一些页面操作函数。Pager模块可以使用这个对象来追溯关于文件的锁，日志文件，和数据库的状态，日志文件的状态等等。一个进程在同一个数据库文件上可以有多个`Pager`对象与之对应，每一个对象都隶属于一个数据库连接。这些对象都是被独立处理的，互不相关。(对于共享缓存的模式来说，对每一个数据库文件，只有一个`Pager`对象，所有数据库文件共享这个对象。)内存数据库也是使用这个对象作为操作句柄。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/lLkn3u.png)\n\n后面会给出一个`Pager`对象的一些成员变量。在这个对象的后面会紧跟着一片内存空间，这个空间会用来存储页面缓存、数据库文件句柄、日志文件句柄、和数据库文件名、日志文件名。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/hWBtgL.png)\n\n正如之前提到的，SQlite在一个用户事务中，执行每一个更新(insert,delete,update)操作的时候都会放在一个savepoint保存点内。同样的，应用也可以设置自己的保存点。可以同时存在多个保存点，存储在aSavepoint数组内。这个保存点的数据结构后面也有。当SQLite创建了一个保存点savepoint的时候，它就会把`iHdrOffset`这个变量置0。但是如果在某个savepoint已经激活的时候，它打开了回滚日志文件并且在文件中写入了一条记录头，那么它就会把`iHdrOffset`改为在写入回滚日志之前的最后一条记录的字节偏移。当`PagerSavepoint`对象创建的时候,`iOffset`会被设置为回滚日志的起始偏移。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/1ijSOI.png)\n\n### Pager接口函数\nPager模块实现了一系列给Tree模块使用的接口方法。为了便于后面的理解，下面先列举一些重要的接口方法，这些接口方法都是以`sqlite3Pager`开头，所有的方法都仅限SQLite内部使用。\n\n1. sqlite3PagerOpen:方法创建一个新的`Pager`对象，打开给定的数据库文件，创建和初始化一个空的页面缓存，并且把这个缓存的指针返还给`Pager`对象。它会根据给定的数据库名，创建/打开一个合适的文件。数据库文件在此时并不会上锁，既没有创建日志文件，也没有执行数据库恢复操作。(数据库的恢复是会被延迟到首次从数据库中读取一个页面的时候)\n\n2. sqlite3PagerClose:方法销毁一个`Pager`对象，并且关闭关联的已经打开的数据库文件。如果它是一个临时文件，pager还会删除掉和这个文件。如果它不是一个临时文件并且在这个方法被调用的时候，这个文件还有一个事务存在，那么这个事务就会被强制终止，并且把它的变更全部回滚。所有内存中的缓存都会失效，从用户进程地址空间内释放。在这个方法调用之后再去访问缓存都会导致崩溃。换句话说，所有的资源都被释放了。\n\n3. sqlite3PagerGet:这个方法会给调用者从数据库文件中复制到内存中一份可用的数据页面。调用者指定了请求页面的页面号。方法返回一个拷贝到内存缓存中的页面地址。因此，缓存空间不被回收的话，它就会固定下这个拷贝的页面。在调用这个方法最开始它就会在数据库上获取一个共享锁。此时它会决定是否需要清理现有的页面缓存--如果数据库的文件变更计数器(在文件头部第24字节开始的4个字节整型)和当前缓存中的之前获取到的这个值不一样，它就会开始清理缓存。另外如果有必要的话(存在一个回滚日志文件)，数据库就会从日志文件中回滚(后面的章节会讨论日志的回滚)。如果请求的页面不在缓存中，pager就会加载请求的页面到缓存中。但是，如果目前的数据库文件小于请求的页面号，那么实际也不会触发文件读，但是内存中会依旧分配一个页面，并且全部初始化为0.(当然对于内存数据库来说，不会触发任何的文件操作。)\n\n4. sqlite3PagerWrite:这个方法可以将请求的数据库页面对调用者是可写的。(注意这里是可写不是写入数据。)这个方法必须在Tree模块修改缓存数据之前调用，否则的话Pager并不知道某一个缓存的页面被修改了。(处于性能考虑，SQLite避免了从Tree模块到Pager模块互相拷贝数据，而是让Tree模块直接修改Pager缓存的数据。)Pager还会在数据库文件上获取一个保留锁，并且创建一个回滚日志文件。也就是说它创建了一个隐式的写事务。如果当前页面还不在日志文件中，那么它就会拷贝这个页面中的原始数据到回滚日志中去。如果这个原始的页面已经在日志文件中了，那么SQLite只会标记这个页面为写脏。如果当前的事务是在一个用户事务中，并且当前页面也已经在主回滚日志中了，那么这个方法也还会在状态日志中写入一条状态记录。\n\n5. sqlite3PagerLookup:这个方法返回在已经请求在内存缓存中的页面。如果不在，则返回NULL。对前者来说，它会固定这个页面。\n\n6. sqlite3PagerRef:方法给指定页面的引用计数+1。我们称这个页面被调用者固定了。如果页面在缓存的已释放链表中，这个方法会从这个已释放列表中移除该页面。\n\n7. sqlite3PagerUnref:方法给指定页面的引用计数-1。当这个页面的引用计数降低到0的时候，我们称这个页面已经被解除固定，并且被释放了。(被释放的页面依旧存在内存中，它会存储在已释放的链表内。）当所有的页面都被解除固定了的时候，在数据库上的共享锁就会被释放，`Pager`对象就会被重置。\n\n8. sqlite3PagerBegin:方法在相关联的数据库文件上开启一个显式的写事务。如果数据库不是一个临时数据库，它也会打开一个回滚日志文件。(对于临时数据库，回滚日志的打开会一直推迟到真正写入回滚日志的时候。)从前面可以知道隐式的写事务是由`sqlite3PagerWrite`开启的。因此，如果数据库已经保留用来准备写入了，那么这个方法就不会做任何操作。否则的话，它会首先在数据库文件上持有一个保留锁，并且如果在参数指明的情况下，它还会立刻在数据库文件上获取一个排它锁，而不是真正等到Tree模块尝试写入数据的时候。\n\n9. sqlite3PagerCommitPhaseOne:方法在数据库文件上提交当前的事务:文件变更计数器+1，同步日志文件，把所有的变更(例如页面缓存中的脏页)同步到数据库文件中\n\n10. sqlite3PagerCommitPhaseTwo:方法释放(包括删除、无效化、或者裁剪)日志文件。\n\n11. sqlite3PagerRollback:方法在数据库文件上放弃当前的事务:回滚事务给数据库文件带来的所有变更，并且把数据库的锁降级到共享锁。所有的缓存页面转变为它们的原始数据内容。日志文件被释放。\n\n12. sqlite3PagerOpenSavepoint:方法创建一个新的保存点句柄对象，为当前的数据库状态建立一个保存点。\n\n13. sqlite3PagerSavepoint:方法释放或者回滚一个保存点。对于释放操作来说，它会释放和销毁指定的一个保存点句柄对象。对于回滚操作来说，它回滚数据库上在此保存点建立之后的所有变更，并且后面所有的保存点都会被删除。\n\n# 页面缓存\n页面缓存存在于应用进程的地址空间内。（对于同一个页面来说，原生操作系统可能也会对它做一次缓存，当应用从某个文件中读取一段数据的时候，操作系统一般都会给自己拷贝一份，再给应用拷贝一份。我们不关心操作系统是如何管理它的缓存的。SQLite的缓存组织和管理独立于那些原生操作系统。）下图描述了一个典型的情况。在图中，两个进程(其中有一个是多线程的)在访问同一个数据库文件。他们有自己的缓存。甚至于同一个线程在默认操作模式下，多次打开了同一个数据库。SQLite为这些数据库连接分配了独立的缓存。通过它们自己不同的`Pager`对象来访问这些缓存。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/It7kz3.png)\n\n## 缓存状态\n页面缓存的状态(在上图中`Pager`对象中有对应的变量)决定了Pager模块可以对缓存做什么。两个变量`eState`和`eLock`控制了Pager的行为。页面缓存的总是以下7种状态之一(`Pager.eState`成员变量的值)。下图是这7种状态值的转换图。\n\n1. **PAGER_OPEN**:当一个`Pager`对象创建的时候，这是它的初始状态。此时pager无法通过`Pager`对象来读或者写数据库文件。当前内存中可能没有页面缓存，缓存是空的。数据库文件上应该也没有锁，在当前数据库上没有事务。\n\n2. **PAGER_READER**:在这个状态的时候，当前数据库连接上至少有一个读事务，pager可以读取对应数据库文件的页面。(但是，在排他锁的模式下，读事务可能并不会打开。)\n\n3. **PAGER_WRITER_LOCKED**:当一个`Pager`对象在这个状态的时候，当前数据库连接上已经打开了一个写事务。pager可以在对应的数据库文件上读页面数据，但是它还没有在数据库文件或者缓存页面中做任何的变更。\n\n4. **PAGER_WRITER_CACHEMOD**:当一个`Pager`对象在这个状态的时候，pager给与Tree模块权限来更新缓存的页面数据，并且Tree模块可能已经对它做出了一些变更。\n\n5. **PAGER_WRITER_DBMOD**:当一个`Pager`对象在这个状态的时候，pager可能已经开始写数据库文件了。\n\n6. **PAGER_WRITER_FINISHED**:当一个`Pager`对象在这个状态的时候，pager已经完成将当前写事务中发生的所有变更的页面写入到数据库文件了。写事务已经不能再做任何的变更了，此时已经在准备提交了。\n\n7. **PAGER_ERROR**:出错的状态，例如I/O失败，磁盘空间不足，内存不足等等。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/yUn3tG.png)\n\n根据`eLock`变量的值，一个`Pager`对象可以是如下4中状态之一。\n\n1. **NO_LOCK**:当前不在读写任何事务。\n\n2. **SHARED_LOCK**:Pager已经从数据库文件中读了页面数据了。在同一个时间，同一个文件上可以有多个读事务，这些读事务可以各自通过他们的`Pager`对象来访问数据库文件。此时不允许修改缓存的页面。\n\n3. **RESERVED_LOCK**:pager已为写入数据保留了数据库文件，但是还没有做出任何的变更。在同一时间只有一个pager可以保留指定的数据库文件。因为原始的数据库文件还没有被修改，其它的Pager依旧可以读。\n\n4. **EXCLUSIVE_LOCK**:pager已经把缓存页面回写到数据库文件了。此时的文件访问是独占的。当这个pager在写入的时候，没有其他的pager可以读写这个文件。\n\n页面缓存开始于NO_LOCK的状态。当Tree模块首次调用`sqlite3PagerGet`方法读取任何一个页面的时候，pager就会转换到SHARED_LOCK状态。当Tree模块通过执行`sqlite3PagerUnref`方法释放所有页面的时候，pager就会转换回NO_LOCK状态。(这个时候，它应该不会清理页面缓存。)当Tree模块首次调用`sqlite3PagerWrite`方法的时候，pager就会转换到RESERVED_LOCK状态。(`sqlite3PagerWrite`方法只有在pager已经就绪读的时候才可以被调用)。pager在真正写入第一个页面到数据库文件的时候，就会转换到EXCLUSIVE_LOCK状态。在`sqlite3PagerRollback`或者`sqlite3PagerCommitPhasTwo`两个方法的执行过程中，pager会转换回NO_LOCK状态。\n\n* 对于内存数据库或者临时数据库来说，`Pager.eLock`永远是EXCLUSICE_LOCK，因为它始终是独占的。\n\n## 缓存的组织结构\n\n每一个页面缓存都是由一个`PCache`句柄对象来管理。pager持有了这个`PCache`对象的引用(可以看上面pager的结构图)。下图描述了一个`PCache`对象的一些成员变量。SQLite支持插件化的缓存结构，用户可以自己提供一个缓存结构。它提供了它自己的插件缓存模块(由pcache1.c源码实现)，后面会讨论这个缓存实现。这个也将会是默认的缓存管理，除非用户自己提供一个。`PCache`对象的最后一个成员就是pCache,持有了这个可插件化的缓存模块。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/EWLiFD.png)\n\n通常情况下，为了加速查询一个缓存，当前持有的缓存项都会被较好的组织好。缓存空间会被分割为一个个存储槽来持有数据项。SQLite使用一个哈希表来组织已缓存的页面，并且使用页面槽来持有表中的页面。缓存是完全关联的，因此任何一个存储槽都可以存储任何页面。哈希表初始化为空。随着页面需求的增长，pager会创建新的存储槽，然后将它们插入到哈希表内。`PCache.nMax`值决定了一个缓存可以持有的最大存储槽的数量。主数据库和其他attach连接上的数据库默认值是2000，临时数据库是500。内存数据库没有这个限制，根据物理内存的大小，有多少用多少。\n\nSQLite使用一个`PgHdr`类型的对象来标识缓存中的每一个页面对象。尽管一个可插件化的缓存可以有它自己的页面头部对象，但是pager也依旧可以理解这个对象。下图描述了SQLite自己的可插件化的缓存，由`PCache1`对象表示。在哈希表中的每一个插槽都由一个类型为`PgHdr1`的头部对象表示。这个插件化的组件是可以理解这个类型的，pager对此也不透明。插槽数据就存储在`PgHdr1`对象的正前方；这个插槽的数据大小由`PCache1.szSize`变量决定。这个插槽数据持有了一个`PgHdr`对象，一个数据库页面数据，和一些私有数据，这些私有数据区域是Tree模块用来保存页面特有的内存中的控制信息。(内存数据库没有日志文件，所以它的回滚信息也记录在内存对象中。那些对象就跟随在这个私有数据区域之后:这些指针只会被pager所使用。)当pager将页面数据写入缓存的时候，这些额外的非页面数据空间会被初始化为0。缓存中的所有页面通过`PCache1.aphash`哈希数组来访问；数组大小存储在`PCache1.nHash`变量内；这个数组也会根据需要调整大小。每一个数组元素都指向一个槽桶(bucket)；桶内的所有槽都会被组织在一个无序的单向链表内。\n\n`PgHdr`对象只对pager模块可见，对Tree以及更高的模块不可见。头部有很多控制变量。`pgno`代表了数据库页面的页号。`needSync`标记位表示在回写这个页面到数据库文件的时候，日志文件是否需要flush一下。`dirty`标记位表示页面是否已经被修改过了，并且新的数据还没有回写到数据库文件内。`nRef`变量是这个页面的引用计数。如果`nRef`大于0，那么这个分页就还在使用中，我们说这个页面是被固定了，否则这个页面就是非固定的，并是被释放的。`pDirtyNext`和`pDirtyPrev`指针用来将所有的脏页面链接到一起。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/zIdkXn.png)\n\n**缓存组**:SQLite有一个选项，可以将所有`PCache1`对象放在一个组中。当这些高速缓存受到内存压力的影响时，它们可以回收彼此未固定的页面槽。\n\n## 缓存的读取\n缓存的使用者无法通过地址寻址方式来访问一个缓存元素。事实上，它们甚至不知道一个页面的拷贝存储在哪个位置，当然也就不知道它们的地址了。缓存的内容是可寻址的，可以通过页号来搜索到一个页面。在管理数据的时候，它会使用`PCache1.apHash`哈希数组来讲页面号转换为一个合适的缓存存储槽。一开始，页面缓存是空的，但是随着需求的增加，页面会被主键添加到缓存中去。正如之前所提到的，为了读一个分页，调用者(Tree模块)需要调用`sqlite3PagerGet`方法，并且给定页号。这个方法将会由以下几步来请求一个页面P。\n\n1. 搜索缓存空间。\n    * 在页号P上应用一个非常简单的哈希算法，来计算获取`apHash`的索引号:算法就是用分页号模`apHash`数组大小\n    * 在`apHash`数组上使用这个索引获取到哈希桶。\n    * 通过遍历`pNext`指针来搜索这个桶。如果P页面在这里找到了，那么我们就说这个缓存命中了，它会固定一个页面(也就是将页面`PgHdr.nRef`的值+1)。并且会给调用者返回页面的内存地址。\n\n2. 如果页面P在缓存中没有找到，那么就认为是缓存缺失。方法就会去寻找一个空闲的插槽来加载请求的页面。(如果缓存尚未达到最大限制`PCache.nMax`，它就会创建一个新的空间的插槽。)\n\n3. 如果目前找不到一个可以使用的空闲的插槽或者也不能创建新的，它会决定某个页面是否可以释放用来给P页面复用插槽。这个称为替换插槽。(后面的小节我们会讨论这个)\n\n4. 如果这个被替换的插槽或者空闲插槽已经被标记为脏页面了，那么它就会将这个页面回写到数据库文件中去。(遵循预写日志（WAL）协议，它也会刷新日志文件)\n\n5. 两种情况。(a)如果这个P页面是小于等于文件中当前的最大页面数的，它就会从数据库文件中向空闲的插槽中读取页面P，然后固定这个页面(设置`PgHdr.nRef`为1)，然后返回页面地址给调用者。(b)如果P比当前的最大页面数量还要大，它不再读取页面，而是把整个页面初始化为0。在两种情况中，它都会把页面底部的私有区域初始化为0，不论这个页面是否是从数据库文件中读的。也都会把(`PgHdr.nRef`设为1。)\n\nSQLite严格按照按需加载请求页面的策略，使得页面拉取变得非常简单。(关于这个后续还会细说。)\n\n当在缓存中的页面地址返回给调用者(Tree模块)的时候，pager并不知道调用者什么时候会对页面内容进行操作。因此对于每一个页面，SQLite有如下的一个标准协议:调用者请求(固定)一个页面，使用页面，然后释放页面。已经固定的页面是正在活跃使用中的，缓存管理器不能回收这个页面。为了避免出现所有缓存页面都被固定的场景，SQLite在缓存中需要有一个最小数量的页面，这样它就始终可以有缓存插槽来回收了，在3.7.8版本的时候这个值是10。\n\n## 缓存的更新\n在获取到一个页面之后，调用者可以直接修改这个页面的内容。但是正如之前所提到的，在做出修改之前，它必须调用`sqlite3PagerWrite`方法。在方法返回之后，调用者就可以随意更新页面内容了。\n\n在首次调用`sqlite3PagerWrite`方法的时候，pager会将原始的页面内容作为一个日志记录的一部分写到回滚日志文件中，并且设置`PgHdr.needSync`标记。在此之后，当日志记录刷新到磁盘的时候，pager就会清除这个标记位。(SQLite遵循SQL协议:它直到这个页面对应的`needSync`标记位清除的时候才会将一个已修改的页面写入到数据库文件中去。)每次调用`sqlite3PagerWrite`方法的时候`PgHdr.dirty`都会被置位；只有当这个页面的内容被回写到数据库文件的时候这个标记位才会被清除。因为调用者什么时候改页面内容，pager是不知道的。数据库文件也不能实时反映页面内容的更新。因此pager遵循延迟回写数据库文件的策略。仅当pager执行缓存刷新或有选择地回收脏页时，更新才会反映到数据库文件。\n\n延迟的数据库文件更新会导致事务的内存使用增长，当内存使用到达上限的时候，缓存管理器就会执行缓存替换。\n\n## 缓存拉取策略\n缓存拉取策略决定了什么时候将一个页面加载进缓存。按需拉取的策略只会在请求页面的时候才会将页面加载进缓存。在调用者请求页面的时候，调用者此时是阻塞的，一直到页面从数据库文件中读取完成。很多缓存系统使用了很复杂的预拉取技术提前将页面写入缓存，这样可以减少阻塞的频率。SQLite从文件中一次读一个页面，严格按照按需加载的策略，保持逻辑简单。\n\n## 缓存管理\n通常情况下，一个页面缓存的大小是有限的。除非数据库非常小，否则它一般只能持有数据库一小部分的页面。在不同的时间点，缓存需要回收掉一些页面来持有不同的页面。因此，缓存的页面需要非常小心的管理来获取性能的最大化。基本想法就是，在缓存中保留那些立刻会被请求的页面。在设计一个缓存策略的时候，我们需要考虑三件事情:\n\n1. 每当缓存中有一个页面的时候，在数据库文件中也有这个页面的一个主副本。每当这个缓存被更新的时候，这个主副本也需要被更新。\n\n2. 对于不在缓存中的请求页面，将引用主副本，并从主副本中创建新的缓存副本\n\n3. 如果缓存已经满了，并且一个新的页面需要被放入缓存，会有一个替换算法来决定从缓存中移除掉一些旧的页面来给新的页面腾出空间。\n\n因为缓存空间大小有限，我们需要回收一些缓存控件来适应将一个大的页面集合映射到一个小型的缓存插槽内(见下图)。在图里，26个主页面需要通过回收插槽的方式来映射到5个缓存插槽内。缓存管理在缓存性能和整体性能上都非常关键。在还有剩余空间的时候，对于缓存来说没什么难的。它的挑战就在于缓存已满的时候。它的职责就是哪些页面可以保留，哪些页面可以被替换出去。我们需要一个高命中率的缓存。因此对于缓存替换来说，最关键的地方就是决定那个页面可以保留。接下来我们就讨论缓存替换\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/UK0ZuX.png)\n\n### 缓存替换\n缓存替换发生在缓存已经满的时候，旧的页面需要被移出去来给新的页面腾出空间。在前面提到，在页面都满了的时候，当一个请求的页面不在缓存中并且也没有可用的空闲的插槽的时候，其中的一个页面需要牺牲以被替换掉。而这个页面的选择不是一个简单的决定。之前也说过，页面的缓存是完全关联的，任何一个插槽都可以给这个新页面。由于考虑使用多个插槽进行替换，因此所选的插槽由缓存替换策略决定。替换策略的主要目标是将那些页面保留在缓存中，以便可以在不引用主副本页的情况下从缓存中满足大部​​分请求。因此缓存命中率需要非常高。如果命中率很低，那么这个缓存也不值得用来加速页面访问了。\n\n我们并不知道未来可能引用哪些页面。所以，缓存管理器通过一些启发式的或者优先的访问历史来决定替换页面。因此，通常在实践中使用的替换方案有时会在选择被替换页面时造成“错误”，当调用者立即召回被替换页面时，这种替换很快就会被撤销。如果一个页面P在被替换出去之后，又立刻被引用了，或者在再次被引用期间，其他页面一个都没有被引用，那么这个决定是比较差的。替换策略的目标是最大程度地减少错误，并最大程度地提高缓存未命中之间的时间间隔。缓存之间的主要差别就在于替换策略。在硬件和软件开发中，先进先出，最近最少使用，最少使用，时钟策略已广泛遵循高速缓存替换策略。SQLite则使用一种最近最少使用替换策略(LRU)。\n\n### LRU缓存替换\nLRU是一个非常流行的替换策略。它及其变体已在软件和硬件缓存开发的许多领域中成功实现。它利用对页面引用的时间局部性。(时间局部性是指在短时间内很有可能重复访问同一页面。)也就是说，一个页面在现在被访问了，那么它很有可能将会被再次访问。一个页面很长时间没有被访问了，那么它很有可能近期不会被再次访问。选择的被替换者，就是最长时间没有被访问的那一个。\n\n### SQLite的缓存替换\nSQLite把一些不活跃的页面放在一个逻辑队列中。当一个页面被取消固定的时候，pager就会将这个页面放在队列的尾部。(队列末尾的页面始终是最近访问的页面，而队列头部的页面则是最早访问过的页面。)被替换的那个页面一般都会选择队列头部的，但不一定像纯LRU方案那样总是队列的头元素。SQLite尝试从队列的开头开始找到一个插槽，以便回收该插槽不会涉及刷新日志文件。因为回收一个页面如果导致文件刷新的话，那么会减慢速度。如果能找到这么一个替换页面，那最前面的那个就会被回收。否则，SQLite就会刷新日志文件，然后回收头部的那个插槽。如果这个页面是脏页面，还会会写到数据库中。\n\n# 事务管理\n在SQLite中Pager也是一个事务管理器，它会通过管理数据库文件上的锁，以及管理日志文件中的日志记录来确保事务的ACID。尽管SQLite锁管理器负责获取并释放文件上的锁，但pager会决定锁的模式以及获取和释放锁的时间点。它会严格遵循以下两个锁阶段，来创建一个事务的线性执行。它也决定了日志记录的内容以及何时写入日志文件。\n\n和DBMS一样，SQLite的事务管理有两个组件:1.正常处理和 2.恢复处理。在正常处理过程中，pager会在日志文件中保存一些回滚需要的信息，然后在发起回滚的时候，使用这些数据来确保回滚。下面两个小节将会讲述这两个组件。事务管理的一些细节会有单独的文章，而这里我将会从整体的角度上来看。\n\n## 正常处理流程\n正常的处理流程包含了从数据库文件读页面和写页面到数据库文件，提交事务，结算子事务，设置和释放保存点。另外，pager回收插槽的选择和刷新页面缓存也是正常处理流程中的一部分。\n\n### 读操作\n为了在一个数据库页面上操作，调用者(Tree模块)需要调用`sqlite3PagerGet`方法。即使页面不在数据库内，也需要调用这个方法:因为新的页面会由pager创建。方法会在数据库文件上获取一个共享锁。如果获取共享锁失败，那么说明此时数据库上已经有一个与之冲突的锁，方法会返回SQLITE_BUSY给调用者。否则，它就执行缓存读，然后将页面的指针地址返回给调用者。前面提到，这个操作会固定住一个页面。\n\n从前文的图中可以看到，每一个内存页面中，后面跟了一块私有空间。这个额外的空间在从数据库文件加载或者全新创建的时候都会被初始化为0。这个空间之后会由Tree模块来再次初始化。\n\npager首次从数据文件获取一个共享锁的时候，它可以决定文件是否需要恢复。他会寻找一个日志文件(后面会讨论文件的恢复和失败恢复)。如果这个日志文件确实存在，那么说明在之前的事务执行过程中出现了一次失败，并且pager在调用`sqlite3PagerGet`返回之前，会回滚那次失败的事务，并且释放这个日志文件。\n\n如上所述，一个已经请求过的页面可能并不会在页面缓存中。在那个情况下，pager找到一个空闲的缓存插槽并且从数据库文件中加载页面，整个过程对用户是透明的。获取一个空闲的缓存插销也可能会导致一次数据库文件的写入，即缓存的刷新。\n\n### 写操作\n在修改一个页面之前，调用者(Tree模块)必须先固定住这个页面(通过调用`sqlite3PagerGet`方法)。然后在通过`sqlite3PagerWrite`方法，让对应的页面变得可写。一旦变成可写状态，调用者就可以随意更改内容，且不用通知pager。写入一个页面并不会导致缓存的刷新。尽管pager可能需要在数据库上请求一个保留锁。首次调用`sqlite3PagerWrite`方法的时候，pager就会在数据库文件上获取一个保留锁。这个保留锁的意思就是即将要写入数据库了。同时只能有一个事务可以持有一个保留锁。如果pager无法获取这个锁，那就意味着在文件上有其他的事务获取了同级或者更高级的锁。在这个情况下，pager就会返回SQLITE_BUSY给调用者。\n\npager首次请求保留锁的时候，我们称之为读事务升级为写事务。(对用户事务或者系统事务来说都一样。)在这个时间点，pager创建并打开一个回滚日志文件。(回滚日志文件也在与数据库的同级目录下，只不过后面会增加'-journal'。)它会初始化第一个分片的记录头(具体可以看日志相关的)，记录下数据库文件的原始大小，然后把记录写入日志文件。如果数据库文件大小因为事务而扩大了，那么只需要按照这个原始大小裁剪就可以了，因为新的页面都是往数据库后面添加的。\n\n为了让一个页面可写，pager会把这个页面的原始内容写到回滚日志文件中。新创建的分页不会记录log，因为它本身就没有旧的数据。一个页面最多写入一次回滚日志文件。对数据库的变更不会立刻写入数据库文件。这些变更会先在内存中持有。数据库文件中依旧是未改变的，也就意味着，其他事务还能继续从文件中读。\n\n**扇区记录**:如果存储设备中的扇区可以存储超过一个数据库页面，SQLite会log整个扇区，而不是仅仅只有被改变的页面。\n\n**页面log策略**:一旦当有一个页面额镜像数据被拷贝到回滚日志中，尽管当前的事务再去多次调用`sqlite3PagerWrite`方法，页面也不会出现在后续新的日志记录中了。这个日志记录方式有一个好处就是，一个页面可以无脑的从日志文件的数据区中恢复出来。因此撤销操作是幂等的，并且它不会产生任何补偿日志记录。\n\n### 缓存刷新\n缓存刷新是pager模块的一个内部操作，调用者(Tree模块)不能直接调用缓存刷新。有两种场景pager想要把缓存刷新到内存之外(即磁盘上):1.缓存已经满了，并且需要做一次缓存替换。2.事务依旧准备好去提交它的变更了。pager会将一些或者所有已经变更的页面写入到数据库文件中去。在写入之前，pager必须保证没有其他事务正在读数据库事务了。SQLite遵循WAL协议写入数据库。也就意味着，在写入到数据库文件之前还需要刷新写入日志回滚的记录。pager遵循下面的步骤:\n\n1. 它先判断决定是否有必要刷新日志文件。如果事务是同步的，并且已经把新数据写入到日志文件了，并且数据库文件不是一个临时文件(因为对于临时数据库我们不需要考虑断电恢复)，那么pager就需要做一次日志文件的flush刷新。在这个场景下，只需要在日志文件上执行`fsync`系统调用来确保所有的日志文件的写入已经落到磁盘上了。此时，pager没有将在日志片段头部中日志记录的数量(`nRec`)的值写入到文件中。(`nRec`值是回滚操作的关键资源。当这个片段头部构建的时候，这个值会被同步事务设置为0，被异步事务设置为-1。)在日志文件被刷新到磁盘上之后，pager就会将`nRec`值写入，然后再做一次`fsync`。因为磁盘的写入不是原子的，它不会再重写`nRec`字段。pager会为新的日志记录创建一个新的日志片段。在这些情况下，SQLite使用多段日志文件。\n\n2. 它会尝试在数据库文件上获取一个排它锁。(pager不会无条件的等待锁。他会尝试在非阻塞条件下尝试获取锁。如果其他事务还在持有共享锁，那么这个锁就会失败，然后返回SQLITE_BUSY，事务不会被终止。)\n\n3. 将所有已经修改的页面(在页面缓存中持有的)或者选中的一些回写到数据库文件中。页面写入就地完成。他它会清空缓存中这些页面的脏标记位。(此时不会立刻刷新数据库文件到磁盘。)\n\n如果写入数据库文件的原因是因为缓存满了，那么pager还不会立刻提交事务。相反的，此时事务可能会继续对数据库页面做一些修改。后续的数据库写入依旧是重复这三个步骤。\n\n**注意**:排他锁会一直持有直至数据库的事务最终完成。这也就意味着说，从第一次页面写入到数据库一直到事务提交或者终止，进程内的其他数据库连接或者其他进程内的数据库连接都无法对当前数据库发起读写事务。对于一些较短的写事务来说，数据更新都会在缓存中持有，以及排它锁只会在事务最终提交的时候才会请求。但是一个较长的写事务会导致其他读事务的性能下降。\n\n### 提交操作\n根据提交事务是修改单个数据库还是多个数据库，SQLite遵循的提交协议略有不同。\n\n**单个数据库场景**:当Tree模块准备提交一个事务额时候，它会先调用`sqlite3PagerCommitPhaseOne`，然后调用`sqlite3PagerCommitPhaseTwo`。提交读事务简单。pager从数据库文件上释放共享锁，然后返回到NO_LOCK状态。他它也不需要去清理页面缓存。(下一个事务开始的时候，页面缓存已经有一个\"预热\"了。)为了提交一个写事务，pager按照如下的步骤有序执行:\n\n1. 在数据库文件上获取一个排他锁。(如果锁获取失败了，就会给`sqlite3PagerCommitPhaseOne`方法的调用者返回SQLITE_BUSY。它此时不能提交事务，因为此时还有其他读事务。)然后它会将数据库的metadata的文件变更计数器上+1。将缓存中所有已经发生变更的数据回写到数据库文件内。(按照上面**缓存刷新**小节中的1-3步骤)\n\n2. 很多操作系统例如Linux，会将这些文件写入缓存到系统内存空间中，并且不会立刻将数据回写到本地磁盘。为了避免这个场景，pager会调用`fsync`系统调用来刷新到磁盘上。这样做是为了消除系统重新启动时的重做逻辑。\n\n3. 然后，它完成（即删除，截断或使之无效）日志文件。\n\n4. 最终它会释放数据库文件上的排它锁。如果同时执行选择操作（即读取事务），它将返回SHARED_LOCK状态；否则，返回NO_LOCK状态。它也没必要去清除页面缓存。\n\n单个数据库的提交点是在于他完成日志文件的时候。\n\n**多个数据库场景**:这个提交协议涉及的更多，它类似于分布式数据库系统中的事务提交。VM模块（`VdbeCommit`函数）实际上驱动提交协议作为提交协调器。每个数据库的pager执行自己“本地”的提交操作。如果一个读事务或者写事务，只修改了单个数据库(临时数据库不算)，那么这个协议就和普通提交一样。如果修改了多个，那么就按照下面步骤执行:\n\n1. 释放事务没有更新的那些数据库上的共享锁。(如果当前线程内的其他读事务也不再激活了。)\n\n2. 在那些发生更新的数据库文件上请求排它锁。增加数据库文件的 文件变更计数器。\n\n3. 创建一个新的主日志文件。(这个主日志文件和主数据库同级目录，同名，但是后续跟着'-mj',以及8个十六进制的随机数。即使主数据库文件没有发生数据变更，也是如此。)在主日志文件中填充所有各个独立的回滚日志文件的名字，然后将主日志文件和日志文件目录flush到磁盘上。(临时数据库文件不包含在内。)\n\n4. 将主日志文件的名字写到各个独立的回滚日志中的主日志记录中。并且flush回滚日志到磁盘。(pager可能一直到提交事务的时候它才会知道它只是多数据库事务的一部分。)\n\n5. flush各自的数据库文件。\n\n6. 删除主日志文件，并且flush日志文件目录。\n\n7. 完成（即删除，截断或使之无效）各自的日志文件\n\n8. 释放所有数据库文件上的排它锁。所有pager会返回到SHARED_LOCK或者NO_LOCK状态。pager无需清除页面缓存。\n\n多数据库的提交点是在于他删除了主日志文件。\n\n**关于完成日志文件**:当journal_mode持久存在时，日志文件将被截断为零大小，而不是使日志头无效。\n\n**注意**:如果主数据库是个临时数据库或者内存数据库，SQLite是不保证多数据库事务的提交的原子性的。也就是说，全局恢复可能会有问题。它不会创建主日志文件。VM会依次挨个在每个数据库上做单独的提交。因此这个事务对于每一个数据库来说是原子的，但是期间一旦出现掉电之类的问题，可能会导致一部分数据库会执行恢复，而另一部分不会。\n\n**提交失败**:用户事务是应用通过执行COMMIT命令自己提交的，然后SQLite尝试结束这个事务。正如之前提到的，尝试提交的事务可能会因为锁的冲突导致失败，并且返回SQLITE_BUSY。因为此时数据库上可能还有其他的读事务，如果是因为这个导致的失败，事务依旧保持激活状态，应用可以在之后再次发起尝试。SQLite不会自动做重试，需要应用自己去做。\n\n### 语句级操作\n语句级子事务被实现为在子事务结束时释放的匿名保存点。在语句子事务级别的一般操作有读，写和提交。下面我们将讨论这些。\n\n**读操作**:语句子事务通过包含的用户事务读取页面。用户事务遵循所有规则。\n\n**写操作**:在写事务中有两个部分:锁和日志。一个语句级的子事务通过包含的用户事务来请求锁。但是语句级的日志有一点点的不同，并且是由单独的临时语句级日志文件处理。(语句级的日志文件名是任意命名的，以`etilqs_`开头，临时文件。）pager会在语句级日志文件中写入一部分日志记录，还会在主回滚日志中写入一部分。当子事务尝试通过`sqlite3PagerWrite`操作使页面可写时，它将执行以下两个替代操作之一：\n\n1. 如果页面不在回滚日志中，pager就会将新的日志记录添加进回滚日志中。(但是后续新的页面就不会加入log了。)\n\n2. 如果页面不在这个语句级的日志文件中，那么pager会把新的日志记录加入其中。(当语句级子事务在文件中写入第一条log记录的时候，pager就会创建语句级的日志文件。)\n\npager从来都不会flush语句级日志，因为这个从来都不需要失败恢复。如果出现了一个系统失败或掉电，主回滚日志将会负责数据库恢复。可以注意到，当一个页面即是回滚日志文件，又是语句级日志文件的时候，回滚日志文件中持有最旧版本的页面数据。\n\n**提交操作**:语句提交非常简单，pager删除语句日志文件。(但是，看以下两个小节。)\n\n### 设置保存点\n当一个用户事务建立一个保存点的时候，SQLite就会进入保存点模式。在这个模式下，SQLite在语句提交的时候，不会删除语句级的日志。它会持有日志文件，直至事务释放了所有的保存点，或者提交事务，或者终止事务。在保存点模式下，日志记录有一点点区别:如果页面已经被前一个语句加入日志文件，那么这个页面将会被当前语句再次加入日志文件中。因此，语句级的日志对同一个数据库分页可以有多条记录。\n\n### 释放保存点\n当应用执行`release sp`命令的时候，SQLite会销毁对应的`PagerSavepoint`对象，以及那些在`sp`保存点之后建立的保存点。应用也无法再次引用那些保存点。\n\n## 恢复处理流程\n大部分的事务和语句子事务都是自己提交。但是偶尔情况下，一些事务和语句会自己终止。在很少的情况下，会出现一些应用和系统失败。无论哪种情况，SQLite都可能需要通过执行一些回滚操作将数据库恢复到可接受的一致状态。在前两种情况下(终止语句和事务)，恢复时会提供内存中的可靠信息。在后两种情况下(失败),数据库可能会出错，并且没有内存信息。在事务过程中，事务将还原到先前的保存点。在后面的小节内，将讨论这4个场景。\n\n### 事务终止\n在SQLite里，从终止中恢复是很简单的。pager可能会，也可能不会从数据库文件中移除事务所带来的的影响。如果事务只持有了数据库文件上的保留锁或未决锁，那么它可以保证文件不被修改；pager完成释放日志文件，并且丢弃在页面缓存中所有的脏页面。否则，事务将会在数据库文件上持有一个排他锁，并且一些页面可能已经被事务回写到数据库文件了，pager就会执行下面的回滚操作。\n\npager从回滚日志中一条一条读取日志记录，然后从日志记录中恢复页面数据。因此，在扫描日志文件的最后，数据库已经恢复到事务开始时的最初始状态了。如果事务已经将数据库扩展了，那么pager还会将数据库文件裁剪到原始的大小。pager会先flush数据库文件，然后接下来会完成释放回滚日志文件。它会释放排他锁，并且清空页面缓存。\n\n### 语句级子事务终止\n正如之前所提到的，一个语句级的子事务可能同时会在回滚日志和语句级日志中添加日志记录。SQLite需要从语句级日志，以及一些主回滚日志中回滚所有的日志记录。每一个语句都会被当做一个匿名的保存点。所以一个语句的终止，就等同于恢复一个匿名保存点。我们在下面的章节中讨论这个。\n\n### 回滚到保存点\n在之前提到，当在保存点模式的时候，事务是不会删除语句级日志的。当事务执行了一个`roll to sp`命令的时候，SQLite同样会回滚在`sp`保存点之后建立的所有保存点。`PagerSavepoint`对象对应的三个成员变量起着至关重要的作用：`iOffset`，`iHdrOffset`和`iSubRec`。它首先回滚主回滚日志中的所有日志记录，从iOffset处开始直到日志文件结束。然后，它将回滚从`iSubRec`开始的语句日志中的所有日志记录，直到文件末尾来还原保存点。然而，在前一个情况下，如果`iHdrOffset`是非零，那么从主回滚日志中回滚日志记录会分为以下两步:(1)从`iOffset`到`iHdrOffset`以及(2)所有后续的日志段。在恢复的过程中，pager记下了哪些页面被回滚了，并确保页面不会被回滚超过一次。`Pager.dbSize`也会被回滚到保存点之前的大小(即PagerSavepoint.nOrig)。如果是恢复整个事务，那么只需要用到主回滚日志就行。SQLite会销毁所有在`sp`保存点之后创建的所有`PagerSavepoint`对象，但不包括`sp`自己。这些保存点对应用来说也都不可访问了。\n\n### 失败恢复\n在进程崩溃或者系统出错的时候，数据库文件中可能会遗留一些不一致的数据。当没有应用在更新数据库，并且存在回滚日志文件的时候，这就意味着之前的事务可能已经存在失败情况了，并且SQLite可能需要从失败带来的影响中恢复数据库。如果对应的数据库文件是未上锁或者只有共享锁的情况下，那么这个回滚日志文件可以说是激活状态的。但是如果日志文件是有多数据库事务创建的，并且没有主日志文件，那么这个日志文件并不是激活的。\n\n**判定日志是否激活**:有两种情况:(1)如果不涉及多数据库的主日志，也就是说日志文件中没有出现主日志文件记录。如果日志文件存在，并且是有效的(有一个按格式化的日志头部并且不为0)，并且数据库文件上没有保留锁或者高于保留锁的锁，并且数据库不是空的，那么这个日志文件就是激活状态。(2)如果主数据库日志名出现在回滚日志文件中，并且主回滚日志存在，并且日志中引用了回滚日志文件，并且在对应的数据库文件上没有保留锁或者更高的锁，那么这个日志文件就是激活的。\n\n**警告**:如果当前的应用是以只读的权限打开数据库文件，并且对文件或者对目录没有写权限，那么恢复就会失败，并且SQLite会返回特定的错误码。\n\npager在想从数据库文件中第一次读取页面的时候，它会按照如下的恢复顺序来执行。\n\n1. 它先在数据库文件上获取一个共享锁。(如果无法获取到这个锁，它就会返回给应用SQLITE_BUSY错误码。)\n\n2. 检查数据库上是否有一个激活的日志文件。如果数据库没有激活的日志文件，那么恢复操作就到此为止了。如果存在一个激活的日志文件，那么日志文件就会按照如下的步骤来回滚。\n\n3. 在数据库文件上获取一个排它锁。(pager不会在数据库上获取保留锁，因为这样会让其他的pager认为日志文件已经不再是激活状态了，然后它们就会直接读数据库。最后它是需要在数据库上获取一个排他锁，因为写入数据库是恢复工作的一部分。) 如果获取锁失败，那么就意味着此时有另一个pager正在尝试回滚。在那种情况下，它会释放所有的锁并且返回SQLITE_BUSY错误码给应用层。\n\n4. 从日志回滚文件中读取所有的日志记录，并且撤销这些日志(回滚)。这个操作会将数据库恢复到发生崩溃的事务开始时候的状态。并且数据库此时就在一致的状态了。如果需要的话，数据库文件还会被缩减到事务开始之前的大小。\n\n5. flush刷新数据库文件。如果发生另一次电源故障或崩溃，这可以保护数据库的完整性。\n\n6. 释放(包括删除、无效化、或者裁剪)日志文件。\n\n7. 如果安全的话，删除主日志文件。\n\n8. 把锁降级到共享锁。(因为pager是在`sqlite3PagerGet`方法的内部执行的恢复。)\n\n在以上的算法策略成功的执行之后，数据库文件此时就已经保证恢复到之前的状态了。此时再读取文件的时候就是安全的了。\n\n**过时的主日志文件**:如果没有独立的回滚日志引用主日志文件，那么这个主日志文件就可以认为是过时的。pager会先读主日志文件，然后获取所有回滚日志文件的名字。然后，它分别检查每个回滚日记文件。如果每一个日志文件都存在，并且指向主日志文件，那么这个主日志文件就不是过时的。如果所有的回滚日志文件都不存在，或者他们指向了其他的主日志文件，或者没有指向主日志文件，那么这个主日志文件就是过时的，并且pager会删除掉这个主日志文件。没有要求说这个过时的主日志文件需要被删除。这样做的唯一原因就是为了释放磁盘空间。\n\n## 其他的管理问题\n### 检查点\n大部分数据库系统为了减小数据库失败的恢复压力，在固定的时间点都会有一个检查点。因为SQLite在同一个时间点同一个数据库上最多只会有一个写事务。日志文件中也只有当前事务的日志记录。SQLite会在事务完成的时候，处理掉日志文件。最终SQLite就不会有日志的积压，也不会需要去执行一个检查点，日志中也不会有检查点的逻辑。当事务提交的时候，数据库会保证在处理日志文件之前，将数据库的更新已经都写入数据库中了。(在SQLite3.7.0中，SQLite的开发者介绍了WAL日志特性。在这个日志模式下，会执行检查点。后续会讨论这个日志模式。)\n\n### 空间约束\n在某些DBMS中，最麻烦的问题是日志空间不足。换句话树，就是文件系统没有足够的空间来给日志文件继续扩大写入新的日志记录。在某些DBMS中，中止事务会生成（补偿）日志记录，同时撤消某些更新，从而使情况进一步恶化。日志空间的不足可能会在那些系统中产生事务中止和系统重启的问题。但是SQLite不会，因为事务的终止不会产生任何新的日志记录。系统重启尽管也会有问题，但是只会在一些极端的场景下:事务会收缩数据库文件，并且释放的空间已经由本机文件系统分配用于其他目的。在这个情况下，恢复可能失败，因为SQLite已经无法将数据库文件恢复到原始的大小了。此时数据库就会被阻塞，直到所需的空间可用于数据库文件恢复到原始大小为止。\n\n还有一个其他的相关的问题:数据库文件没有足够的空间可以增长了。在这个场景下，pager会返回SQLITE_FULL错误码给应用，这有可能会终止事务。所以这也有可能会在SQLite中导致问题。","slug":"2020-08-17_db-system-design-imp(Pager)","published":1,"updated":"2022-07-28T13:38:40.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwoc001ip9c99lbobm13","content":"<blockquote>\n<p>本文讨论的是SQLite的Pager模块。本模块在原生操作系统的基础上实现了一个抽象的基于页面的数据库文件系统。它按照固定大小的页面来管理数据，并且定义了一些接口从数据库文件中来操作这些页面。它提供了一个数据库页面的内存缓存，来帮助BTree模块加速操作数据库页面。它不仅仅是一个缓存的管理中心，同样也是实现ACID的事务管理中，以及事务回滚管理。并发控制和回滚机制对于上层模块来说是完全透明的。他可以理解为一个传统数据库管理系统的持久化层。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"Pager模块\"><a href=\"#Pager模块\" class=\"headerlink\" title=\"Pager模块\"></a>Pager模块</h1><p>除了内存数据库以外，数据库都是以原生文件的形式落在磁盘上的。SQLite无法高效的直接读取和操作磁盘上的文件。当需要数据项的时候，它会从数据库文件中读取数据到主内存中，然后在内存中操作数据，在有必要的时候，还会回写到磁盘文件中去。相对于紧凑的主内存来说，一般情况下数据库文件都会很大。因为内存有限，所以一般内存中只会保留一小部分来存储的数据，而这部分内存通常就被叫做数据库缓存或者数据缓存;在SQLite的术语中，它被称为page cache。而这个缓存是在应用进程的地址空间内，而不是操作系统的地址空间。(操作系统有它自己的数据缓存。)</p>\n<p>page缓存管理器在SQLite的世界里就是Pager。它面对的是可随机访问的原生字节流的文件，并且需要将他们转换为可以随机访问的高级别的分页式的文件，而这个页面的大小是固定的。不同的数据库文件可以有不同的页面大小。区别于原生操作系统，Pager提供了一个简单可用的接口来访问数据库文件的页面。Tree模块将会使用Pager提供的接口来操作，而不会直接操作原生的数据库或者日志文件。Tree模块看到的数据库逻辑上是一个页面的数组，并且通过他们数组的下标索引来获取页面。</p>\n<p>SQLite对于每一个打开的数据库文件(或者说数据库连接)，都会有一个单独的页面缓存。当一个应用进程打开一个数据库文件的时候，Pager就会为它创建和初始化一个新的页面缓存。如果进程多次打开同一个数据库文件的时候，在默认模式下，Pager会单独为这个文件创建和初始化页面缓存多次。(SQLite提供一个高级特性，那就是所有打开同一个数据库文件的数据库连接可以共享一个页面缓存。)在使用内存数据库的时候，不会访问任何外部存储设备。但是它们也会被当做原生的数据库文件来处理，并且会被整个存储到缓存中。因此Tree模块可以使用相同的接口来操作这两类数据库。</p>\n<p>在SQLite中Pager属于最底层的模块。这是唯一的一个通过直接调用操作系统提供的I&#x2F;O API来访问原生文件的模块。它会直接读写数据库文件或者日志文件。它不会理解数据库是如何组织数据结构的。它也不会去干涉数据库的内容，或者自己去修改内容。它只需要保证存在数据库文件中的数据可以被重复地无任何修改地检索。从这个角度上来说，Pager是一个被动的模块。(它有可能会修改一些数据库文件头部记录中的信息，例如文件修改计数器file change counter。)</p>\n<p>对于每一个数据文件来说，Pager在文件和内存缓存之间转移页面内容是作为一个缓存管理器的基本功能。而这个转移对于Tree模块和一些高层模块来说是透明的。Pager就是原生系统文件和高层之间的一个媒介。它还要协调页面回写到数据库文件中去。</p>\n<p>除了缓存管理的工作之外，pager也承担了一个典型的DBMS的其他功能。它提供一个典型的事务处理系统的核心服务:事务管理，数据管理，日志管理，和锁管理。作为一个事务管理者，它通过接管并发控制和数据恢复，来实现了事务的ACID属性。它也负责原子性提交和事务的回滚。作为一个数据管理者，它通过缓存和一些文件空间管理来协调数据库文件页面的读写。作为日志管理者，它决定了在日志文件中的日志写入。作为一个锁管理者，它可以确保在操作数据库页面之前，在数据库文件上已经有了一个合理的锁。</p>\n<h1 id=\"Pager接口\"><a href=\"#Pager接口\" class=\"headerlink\" title=\"Pager接口\"></a>Pager接口</h1><p>在这一小节中，我将会给出一些Pager模块导出的接口，这些接口将会给Tree模块使用。在此之前，我们先讨论一下Pager和Tree模块之间的交互协议。</p>\n<h2 id=\"Pager-client调用交互协议\"><a href=\"#Pager-client调用交互协议\" class=\"headerlink\" title=\"Pager-client调用交互协议\"></a>Pager-client调用交互协议</h2><p>在Pager之上的模块是完全隔离了低级别的锁和日志管理机制。事实上，它们并不知道锁和日志的存在的。Tree模块把所有的事情都看做一个事务，并且它不关心事务的ACID是如何实现的。而Pager模块则把一个事务的所有活动拆分为锁、日志、以及读写数据库文件。Tree模块以页面号来向Pager中请求一个页面数据。反过来，Pager会返回一个已经加载到页面缓存中的页面数据的指针地址。在修改一个页面之前，Tree模块需要先通知Pager模块。这样Pager模块可以在日志文件中存放足够的信息来防止之后要做数据恢复，以及提前在数据库文件上加上合适的锁。在它使用完页面之后，还要通知Pager，这样如果页面数据发生改变的时候，Pager还会将数据回写到数据库文件中。</p>\n<h3 id=\"Pager接口结构\"><a href=\"#Pager接口结构\" class=\"headerlink\" title=\"Pager接口结构\"></a>Pager接口结构</h3><p>Pager模块实现了一个数据结构叫<code>Pager</code>。每一个数据库文件都是通过单独的<code>Pager</code>对象来管理的，并且每一个<code>Pager</code>也只会关联到有且仅有一个数据库文件上。(在Pager模块层中，这个对象就等同于数据库文件。)在Tree模块中，如果需要使用一个数据库文件，那么需要先创建一个Pager对象，然后在这个对象上使用一些页面操作函数。Pager模块可以使用这个对象来追溯关于文件的锁，日志文件，和数据库的状态，日志文件的状态等等。一个进程在同一个数据库文件上可以有多个<code>Pager</code>对象与之对应，每一个对象都隶属于一个数据库连接。这些对象都是被独立处理的，互不相关。(对于共享缓存的模式来说，对每一个数据库文件，只有一个<code>Pager</code>对象，所有数据库文件共享这个对象。)内存数据库也是使用这个对象作为操作句柄。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/lLkn3u.png\"></p>\n<p>后面会给出一个<code>Pager</code>对象的一些成员变量。在这个对象的后面会紧跟着一片内存空间，这个空间会用来存储页面缓存、数据库文件句柄、日志文件句柄、和数据库文件名、日志文件名。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/hWBtgL.png\"></p>\n<p>正如之前提到的，SQlite在一个用户事务中，执行每一个更新(insert,delete,update)操作的时候都会放在一个savepoint保存点内。同样的，应用也可以设置自己的保存点。可以同时存在多个保存点，存储在aSavepoint数组内。这个保存点的数据结构后面也有。当SQLite创建了一个保存点savepoint的时候，它就会把<code>iHdrOffset</code>这个变量置0。但是如果在某个savepoint已经激活的时候，它打开了回滚日志文件并且在文件中写入了一条记录头，那么它就会把<code>iHdrOffset</code>改为在写入回滚日志之前的最后一条记录的字节偏移。当<code>PagerSavepoint</code>对象创建的时候,<code>iOffset</code>会被设置为回滚日志的起始偏移。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/1ijSOI.png\"></p>\n<h3 id=\"Pager接口函数\"><a href=\"#Pager接口函数\" class=\"headerlink\" title=\"Pager接口函数\"></a>Pager接口函数</h3><p>Pager模块实现了一系列给Tree模块使用的接口方法。为了便于后面的理解，下面先列举一些重要的接口方法，这些接口方法都是以<code>sqlite3Pager</code>开头，所有的方法都仅限SQLite内部使用。</p>\n<ol>\n<li><p>sqlite3PagerOpen:方法创建一个新的<code>Pager</code>对象，打开给定的数据库文件，创建和初始化一个空的页面缓存，并且把这个缓存的指针返还给<code>Pager</code>对象。它会根据给定的数据库名，创建&#x2F;打开一个合适的文件。数据库文件在此时并不会上锁，既没有创建日志文件，也没有执行数据库恢复操作。(数据库的恢复是会被延迟到首次从数据库中读取一个页面的时候)</p>\n</li>\n<li><p>sqlite3PagerClose:方法销毁一个<code>Pager</code>对象，并且关闭关联的已经打开的数据库文件。如果它是一个临时文件，pager还会删除掉和这个文件。如果它不是一个临时文件并且在这个方法被调用的时候，这个文件还有一个事务存在，那么这个事务就会被强制终止，并且把它的变更全部回滚。所有内存中的缓存都会失效，从用户进程地址空间内释放。在这个方法调用之后再去访问缓存都会导致崩溃。换句话说，所有的资源都被释放了。</p>\n</li>\n<li><p>sqlite3PagerGet:这个方法会给调用者从数据库文件中复制到内存中一份可用的数据页面。调用者指定了请求页面的页面号。方法返回一个拷贝到内存缓存中的页面地址。因此，缓存空间不被回收的话，它就会固定下这个拷贝的页面。在调用这个方法最开始它就会在数据库上获取一个共享锁。此时它会决定是否需要清理现有的页面缓存–如果数据库的文件变更计数器(在文件头部第24字节开始的4个字节整型)和当前缓存中的之前获取到的这个值不一样，它就会开始清理缓存。另外如果有必要的话(存在一个回滚日志文件)，数据库就会从日志文件中回滚(后面的章节会讨论日志的回滚)。如果请求的页面不在缓存中，pager就会加载请求的页面到缓存中。但是，如果目前的数据库文件小于请求的页面号，那么实际也不会触发文件读，但是内存中会依旧分配一个页面，并且全部初始化为0.(当然对于内存数据库来说，不会触发任何的文件操作。)</p>\n</li>\n<li><p>sqlite3PagerWrite:这个方法可以将请求的数据库页面对调用者是可写的。(注意这里是可写不是写入数据。)这个方法必须在Tree模块修改缓存数据之前调用，否则的话Pager并不知道某一个缓存的页面被修改了。(处于性能考虑，SQLite避免了从Tree模块到Pager模块互相拷贝数据，而是让Tree模块直接修改Pager缓存的数据。)Pager还会在数据库文件上获取一个保留锁，并且创建一个回滚日志文件。也就是说它创建了一个隐式的写事务。如果当前页面还不在日志文件中，那么它就会拷贝这个页面中的原始数据到回滚日志中去。如果这个原始的页面已经在日志文件中了，那么SQLite只会标记这个页面为写脏。如果当前的事务是在一个用户事务中，并且当前页面也已经在主回滚日志中了，那么这个方法也还会在状态日志中写入一条状态记录。</p>\n</li>\n<li><p>sqlite3PagerLookup:这个方法返回在已经请求在内存缓存中的页面。如果不在，则返回NULL。对前者来说，它会固定这个页面。</p>\n</li>\n<li><p>sqlite3PagerRef:方法给指定页面的引用计数+1。我们称这个页面被调用者固定了。如果页面在缓存的已释放链表中，这个方法会从这个已释放列表中移除该页面。</p>\n</li>\n<li><p>sqlite3PagerUnref:方法给指定页面的引用计数-1。当这个页面的引用计数降低到0的时候，我们称这个页面已经被解除固定，并且被释放了。(被释放的页面依旧存在内存中，它会存储在已释放的链表内。）当所有的页面都被解除固定了的时候，在数据库上的共享锁就会被释放，<code>Pager</code>对象就会被重置。</p>\n</li>\n<li><p>sqlite3PagerBegin:方法在相关联的数据库文件上开启一个显式的写事务。如果数据库不是一个临时数据库，它也会打开一个回滚日志文件。(对于临时数据库，回滚日志的打开会一直推迟到真正写入回滚日志的时候。)从前面可以知道隐式的写事务是由<code>sqlite3PagerWrite</code>开启的。因此，如果数据库已经保留用来准备写入了，那么这个方法就不会做任何操作。否则的话，它会首先在数据库文件上持有一个保留锁，并且如果在参数指明的情况下，它还会立刻在数据库文件上获取一个排它锁，而不是真正等到Tree模块尝试写入数据的时候。</p>\n</li>\n<li><p>sqlite3PagerCommitPhaseOne:方法在数据库文件上提交当前的事务:文件变更计数器+1，同步日志文件，把所有的变更(例如页面缓存中的脏页)同步到数据库文件中</p>\n</li>\n<li><p>sqlite3PagerCommitPhaseTwo:方法释放(包括删除、无效化、或者裁剪)日志文件。</p>\n</li>\n<li><p>sqlite3PagerRollback:方法在数据库文件上放弃当前的事务:回滚事务给数据库文件带来的所有变更，并且把数据库的锁降级到共享锁。所有的缓存页面转变为它们的原始数据内容。日志文件被释放。</p>\n</li>\n<li><p>sqlite3PagerOpenSavepoint:方法创建一个新的保存点句柄对象，为当前的数据库状态建立一个保存点。</p>\n</li>\n<li><p>sqlite3PagerSavepoint:方法释放或者回滚一个保存点。对于释放操作来说，它会释放和销毁指定的一个保存点句柄对象。对于回滚操作来说，它回滚数据库上在此保存点建立之后的所有变更，并且后面所有的保存点都会被删除。</p>\n</li>\n</ol>\n<h1 id=\"页面缓存\"><a href=\"#页面缓存\" class=\"headerlink\" title=\"页面缓存\"></a>页面缓存</h1><p>页面缓存存在于应用进程的地址空间内。（对于同一个页面来说，原生操作系统可能也会对它做一次缓存，当应用从某个文件中读取一段数据的时候，操作系统一般都会给自己拷贝一份，再给应用拷贝一份。我们不关心操作系统是如何管理它的缓存的。SQLite的缓存组织和管理独立于那些原生操作系统。）下图描述了一个典型的情况。在图中，两个进程(其中有一个是多线程的)在访问同一个数据库文件。他们有自己的缓存。甚至于同一个线程在默认操作模式下，多次打开了同一个数据库。SQLite为这些数据库连接分配了独立的缓存。通过它们自己不同的<code>Pager</code>对象来访问这些缓存。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/It7kz3.png\"></p>\n<h2 id=\"缓存状态\"><a href=\"#缓存状态\" class=\"headerlink\" title=\"缓存状态\"></a>缓存状态</h2><p>页面缓存的状态(在上图中<code>Pager</code>对象中有对应的变量)决定了Pager模块可以对缓存做什么。两个变量<code>eState</code>和<code>eLock</code>控制了Pager的行为。页面缓存的总是以下7种状态之一(<code>Pager.eState</code>成员变量的值)。下图是这7种状态值的转换图。</p>\n<ol>\n<li><p><strong>PAGER_OPEN</strong>:当一个<code>Pager</code>对象创建的时候，这是它的初始状态。此时pager无法通过<code>Pager</code>对象来读或者写数据库文件。当前内存中可能没有页面缓存，缓存是空的。数据库文件上应该也没有锁，在当前数据库上没有事务。</p>\n</li>\n<li><p><strong>PAGER_READER</strong>:在这个状态的时候，当前数据库连接上至少有一个读事务，pager可以读取对应数据库文件的页面。(但是，在排他锁的模式下，读事务可能并不会打开。)</p>\n</li>\n<li><p><strong>PAGER_WRITER_LOCKED</strong>:当一个<code>Pager</code>对象在这个状态的时候，当前数据库连接上已经打开了一个写事务。pager可以在对应的数据库文件上读页面数据，但是它还没有在数据库文件或者缓存页面中做任何的变更。</p>\n</li>\n<li><p><strong>PAGER_WRITER_CACHEMOD</strong>:当一个<code>Pager</code>对象在这个状态的时候，pager给与Tree模块权限来更新缓存的页面数据，并且Tree模块可能已经对它做出了一些变更。</p>\n</li>\n<li><p><strong>PAGER_WRITER_DBMOD</strong>:当一个<code>Pager</code>对象在这个状态的时候，pager可能已经开始写数据库文件了。</p>\n</li>\n<li><p><strong>PAGER_WRITER_FINISHED</strong>:当一个<code>Pager</code>对象在这个状态的时候，pager已经完成将当前写事务中发生的所有变更的页面写入到数据库文件了。写事务已经不能再做任何的变更了，此时已经在准备提交了。</p>\n</li>\n<li><p><strong>PAGER_ERROR</strong>:出错的状态，例如I&#x2F;O失败，磁盘空间不足，内存不足等等。</p>\n</li>\n</ol>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/yUn3tG.png\"></p>\n<p>根据<code>eLock</code>变量的值，一个<code>Pager</code>对象可以是如下4中状态之一。</p>\n<ol>\n<li><p><strong>NO_LOCK</strong>:当前不在读写任何事务。</p>\n</li>\n<li><p><strong>SHARED_LOCK</strong>:Pager已经从数据库文件中读了页面数据了。在同一个时间，同一个文件上可以有多个读事务，这些读事务可以各自通过他们的<code>Pager</code>对象来访问数据库文件。此时不允许修改缓存的页面。</p>\n</li>\n<li><p><strong>RESERVED_LOCK</strong>:pager已为写入数据保留了数据库文件，但是还没有做出任何的变更。在同一时间只有一个pager可以保留指定的数据库文件。因为原始的数据库文件还没有被修改，其它的Pager依旧可以读。</p>\n</li>\n<li><p><strong>EXCLUSIVE_LOCK</strong>:pager已经把缓存页面回写到数据库文件了。此时的文件访问是独占的。当这个pager在写入的时候，没有其他的pager可以读写这个文件。</p>\n</li>\n</ol>\n<p>页面缓存开始于NO_LOCK的状态。当Tree模块首次调用<code>sqlite3PagerGet</code>方法读取任何一个页面的时候，pager就会转换到SHARED_LOCK状态。当Tree模块通过执行<code>sqlite3PagerUnref</code>方法释放所有页面的时候，pager就会转换回NO_LOCK状态。(这个时候，它应该不会清理页面缓存。)当Tree模块首次调用<code>sqlite3PagerWrite</code>方法的时候，pager就会转换到RESERVED_LOCK状态。(<code>sqlite3PagerWrite</code>方法只有在pager已经就绪读的时候才可以被调用)。pager在真正写入第一个页面到数据库文件的时候，就会转换到EXCLUSIVE_LOCK状态。在<code>sqlite3PagerRollback</code>或者<code>sqlite3PagerCommitPhasTwo</code>两个方法的执行过程中，pager会转换回NO_LOCK状态。</p>\n<ul>\n<li>对于内存数据库或者临时数据库来说，<code>Pager.eLock</code>永远是EXCLUSICE_LOCK，因为它始终是独占的。</li>\n</ul>\n<h2 id=\"缓存的组织结构\"><a href=\"#缓存的组织结构\" class=\"headerlink\" title=\"缓存的组织结构\"></a>缓存的组织结构</h2><p>每一个页面缓存都是由一个<code>PCache</code>句柄对象来管理。pager持有了这个<code>PCache</code>对象的引用(可以看上面pager的结构图)。下图描述了一个<code>PCache</code>对象的一些成员变量。SQLite支持插件化的缓存结构，用户可以自己提供一个缓存结构。它提供了它自己的插件缓存模块(由pcache1.c源码实现)，后面会讨论这个缓存实现。这个也将会是默认的缓存管理，除非用户自己提供一个。<code>PCache</code>对象的最后一个成员就是pCache,持有了这个可插件化的缓存模块。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/EWLiFD.png\"></p>\n<p>通常情况下，为了加速查询一个缓存，当前持有的缓存项都会被较好的组织好。缓存空间会被分割为一个个存储槽来持有数据项。SQLite使用一个哈希表来组织已缓存的页面，并且使用页面槽来持有表中的页面。缓存是完全关联的，因此任何一个存储槽都可以存储任何页面。哈希表初始化为空。随着页面需求的增长，pager会创建新的存储槽，然后将它们插入到哈希表内。<code>PCache.nMax</code>值决定了一个缓存可以持有的最大存储槽的数量。主数据库和其他attach连接上的数据库默认值是2000，临时数据库是500。内存数据库没有这个限制，根据物理内存的大小，有多少用多少。</p>\n<p>SQLite使用一个<code>PgHdr</code>类型的对象来标识缓存中的每一个页面对象。尽管一个可插件化的缓存可以有它自己的页面头部对象，但是pager也依旧可以理解这个对象。下图描述了SQLite自己的可插件化的缓存，由<code>PCache1</code>对象表示。在哈希表中的每一个插槽都由一个类型为<code>PgHdr1</code>的头部对象表示。这个插件化的组件是可以理解这个类型的，pager对此也不透明。插槽数据就存储在<code>PgHdr1</code>对象的正前方；这个插槽的数据大小由<code>PCache1.szSize</code>变量决定。这个插槽数据持有了一个<code>PgHdr</code>对象，一个数据库页面数据，和一些私有数据，这些私有数据区域是Tree模块用来保存页面特有的内存中的控制信息。(内存数据库没有日志文件，所以它的回滚信息也记录在内存对象中。那些对象就跟随在这个私有数据区域之后:这些指针只会被pager所使用。)当pager将页面数据写入缓存的时候，这些额外的非页面数据空间会被初始化为0。缓存中的所有页面通过<code>PCache1.aphash</code>哈希数组来访问；数组大小存储在<code>PCache1.nHash</code>变量内；这个数组也会根据需要调整大小。每一个数组元素都指向一个槽桶(bucket)；桶内的所有槽都会被组织在一个无序的单向链表内。</p>\n<p><code>PgHdr</code>对象只对pager模块可见，对Tree以及更高的模块不可见。头部有很多控制变量。<code>pgno</code>代表了数据库页面的页号。<code>needSync</code>标记位表示在回写这个页面到数据库文件的时候，日志文件是否需要flush一下。<code>dirty</code>标记位表示页面是否已经被修改过了，并且新的数据还没有回写到数据库文件内。<code>nRef</code>变量是这个页面的引用计数。如果<code>nRef</code>大于0，那么这个分页就还在使用中，我们说这个页面是被固定了，否则这个页面就是非固定的，并是被释放的。<code>pDirtyNext</code>和<code>pDirtyPrev</code>指针用来将所有的脏页面链接到一起。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/zIdkXn.png\"></p>\n<p><strong>缓存组</strong>:SQLite有一个选项，可以将所有<code>PCache1</code>对象放在一个组中。当这些高速缓存受到内存压力的影响时，它们可以回收彼此未固定的页面槽。</p>\n<h2 id=\"缓存的读取\"><a href=\"#缓存的读取\" class=\"headerlink\" title=\"缓存的读取\"></a>缓存的读取</h2><p>缓存的使用者无法通过地址寻址方式来访问一个缓存元素。事实上，它们甚至不知道一个页面的拷贝存储在哪个位置，当然也就不知道它们的地址了。缓存的内容是可寻址的，可以通过页号来搜索到一个页面。在管理数据的时候，它会使用<code>PCache1.apHash</code>哈希数组来讲页面号转换为一个合适的缓存存储槽。一开始，页面缓存是空的，但是随着需求的增加，页面会被主键添加到缓存中去。正如之前所提到的，为了读一个分页，调用者(Tree模块)需要调用<code>sqlite3PagerGet</code>方法，并且给定页号。这个方法将会由以下几步来请求一个页面P。</p>\n<ol>\n<li><p>搜索缓存空间。</p>\n<ul>\n<li>在页号P上应用一个非常简单的哈希算法，来计算获取<code>apHash</code>的索引号:算法就是用分页号模<code>apHash</code>数组大小</li>\n<li>在<code>apHash</code>数组上使用这个索引获取到哈希桶。</li>\n<li>通过遍历<code>pNext</code>指针来搜索这个桶。如果P页面在这里找到了，那么我们就说这个缓存命中了，它会固定一个页面(也就是将页面<code>PgHdr.nRef</code>的值+1)。并且会给调用者返回页面的内存地址。</li>\n</ul>\n</li>\n<li><p>如果页面P在缓存中没有找到，那么就认为是缓存缺失。方法就会去寻找一个空闲的插槽来加载请求的页面。(如果缓存尚未达到最大限制<code>PCache.nMax</code>，它就会创建一个新的空间的插槽。)</p>\n</li>\n<li><p>如果目前找不到一个可以使用的空闲的插槽或者也不能创建新的，它会决定某个页面是否可以释放用来给P页面复用插槽。这个称为替换插槽。(后面的小节我们会讨论这个)</p>\n</li>\n<li><p>如果这个被替换的插槽或者空闲插槽已经被标记为脏页面了，那么它就会将这个页面回写到数据库文件中去。(遵循预写日志（WAL）协议，它也会刷新日志文件)</p>\n</li>\n<li><p>两种情况。(a)如果这个P页面是小于等于文件中当前的最大页面数的，它就会从数据库文件中向空闲的插槽中读取页面P，然后固定这个页面(设置<code>PgHdr.nRef</code>为1)，然后返回页面地址给调用者。(b)如果P比当前的最大页面数量还要大，它不再读取页面，而是把整个页面初始化为0。在两种情况中，它都会把页面底部的私有区域初始化为0，不论这个页面是否是从数据库文件中读的。也都会把(<code>PgHdr.nRef</code>设为1。)</p>\n</li>\n</ol>\n<p>SQLite严格按照按需加载请求页面的策略，使得页面拉取变得非常简单。(关于这个后续还会细说。)</p>\n<p>当在缓存中的页面地址返回给调用者(Tree模块)的时候，pager并不知道调用者什么时候会对页面内容进行操作。因此对于每一个页面，SQLite有如下的一个标准协议:调用者请求(固定)一个页面，使用页面，然后释放页面。已经固定的页面是正在活跃使用中的，缓存管理器不能回收这个页面。为了避免出现所有缓存页面都被固定的场景，SQLite在缓存中需要有一个最小数量的页面，这样它就始终可以有缓存插槽来回收了，在3.7.8版本的时候这个值是10。</p>\n<h2 id=\"缓存的更新\"><a href=\"#缓存的更新\" class=\"headerlink\" title=\"缓存的更新\"></a>缓存的更新</h2><p>在获取到一个页面之后，调用者可以直接修改这个页面的内容。但是正如之前所提到的，在做出修改之前，它必须调用<code>sqlite3PagerWrite</code>方法。在方法返回之后，调用者就可以随意更新页面内容了。</p>\n<p>在首次调用<code>sqlite3PagerWrite</code>方法的时候，pager会将原始的页面内容作为一个日志记录的一部分写到回滚日志文件中，并且设置<code>PgHdr.needSync</code>标记。在此之后，当日志记录刷新到磁盘的时候，pager就会清除这个标记位。(SQLite遵循SQL协议:它直到这个页面对应的<code>needSync</code>标记位清除的时候才会将一个已修改的页面写入到数据库文件中去。)每次调用<code>sqlite3PagerWrite</code>方法的时候<code>PgHdr.dirty</code>都会被置位；只有当这个页面的内容被回写到数据库文件的时候这个标记位才会被清除。因为调用者什么时候改页面内容，pager是不知道的。数据库文件也不能实时反映页面内容的更新。因此pager遵循延迟回写数据库文件的策略。仅当pager执行缓存刷新或有选择地回收脏页时，更新才会反映到数据库文件。</p>\n<p>延迟的数据库文件更新会导致事务的内存使用增长，当内存使用到达上限的时候，缓存管理器就会执行缓存替换。</p>\n<h2 id=\"缓存拉取策略\"><a href=\"#缓存拉取策略\" class=\"headerlink\" title=\"缓存拉取策略\"></a>缓存拉取策略</h2><p>缓存拉取策略决定了什么时候将一个页面加载进缓存。按需拉取的策略只会在请求页面的时候才会将页面加载进缓存。在调用者请求页面的时候，调用者此时是阻塞的，一直到页面从数据库文件中读取完成。很多缓存系统使用了很复杂的预拉取技术提前将页面写入缓存，这样可以减少阻塞的频率。SQLite从文件中一次读一个页面，严格按照按需加载的策略，保持逻辑简单。</p>\n<h2 id=\"缓存管理\"><a href=\"#缓存管理\" class=\"headerlink\" title=\"缓存管理\"></a>缓存管理</h2><p>通常情况下，一个页面缓存的大小是有限的。除非数据库非常小，否则它一般只能持有数据库一小部分的页面。在不同的时间点，缓存需要回收掉一些页面来持有不同的页面。因此，缓存的页面需要非常小心的管理来获取性能的最大化。基本想法就是，在缓存中保留那些立刻会被请求的页面。在设计一个缓存策略的时候，我们需要考虑三件事情:</p>\n<ol>\n<li><p>每当缓存中有一个页面的时候，在数据库文件中也有这个页面的一个主副本。每当这个缓存被更新的时候，这个主副本也需要被更新。</p>\n</li>\n<li><p>对于不在缓存中的请求页面，将引用主副本，并从主副本中创建新的缓存副本</p>\n</li>\n<li><p>如果缓存已经满了，并且一个新的页面需要被放入缓存，会有一个替换算法来决定从缓存中移除掉一些旧的页面来给新的页面腾出空间。</p>\n</li>\n</ol>\n<p>因为缓存空间大小有限，我们需要回收一些缓存控件来适应将一个大的页面集合映射到一个小型的缓存插槽内(见下图)。在图里，26个主页面需要通过回收插槽的方式来映射到5个缓存插槽内。缓存管理在缓存性能和整体性能上都非常关键。在还有剩余空间的时候，对于缓存来说没什么难的。它的挑战就在于缓存已满的时候。它的职责就是哪些页面可以保留，哪些页面可以被替换出去。我们需要一个高命中率的缓存。因此对于缓存替换来说，最关键的地方就是决定那个页面可以保留。接下来我们就讨论缓存替换</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/UK0ZuX.png\"></p>\n<h3 id=\"缓存替换\"><a href=\"#缓存替换\" class=\"headerlink\" title=\"缓存替换\"></a>缓存替换</h3><p>缓存替换发生在缓存已经满的时候，旧的页面需要被移出去来给新的页面腾出空间。在前面提到，在页面都满了的时候，当一个请求的页面不在缓存中并且也没有可用的空闲的插槽的时候，其中的一个页面需要牺牲以被替换掉。而这个页面的选择不是一个简单的决定。之前也说过，页面的缓存是完全关联的，任何一个插槽都可以给这个新页面。由于考虑使用多个插槽进行替换，因此所选的插槽由缓存替换策略决定。替换策略的主要目标是将那些页面保留在缓存中，以便可以在不引用主副本页的情况下从缓存中满足大部​​分请求。因此缓存命中率需要非常高。如果命中率很低，那么这个缓存也不值得用来加速页面访问了。</p>\n<p>我们并不知道未来可能引用哪些页面。所以，缓存管理器通过一些启发式的或者优先的访问历史来决定替换页面。因此，通常在实践中使用的替换方案有时会在选择被替换页面时造成“错误”，当调用者立即召回被替换页面时，这种替换很快就会被撤销。如果一个页面P在被替换出去之后，又立刻被引用了，或者在再次被引用期间，其他页面一个都没有被引用，那么这个决定是比较差的。替换策略的目标是最大程度地减少错误，并最大程度地提高缓存未命中之间的时间间隔。缓存之间的主要差别就在于替换策略。在硬件和软件开发中，先进先出，最近最少使用，最少使用，时钟策略已广泛遵循高速缓存替换策略。SQLite则使用一种最近最少使用替换策略(LRU)。</p>\n<h3 id=\"LRU缓存替换\"><a href=\"#LRU缓存替换\" class=\"headerlink\" title=\"LRU缓存替换\"></a>LRU缓存替换</h3><p>LRU是一个非常流行的替换策略。它及其变体已在软件和硬件缓存开发的许多领域中成功实现。它利用对页面引用的时间局部性。(时间局部性是指在短时间内很有可能重复访问同一页面。)也就是说，一个页面在现在被访问了，那么它很有可能将会被再次访问。一个页面很长时间没有被访问了，那么它很有可能近期不会被再次访问。选择的被替换者，就是最长时间没有被访问的那一个。</p>\n<h3 id=\"SQLite的缓存替换\"><a href=\"#SQLite的缓存替换\" class=\"headerlink\" title=\"SQLite的缓存替换\"></a>SQLite的缓存替换</h3><p>SQLite把一些不活跃的页面放在一个逻辑队列中。当一个页面被取消固定的时候，pager就会将这个页面放在队列的尾部。(队列末尾的页面始终是最近访问的页面，而队列头部的页面则是最早访问过的页面。)被替换的那个页面一般都会选择队列头部的，但不一定像纯LRU方案那样总是队列的头元素。SQLite尝试从队列的开头开始找到一个插槽，以便回收该插槽不会涉及刷新日志文件。因为回收一个页面如果导致文件刷新的话，那么会减慢速度。如果能找到这么一个替换页面，那最前面的那个就会被回收。否则，SQLite就会刷新日志文件，然后回收头部的那个插槽。如果这个页面是脏页面，还会会写到数据库中。</p>\n<h1 id=\"事务管理\"><a href=\"#事务管理\" class=\"headerlink\" title=\"事务管理\"></a>事务管理</h1><p>在SQLite中Pager也是一个事务管理器，它会通过管理数据库文件上的锁，以及管理日志文件中的日志记录来确保事务的ACID。尽管SQLite锁管理器负责获取并释放文件上的锁，但pager会决定锁的模式以及获取和释放锁的时间点。它会严格遵循以下两个锁阶段，来创建一个事务的线性执行。它也决定了日志记录的内容以及何时写入日志文件。</p>\n<p>和DBMS一样，SQLite的事务管理有两个组件:1.正常处理和 2.恢复处理。在正常处理过程中，pager会在日志文件中保存一些回滚需要的信息，然后在发起回滚的时候，使用这些数据来确保回滚。下面两个小节将会讲述这两个组件。事务管理的一些细节会有单独的文章，而这里我将会从整体的角度上来看。</p>\n<h2 id=\"正常处理流程\"><a href=\"#正常处理流程\" class=\"headerlink\" title=\"正常处理流程\"></a>正常处理流程</h2><p>正常的处理流程包含了从数据库文件读页面和写页面到数据库文件，提交事务，结算子事务，设置和释放保存点。另外，pager回收插槽的选择和刷新页面缓存也是正常处理流程中的一部分。</p>\n<h3 id=\"读操作\"><a href=\"#读操作\" class=\"headerlink\" title=\"读操作\"></a>读操作</h3><p>为了在一个数据库页面上操作，调用者(Tree模块)需要调用<code>sqlite3PagerGet</code>方法。即使页面不在数据库内，也需要调用这个方法:因为新的页面会由pager创建。方法会在数据库文件上获取一个共享锁。如果获取共享锁失败，那么说明此时数据库上已经有一个与之冲突的锁，方法会返回SQLITE_BUSY给调用者。否则，它就执行缓存读，然后将页面的指针地址返回给调用者。前面提到，这个操作会固定住一个页面。</p>\n<p>从前文的图中可以看到，每一个内存页面中，后面跟了一块私有空间。这个额外的空间在从数据库文件加载或者全新创建的时候都会被初始化为0。这个空间之后会由Tree模块来再次初始化。</p>\n<p>pager首次从数据文件获取一个共享锁的时候，它可以决定文件是否需要恢复。他会寻找一个日志文件(后面会讨论文件的恢复和失败恢复)。如果这个日志文件确实存在，那么说明在之前的事务执行过程中出现了一次失败，并且pager在调用<code>sqlite3PagerGet</code>返回之前，会回滚那次失败的事务，并且释放这个日志文件。</p>\n<p>如上所述，一个已经请求过的页面可能并不会在页面缓存中。在那个情况下，pager找到一个空闲的缓存插槽并且从数据库文件中加载页面，整个过程对用户是透明的。获取一个空闲的缓存插销也可能会导致一次数据库文件的写入，即缓存的刷新。</p>\n<h3 id=\"写操作\"><a href=\"#写操作\" class=\"headerlink\" title=\"写操作\"></a>写操作</h3><p>在修改一个页面之前，调用者(Tree模块)必须先固定住这个页面(通过调用<code>sqlite3PagerGet</code>方法)。然后在通过<code>sqlite3PagerWrite</code>方法，让对应的页面变得可写。一旦变成可写状态，调用者就可以随意更改内容，且不用通知pager。写入一个页面并不会导致缓存的刷新。尽管pager可能需要在数据库上请求一个保留锁。首次调用<code>sqlite3PagerWrite</code>方法的时候，pager就会在数据库文件上获取一个保留锁。这个保留锁的意思就是即将要写入数据库了。同时只能有一个事务可以持有一个保留锁。如果pager无法获取这个锁，那就意味着在文件上有其他的事务获取了同级或者更高级的锁。在这个情况下，pager就会返回SQLITE_BUSY给调用者。</p>\n<p>pager首次请求保留锁的时候，我们称之为读事务升级为写事务。(对用户事务或者系统事务来说都一样。)在这个时间点，pager创建并打开一个回滚日志文件。(回滚日志文件也在与数据库的同级目录下，只不过后面会增加’-journal’。)它会初始化第一个分片的记录头(具体可以看日志相关的)，记录下数据库文件的原始大小，然后把记录写入日志文件。如果数据库文件大小因为事务而扩大了，那么只需要按照这个原始大小裁剪就可以了，因为新的页面都是往数据库后面添加的。</p>\n<p>为了让一个页面可写，pager会把这个页面的原始内容写到回滚日志文件中。新创建的分页不会记录log，因为它本身就没有旧的数据。一个页面最多写入一次回滚日志文件。对数据库的变更不会立刻写入数据库文件。这些变更会先在内存中持有。数据库文件中依旧是未改变的，也就意味着，其他事务还能继续从文件中读。</p>\n<p><strong>扇区记录</strong>:如果存储设备中的扇区可以存储超过一个数据库页面，SQLite会log整个扇区，而不是仅仅只有被改变的页面。</p>\n<p><strong>页面log策略</strong>:一旦当有一个页面额镜像数据被拷贝到回滚日志中，尽管当前的事务再去多次调用<code>sqlite3PagerWrite</code>方法，页面也不会出现在后续新的日志记录中了。这个日志记录方式有一个好处就是，一个页面可以无脑的从日志文件的数据区中恢复出来。因此撤销操作是幂等的，并且它不会产生任何补偿日志记录。</p>\n<h3 id=\"缓存刷新\"><a href=\"#缓存刷新\" class=\"headerlink\" title=\"缓存刷新\"></a>缓存刷新</h3><p>缓存刷新是pager模块的一个内部操作，调用者(Tree模块)不能直接调用缓存刷新。有两种场景pager想要把缓存刷新到内存之外(即磁盘上):1.缓存已经满了，并且需要做一次缓存替换。2.事务依旧准备好去提交它的变更了。pager会将一些或者所有已经变更的页面写入到数据库文件中去。在写入之前，pager必须保证没有其他事务正在读数据库事务了。SQLite遵循WAL协议写入数据库。也就意味着，在写入到数据库文件之前还需要刷新写入日志回滚的记录。pager遵循下面的步骤:</p>\n<ol>\n<li><p>它先判断决定是否有必要刷新日志文件。如果事务是同步的，并且已经把新数据写入到日志文件了，并且数据库文件不是一个临时文件(因为对于临时数据库我们不需要考虑断电恢复)，那么pager就需要做一次日志文件的flush刷新。在这个场景下，只需要在日志文件上执行<code>fsync</code>系统调用来确保所有的日志文件的写入已经落到磁盘上了。此时，pager没有将在日志片段头部中日志记录的数量(<code>nRec</code>)的值写入到文件中。(<code>nRec</code>值是回滚操作的关键资源。当这个片段头部构建的时候，这个值会被同步事务设置为0，被异步事务设置为-1。)在日志文件被刷新到磁盘上之后，pager就会将<code>nRec</code>值写入，然后再做一次<code>fsync</code>。因为磁盘的写入不是原子的，它不会再重写<code>nRec</code>字段。pager会为新的日志记录创建一个新的日志片段。在这些情况下，SQLite使用多段日志文件。</p>\n</li>\n<li><p>它会尝试在数据库文件上获取一个排它锁。(pager不会无条件的等待锁。他会尝试在非阻塞条件下尝试获取锁。如果其他事务还在持有共享锁，那么这个锁就会失败，然后返回SQLITE_BUSY，事务不会被终止。)</p>\n</li>\n<li><p>将所有已经修改的页面(在页面缓存中持有的)或者选中的一些回写到数据库文件中。页面写入就地完成。他它会清空缓存中这些页面的脏标记位。(此时不会立刻刷新数据库文件到磁盘。)</p>\n</li>\n</ol>\n<p>如果写入数据库文件的原因是因为缓存满了，那么pager还不会立刻提交事务。相反的，此时事务可能会继续对数据库页面做一些修改。后续的数据库写入依旧是重复这三个步骤。</p>\n<p><strong>注意</strong>:排他锁会一直持有直至数据库的事务最终完成。这也就意味着说，从第一次页面写入到数据库一直到事务提交或者终止，进程内的其他数据库连接或者其他进程内的数据库连接都无法对当前数据库发起读写事务。对于一些较短的写事务来说，数据更新都会在缓存中持有，以及排它锁只会在事务最终提交的时候才会请求。但是一个较长的写事务会导致其他读事务的性能下降。</p>\n<h3 id=\"提交操作\"><a href=\"#提交操作\" class=\"headerlink\" title=\"提交操作\"></a>提交操作</h3><p>根据提交事务是修改单个数据库还是多个数据库，SQLite遵循的提交协议略有不同。</p>\n<p><strong>单个数据库场景</strong>:当Tree模块准备提交一个事务额时候，它会先调用<code>sqlite3PagerCommitPhaseOne</code>，然后调用<code>sqlite3PagerCommitPhaseTwo</code>。提交读事务简单。pager从数据库文件上释放共享锁，然后返回到NO_LOCK状态。他它也不需要去清理页面缓存。(下一个事务开始的时候，页面缓存已经有一个”预热”了。)为了提交一个写事务，pager按照如下的步骤有序执行:</p>\n<ol>\n<li><p>在数据库文件上获取一个排他锁。(如果锁获取失败了，就会给<code>sqlite3PagerCommitPhaseOne</code>方法的调用者返回SQLITE_BUSY。它此时不能提交事务，因为此时还有其他读事务。)然后它会将数据库的metadata的文件变更计数器上+1。将缓存中所有已经发生变更的数据回写到数据库文件内。(按照上面<strong>缓存刷新</strong>小节中的1-3步骤)</p>\n</li>\n<li><p>很多操作系统例如Linux，会将这些文件写入缓存到系统内存空间中，并且不会立刻将数据回写到本地磁盘。为了避免这个场景，pager会调用<code>fsync</code>系统调用来刷新到磁盘上。这样做是为了消除系统重新启动时的重做逻辑。</p>\n</li>\n<li><p>然后，它完成（即删除，截断或使之无效）日志文件。</p>\n</li>\n<li><p>最终它会释放数据库文件上的排它锁。如果同时执行选择操作（即读取事务），它将返回SHARED_LOCK状态；否则，返回NO_LOCK状态。它也没必要去清除页面缓存。</p>\n</li>\n</ol>\n<p>单个数据库的提交点是在于他完成日志文件的时候。</p>\n<p><strong>多个数据库场景</strong>:这个提交协议涉及的更多，它类似于分布式数据库系统中的事务提交。VM模块（<code>VdbeCommit</code>函数）实际上驱动提交协议作为提交协调器。每个数据库的pager执行自己“本地”的提交操作。如果一个读事务或者写事务，只修改了单个数据库(临时数据库不算)，那么这个协议就和普通提交一样。如果修改了多个，那么就按照下面步骤执行:</p>\n<ol>\n<li><p>释放事务没有更新的那些数据库上的共享锁。(如果当前线程内的其他读事务也不再激活了。)</p>\n</li>\n<li><p>在那些发生更新的数据库文件上请求排它锁。增加数据库文件的 文件变更计数器。</p>\n</li>\n<li><p>创建一个新的主日志文件。(这个主日志文件和主数据库同级目录，同名，但是后续跟着’-mj’,以及8个十六进制的随机数。即使主数据库文件没有发生数据变更，也是如此。)在主日志文件中填充所有各个独立的回滚日志文件的名字，然后将主日志文件和日志文件目录flush到磁盘上。(临时数据库文件不包含在内。)</p>\n</li>\n<li><p>将主日志文件的名字写到各个独立的回滚日志中的主日志记录中。并且flush回滚日志到磁盘。(pager可能一直到提交事务的时候它才会知道它只是多数据库事务的一部分。)</p>\n</li>\n<li><p>flush各自的数据库文件。</p>\n</li>\n<li><p>删除主日志文件，并且flush日志文件目录。</p>\n</li>\n<li><p>完成（即删除，截断或使之无效）各自的日志文件</p>\n</li>\n<li><p>释放所有数据库文件上的排它锁。所有pager会返回到SHARED_LOCK或者NO_LOCK状态。pager无需清除页面缓存。</p>\n</li>\n</ol>\n<p>多数据库的提交点是在于他删除了主日志文件。</p>\n<p><strong>关于完成日志文件</strong>:当journal_mode持久存在时，日志文件将被截断为零大小，而不是使日志头无效。</p>\n<p><strong>注意</strong>:如果主数据库是个临时数据库或者内存数据库，SQLite是不保证多数据库事务的提交的原子性的。也就是说，全局恢复可能会有问题。它不会创建主日志文件。VM会依次挨个在每个数据库上做单独的提交。因此这个事务对于每一个数据库来说是原子的，但是期间一旦出现掉电之类的问题，可能会导致一部分数据库会执行恢复，而另一部分不会。</p>\n<p><strong>提交失败</strong>:用户事务是应用通过执行COMMIT命令自己提交的，然后SQLite尝试结束这个事务。正如之前提到的，尝试提交的事务可能会因为锁的冲突导致失败，并且返回SQLITE_BUSY。因为此时数据库上可能还有其他的读事务，如果是因为这个导致的失败，事务依旧保持激活状态，应用可以在之后再次发起尝试。SQLite不会自动做重试，需要应用自己去做。</p>\n<h3 id=\"语句级操作\"><a href=\"#语句级操作\" class=\"headerlink\" title=\"语句级操作\"></a>语句级操作</h3><p>语句级子事务被实现为在子事务结束时释放的匿名保存点。在语句子事务级别的一般操作有读，写和提交。下面我们将讨论这些。</p>\n<p><strong>读操作</strong>:语句子事务通过包含的用户事务读取页面。用户事务遵循所有规则。</p>\n<p><strong>写操作</strong>:在写事务中有两个部分:锁和日志。一个语句级的子事务通过包含的用户事务来请求锁。但是语句级的日志有一点点的不同，并且是由单独的临时语句级日志文件处理。(语句级的日志文件名是任意命名的，以<code>etilqs_</code>开头，临时文件。）pager会在语句级日志文件中写入一部分日志记录，还会在主回滚日志中写入一部分。当子事务尝试通过<code>sqlite3PagerWrite</code>操作使页面可写时，它将执行以下两个替代操作之一：</p>\n<ol>\n<li><p>如果页面不在回滚日志中，pager就会将新的日志记录添加进回滚日志中。(但是后续新的页面就不会加入log了。)</p>\n</li>\n<li><p>如果页面不在这个语句级的日志文件中，那么pager会把新的日志记录加入其中。(当语句级子事务在文件中写入第一条log记录的时候，pager就会创建语句级的日志文件。)</p>\n</li>\n</ol>\n<p>pager从来都不会flush语句级日志，因为这个从来都不需要失败恢复。如果出现了一个系统失败或掉电，主回滚日志将会负责数据库恢复。可以注意到，当一个页面即是回滚日志文件，又是语句级日志文件的时候，回滚日志文件中持有最旧版本的页面数据。</p>\n<p><strong>提交操作</strong>:语句提交非常简单，pager删除语句日志文件。(但是，看以下两个小节。)</p>\n<h3 id=\"设置保存点\"><a href=\"#设置保存点\" class=\"headerlink\" title=\"设置保存点\"></a>设置保存点</h3><p>当一个用户事务建立一个保存点的时候，SQLite就会进入保存点模式。在这个模式下，SQLite在语句提交的时候，不会删除语句级的日志。它会持有日志文件，直至事务释放了所有的保存点，或者提交事务，或者终止事务。在保存点模式下，日志记录有一点点区别:如果页面已经被前一个语句加入日志文件，那么这个页面将会被当前语句再次加入日志文件中。因此，语句级的日志对同一个数据库分页可以有多条记录。</p>\n<h3 id=\"释放保存点\"><a href=\"#释放保存点\" class=\"headerlink\" title=\"释放保存点\"></a>释放保存点</h3><p>当应用执行<code>release sp</code>命令的时候，SQLite会销毁对应的<code>PagerSavepoint</code>对象，以及那些在<code>sp</code>保存点之后建立的保存点。应用也无法再次引用那些保存点。</p>\n<h2 id=\"恢复处理流程\"><a href=\"#恢复处理流程\" class=\"headerlink\" title=\"恢复处理流程\"></a>恢复处理流程</h2><p>大部分的事务和语句子事务都是自己提交。但是偶尔情况下，一些事务和语句会自己终止。在很少的情况下，会出现一些应用和系统失败。无论哪种情况，SQLite都可能需要通过执行一些回滚操作将数据库恢复到可接受的一致状态。在前两种情况下(终止语句和事务)，恢复时会提供内存中的可靠信息。在后两种情况下(失败),数据库可能会出错，并且没有内存信息。在事务过程中，事务将还原到先前的保存点。在后面的小节内，将讨论这4个场景。</p>\n<h3 id=\"事务终止\"><a href=\"#事务终止\" class=\"headerlink\" title=\"事务终止\"></a>事务终止</h3><p>在SQLite里，从终止中恢复是很简单的。pager可能会，也可能不会从数据库文件中移除事务所带来的的影响。如果事务只持有了数据库文件上的保留锁或未决锁，那么它可以保证文件不被修改；pager完成释放日志文件，并且丢弃在页面缓存中所有的脏页面。否则，事务将会在数据库文件上持有一个排他锁，并且一些页面可能已经被事务回写到数据库文件了，pager就会执行下面的回滚操作。</p>\n<p>pager从回滚日志中一条一条读取日志记录，然后从日志记录中恢复页面数据。因此，在扫描日志文件的最后，数据库已经恢复到事务开始时的最初始状态了。如果事务已经将数据库扩展了，那么pager还会将数据库文件裁剪到原始的大小。pager会先flush数据库文件，然后接下来会完成释放回滚日志文件。它会释放排他锁，并且清空页面缓存。</p>\n<h3 id=\"语句级子事务终止\"><a href=\"#语句级子事务终止\" class=\"headerlink\" title=\"语句级子事务终止\"></a>语句级子事务终止</h3><p>正如之前所提到的，一个语句级的子事务可能同时会在回滚日志和语句级日志中添加日志记录。SQLite需要从语句级日志，以及一些主回滚日志中回滚所有的日志记录。每一个语句都会被当做一个匿名的保存点。所以一个语句的终止，就等同于恢复一个匿名保存点。我们在下面的章节中讨论这个。</p>\n<h3 id=\"回滚到保存点\"><a href=\"#回滚到保存点\" class=\"headerlink\" title=\"回滚到保存点\"></a>回滚到保存点</h3><p>在之前提到，当在保存点模式的时候，事务是不会删除语句级日志的。当事务执行了一个<code>roll to sp</code>命令的时候，SQLite同样会回滚在<code>sp</code>保存点之后建立的所有保存点。<code>PagerSavepoint</code>对象对应的三个成员变量起着至关重要的作用：<code>iOffset</code>，<code>iHdrOffset</code>和<code>iSubRec</code>。它首先回滚主回滚日志中的所有日志记录，从iOffset处开始直到日志文件结束。然后，它将回滚从<code>iSubRec</code>开始的语句日志中的所有日志记录，直到文件末尾来还原保存点。然而，在前一个情况下，如果<code>iHdrOffset</code>是非零，那么从主回滚日志中回滚日志记录会分为以下两步:(1)从<code>iOffset</code>到<code>iHdrOffset</code>以及(2)所有后续的日志段。在恢复的过程中，pager记下了哪些页面被回滚了，并确保页面不会被回滚超过一次。<code>Pager.dbSize</code>也会被回滚到保存点之前的大小(即PagerSavepoint.nOrig)。如果是恢复整个事务，那么只需要用到主回滚日志就行。SQLite会销毁所有在<code>sp</code>保存点之后创建的所有<code>PagerSavepoint</code>对象，但不包括<code>sp</code>自己。这些保存点对应用来说也都不可访问了。</p>\n<h3 id=\"失败恢复\"><a href=\"#失败恢复\" class=\"headerlink\" title=\"失败恢复\"></a>失败恢复</h3><p>在进程崩溃或者系统出错的时候，数据库文件中可能会遗留一些不一致的数据。当没有应用在更新数据库，并且存在回滚日志文件的时候，这就意味着之前的事务可能已经存在失败情况了，并且SQLite可能需要从失败带来的影响中恢复数据库。如果对应的数据库文件是未上锁或者只有共享锁的情况下，那么这个回滚日志文件可以说是激活状态的。但是如果日志文件是有多数据库事务创建的，并且没有主日志文件，那么这个日志文件并不是激活的。</p>\n<p><strong>判定日志是否激活</strong>:有两种情况:(1)如果不涉及多数据库的主日志，也就是说日志文件中没有出现主日志文件记录。如果日志文件存在，并且是有效的(有一个按格式化的日志头部并且不为0)，并且数据库文件上没有保留锁或者高于保留锁的锁，并且数据库不是空的，那么这个日志文件就是激活状态。(2)如果主数据库日志名出现在回滚日志文件中，并且主回滚日志存在，并且日志中引用了回滚日志文件，并且在对应的数据库文件上没有保留锁或者更高的锁，那么这个日志文件就是激活的。</p>\n<p><strong>警告</strong>:如果当前的应用是以只读的权限打开数据库文件，并且对文件或者对目录没有写权限，那么恢复就会失败，并且SQLite会返回特定的错误码。</p>\n<p>pager在想从数据库文件中第一次读取页面的时候，它会按照如下的恢复顺序来执行。</p>\n<ol>\n<li><p>它先在数据库文件上获取一个共享锁。(如果无法获取到这个锁，它就会返回给应用SQLITE_BUSY错误码。)</p>\n</li>\n<li><p>检查数据库上是否有一个激活的日志文件。如果数据库没有激活的日志文件，那么恢复操作就到此为止了。如果存在一个激活的日志文件，那么日志文件就会按照如下的步骤来回滚。</p>\n</li>\n<li><p>在数据库文件上获取一个排它锁。(pager不会在数据库上获取保留锁，因为这样会让其他的pager认为日志文件已经不再是激活状态了，然后它们就会直接读数据库。最后它是需要在数据库上获取一个排他锁，因为写入数据库是恢复工作的一部分。) 如果获取锁失败，那么就意味着此时有另一个pager正在尝试回滚。在那种情况下，它会释放所有的锁并且返回SQLITE_BUSY错误码给应用层。</p>\n</li>\n<li><p>从日志回滚文件中读取所有的日志记录，并且撤销这些日志(回滚)。这个操作会将数据库恢复到发生崩溃的事务开始时候的状态。并且数据库此时就在一致的状态了。如果需要的话，数据库文件还会被缩减到事务开始之前的大小。</p>\n</li>\n<li><p>flush刷新数据库文件。如果发生另一次电源故障或崩溃，这可以保护数据库的完整性。</p>\n</li>\n<li><p>释放(包括删除、无效化、或者裁剪)日志文件。</p>\n</li>\n<li><p>如果安全的话，删除主日志文件。</p>\n</li>\n<li><p>把锁降级到共享锁。(因为pager是在<code>sqlite3PagerGet</code>方法的内部执行的恢复。)</p>\n</li>\n</ol>\n<p>在以上的算法策略成功的执行之后，数据库文件此时就已经保证恢复到之前的状态了。此时再读取文件的时候就是安全的了。</p>\n<p><strong>过时的主日志文件</strong>:如果没有独立的回滚日志引用主日志文件，那么这个主日志文件就可以认为是过时的。pager会先读主日志文件，然后获取所有回滚日志文件的名字。然后，它分别检查每个回滚日记文件。如果每一个日志文件都存在，并且指向主日志文件，那么这个主日志文件就不是过时的。如果所有的回滚日志文件都不存在，或者他们指向了其他的主日志文件，或者没有指向主日志文件，那么这个主日志文件就是过时的，并且pager会删除掉这个主日志文件。没有要求说这个过时的主日志文件需要被删除。这样做的唯一原因就是为了释放磁盘空间。</p>\n<h2 id=\"其他的管理问题\"><a href=\"#其他的管理问题\" class=\"headerlink\" title=\"其他的管理问题\"></a>其他的管理问题</h2><h3 id=\"检查点\"><a href=\"#检查点\" class=\"headerlink\" title=\"检查点\"></a>检查点</h3><p>大部分数据库系统为了减小数据库失败的恢复压力，在固定的时间点都会有一个检查点。因为SQLite在同一个时间点同一个数据库上最多只会有一个写事务。日志文件中也只有当前事务的日志记录。SQLite会在事务完成的时候，处理掉日志文件。最终SQLite就不会有日志的积压，也不会需要去执行一个检查点，日志中也不会有检查点的逻辑。当事务提交的时候，数据库会保证在处理日志文件之前，将数据库的更新已经都写入数据库中了。(在SQLite3.7.0中，SQLite的开发者介绍了WAL日志特性。在这个日志模式下，会执行检查点。后续会讨论这个日志模式。)</p>\n<h3 id=\"空间约束\"><a href=\"#空间约束\" class=\"headerlink\" title=\"空间约束\"></a>空间约束</h3><p>在某些DBMS中，最麻烦的问题是日志空间不足。换句话树，就是文件系统没有足够的空间来给日志文件继续扩大写入新的日志记录。在某些DBMS中，中止事务会生成（补偿）日志记录，同时撤消某些更新，从而使情况进一步恶化。日志空间的不足可能会在那些系统中产生事务中止和系统重启的问题。但是SQLite不会，因为事务的终止不会产生任何新的日志记录。系统重启尽管也会有问题，但是只会在一些极端的场景下:事务会收缩数据库文件，并且释放的空间已经由本机文件系统分配用于其他目的。在这个情况下，恢复可能失败，因为SQLite已经无法将数据库文件恢复到原始的大小了。此时数据库就会被阻塞，直到所需的空间可用于数据库文件恢复到原始大小为止。</p>\n<p>还有一个其他的相关的问题:数据库文件没有足够的空间可以增长了。在这个场景下，pager会返回SQLITE_FULL错误码给应用，这有可能会终止事务。所以这也有可能会在SQLite中导致问题。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文讨论的是SQLite的Pager模块。本模块在原生操作系统的基础上实现了一个抽象的基于页面的数据库文件系统。它按照固定大小的页面来管理数据，并且定义了一些接口从数据库文件中来操作这些页面。它提供了一个数据库页面的内存缓存，来帮助BTree模块加速操作数据库页面。它不仅仅是一个缓存的管理中心，同样也是实现ACID的事务管理中，以及事务回滚管理。并发控制和回滚机制对于上层模块来说是完全透明的。他可以理解为一个传统数据库管理系统的持久化层。</p>\n</blockquote>","more":"<h1 id=\"Pager模块\"><a href=\"#Pager模块\" class=\"headerlink\" title=\"Pager模块\"></a>Pager模块</h1><p>除了内存数据库以外，数据库都是以原生文件的形式落在磁盘上的。SQLite无法高效的直接读取和操作磁盘上的文件。当需要数据项的时候，它会从数据库文件中读取数据到主内存中，然后在内存中操作数据，在有必要的时候，还会回写到磁盘文件中去。相对于紧凑的主内存来说，一般情况下数据库文件都会很大。因为内存有限，所以一般内存中只会保留一小部分来存储的数据，而这部分内存通常就被叫做数据库缓存或者数据缓存;在SQLite的术语中，它被称为page cache。而这个缓存是在应用进程的地址空间内，而不是操作系统的地址空间。(操作系统有它自己的数据缓存。)</p>\n<p>page缓存管理器在SQLite的世界里就是Pager。它面对的是可随机访问的原生字节流的文件，并且需要将他们转换为可以随机访问的高级别的分页式的文件，而这个页面的大小是固定的。不同的数据库文件可以有不同的页面大小。区别于原生操作系统，Pager提供了一个简单可用的接口来访问数据库文件的页面。Tree模块将会使用Pager提供的接口来操作，而不会直接操作原生的数据库或者日志文件。Tree模块看到的数据库逻辑上是一个页面的数组，并且通过他们数组的下标索引来获取页面。</p>\n<p>SQLite对于每一个打开的数据库文件(或者说数据库连接)，都会有一个单独的页面缓存。当一个应用进程打开一个数据库文件的时候，Pager就会为它创建和初始化一个新的页面缓存。如果进程多次打开同一个数据库文件的时候，在默认模式下，Pager会单独为这个文件创建和初始化页面缓存多次。(SQLite提供一个高级特性，那就是所有打开同一个数据库文件的数据库连接可以共享一个页面缓存。)在使用内存数据库的时候，不会访问任何外部存储设备。但是它们也会被当做原生的数据库文件来处理，并且会被整个存储到缓存中。因此Tree模块可以使用相同的接口来操作这两类数据库。</p>\n<p>在SQLite中Pager属于最底层的模块。这是唯一的一个通过直接调用操作系统提供的I&#x2F;O API来访问原生文件的模块。它会直接读写数据库文件或者日志文件。它不会理解数据库是如何组织数据结构的。它也不会去干涉数据库的内容，或者自己去修改内容。它只需要保证存在数据库文件中的数据可以被重复地无任何修改地检索。从这个角度上来说，Pager是一个被动的模块。(它有可能会修改一些数据库文件头部记录中的信息，例如文件修改计数器file change counter。)</p>\n<p>对于每一个数据文件来说，Pager在文件和内存缓存之间转移页面内容是作为一个缓存管理器的基本功能。而这个转移对于Tree模块和一些高层模块来说是透明的。Pager就是原生系统文件和高层之间的一个媒介。它还要协调页面回写到数据库文件中去。</p>\n<p>除了缓存管理的工作之外，pager也承担了一个典型的DBMS的其他功能。它提供一个典型的事务处理系统的核心服务:事务管理，数据管理，日志管理，和锁管理。作为一个事务管理者，它通过接管并发控制和数据恢复，来实现了事务的ACID属性。它也负责原子性提交和事务的回滚。作为一个数据管理者，它通过缓存和一些文件空间管理来协调数据库文件页面的读写。作为日志管理者，它决定了在日志文件中的日志写入。作为一个锁管理者，它可以确保在操作数据库页面之前，在数据库文件上已经有了一个合理的锁。</p>\n<h1 id=\"Pager接口\"><a href=\"#Pager接口\" class=\"headerlink\" title=\"Pager接口\"></a>Pager接口</h1><p>在这一小节中，我将会给出一些Pager模块导出的接口，这些接口将会给Tree模块使用。在此之前，我们先讨论一下Pager和Tree模块之间的交互协议。</p>\n<h2 id=\"Pager-client调用交互协议\"><a href=\"#Pager-client调用交互协议\" class=\"headerlink\" title=\"Pager-client调用交互协议\"></a>Pager-client调用交互协议</h2><p>在Pager之上的模块是完全隔离了低级别的锁和日志管理机制。事实上，它们并不知道锁和日志的存在的。Tree模块把所有的事情都看做一个事务，并且它不关心事务的ACID是如何实现的。而Pager模块则把一个事务的所有活动拆分为锁、日志、以及读写数据库文件。Tree模块以页面号来向Pager中请求一个页面数据。反过来，Pager会返回一个已经加载到页面缓存中的页面数据的指针地址。在修改一个页面之前，Tree模块需要先通知Pager模块。这样Pager模块可以在日志文件中存放足够的信息来防止之后要做数据恢复，以及提前在数据库文件上加上合适的锁。在它使用完页面之后，还要通知Pager，这样如果页面数据发生改变的时候，Pager还会将数据回写到数据库文件中。</p>\n<h3 id=\"Pager接口结构\"><a href=\"#Pager接口结构\" class=\"headerlink\" title=\"Pager接口结构\"></a>Pager接口结构</h3><p>Pager模块实现了一个数据结构叫<code>Pager</code>。每一个数据库文件都是通过单独的<code>Pager</code>对象来管理的，并且每一个<code>Pager</code>也只会关联到有且仅有一个数据库文件上。(在Pager模块层中，这个对象就等同于数据库文件。)在Tree模块中，如果需要使用一个数据库文件，那么需要先创建一个Pager对象，然后在这个对象上使用一些页面操作函数。Pager模块可以使用这个对象来追溯关于文件的锁，日志文件，和数据库的状态，日志文件的状态等等。一个进程在同一个数据库文件上可以有多个<code>Pager</code>对象与之对应，每一个对象都隶属于一个数据库连接。这些对象都是被独立处理的，互不相关。(对于共享缓存的模式来说，对每一个数据库文件，只有一个<code>Pager</code>对象，所有数据库文件共享这个对象。)内存数据库也是使用这个对象作为操作句柄。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/lLkn3u.png\"></p>\n<p>后面会给出一个<code>Pager</code>对象的一些成员变量。在这个对象的后面会紧跟着一片内存空间，这个空间会用来存储页面缓存、数据库文件句柄、日志文件句柄、和数据库文件名、日志文件名。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/hWBtgL.png\"></p>\n<p>正如之前提到的，SQlite在一个用户事务中，执行每一个更新(insert,delete,update)操作的时候都会放在一个savepoint保存点内。同样的，应用也可以设置自己的保存点。可以同时存在多个保存点，存储在aSavepoint数组内。这个保存点的数据结构后面也有。当SQLite创建了一个保存点savepoint的时候，它就会把<code>iHdrOffset</code>这个变量置0。但是如果在某个savepoint已经激活的时候，它打开了回滚日志文件并且在文件中写入了一条记录头，那么它就会把<code>iHdrOffset</code>改为在写入回滚日志之前的最后一条记录的字节偏移。当<code>PagerSavepoint</code>对象创建的时候,<code>iOffset</code>会被设置为回滚日志的起始偏移。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/1ijSOI.png\"></p>\n<h3 id=\"Pager接口函数\"><a href=\"#Pager接口函数\" class=\"headerlink\" title=\"Pager接口函数\"></a>Pager接口函数</h3><p>Pager模块实现了一系列给Tree模块使用的接口方法。为了便于后面的理解，下面先列举一些重要的接口方法，这些接口方法都是以<code>sqlite3Pager</code>开头，所有的方法都仅限SQLite内部使用。</p>\n<ol>\n<li><p>sqlite3PagerOpen:方法创建一个新的<code>Pager</code>对象，打开给定的数据库文件，创建和初始化一个空的页面缓存，并且把这个缓存的指针返还给<code>Pager</code>对象。它会根据给定的数据库名，创建&#x2F;打开一个合适的文件。数据库文件在此时并不会上锁，既没有创建日志文件，也没有执行数据库恢复操作。(数据库的恢复是会被延迟到首次从数据库中读取一个页面的时候)</p>\n</li>\n<li><p>sqlite3PagerClose:方法销毁一个<code>Pager</code>对象，并且关闭关联的已经打开的数据库文件。如果它是一个临时文件，pager还会删除掉和这个文件。如果它不是一个临时文件并且在这个方法被调用的时候，这个文件还有一个事务存在，那么这个事务就会被强制终止，并且把它的变更全部回滚。所有内存中的缓存都会失效，从用户进程地址空间内释放。在这个方法调用之后再去访问缓存都会导致崩溃。换句话说，所有的资源都被释放了。</p>\n</li>\n<li><p>sqlite3PagerGet:这个方法会给调用者从数据库文件中复制到内存中一份可用的数据页面。调用者指定了请求页面的页面号。方法返回一个拷贝到内存缓存中的页面地址。因此，缓存空间不被回收的话，它就会固定下这个拷贝的页面。在调用这个方法最开始它就会在数据库上获取一个共享锁。此时它会决定是否需要清理现有的页面缓存–如果数据库的文件变更计数器(在文件头部第24字节开始的4个字节整型)和当前缓存中的之前获取到的这个值不一样，它就会开始清理缓存。另外如果有必要的话(存在一个回滚日志文件)，数据库就会从日志文件中回滚(后面的章节会讨论日志的回滚)。如果请求的页面不在缓存中，pager就会加载请求的页面到缓存中。但是，如果目前的数据库文件小于请求的页面号，那么实际也不会触发文件读，但是内存中会依旧分配一个页面，并且全部初始化为0.(当然对于内存数据库来说，不会触发任何的文件操作。)</p>\n</li>\n<li><p>sqlite3PagerWrite:这个方法可以将请求的数据库页面对调用者是可写的。(注意这里是可写不是写入数据。)这个方法必须在Tree模块修改缓存数据之前调用，否则的话Pager并不知道某一个缓存的页面被修改了。(处于性能考虑，SQLite避免了从Tree模块到Pager模块互相拷贝数据，而是让Tree模块直接修改Pager缓存的数据。)Pager还会在数据库文件上获取一个保留锁，并且创建一个回滚日志文件。也就是说它创建了一个隐式的写事务。如果当前页面还不在日志文件中，那么它就会拷贝这个页面中的原始数据到回滚日志中去。如果这个原始的页面已经在日志文件中了，那么SQLite只会标记这个页面为写脏。如果当前的事务是在一个用户事务中，并且当前页面也已经在主回滚日志中了，那么这个方法也还会在状态日志中写入一条状态记录。</p>\n</li>\n<li><p>sqlite3PagerLookup:这个方法返回在已经请求在内存缓存中的页面。如果不在，则返回NULL。对前者来说，它会固定这个页面。</p>\n</li>\n<li><p>sqlite3PagerRef:方法给指定页面的引用计数+1。我们称这个页面被调用者固定了。如果页面在缓存的已释放链表中，这个方法会从这个已释放列表中移除该页面。</p>\n</li>\n<li><p>sqlite3PagerUnref:方法给指定页面的引用计数-1。当这个页面的引用计数降低到0的时候，我们称这个页面已经被解除固定，并且被释放了。(被释放的页面依旧存在内存中，它会存储在已释放的链表内。）当所有的页面都被解除固定了的时候，在数据库上的共享锁就会被释放，<code>Pager</code>对象就会被重置。</p>\n</li>\n<li><p>sqlite3PagerBegin:方法在相关联的数据库文件上开启一个显式的写事务。如果数据库不是一个临时数据库，它也会打开一个回滚日志文件。(对于临时数据库，回滚日志的打开会一直推迟到真正写入回滚日志的时候。)从前面可以知道隐式的写事务是由<code>sqlite3PagerWrite</code>开启的。因此，如果数据库已经保留用来准备写入了，那么这个方法就不会做任何操作。否则的话，它会首先在数据库文件上持有一个保留锁，并且如果在参数指明的情况下，它还会立刻在数据库文件上获取一个排它锁，而不是真正等到Tree模块尝试写入数据的时候。</p>\n</li>\n<li><p>sqlite3PagerCommitPhaseOne:方法在数据库文件上提交当前的事务:文件变更计数器+1，同步日志文件，把所有的变更(例如页面缓存中的脏页)同步到数据库文件中</p>\n</li>\n<li><p>sqlite3PagerCommitPhaseTwo:方法释放(包括删除、无效化、或者裁剪)日志文件。</p>\n</li>\n<li><p>sqlite3PagerRollback:方法在数据库文件上放弃当前的事务:回滚事务给数据库文件带来的所有变更，并且把数据库的锁降级到共享锁。所有的缓存页面转变为它们的原始数据内容。日志文件被释放。</p>\n</li>\n<li><p>sqlite3PagerOpenSavepoint:方法创建一个新的保存点句柄对象，为当前的数据库状态建立一个保存点。</p>\n</li>\n<li><p>sqlite3PagerSavepoint:方法释放或者回滚一个保存点。对于释放操作来说，它会释放和销毁指定的一个保存点句柄对象。对于回滚操作来说，它回滚数据库上在此保存点建立之后的所有变更，并且后面所有的保存点都会被删除。</p>\n</li>\n</ol>\n<h1 id=\"页面缓存\"><a href=\"#页面缓存\" class=\"headerlink\" title=\"页面缓存\"></a>页面缓存</h1><p>页面缓存存在于应用进程的地址空间内。（对于同一个页面来说，原生操作系统可能也会对它做一次缓存，当应用从某个文件中读取一段数据的时候，操作系统一般都会给自己拷贝一份，再给应用拷贝一份。我们不关心操作系统是如何管理它的缓存的。SQLite的缓存组织和管理独立于那些原生操作系统。）下图描述了一个典型的情况。在图中，两个进程(其中有一个是多线程的)在访问同一个数据库文件。他们有自己的缓存。甚至于同一个线程在默认操作模式下，多次打开了同一个数据库。SQLite为这些数据库连接分配了独立的缓存。通过它们自己不同的<code>Pager</code>对象来访问这些缓存。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/It7kz3.png\"></p>\n<h2 id=\"缓存状态\"><a href=\"#缓存状态\" class=\"headerlink\" title=\"缓存状态\"></a>缓存状态</h2><p>页面缓存的状态(在上图中<code>Pager</code>对象中有对应的变量)决定了Pager模块可以对缓存做什么。两个变量<code>eState</code>和<code>eLock</code>控制了Pager的行为。页面缓存的总是以下7种状态之一(<code>Pager.eState</code>成员变量的值)。下图是这7种状态值的转换图。</p>\n<ol>\n<li><p><strong>PAGER_OPEN</strong>:当一个<code>Pager</code>对象创建的时候，这是它的初始状态。此时pager无法通过<code>Pager</code>对象来读或者写数据库文件。当前内存中可能没有页面缓存，缓存是空的。数据库文件上应该也没有锁，在当前数据库上没有事务。</p>\n</li>\n<li><p><strong>PAGER_READER</strong>:在这个状态的时候，当前数据库连接上至少有一个读事务，pager可以读取对应数据库文件的页面。(但是，在排他锁的模式下，读事务可能并不会打开。)</p>\n</li>\n<li><p><strong>PAGER_WRITER_LOCKED</strong>:当一个<code>Pager</code>对象在这个状态的时候，当前数据库连接上已经打开了一个写事务。pager可以在对应的数据库文件上读页面数据，但是它还没有在数据库文件或者缓存页面中做任何的变更。</p>\n</li>\n<li><p><strong>PAGER_WRITER_CACHEMOD</strong>:当一个<code>Pager</code>对象在这个状态的时候，pager给与Tree模块权限来更新缓存的页面数据，并且Tree模块可能已经对它做出了一些变更。</p>\n</li>\n<li><p><strong>PAGER_WRITER_DBMOD</strong>:当一个<code>Pager</code>对象在这个状态的时候，pager可能已经开始写数据库文件了。</p>\n</li>\n<li><p><strong>PAGER_WRITER_FINISHED</strong>:当一个<code>Pager</code>对象在这个状态的时候，pager已经完成将当前写事务中发生的所有变更的页面写入到数据库文件了。写事务已经不能再做任何的变更了，此时已经在准备提交了。</p>\n</li>\n<li><p><strong>PAGER_ERROR</strong>:出错的状态，例如I&#x2F;O失败，磁盘空间不足，内存不足等等。</p>\n</li>\n</ol>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/yUn3tG.png\"></p>\n<p>根据<code>eLock</code>变量的值，一个<code>Pager</code>对象可以是如下4中状态之一。</p>\n<ol>\n<li><p><strong>NO_LOCK</strong>:当前不在读写任何事务。</p>\n</li>\n<li><p><strong>SHARED_LOCK</strong>:Pager已经从数据库文件中读了页面数据了。在同一个时间，同一个文件上可以有多个读事务，这些读事务可以各自通过他们的<code>Pager</code>对象来访问数据库文件。此时不允许修改缓存的页面。</p>\n</li>\n<li><p><strong>RESERVED_LOCK</strong>:pager已为写入数据保留了数据库文件，但是还没有做出任何的变更。在同一时间只有一个pager可以保留指定的数据库文件。因为原始的数据库文件还没有被修改，其它的Pager依旧可以读。</p>\n</li>\n<li><p><strong>EXCLUSIVE_LOCK</strong>:pager已经把缓存页面回写到数据库文件了。此时的文件访问是独占的。当这个pager在写入的时候，没有其他的pager可以读写这个文件。</p>\n</li>\n</ol>\n<p>页面缓存开始于NO_LOCK的状态。当Tree模块首次调用<code>sqlite3PagerGet</code>方法读取任何一个页面的时候，pager就会转换到SHARED_LOCK状态。当Tree模块通过执行<code>sqlite3PagerUnref</code>方法释放所有页面的时候，pager就会转换回NO_LOCK状态。(这个时候，它应该不会清理页面缓存。)当Tree模块首次调用<code>sqlite3PagerWrite</code>方法的时候，pager就会转换到RESERVED_LOCK状态。(<code>sqlite3PagerWrite</code>方法只有在pager已经就绪读的时候才可以被调用)。pager在真正写入第一个页面到数据库文件的时候，就会转换到EXCLUSIVE_LOCK状态。在<code>sqlite3PagerRollback</code>或者<code>sqlite3PagerCommitPhasTwo</code>两个方法的执行过程中，pager会转换回NO_LOCK状态。</p>\n<ul>\n<li>对于内存数据库或者临时数据库来说，<code>Pager.eLock</code>永远是EXCLUSICE_LOCK，因为它始终是独占的。</li>\n</ul>\n<h2 id=\"缓存的组织结构\"><a href=\"#缓存的组织结构\" class=\"headerlink\" title=\"缓存的组织结构\"></a>缓存的组织结构</h2><p>每一个页面缓存都是由一个<code>PCache</code>句柄对象来管理。pager持有了这个<code>PCache</code>对象的引用(可以看上面pager的结构图)。下图描述了一个<code>PCache</code>对象的一些成员变量。SQLite支持插件化的缓存结构，用户可以自己提供一个缓存结构。它提供了它自己的插件缓存模块(由pcache1.c源码实现)，后面会讨论这个缓存实现。这个也将会是默认的缓存管理，除非用户自己提供一个。<code>PCache</code>对象的最后一个成员就是pCache,持有了这个可插件化的缓存模块。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/EWLiFD.png\"></p>\n<p>通常情况下，为了加速查询一个缓存，当前持有的缓存项都会被较好的组织好。缓存空间会被分割为一个个存储槽来持有数据项。SQLite使用一个哈希表来组织已缓存的页面，并且使用页面槽来持有表中的页面。缓存是完全关联的，因此任何一个存储槽都可以存储任何页面。哈希表初始化为空。随着页面需求的增长，pager会创建新的存储槽，然后将它们插入到哈希表内。<code>PCache.nMax</code>值决定了一个缓存可以持有的最大存储槽的数量。主数据库和其他attach连接上的数据库默认值是2000，临时数据库是500。内存数据库没有这个限制，根据物理内存的大小，有多少用多少。</p>\n<p>SQLite使用一个<code>PgHdr</code>类型的对象来标识缓存中的每一个页面对象。尽管一个可插件化的缓存可以有它自己的页面头部对象，但是pager也依旧可以理解这个对象。下图描述了SQLite自己的可插件化的缓存，由<code>PCache1</code>对象表示。在哈希表中的每一个插槽都由一个类型为<code>PgHdr1</code>的头部对象表示。这个插件化的组件是可以理解这个类型的，pager对此也不透明。插槽数据就存储在<code>PgHdr1</code>对象的正前方；这个插槽的数据大小由<code>PCache1.szSize</code>变量决定。这个插槽数据持有了一个<code>PgHdr</code>对象，一个数据库页面数据，和一些私有数据，这些私有数据区域是Tree模块用来保存页面特有的内存中的控制信息。(内存数据库没有日志文件，所以它的回滚信息也记录在内存对象中。那些对象就跟随在这个私有数据区域之后:这些指针只会被pager所使用。)当pager将页面数据写入缓存的时候，这些额外的非页面数据空间会被初始化为0。缓存中的所有页面通过<code>PCache1.aphash</code>哈希数组来访问；数组大小存储在<code>PCache1.nHash</code>变量内；这个数组也会根据需要调整大小。每一个数组元素都指向一个槽桶(bucket)；桶内的所有槽都会被组织在一个无序的单向链表内。</p>\n<p><code>PgHdr</code>对象只对pager模块可见，对Tree以及更高的模块不可见。头部有很多控制变量。<code>pgno</code>代表了数据库页面的页号。<code>needSync</code>标记位表示在回写这个页面到数据库文件的时候，日志文件是否需要flush一下。<code>dirty</code>标记位表示页面是否已经被修改过了，并且新的数据还没有回写到数据库文件内。<code>nRef</code>变量是这个页面的引用计数。如果<code>nRef</code>大于0，那么这个分页就还在使用中，我们说这个页面是被固定了，否则这个页面就是非固定的，并是被释放的。<code>pDirtyNext</code>和<code>pDirtyPrev</code>指针用来将所有的脏页面链接到一起。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/zIdkXn.png\"></p>\n<p><strong>缓存组</strong>:SQLite有一个选项，可以将所有<code>PCache1</code>对象放在一个组中。当这些高速缓存受到内存压力的影响时，它们可以回收彼此未固定的页面槽。</p>\n<h2 id=\"缓存的读取\"><a href=\"#缓存的读取\" class=\"headerlink\" title=\"缓存的读取\"></a>缓存的读取</h2><p>缓存的使用者无法通过地址寻址方式来访问一个缓存元素。事实上，它们甚至不知道一个页面的拷贝存储在哪个位置，当然也就不知道它们的地址了。缓存的内容是可寻址的，可以通过页号来搜索到一个页面。在管理数据的时候，它会使用<code>PCache1.apHash</code>哈希数组来讲页面号转换为一个合适的缓存存储槽。一开始，页面缓存是空的，但是随着需求的增加，页面会被主键添加到缓存中去。正如之前所提到的，为了读一个分页，调用者(Tree模块)需要调用<code>sqlite3PagerGet</code>方法，并且给定页号。这个方法将会由以下几步来请求一个页面P。</p>\n<ol>\n<li><p>搜索缓存空间。</p>\n<ul>\n<li>在页号P上应用一个非常简单的哈希算法，来计算获取<code>apHash</code>的索引号:算法就是用分页号模<code>apHash</code>数组大小</li>\n<li>在<code>apHash</code>数组上使用这个索引获取到哈希桶。</li>\n<li>通过遍历<code>pNext</code>指针来搜索这个桶。如果P页面在这里找到了，那么我们就说这个缓存命中了，它会固定一个页面(也就是将页面<code>PgHdr.nRef</code>的值+1)。并且会给调用者返回页面的内存地址。</li>\n</ul>\n</li>\n<li><p>如果页面P在缓存中没有找到，那么就认为是缓存缺失。方法就会去寻找一个空闲的插槽来加载请求的页面。(如果缓存尚未达到最大限制<code>PCache.nMax</code>，它就会创建一个新的空间的插槽。)</p>\n</li>\n<li><p>如果目前找不到一个可以使用的空闲的插槽或者也不能创建新的，它会决定某个页面是否可以释放用来给P页面复用插槽。这个称为替换插槽。(后面的小节我们会讨论这个)</p>\n</li>\n<li><p>如果这个被替换的插槽或者空闲插槽已经被标记为脏页面了，那么它就会将这个页面回写到数据库文件中去。(遵循预写日志（WAL）协议，它也会刷新日志文件)</p>\n</li>\n<li><p>两种情况。(a)如果这个P页面是小于等于文件中当前的最大页面数的，它就会从数据库文件中向空闲的插槽中读取页面P，然后固定这个页面(设置<code>PgHdr.nRef</code>为1)，然后返回页面地址给调用者。(b)如果P比当前的最大页面数量还要大，它不再读取页面，而是把整个页面初始化为0。在两种情况中，它都会把页面底部的私有区域初始化为0，不论这个页面是否是从数据库文件中读的。也都会把(<code>PgHdr.nRef</code>设为1。)</p>\n</li>\n</ol>\n<p>SQLite严格按照按需加载请求页面的策略，使得页面拉取变得非常简单。(关于这个后续还会细说。)</p>\n<p>当在缓存中的页面地址返回给调用者(Tree模块)的时候，pager并不知道调用者什么时候会对页面内容进行操作。因此对于每一个页面，SQLite有如下的一个标准协议:调用者请求(固定)一个页面，使用页面，然后释放页面。已经固定的页面是正在活跃使用中的，缓存管理器不能回收这个页面。为了避免出现所有缓存页面都被固定的场景，SQLite在缓存中需要有一个最小数量的页面，这样它就始终可以有缓存插槽来回收了，在3.7.8版本的时候这个值是10。</p>\n<h2 id=\"缓存的更新\"><a href=\"#缓存的更新\" class=\"headerlink\" title=\"缓存的更新\"></a>缓存的更新</h2><p>在获取到一个页面之后，调用者可以直接修改这个页面的内容。但是正如之前所提到的，在做出修改之前，它必须调用<code>sqlite3PagerWrite</code>方法。在方法返回之后，调用者就可以随意更新页面内容了。</p>\n<p>在首次调用<code>sqlite3PagerWrite</code>方法的时候，pager会将原始的页面内容作为一个日志记录的一部分写到回滚日志文件中，并且设置<code>PgHdr.needSync</code>标记。在此之后，当日志记录刷新到磁盘的时候，pager就会清除这个标记位。(SQLite遵循SQL协议:它直到这个页面对应的<code>needSync</code>标记位清除的时候才会将一个已修改的页面写入到数据库文件中去。)每次调用<code>sqlite3PagerWrite</code>方法的时候<code>PgHdr.dirty</code>都会被置位；只有当这个页面的内容被回写到数据库文件的时候这个标记位才会被清除。因为调用者什么时候改页面内容，pager是不知道的。数据库文件也不能实时反映页面内容的更新。因此pager遵循延迟回写数据库文件的策略。仅当pager执行缓存刷新或有选择地回收脏页时，更新才会反映到数据库文件。</p>\n<p>延迟的数据库文件更新会导致事务的内存使用增长，当内存使用到达上限的时候，缓存管理器就会执行缓存替换。</p>\n<h2 id=\"缓存拉取策略\"><a href=\"#缓存拉取策略\" class=\"headerlink\" title=\"缓存拉取策略\"></a>缓存拉取策略</h2><p>缓存拉取策略决定了什么时候将一个页面加载进缓存。按需拉取的策略只会在请求页面的时候才会将页面加载进缓存。在调用者请求页面的时候，调用者此时是阻塞的，一直到页面从数据库文件中读取完成。很多缓存系统使用了很复杂的预拉取技术提前将页面写入缓存，这样可以减少阻塞的频率。SQLite从文件中一次读一个页面，严格按照按需加载的策略，保持逻辑简单。</p>\n<h2 id=\"缓存管理\"><a href=\"#缓存管理\" class=\"headerlink\" title=\"缓存管理\"></a>缓存管理</h2><p>通常情况下，一个页面缓存的大小是有限的。除非数据库非常小，否则它一般只能持有数据库一小部分的页面。在不同的时间点，缓存需要回收掉一些页面来持有不同的页面。因此，缓存的页面需要非常小心的管理来获取性能的最大化。基本想法就是，在缓存中保留那些立刻会被请求的页面。在设计一个缓存策略的时候，我们需要考虑三件事情:</p>\n<ol>\n<li><p>每当缓存中有一个页面的时候，在数据库文件中也有这个页面的一个主副本。每当这个缓存被更新的时候，这个主副本也需要被更新。</p>\n</li>\n<li><p>对于不在缓存中的请求页面，将引用主副本，并从主副本中创建新的缓存副本</p>\n</li>\n<li><p>如果缓存已经满了，并且一个新的页面需要被放入缓存，会有一个替换算法来决定从缓存中移除掉一些旧的页面来给新的页面腾出空间。</p>\n</li>\n</ol>\n<p>因为缓存空间大小有限，我们需要回收一些缓存控件来适应将一个大的页面集合映射到一个小型的缓存插槽内(见下图)。在图里，26个主页面需要通过回收插槽的方式来映射到5个缓存插槽内。缓存管理在缓存性能和整体性能上都非常关键。在还有剩余空间的时候，对于缓存来说没什么难的。它的挑战就在于缓存已满的时候。它的职责就是哪些页面可以保留，哪些页面可以被替换出去。我们需要一个高命中率的缓存。因此对于缓存替换来说，最关键的地方就是决定那个页面可以保留。接下来我们就讨论缓存替换</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/08/UK0ZuX.png\"></p>\n<h3 id=\"缓存替换\"><a href=\"#缓存替换\" class=\"headerlink\" title=\"缓存替换\"></a>缓存替换</h3><p>缓存替换发生在缓存已经满的时候，旧的页面需要被移出去来给新的页面腾出空间。在前面提到，在页面都满了的时候，当一个请求的页面不在缓存中并且也没有可用的空闲的插槽的时候，其中的一个页面需要牺牲以被替换掉。而这个页面的选择不是一个简单的决定。之前也说过，页面的缓存是完全关联的，任何一个插槽都可以给这个新页面。由于考虑使用多个插槽进行替换，因此所选的插槽由缓存替换策略决定。替换策略的主要目标是将那些页面保留在缓存中，以便可以在不引用主副本页的情况下从缓存中满足大部​​分请求。因此缓存命中率需要非常高。如果命中率很低，那么这个缓存也不值得用来加速页面访问了。</p>\n<p>我们并不知道未来可能引用哪些页面。所以，缓存管理器通过一些启发式的或者优先的访问历史来决定替换页面。因此，通常在实践中使用的替换方案有时会在选择被替换页面时造成“错误”，当调用者立即召回被替换页面时，这种替换很快就会被撤销。如果一个页面P在被替换出去之后，又立刻被引用了，或者在再次被引用期间，其他页面一个都没有被引用，那么这个决定是比较差的。替换策略的目标是最大程度地减少错误，并最大程度地提高缓存未命中之间的时间间隔。缓存之间的主要差别就在于替换策略。在硬件和软件开发中，先进先出，最近最少使用，最少使用，时钟策略已广泛遵循高速缓存替换策略。SQLite则使用一种最近最少使用替换策略(LRU)。</p>\n<h3 id=\"LRU缓存替换\"><a href=\"#LRU缓存替换\" class=\"headerlink\" title=\"LRU缓存替换\"></a>LRU缓存替换</h3><p>LRU是一个非常流行的替换策略。它及其变体已在软件和硬件缓存开发的许多领域中成功实现。它利用对页面引用的时间局部性。(时间局部性是指在短时间内很有可能重复访问同一页面。)也就是说，一个页面在现在被访问了，那么它很有可能将会被再次访问。一个页面很长时间没有被访问了，那么它很有可能近期不会被再次访问。选择的被替换者，就是最长时间没有被访问的那一个。</p>\n<h3 id=\"SQLite的缓存替换\"><a href=\"#SQLite的缓存替换\" class=\"headerlink\" title=\"SQLite的缓存替换\"></a>SQLite的缓存替换</h3><p>SQLite把一些不活跃的页面放在一个逻辑队列中。当一个页面被取消固定的时候，pager就会将这个页面放在队列的尾部。(队列末尾的页面始终是最近访问的页面，而队列头部的页面则是最早访问过的页面。)被替换的那个页面一般都会选择队列头部的，但不一定像纯LRU方案那样总是队列的头元素。SQLite尝试从队列的开头开始找到一个插槽，以便回收该插槽不会涉及刷新日志文件。因为回收一个页面如果导致文件刷新的话，那么会减慢速度。如果能找到这么一个替换页面，那最前面的那个就会被回收。否则，SQLite就会刷新日志文件，然后回收头部的那个插槽。如果这个页面是脏页面，还会会写到数据库中。</p>\n<h1 id=\"事务管理\"><a href=\"#事务管理\" class=\"headerlink\" title=\"事务管理\"></a>事务管理</h1><p>在SQLite中Pager也是一个事务管理器，它会通过管理数据库文件上的锁，以及管理日志文件中的日志记录来确保事务的ACID。尽管SQLite锁管理器负责获取并释放文件上的锁，但pager会决定锁的模式以及获取和释放锁的时间点。它会严格遵循以下两个锁阶段，来创建一个事务的线性执行。它也决定了日志记录的内容以及何时写入日志文件。</p>\n<p>和DBMS一样，SQLite的事务管理有两个组件:1.正常处理和 2.恢复处理。在正常处理过程中，pager会在日志文件中保存一些回滚需要的信息，然后在发起回滚的时候，使用这些数据来确保回滚。下面两个小节将会讲述这两个组件。事务管理的一些细节会有单独的文章，而这里我将会从整体的角度上来看。</p>\n<h2 id=\"正常处理流程\"><a href=\"#正常处理流程\" class=\"headerlink\" title=\"正常处理流程\"></a>正常处理流程</h2><p>正常的处理流程包含了从数据库文件读页面和写页面到数据库文件，提交事务，结算子事务，设置和释放保存点。另外，pager回收插槽的选择和刷新页面缓存也是正常处理流程中的一部分。</p>\n<h3 id=\"读操作\"><a href=\"#读操作\" class=\"headerlink\" title=\"读操作\"></a>读操作</h3><p>为了在一个数据库页面上操作，调用者(Tree模块)需要调用<code>sqlite3PagerGet</code>方法。即使页面不在数据库内，也需要调用这个方法:因为新的页面会由pager创建。方法会在数据库文件上获取一个共享锁。如果获取共享锁失败，那么说明此时数据库上已经有一个与之冲突的锁，方法会返回SQLITE_BUSY给调用者。否则，它就执行缓存读，然后将页面的指针地址返回给调用者。前面提到，这个操作会固定住一个页面。</p>\n<p>从前文的图中可以看到，每一个内存页面中，后面跟了一块私有空间。这个额外的空间在从数据库文件加载或者全新创建的时候都会被初始化为0。这个空间之后会由Tree模块来再次初始化。</p>\n<p>pager首次从数据文件获取一个共享锁的时候，它可以决定文件是否需要恢复。他会寻找一个日志文件(后面会讨论文件的恢复和失败恢复)。如果这个日志文件确实存在，那么说明在之前的事务执行过程中出现了一次失败，并且pager在调用<code>sqlite3PagerGet</code>返回之前，会回滚那次失败的事务，并且释放这个日志文件。</p>\n<p>如上所述，一个已经请求过的页面可能并不会在页面缓存中。在那个情况下，pager找到一个空闲的缓存插槽并且从数据库文件中加载页面，整个过程对用户是透明的。获取一个空闲的缓存插销也可能会导致一次数据库文件的写入，即缓存的刷新。</p>\n<h3 id=\"写操作\"><a href=\"#写操作\" class=\"headerlink\" title=\"写操作\"></a>写操作</h3><p>在修改一个页面之前，调用者(Tree模块)必须先固定住这个页面(通过调用<code>sqlite3PagerGet</code>方法)。然后在通过<code>sqlite3PagerWrite</code>方法，让对应的页面变得可写。一旦变成可写状态，调用者就可以随意更改内容，且不用通知pager。写入一个页面并不会导致缓存的刷新。尽管pager可能需要在数据库上请求一个保留锁。首次调用<code>sqlite3PagerWrite</code>方法的时候，pager就会在数据库文件上获取一个保留锁。这个保留锁的意思就是即将要写入数据库了。同时只能有一个事务可以持有一个保留锁。如果pager无法获取这个锁，那就意味着在文件上有其他的事务获取了同级或者更高级的锁。在这个情况下，pager就会返回SQLITE_BUSY给调用者。</p>\n<p>pager首次请求保留锁的时候，我们称之为读事务升级为写事务。(对用户事务或者系统事务来说都一样。)在这个时间点，pager创建并打开一个回滚日志文件。(回滚日志文件也在与数据库的同级目录下，只不过后面会增加’-journal’。)它会初始化第一个分片的记录头(具体可以看日志相关的)，记录下数据库文件的原始大小，然后把记录写入日志文件。如果数据库文件大小因为事务而扩大了，那么只需要按照这个原始大小裁剪就可以了，因为新的页面都是往数据库后面添加的。</p>\n<p>为了让一个页面可写，pager会把这个页面的原始内容写到回滚日志文件中。新创建的分页不会记录log，因为它本身就没有旧的数据。一个页面最多写入一次回滚日志文件。对数据库的变更不会立刻写入数据库文件。这些变更会先在内存中持有。数据库文件中依旧是未改变的，也就意味着，其他事务还能继续从文件中读。</p>\n<p><strong>扇区记录</strong>:如果存储设备中的扇区可以存储超过一个数据库页面，SQLite会log整个扇区，而不是仅仅只有被改变的页面。</p>\n<p><strong>页面log策略</strong>:一旦当有一个页面额镜像数据被拷贝到回滚日志中，尽管当前的事务再去多次调用<code>sqlite3PagerWrite</code>方法，页面也不会出现在后续新的日志记录中了。这个日志记录方式有一个好处就是，一个页面可以无脑的从日志文件的数据区中恢复出来。因此撤销操作是幂等的，并且它不会产生任何补偿日志记录。</p>\n<h3 id=\"缓存刷新\"><a href=\"#缓存刷新\" class=\"headerlink\" title=\"缓存刷新\"></a>缓存刷新</h3><p>缓存刷新是pager模块的一个内部操作，调用者(Tree模块)不能直接调用缓存刷新。有两种场景pager想要把缓存刷新到内存之外(即磁盘上):1.缓存已经满了，并且需要做一次缓存替换。2.事务依旧准备好去提交它的变更了。pager会将一些或者所有已经变更的页面写入到数据库文件中去。在写入之前，pager必须保证没有其他事务正在读数据库事务了。SQLite遵循WAL协议写入数据库。也就意味着，在写入到数据库文件之前还需要刷新写入日志回滚的记录。pager遵循下面的步骤:</p>\n<ol>\n<li><p>它先判断决定是否有必要刷新日志文件。如果事务是同步的，并且已经把新数据写入到日志文件了，并且数据库文件不是一个临时文件(因为对于临时数据库我们不需要考虑断电恢复)，那么pager就需要做一次日志文件的flush刷新。在这个场景下，只需要在日志文件上执行<code>fsync</code>系统调用来确保所有的日志文件的写入已经落到磁盘上了。此时，pager没有将在日志片段头部中日志记录的数量(<code>nRec</code>)的值写入到文件中。(<code>nRec</code>值是回滚操作的关键资源。当这个片段头部构建的时候，这个值会被同步事务设置为0，被异步事务设置为-1。)在日志文件被刷新到磁盘上之后，pager就会将<code>nRec</code>值写入，然后再做一次<code>fsync</code>。因为磁盘的写入不是原子的，它不会再重写<code>nRec</code>字段。pager会为新的日志记录创建一个新的日志片段。在这些情况下，SQLite使用多段日志文件。</p>\n</li>\n<li><p>它会尝试在数据库文件上获取一个排它锁。(pager不会无条件的等待锁。他会尝试在非阻塞条件下尝试获取锁。如果其他事务还在持有共享锁，那么这个锁就会失败，然后返回SQLITE_BUSY，事务不会被终止。)</p>\n</li>\n<li><p>将所有已经修改的页面(在页面缓存中持有的)或者选中的一些回写到数据库文件中。页面写入就地完成。他它会清空缓存中这些页面的脏标记位。(此时不会立刻刷新数据库文件到磁盘。)</p>\n</li>\n</ol>\n<p>如果写入数据库文件的原因是因为缓存满了，那么pager还不会立刻提交事务。相反的，此时事务可能会继续对数据库页面做一些修改。后续的数据库写入依旧是重复这三个步骤。</p>\n<p><strong>注意</strong>:排他锁会一直持有直至数据库的事务最终完成。这也就意味着说，从第一次页面写入到数据库一直到事务提交或者终止，进程内的其他数据库连接或者其他进程内的数据库连接都无法对当前数据库发起读写事务。对于一些较短的写事务来说，数据更新都会在缓存中持有，以及排它锁只会在事务最终提交的时候才会请求。但是一个较长的写事务会导致其他读事务的性能下降。</p>\n<h3 id=\"提交操作\"><a href=\"#提交操作\" class=\"headerlink\" title=\"提交操作\"></a>提交操作</h3><p>根据提交事务是修改单个数据库还是多个数据库，SQLite遵循的提交协议略有不同。</p>\n<p><strong>单个数据库场景</strong>:当Tree模块准备提交一个事务额时候，它会先调用<code>sqlite3PagerCommitPhaseOne</code>，然后调用<code>sqlite3PagerCommitPhaseTwo</code>。提交读事务简单。pager从数据库文件上释放共享锁，然后返回到NO_LOCK状态。他它也不需要去清理页面缓存。(下一个事务开始的时候，页面缓存已经有一个”预热”了。)为了提交一个写事务，pager按照如下的步骤有序执行:</p>\n<ol>\n<li><p>在数据库文件上获取一个排他锁。(如果锁获取失败了，就会给<code>sqlite3PagerCommitPhaseOne</code>方法的调用者返回SQLITE_BUSY。它此时不能提交事务，因为此时还有其他读事务。)然后它会将数据库的metadata的文件变更计数器上+1。将缓存中所有已经发生变更的数据回写到数据库文件内。(按照上面<strong>缓存刷新</strong>小节中的1-3步骤)</p>\n</li>\n<li><p>很多操作系统例如Linux，会将这些文件写入缓存到系统内存空间中，并且不会立刻将数据回写到本地磁盘。为了避免这个场景，pager会调用<code>fsync</code>系统调用来刷新到磁盘上。这样做是为了消除系统重新启动时的重做逻辑。</p>\n</li>\n<li><p>然后，它完成（即删除，截断或使之无效）日志文件。</p>\n</li>\n<li><p>最终它会释放数据库文件上的排它锁。如果同时执行选择操作（即读取事务），它将返回SHARED_LOCK状态；否则，返回NO_LOCK状态。它也没必要去清除页面缓存。</p>\n</li>\n</ol>\n<p>单个数据库的提交点是在于他完成日志文件的时候。</p>\n<p><strong>多个数据库场景</strong>:这个提交协议涉及的更多，它类似于分布式数据库系统中的事务提交。VM模块（<code>VdbeCommit</code>函数）实际上驱动提交协议作为提交协调器。每个数据库的pager执行自己“本地”的提交操作。如果一个读事务或者写事务，只修改了单个数据库(临时数据库不算)，那么这个协议就和普通提交一样。如果修改了多个，那么就按照下面步骤执行:</p>\n<ol>\n<li><p>释放事务没有更新的那些数据库上的共享锁。(如果当前线程内的其他读事务也不再激活了。)</p>\n</li>\n<li><p>在那些发生更新的数据库文件上请求排它锁。增加数据库文件的 文件变更计数器。</p>\n</li>\n<li><p>创建一个新的主日志文件。(这个主日志文件和主数据库同级目录，同名，但是后续跟着’-mj’,以及8个十六进制的随机数。即使主数据库文件没有发生数据变更，也是如此。)在主日志文件中填充所有各个独立的回滚日志文件的名字，然后将主日志文件和日志文件目录flush到磁盘上。(临时数据库文件不包含在内。)</p>\n</li>\n<li><p>将主日志文件的名字写到各个独立的回滚日志中的主日志记录中。并且flush回滚日志到磁盘。(pager可能一直到提交事务的时候它才会知道它只是多数据库事务的一部分。)</p>\n</li>\n<li><p>flush各自的数据库文件。</p>\n</li>\n<li><p>删除主日志文件，并且flush日志文件目录。</p>\n</li>\n<li><p>完成（即删除，截断或使之无效）各自的日志文件</p>\n</li>\n<li><p>释放所有数据库文件上的排它锁。所有pager会返回到SHARED_LOCK或者NO_LOCK状态。pager无需清除页面缓存。</p>\n</li>\n</ol>\n<p>多数据库的提交点是在于他删除了主日志文件。</p>\n<p><strong>关于完成日志文件</strong>:当journal_mode持久存在时，日志文件将被截断为零大小，而不是使日志头无效。</p>\n<p><strong>注意</strong>:如果主数据库是个临时数据库或者内存数据库，SQLite是不保证多数据库事务的提交的原子性的。也就是说，全局恢复可能会有问题。它不会创建主日志文件。VM会依次挨个在每个数据库上做单独的提交。因此这个事务对于每一个数据库来说是原子的，但是期间一旦出现掉电之类的问题，可能会导致一部分数据库会执行恢复，而另一部分不会。</p>\n<p><strong>提交失败</strong>:用户事务是应用通过执行COMMIT命令自己提交的，然后SQLite尝试结束这个事务。正如之前提到的，尝试提交的事务可能会因为锁的冲突导致失败，并且返回SQLITE_BUSY。因为此时数据库上可能还有其他的读事务，如果是因为这个导致的失败，事务依旧保持激活状态，应用可以在之后再次发起尝试。SQLite不会自动做重试，需要应用自己去做。</p>\n<h3 id=\"语句级操作\"><a href=\"#语句级操作\" class=\"headerlink\" title=\"语句级操作\"></a>语句级操作</h3><p>语句级子事务被实现为在子事务结束时释放的匿名保存点。在语句子事务级别的一般操作有读，写和提交。下面我们将讨论这些。</p>\n<p><strong>读操作</strong>:语句子事务通过包含的用户事务读取页面。用户事务遵循所有规则。</p>\n<p><strong>写操作</strong>:在写事务中有两个部分:锁和日志。一个语句级的子事务通过包含的用户事务来请求锁。但是语句级的日志有一点点的不同，并且是由单独的临时语句级日志文件处理。(语句级的日志文件名是任意命名的，以<code>etilqs_</code>开头，临时文件。）pager会在语句级日志文件中写入一部分日志记录，还会在主回滚日志中写入一部分。当子事务尝试通过<code>sqlite3PagerWrite</code>操作使页面可写时，它将执行以下两个替代操作之一：</p>\n<ol>\n<li><p>如果页面不在回滚日志中，pager就会将新的日志记录添加进回滚日志中。(但是后续新的页面就不会加入log了。)</p>\n</li>\n<li><p>如果页面不在这个语句级的日志文件中，那么pager会把新的日志记录加入其中。(当语句级子事务在文件中写入第一条log记录的时候，pager就会创建语句级的日志文件。)</p>\n</li>\n</ol>\n<p>pager从来都不会flush语句级日志，因为这个从来都不需要失败恢复。如果出现了一个系统失败或掉电，主回滚日志将会负责数据库恢复。可以注意到，当一个页面即是回滚日志文件，又是语句级日志文件的时候，回滚日志文件中持有最旧版本的页面数据。</p>\n<p><strong>提交操作</strong>:语句提交非常简单，pager删除语句日志文件。(但是，看以下两个小节。)</p>\n<h3 id=\"设置保存点\"><a href=\"#设置保存点\" class=\"headerlink\" title=\"设置保存点\"></a>设置保存点</h3><p>当一个用户事务建立一个保存点的时候，SQLite就会进入保存点模式。在这个模式下，SQLite在语句提交的时候，不会删除语句级的日志。它会持有日志文件，直至事务释放了所有的保存点，或者提交事务，或者终止事务。在保存点模式下，日志记录有一点点区别:如果页面已经被前一个语句加入日志文件，那么这个页面将会被当前语句再次加入日志文件中。因此，语句级的日志对同一个数据库分页可以有多条记录。</p>\n<h3 id=\"释放保存点\"><a href=\"#释放保存点\" class=\"headerlink\" title=\"释放保存点\"></a>释放保存点</h3><p>当应用执行<code>release sp</code>命令的时候，SQLite会销毁对应的<code>PagerSavepoint</code>对象，以及那些在<code>sp</code>保存点之后建立的保存点。应用也无法再次引用那些保存点。</p>\n<h2 id=\"恢复处理流程\"><a href=\"#恢复处理流程\" class=\"headerlink\" title=\"恢复处理流程\"></a>恢复处理流程</h2><p>大部分的事务和语句子事务都是自己提交。但是偶尔情况下，一些事务和语句会自己终止。在很少的情况下，会出现一些应用和系统失败。无论哪种情况，SQLite都可能需要通过执行一些回滚操作将数据库恢复到可接受的一致状态。在前两种情况下(终止语句和事务)，恢复时会提供内存中的可靠信息。在后两种情况下(失败),数据库可能会出错，并且没有内存信息。在事务过程中，事务将还原到先前的保存点。在后面的小节内，将讨论这4个场景。</p>\n<h3 id=\"事务终止\"><a href=\"#事务终止\" class=\"headerlink\" title=\"事务终止\"></a>事务终止</h3><p>在SQLite里，从终止中恢复是很简单的。pager可能会，也可能不会从数据库文件中移除事务所带来的的影响。如果事务只持有了数据库文件上的保留锁或未决锁，那么它可以保证文件不被修改；pager完成释放日志文件，并且丢弃在页面缓存中所有的脏页面。否则，事务将会在数据库文件上持有一个排他锁，并且一些页面可能已经被事务回写到数据库文件了，pager就会执行下面的回滚操作。</p>\n<p>pager从回滚日志中一条一条读取日志记录，然后从日志记录中恢复页面数据。因此，在扫描日志文件的最后，数据库已经恢复到事务开始时的最初始状态了。如果事务已经将数据库扩展了，那么pager还会将数据库文件裁剪到原始的大小。pager会先flush数据库文件，然后接下来会完成释放回滚日志文件。它会释放排他锁，并且清空页面缓存。</p>\n<h3 id=\"语句级子事务终止\"><a href=\"#语句级子事务终止\" class=\"headerlink\" title=\"语句级子事务终止\"></a>语句级子事务终止</h3><p>正如之前所提到的，一个语句级的子事务可能同时会在回滚日志和语句级日志中添加日志记录。SQLite需要从语句级日志，以及一些主回滚日志中回滚所有的日志记录。每一个语句都会被当做一个匿名的保存点。所以一个语句的终止，就等同于恢复一个匿名保存点。我们在下面的章节中讨论这个。</p>\n<h3 id=\"回滚到保存点\"><a href=\"#回滚到保存点\" class=\"headerlink\" title=\"回滚到保存点\"></a>回滚到保存点</h3><p>在之前提到，当在保存点模式的时候，事务是不会删除语句级日志的。当事务执行了一个<code>roll to sp</code>命令的时候，SQLite同样会回滚在<code>sp</code>保存点之后建立的所有保存点。<code>PagerSavepoint</code>对象对应的三个成员变量起着至关重要的作用：<code>iOffset</code>，<code>iHdrOffset</code>和<code>iSubRec</code>。它首先回滚主回滚日志中的所有日志记录，从iOffset处开始直到日志文件结束。然后，它将回滚从<code>iSubRec</code>开始的语句日志中的所有日志记录，直到文件末尾来还原保存点。然而，在前一个情况下，如果<code>iHdrOffset</code>是非零，那么从主回滚日志中回滚日志记录会分为以下两步:(1)从<code>iOffset</code>到<code>iHdrOffset</code>以及(2)所有后续的日志段。在恢复的过程中，pager记下了哪些页面被回滚了，并确保页面不会被回滚超过一次。<code>Pager.dbSize</code>也会被回滚到保存点之前的大小(即PagerSavepoint.nOrig)。如果是恢复整个事务，那么只需要用到主回滚日志就行。SQLite会销毁所有在<code>sp</code>保存点之后创建的所有<code>PagerSavepoint</code>对象，但不包括<code>sp</code>自己。这些保存点对应用来说也都不可访问了。</p>\n<h3 id=\"失败恢复\"><a href=\"#失败恢复\" class=\"headerlink\" title=\"失败恢复\"></a>失败恢复</h3><p>在进程崩溃或者系统出错的时候，数据库文件中可能会遗留一些不一致的数据。当没有应用在更新数据库，并且存在回滚日志文件的时候，这就意味着之前的事务可能已经存在失败情况了，并且SQLite可能需要从失败带来的影响中恢复数据库。如果对应的数据库文件是未上锁或者只有共享锁的情况下，那么这个回滚日志文件可以说是激活状态的。但是如果日志文件是有多数据库事务创建的，并且没有主日志文件，那么这个日志文件并不是激活的。</p>\n<p><strong>判定日志是否激活</strong>:有两种情况:(1)如果不涉及多数据库的主日志，也就是说日志文件中没有出现主日志文件记录。如果日志文件存在，并且是有效的(有一个按格式化的日志头部并且不为0)，并且数据库文件上没有保留锁或者高于保留锁的锁，并且数据库不是空的，那么这个日志文件就是激活状态。(2)如果主数据库日志名出现在回滚日志文件中，并且主回滚日志存在，并且日志中引用了回滚日志文件，并且在对应的数据库文件上没有保留锁或者更高的锁，那么这个日志文件就是激活的。</p>\n<p><strong>警告</strong>:如果当前的应用是以只读的权限打开数据库文件，并且对文件或者对目录没有写权限，那么恢复就会失败，并且SQLite会返回特定的错误码。</p>\n<p>pager在想从数据库文件中第一次读取页面的时候，它会按照如下的恢复顺序来执行。</p>\n<ol>\n<li><p>它先在数据库文件上获取一个共享锁。(如果无法获取到这个锁，它就会返回给应用SQLITE_BUSY错误码。)</p>\n</li>\n<li><p>检查数据库上是否有一个激活的日志文件。如果数据库没有激活的日志文件，那么恢复操作就到此为止了。如果存在一个激活的日志文件，那么日志文件就会按照如下的步骤来回滚。</p>\n</li>\n<li><p>在数据库文件上获取一个排它锁。(pager不会在数据库上获取保留锁，因为这样会让其他的pager认为日志文件已经不再是激活状态了，然后它们就会直接读数据库。最后它是需要在数据库上获取一个排他锁，因为写入数据库是恢复工作的一部分。) 如果获取锁失败，那么就意味着此时有另一个pager正在尝试回滚。在那种情况下，它会释放所有的锁并且返回SQLITE_BUSY错误码给应用层。</p>\n</li>\n<li><p>从日志回滚文件中读取所有的日志记录，并且撤销这些日志(回滚)。这个操作会将数据库恢复到发生崩溃的事务开始时候的状态。并且数据库此时就在一致的状态了。如果需要的话，数据库文件还会被缩减到事务开始之前的大小。</p>\n</li>\n<li><p>flush刷新数据库文件。如果发生另一次电源故障或崩溃，这可以保护数据库的完整性。</p>\n</li>\n<li><p>释放(包括删除、无效化、或者裁剪)日志文件。</p>\n</li>\n<li><p>如果安全的话，删除主日志文件。</p>\n</li>\n<li><p>把锁降级到共享锁。(因为pager是在<code>sqlite3PagerGet</code>方法的内部执行的恢复。)</p>\n</li>\n</ol>\n<p>在以上的算法策略成功的执行之后，数据库文件此时就已经保证恢复到之前的状态了。此时再读取文件的时候就是安全的了。</p>\n<p><strong>过时的主日志文件</strong>:如果没有独立的回滚日志引用主日志文件，那么这个主日志文件就可以认为是过时的。pager会先读主日志文件，然后获取所有回滚日志文件的名字。然后，它分别检查每个回滚日记文件。如果每一个日志文件都存在，并且指向主日志文件，那么这个主日志文件就不是过时的。如果所有的回滚日志文件都不存在，或者他们指向了其他的主日志文件，或者没有指向主日志文件，那么这个主日志文件就是过时的，并且pager会删除掉这个主日志文件。没有要求说这个过时的主日志文件需要被删除。这样做的唯一原因就是为了释放磁盘空间。</p>\n<h2 id=\"其他的管理问题\"><a href=\"#其他的管理问题\" class=\"headerlink\" title=\"其他的管理问题\"></a>其他的管理问题</h2><h3 id=\"检查点\"><a href=\"#检查点\" class=\"headerlink\" title=\"检查点\"></a>检查点</h3><p>大部分数据库系统为了减小数据库失败的恢复压力，在固定的时间点都会有一个检查点。因为SQLite在同一个时间点同一个数据库上最多只会有一个写事务。日志文件中也只有当前事务的日志记录。SQLite会在事务完成的时候，处理掉日志文件。最终SQLite就不会有日志的积压，也不会需要去执行一个检查点，日志中也不会有检查点的逻辑。当事务提交的时候，数据库会保证在处理日志文件之前，将数据库的更新已经都写入数据库中了。(在SQLite3.7.0中，SQLite的开发者介绍了WAL日志特性。在这个日志模式下，会执行检查点。后续会讨论这个日志模式。)</p>\n<h3 id=\"空间约束\"><a href=\"#空间约束\" class=\"headerlink\" title=\"空间约束\"></a>空间约束</h3><p>在某些DBMS中，最麻烦的问题是日志空间不足。换句话树，就是文件系统没有足够的空间来给日志文件继续扩大写入新的日志记录。在某些DBMS中，中止事务会生成（补偿）日志记录，同时撤消某些更新，从而使情况进一步恶化。日志空间的不足可能会在那些系统中产生事务中止和系统重启的问题。但是SQLite不会，因为事务的终止不会产生任何新的日志记录。系统重启尽管也会有问题，但是只会在一些极端的场景下:事务会收缩数据库文件，并且释放的空间已经由本机文件系统分配用于其他目的。在这个情况下，恢复可能失败，因为SQLite已经无法将数据库文件恢复到原始的大小了。此时数据库就会被阻塞，直到所需的空间可用于数据库文件恢复到原始大小为止。</p>\n<p>还有一个其他的相关的问题:数据库文件没有足够的空间可以增长了。在这个场景下，pager会返回SQLITE_FULL错误码给应用，这有可能会终止事务。所以这也有可能会在SQLite中导致问题。</p>"},{"title":"WAL Mode","date":"2020-08-28T16:00:00.000Z","top":300,"_content":"\n在版本为release 3.7.0的版本上，SQLite介绍了一种新的日志机制，叫WAL日志。这个日志模式与传统回滚日志模式二选一。可以通过`pragma journal_mode=WAL`指令来开启这个模式。当数据库在WAL模式下(在Pager文章内提到，日志文件的头偏移量处于18位置的值是2)，SQLite就会完全使用WAL日志了。在wal日志模式下，日志文件的名字和数据库的名字一样，后面紧跟'-wal'后缀，并且会与原始数据库文件存在于同一个目录下。\n\n<!-- more -->\n\n在当前日志模式下，日志活动和传统日志的活动非常相似。写事务会在修改页面之前，将页面镜像放在日志记录中存储在日志内。(但是页面镜像是被更新或者新增后的新版本，俗称重做镜像。)当事务提交的时候，一个提交记录就会添加在wal日志文件的尾部。事务可能不会在数据库文件上请求独占锁，并且可能不会写入文件。这就避免了写事务阻塞了并发的读事务。读事务也不会阻塞写事务。新的写事务就持续将日志添加到wal日志文件中。\n\nwal日志文件的前32个字节表述了这个文件的格式。下表展示了wal日志文件头部的格式。它们都是4字节的无符号大端整型。这两个魔数确定了二选一的校验和算法用于计算每个日志帧的校验和。\n\n| 偏移 | 大小 | 描述 |\n| ---- | ---- | ---- |\n| 0 | 4 | 魔数:0x377f0682(小端整型) 或 0x377f0683(大端整型) |\n| 4 | 4 | 文件格式版本 |\n| 8 | 4 | 数据库页面大小 |\n| 12 | 4 | 检查点的序号值 |\n| 16 | 4 | 盐-1: 随机整数，每个检查点都递增 |\n| 20 | 4 | 盐-2: 诶个检查点都不同的随机整数 |\n| 24 | 4 | 校验和-1: 文件头24字节校验和的第一部分 |\n| 28 | 4 | 校验和-2: 文件头24字节校验和的第二部分 |\n\n在wal日志文件头后面，跟随着若干个日志帧。每一个日志帧由一个24字节的日志帧头开头，后面跟随着被日志记录的页面的内容。新的日志帧永远都会是被添加到日志文件的尾部。下面的表格展示了wal帧头部的格式。它们也都是4字节的无符号大端整型。\n\n| 偏移 | 大小 | 描述 |\n| ---- | ---- | ---- |\n| 0 | 4 | 当前被日志记录的页面的页面号 |\n| 4 | 4 | 对于提交记录来说，这个字段是提交后数据库文件的页面数。<br/>对其他记录来说，都为0 |\n| 8 | 4 | 盐-1 同WAL头 |\n| 12 | 4 | 盐-2 同WAL头 |\n| 16 | 4 | 校验和-1:当前帧的前8个字节和页面镜像内容的累计校验和的前第一部分 |\n| 20 | 4 | 校验和-2:当前帧的前8个字节和页面镜像内容的累计校验和的前第二部分 |\n\nwal日志的结构对读数据库会有一点影响。当pager开启一个新的读事务时，它会为这个事务记录在WAL日志中的最后的有效提交记录(即一个日志帧)的索引号。事务将使用此标记的帧作为所有后续读取操作的哨点。假设，pager请求在事务中读取页面p。它首先会在WAL日志文件中查找，看看在标记的页面帧之上或者之前是否存在这个页面p。在这种情况之下，标记帧之上的或者在标记帧之前的最后一个有效帧将会被读取使用。否则，pager就会从数据库文件中读取这个页面。并发的写事务确实可以将新的日志记录追加到日志文件的尾部，但是只要读事务忽略在标记帧之后追加的内容，那么它在某个时间点，就能看到数据库的一个具有一致性的快照。这个技术可以允许存在并发的读事务，看到数据库的不同版本。因为页面p的日志帧可以出现在wal日志文件的任何地方，所以pager需要从开头开始扫描查找这个页面p的日志帧，一直到那个哨兵帧。当事务开始的时候，日志文件已经很大了，那么这个扫描就会非常耗时。SQLite维护了一个单独的数据结构，名为`wal-index`来加快检索。它就是基于哈希索引来将一个页面号p映射到一个合适的日志帧内。\n\n`wal-index`通过共享内存或者内存映射文件来实现。被映射的文件和数据库文件在同一个目录下，并且在文件名后追加了'-shm'。(由于使用了共享内存和内存映射文件，因此当数据库文件在一个网络文件系统上，并且用户是位于不同的机器上时，wal日志模式不可使用。因为分布式客户端无法共享内存。)当与数据库的最后一个连接关闭时，SQLite会截断或使`wal-index`文件无效。这意味着`wal-index`文件是一个临时文件。崩溃恢复后，将从wal日志文件中重建`wal-index`文件。\n\n不像回滚日志的架构，wal日志的架构需要检查点来控制日志文件的大小。应用无需手动执行检查点，但是如果需要的话，也可以关闭自动检查点，从而可以在空闲时间或者其他线程或者其他进程内执行检查点。当wal日志文件的达到阈值为1000个页面的时候，SQLite会自动执行检查点。(可以通过在编译期设置SQLITE_DEFAULT_WAL_AUTOCHECKPOINT宏来设置不同的阈值。)检查点操作按有序执行，并且独占数据库。每次检查点的调用执行期间，SQLite按照如下次序执行:\n\n* 首先，flush刷新写入wal日志文件。\n* 第二，将有效的页面内容转移到数据库文件中去。\n* 第三，flush刷新写入到数据库文件中(仅当整个wal日志都被拷贝进数据库文件了)。\n* 第四，wal文件头部的盐-1值递增，盐-2值重随机。(使wal日志文件中的所有日志无效化。)\n* 第五，更新`wal-index`\n\n检查点操作可以与读事务并发执行。在这种情况下，检查点操作会在任何一个读事务的wal标记帧前停止操作。因为再执行下去，就有可能会影响到其中一个读事务正在读取的页面。检查点会记住它已经执行到的地方;下一次执行的时候，从那个地方再次继续。当整个wal日志都被检查点操作执行完毕的时候，日志就会被倒回以防止日志文件的无限制增长。因此一个长时间的读事务可能会导致检查点长时间无法执行，但是事务终归会终止，而检查点也终归会继续执行。\n\n相比于两次flush日志文件来说(对于普通的journal日志来说，第一次需要flush页面镜像，第二次需要flush`nRec`这个值，因为如果说一个扇区的写入可能是原子的，那么两个扇区的写入必然不是原子的)，WAL的写操作速度会变得非常快，因为它只有一次写和flush。如果应用愿意牺牲在系统掉电情况下数据库的耐久性，那么flush日志内容到磁盘也不是必须的。(可以通过设置`PRAGMA synchronous=FULL`来让每一个写事务都将日志flush到磁盘，设置`PRAGMA synchronous=NORMAL`来取消这个强制flush。)\n\n应用可以通过`sqlite3_wal_hook()`方法在任何一个事务即将提交给WAL的时候，回调hook的方法。回调方法中可以根据自己的需要来决定何时调用`sqlite3_wal_checkpoint()` 或 `sqlite3_wal_checkpoint_v2()` 来执行检查点。自动检查点就是通过`sqlite3_wal_hook()`做了一个简单实现。checkpoint一共有三种子类型，分别是PASSIVE，FULL，RESTART。通过`sqlite3_wal_checkpoint()`启动的检查点以及自动检查点都是属于PASSIVE类型，这也是默认的类型。这种子类型的检查点会因为数据库内并发存在读写事务而导致检查点的终止。FULL和RESTART类型均会尽最大能力去完成检查点的执行，这些子类型会通过调用`sqlite3_wal_checkpoint_v2()`函数来完成检查点。\n\n**校验和算法:**校验和的算法会将输入值划分为偶数个4字节的字节流。换句话说，校验和的输入值必须是8字节的整数倍。假设输入为x(0)-x(N),每个x为4字节，N为奇数，算法如下:\n\n```c\ns0 = s1 = 0\nfor i from 0 to n-1 step 2:\n   s0 += x(i) + s1;\n   s1 += x(i+1) + s0;\nend for\n//result in s0 and s1\n```\n\n输出s0和s1均为加权校验和，使用斐波纳契权重以相反的顺序进行。(最大斐波那契权重出现在求和序列的第一个元素上。)s1值覆盖序列的所有32位整数项，而s0省略最后一项。\n\n此功能有一些优点和缺点。\n\n优点是:\n1. 减少数据库文件上的flush刷新。\n2. 提高读写并发。\n3. 事务处理在大部分场景下更快。\n\n缺点是:\n1. 操作系统需要支持内存文件映射。\n2. 数据库文件等需要在本地机器上。\n3. 数据库文件不得挂载在NFS上。\n4. 数据库事务尽管在单个数据库中是原子的，但是跨数据库事务可能不是原子的。\n5. 事务回滚会更慢。\n6. 需要两个文件来支持(-wal,-shm)\n7. 检查点的存在。","source":"_posts/2020-08-29_db_system_design_imp(WAL).md","raw":"---\ntitle: WAL Mode\ndate: 2020-08-29\ntags: [sqlite3]\ntop: 300\ncategories: sqlite3\n---\n\n在版本为release 3.7.0的版本上，SQLite介绍了一种新的日志机制，叫WAL日志。这个日志模式与传统回滚日志模式二选一。可以通过`pragma journal_mode=WAL`指令来开启这个模式。当数据库在WAL模式下(在Pager文章内提到，日志文件的头偏移量处于18位置的值是2)，SQLite就会完全使用WAL日志了。在wal日志模式下，日志文件的名字和数据库的名字一样，后面紧跟'-wal'后缀，并且会与原始数据库文件存在于同一个目录下。\n\n<!-- more -->\n\n在当前日志模式下，日志活动和传统日志的活动非常相似。写事务会在修改页面之前，将页面镜像放在日志记录中存储在日志内。(但是页面镜像是被更新或者新增后的新版本，俗称重做镜像。)当事务提交的时候，一个提交记录就会添加在wal日志文件的尾部。事务可能不会在数据库文件上请求独占锁，并且可能不会写入文件。这就避免了写事务阻塞了并发的读事务。读事务也不会阻塞写事务。新的写事务就持续将日志添加到wal日志文件中。\n\nwal日志文件的前32个字节表述了这个文件的格式。下表展示了wal日志文件头部的格式。它们都是4字节的无符号大端整型。这两个魔数确定了二选一的校验和算法用于计算每个日志帧的校验和。\n\n| 偏移 | 大小 | 描述 |\n| ---- | ---- | ---- |\n| 0 | 4 | 魔数:0x377f0682(小端整型) 或 0x377f0683(大端整型) |\n| 4 | 4 | 文件格式版本 |\n| 8 | 4 | 数据库页面大小 |\n| 12 | 4 | 检查点的序号值 |\n| 16 | 4 | 盐-1: 随机整数，每个检查点都递增 |\n| 20 | 4 | 盐-2: 诶个检查点都不同的随机整数 |\n| 24 | 4 | 校验和-1: 文件头24字节校验和的第一部分 |\n| 28 | 4 | 校验和-2: 文件头24字节校验和的第二部分 |\n\n在wal日志文件头后面，跟随着若干个日志帧。每一个日志帧由一个24字节的日志帧头开头，后面跟随着被日志记录的页面的内容。新的日志帧永远都会是被添加到日志文件的尾部。下面的表格展示了wal帧头部的格式。它们也都是4字节的无符号大端整型。\n\n| 偏移 | 大小 | 描述 |\n| ---- | ---- | ---- |\n| 0 | 4 | 当前被日志记录的页面的页面号 |\n| 4 | 4 | 对于提交记录来说，这个字段是提交后数据库文件的页面数。<br/>对其他记录来说，都为0 |\n| 8 | 4 | 盐-1 同WAL头 |\n| 12 | 4 | 盐-2 同WAL头 |\n| 16 | 4 | 校验和-1:当前帧的前8个字节和页面镜像内容的累计校验和的前第一部分 |\n| 20 | 4 | 校验和-2:当前帧的前8个字节和页面镜像内容的累计校验和的前第二部分 |\n\nwal日志的结构对读数据库会有一点影响。当pager开启一个新的读事务时，它会为这个事务记录在WAL日志中的最后的有效提交记录(即一个日志帧)的索引号。事务将使用此标记的帧作为所有后续读取操作的哨点。假设，pager请求在事务中读取页面p。它首先会在WAL日志文件中查找，看看在标记的页面帧之上或者之前是否存在这个页面p。在这种情况之下，标记帧之上的或者在标记帧之前的最后一个有效帧将会被读取使用。否则，pager就会从数据库文件中读取这个页面。并发的写事务确实可以将新的日志记录追加到日志文件的尾部，但是只要读事务忽略在标记帧之后追加的内容，那么它在某个时间点，就能看到数据库的一个具有一致性的快照。这个技术可以允许存在并发的读事务，看到数据库的不同版本。因为页面p的日志帧可以出现在wal日志文件的任何地方，所以pager需要从开头开始扫描查找这个页面p的日志帧，一直到那个哨兵帧。当事务开始的时候，日志文件已经很大了，那么这个扫描就会非常耗时。SQLite维护了一个单独的数据结构，名为`wal-index`来加快检索。它就是基于哈希索引来将一个页面号p映射到一个合适的日志帧内。\n\n`wal-index`通过共享内存或者内存映射文件来实现。被映射的文件和数据库文件在同一个目录下，并且在文件名后追加了'-shm'。(由于使用了共享内存和内存映射文件，因此当数据库文件在一个网络文件系统上，并且用户是位于不同的机器上时，wal日志模式不可使用。因为分布式客户端无法共享内存。)当与数据库的最后一个连接关闭时，SQLite会截断或使`wal-index`文件无效。这意味着`wal-index`文件是一个临时文件。崩溃恢复后，将从wal日志文件中重建`wal-index`文件。\n\n不像回滚日志的架构，wal日志的架构需要检查点来控制日志文件的大小。应用无需手动执行检查点，但是如果需要的话，也可以关闭自动检查点，从而可以在空闲时间或者其他线程或者其他进程内执行检查点。当wal日志文件的达到阈值为1000个页面的时候，SQLite会自动执行检查点。(可以通过在编译期设置SQLITE_DEFAULT_WAL_AUTOCHECKPOINT宏来设置不同的阈值。)检查点操作按有序执行，并且独占数据库。每次检查点的调用执行期间，SQLite按照如下次序执行:\n\n* 首先，flush刷新写入wal日志文件。\n* 第二，将有效的页面内容转移到数据库文件中去。\n* 第三，flush刷新写入到数据库文件中(仅当整个wal日志都被拷贝进数据库文件了)。\n* 第四，wal文件头部的盐-1值递增，盐-2值重随机。(使wal日志文件中的所有日志无效化。)\n* 第五，更新`wal-index`\n\n检查点操作可以与读事务并发执行。在这种情况下，检查点操作会在任何一个读事务的wal标记帧前停止操作。因为再执行下去，就有可能会影响到其中一个读事务正在读取的页面。检查点会记住它已经执行到的地方;下一次执行的时候，从那个地方再次继续。当整个wal日志都被检查点操作执行完毕的时候，日志就会被倒回以防止日志文件的无限制增长。因此一个长时间的读事务可能会导致检查点长时间无法执行，但是事务终归会终止，而检查点也终归会继续执行。\n\n相比于两次flush日志文件来说(对于普通的journal日志来说，第一次需要flush页面镜像，第二次需要flush`nRec`这个值，因为如果说一个扇区的写入可能是原子的，那么两个扇区的写入必然不是原子的)，WAL的写操作速度会变得非常快，因为它只有一次写和flush。如果应用愿意牺牲在系统掉电情况下数据库的耐久性，那么flush日志内容到磁盘也不是必须的。(可以通过设置`PRAGMA synchronous=FULL`来让每一个写事务都将日志flush到磁盘，设置`PRAGMA synchronous=NORMAL`来取消这个强制flush。)\n\n应用可以通过`sqlite3_wal_hook()`方法在任何一个事务即将提交给WAL的时候，回调hook的方法。回调方法中可以根据自己的需要来决定何时调用`sqlite3_wal_checkpoint()` 或 `sqlite3_wal_checkpoint_v2()` 来执行检查点。自动检查点就是通过`sqlite3_wal_hook()`做了一个简单实现。checkpoint一共有三种子类型，分别是PASSIVE，FULL，RESTART。通过`sqlite3_wal_checkpoint()`启动的检查点以及自动检查点都是属于PASSIVE类型，这也是默认的类型。这种子类型的检查点会因为数据库内并发存在读写事务而导致检查点的终止。FULL和RESTART类型均会尽最大能力去完成检查点的执行，这些子类型会通过调用`sqlite3_wal_checkpoint_v2()`函数来完成检查点。\n\n**校验和算法:**校验和的算法会将输入值划分为偶数个4字节的字节流。换句话说，校验和的输入值必须是8字节的整数倍。假设输入为x(0)-x(N),每个x为4字节，N为奇数，算法如下:\n\n```c\ns0 = s1 = 0\nfor i from 0 to n-1 step 2:\n   s0 += x(i) + s1;\n   s1 += x(i+1) + s0;\nend for\n//result in s0 and s1\n```\n\n输出s0和s1均为加权校验和，使用斐波纳契权重以相反的顺序进行。(最大斐波那契权重出现在求和序列的第一个元素上。)s1值覆盖序列的所有32位整数项，而s0省略最后一项。\n\n此功能有一些优点和缺点。\n\n优点是:\n1. 减少数据库文件上的flush刷新。\n2. 提高读写并发。\n3. 事务处理在大部分场景下更快。\n\n缺点是:\n1. 操作系统需要支持内存文件映射。\n2. 数据库文件等需要在本地机器上。\n3. 数据库文件不得挂载在NFS上。\n4. 数据库事务尽管在单个数据库中是原子的，但是跨数据库事务可能不是原子的。\n5. 事务回滚会更慢。\n6. 需要两个文件来支持(-wal,-shm)\n7. 检查点的存在。","slug":"2020-08-29_db_system_design_imp(WAL)","published":1,"updated":"2022-07-28T13:38:40.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwod001np9c9c9cv86bf","content":"<p>在版本为release 3.7.0的版本上，SQLite介绍了一种新的日志机制，叫WAL日志。这个日志模式与传统回滚日志模式二选一。可以通过<code>pragma journal_mode=WAL</code>指令来开启这个模式。当数据库在WAL模式下(在Pager文章内提到，日志文件的头偏移量处于18位置的值是2)，SQLite就会完全使用WAL日志了。在wal日志模式下，日志文件的名字和数据库的名字一样，后面紧跟’-wal’后缀，并且会与原始数据库文件存在于同一个目录下。</p>\n<span id=\"more\"></span>\n\n<p>在当前日志模式下，日志活动和传统日志的活动非常相似。写事务会在修改页面之前，将页面镜像放在日志记录中存储在日志内。(但是页面镜像是被更新或者新增后的新版本，俗称重做镜像。)当事务提交的时候，一个提交记录就会添加在wal日志文件的尾部。事务可能不会在数据库文件上请求独占锁，并且可能不会写入文件。这就避免了写事务阻塞了并发的读事务。读事务也不会阻塞写事务。新的写事务就持续将日志添加到wal日志文件中。</p>\n<p>wal日志文件的前32个字节表述了这个文件的格式。下表展示了wal日志文件头部的格式。它们都是4字节的无符号大端整型。这两个魔数确定了二选一的校验和算法用于计算每个日志帧的校验和。</p>\n<table>\n<thead>\n<tr>\n<th>偏移</th>\n<th>大小</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>4</td>\n<td>魔数:0x377f0682(小端整型) 或 0x377f0683(大端整型)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>4</td>\n<td>文件格式版本</td>\n</tr>\n<tr>\n<td>8</td>\n<td>4</td>\n<td>数据库页面大小</td>\n</tr>\n<tr>\n<td>12</td>\n<td>4</td>\n<td>检查点的序号值</td>\n</tr>\n<tr>\n<td>16</td>\n<td>4</td>\n<td>盐-1: 随机整数，每个检查点都递增</td>\n</tr>\n<tr>\n<td>20</td>\n<td>4</td>\n<td>盐-2: 诶个检查点都不同的随机整数</td>\n</tr>\n<tr>\n<td>24</td>\n<td>4</td>\n<td>校验和-1: 文件头24字节校验和的第一部分</td>\n</tr>\n<tr>\n<td>28</td>\n<td>4</td>\n<td>校验和-2: 文件头24字节校验和的第二部分</td>\n</tr>\n</tbody></table>\n<p>在wal日志文件头后面，跟随着若干个日志帧。每一个日志帧由一个24字节的日志帧头开头，后面跟随着被日志记录的页面的内容。新的日志帧永远都会是被添加到日志文件的尾部。下面的表格展示了wal帧头部的格式。它们也都是4字节的无符号大端整型。</p>\n<table>\n<thead>\n<tr>\n<th>偏移</th>\n<th>大小</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>4</td>\n<td>当前被日志记录的页面的页面号</td>\n</tr>\n<tr>\n<td>4</td>\n<td>4</td>\n<td>对于提交记录来说，这个字段是提交后数据库文件的页面数。<br/>对其他记录来说，都为0</td>\n</tr>\n<tr>\n<td>8</td>\n<td>4</td>\n<td>盐-1 同WAL头</td>\n</tr>\n<tr>\n<td>12</td>\n<td>4</td>\n<td>盐-2 同WAL头</td>\n</tr>\n<tr>\n<td>16</td>\n<td>4</td>\n<td>校验和-1:当前帧的前8个字节和页面镜像内容的累计校验和的前第一部分</td>\n</tr>\n<tr>\n<td>20</td>\n<td>4</td>\n<td>校验和-2:当前帧的前8个字节和页面镜像内容的累计校验和的前第二部分</td>\n</tr>\n</tbody></table>\n<p>wal日志的结构对读数据库会有一点影响。当pager开启一个新的读事务时，它会为这个事务记录在WAL日志中的最后的有效提交记录(即一个日志帧)的索引号。事务将使用此标记的帧作为所有后续读取操作的哨点。假设，pager请求在事务中读取页面p。它首先会在WAL日志文件中查找，看看在标记的页面帧之上或者之前是否存在这个页面p。在这种情况之下，标记帧之上的或者在标记帧之前的最后一个有效帧将会被读取使用。否则，pager就会从数据库文件中读取这个页面。并发的写事务确实可以将新的日志记录追加到日志文件的尾部，但是只要读事务忽略在标记帧之后追加的内容，那么它在某个时间点，就能看到数据库的一个具有一致性的快照。这个技术可以允许存在并发的读事务，看到数据库的不同版本。因为页面p的日志帧可以出现在wal日志文件的任何地方，所以pager需要从开头开始扫描查找这个页面p的日志帧，一直到那个哨兵帧。当事务开始的时候，日志文件已经很大了，那么这个扫描就会非常耗时。SQLite维护了一个单独的数据结构，名为<code>wal-index</code>来加快检索。它就是基于哈希索引来将一个页面号p映射到一个合适的日志帧内。</p>\n<p><code>wal-index</code>通过共享内存或者内存映射文件来实现。被映射的文件和数据库文件在同一个目录下，并且在文件名后追加了’-shm’。(由于使用了共享内存和内存映射文件，因此当数据库文件在一个网络文件系统上，并且用户是位于不同的机器上时，wal日志模式不可使用。因为分布式客户端无法共享内存。)当与数据库的最后一个连接关闭时，SQLite会截断或使<code>wal-index</code>文件无效。这意味着<code>wal-index</code>文件是一个临时文件。崩溃恢复后，将从wal日志文件中重建<code>wal-index</code>文件。</p>\n<p>不像回滚日志的架构，wal日志的架构需要检查点来控制日志文件的大小。应用无需手动执行检查点，但是如果需要的话，也可以关闭自动检查点，从而可以在空闲时间或者其他线程或者其他进程内执行检查点。当wal日志文件的达到阈值为1000个页面的时候，SQLite会自动执行检查点。(可以通过在编译期设置SQLITE_DEFAULT_WAL_AUTOCHECKPOINT宏来设置不同的阈值。)检查点操作按有序执行，并且独占数据库。每次检查点的调用执行期间，SQLite按照如下次序执行:</p>\n<ul>\n<li>首先，flush刷新写入wal日志文件。</li>\n<li>第二，将有效的页面内容转移到数据库文件中去。</li>\n<li>第三，flush刷新写入到数据库文件中(仅当整个wal日志都被拷贝进数据库文件了)。</li>\n<li>第四，wal文件头部的盐-1值递增，盐-2值重随机。(使wal日志文件中的所有日志无效化。)</li>\n<li>第五，更新<code>wal-index</code></li>\n</ul>\n<p>检查点操作可以与读事务并发执行。在这种情况下，检查点操作会在任何一个读事务的wal标记帧前停止操作。因为再执行下去，就有可能会影响到其中一个读事务正在读取的页面。检查点会记住它已经执行到的地方;下一次执行的时候，从那个地方再次继续。当整个wal日志都被检查点操作执行完毕的时候，日志就会被倒回以防止日志文件的无限制增长。因此一个长时间的读事务可能会导致检查点长时间无法执行，但是事务终归会终止，而检查点也终归会继续执行。</p>\n<p>相比于两次flush日志文件来说(对于普通的journal日志来说，第一次需要flush页面镜像，第二次需要flush<code>nRec</code>这个值，因为如果说一个扇区的写入可能是原子的，那么两个扇区的写入必然不是原子的)，WAL的写操作速度会变得非常快，因为它只有一次写和flush。如果应用愿意牺牲在系统掉电情况下数据库的耐久性，那么flush日志内容到磁盘也不是必须的。(可以通过设置<code>PRAGMA synchronous=FULL</code>来让每一个写事务都将日志flush到磁盘，设置<code>PRAGMA synchronous=NORMAL</code>来取消这个强制flush。)</p>\n<p>应用可以通过<code>sqlite3_wal_hook()</code>方法在任何一个事务即将提交给WAL的时候，回调hook的方法。回调方法中可以根据自己的需要来决定何时调用<code>sqlite3_wal_checkpoint()</code> 或 <code>sqlite3_wal_checkpoint_v2()</code> 来执行检查点。自动检查点就是通过<code>sqlite3_wal_hook()</code>做了一个简单实现。checkpoint一共有三种子类型，分别是PASSIVE，FULL，RESTART。通过<code>sqlite3_wal_checkpoint()</code>启动的检查点以及自动检查点都是属于PASSIVE类型，这也是默认的类型。这种子类型的检查点会因为数据库内并发存在读写事务而导致检查点的终止。FULL和RESTART类型均会尽最大能力去完成检查点的执行，这些子类型会通过调用<code>sqlite3_wal_checkpoint_v2()</code>函数来完成检查点。</p>\n<p>**校验和算法:**校验和的算法会将输入值划分为偶数个4字节的字节流。换句话说，校验和的输入值必须是8字节的整数倍。假设输入为x(0)-x(N),每个x为4字节，N为奇数，算法如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s0 = s1 = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i from <span class=\"number\">0</span> to n<span class=\"number\">-1</span> step <span class=\"number\">2</span>:</span><br><span class=\"line\">   s0 += x(i) + s1;</span><br><span class=\"line\">   s1 += x(i+<span class=\"number\">1</span>) + s0;</span><br><span class=\"line\">end <span class=\"keyword\">for</span></span><br><span class=\"line\"><span class=\"comment\">//result in s0 and s1</span></span><br></pre></td></tr></table></figure>\n\n<p>输出s0和s1均为加权校验和，使用斐波纳契权重以相反的顺序进行。(最大斐波那契权重出现在求和序列的第一个元素上。)s1值覆盖序列的所有32位整数项，而s0省略最后一项。</p>\n<p>此功能有一些优点和缺点。</p>\n<p>优点是:</p>\n<ol>\n<li>减少数据库文件上的flush刷新。</li>\n<li>提高读写并发。</li>\n<li>事务处理在大部分场景下更快。</li>\n</ol>\n<p>缺点是:</p>\n<ol>\n<li>操作系统需要支持内存文件映射。</li>\n<li>数据库文件等需要在本地机器上。</li>\n<li>数据库文件不得挂载在NFS上。</li>\n<li>数据库事务尽管在单个数据库中是原子的，但是跨数据库事务可能不是原子的。</li>\n<li>事务回滚会更慢。</li>\n<li>需要两个文件来支持(-wal,-shm)</li>\n<li>检查点的存在。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在版本为release 3.7.0的版本上，SQLite介绍了一种新的日志机制，叫WAL日志。这个日志模式与传统回滚日志模式二选一。可以通过<code>pragma journal_mode=WAL</code>指令来开启这个模式。当数据库在WAL模式下(在Pager文章内提到，日志文件的头偏移量处于18位置的值是2)，SQLite就会完全使用WAL日志了。在wal日志模式下，日志文件的名字和数据库的名字一样，后面紧跟’-wal’后缀，并且会与原始数据库文件存在于同一个目录下。</p>","more":"<p>在当前日志模式下，日志活动和传统日志的活动非常相似。写事务会在修改页面之前，将页面镜像放在日志记录中存储在日志内。(但是页面镜像是被更新或者新增后的新版本，俗称重做镜像。)当事务提交的时候，一个提交记录就会添加在wal日志文件的尾部。事务可能不会在数据库文件上请求独占锁，并且可能不会写入文件。这就避免了写事务阻塞了并发的读事务。读事务也不会阻塞写事务。新的写事务就持续将日志添加到wal日志文件中。</p>\n<p>wal日志文件的前32个字节表述了这个文件的格式。下表展示了wal日志文件头部的格式。它们都是4字节的无符号大端整型。这两个魔数确定了二选一的校验和算法用于计算每个日志帧的校验和。</p>\n<table>\n<thead>\n<tr>\n<th>偏移</th>\n<th>大小</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>4</td>\n<td>魔数:0x377f0682(小端整型) 或 0x377f0683(大端整型)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>4</td>\n<td>文件格式版本</td>\n</tr>\n<tr>\n<td>8</td>\n<td>4</td>\n<td>数据库页面大小</td>\n</tr>\n<tr>\n<td>12</td>\n<td>4</td>\n<td>检查点的序号值</td>\n</tr>\n<tr>\n<td>16</td>\n<td>4</td>\n<td>盐-1: 随机整数，每个检查点都递增</td>\n</tr>\n<tr>\n<td>20</td>\n<td>4</td>\n<td>盐-2: 诶个检查点都不同的随机整数</td>\n</tr>\n<tr>\n<td>24</td>\n<td>4</td>\n<td>校验和-1: 文件头24字节校验和的第一部分</td>\n</tr>\n<tr>\n<td>28</td>\n<td>4</td>\n<td>校验和-2: 文件头24字节校验和的第二部分</td>\n</tr>\n</tbody></table>\n<p>在wal日志文件头后面，跟随着若干个日志帧。每一个日志帧由一个24字节的日志帧头开头，后面跟随着被日志记录的页面的内容。新的日志帧永远都会是被添加到日志文件的尾部。下面的表格展示了wal帧头部的格式。它们也都是4字节的无符号大端整型。</p>\n<table>\n<thead>\n<tr>\n<th>偏移</th>\n<th>大小</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>4</td>\n<td>当前被日志记录的页面的页面号</td>\n</tr>\n<tr>\n<td>4</td>\n<td>4</td>\n<td>对于提交记录来说，这个字段是提交后数据库文件的页面数。<br/>对其他记录来说，都为0</td>\n</tr>\n<tr>\n<td>8</td>\n<td>4</td>\n<td>盐-1 同WAL头</td>\n</tr>\n<tr>\n<td>12</td>\n<td>4</td>\n<td>盐-2 同WAL头</td>\n</tr>\n<tr>\n<td>16</td>\n<td>4</td>\n<td>校验和-1:当前帧的前8个字节和页面镜像内容的累计校验和的前第一部分</td>\n</tr>\n<tr>\n<td>20</td>\n<td>4</td>\n<td>校验和-2:当前帧的前8个字节和页面镜像内容的累计校验和的前第二部分</td>\n</tr>\n</tbody></table>\n<p>wal日志的结构对读数据库会有一点影响。当pager开启一个新的读事务时，它会为这个事务记录在WAL日志中的最后的有效提交记录(即一个日志帧)的索引号。事务将使用此标记的帧作为所有后续读取操作的哨点。假设，pager请求在事务中读取页面p。它首先会在WAL日志文件中查找，看看在标记的页面帧之上或者之前是否存在这个页面p。在这种情况之下，标记帧之上的或者在标记帧之前的最后一个有效帧将会被读取使用。否则，pager就会从数据库文件中读取这个页面。并发的写事务确实可以将新的日志记录追加到日志文件的尾部，但是只要读事务忽略在标记帧之后追加的内容，那么它在某个时间点，就能看到数据库的一个具有一致性的快照。这个技术可以允许存在并发的读事务，看到数据库的不同版本。因为页面p的日志帧可以出现在wal日志文件的任何地方，所以pager需要从开头开始扫描查找这个页面p的日志帧，一直到那个哨兵帧。当事务开始的时候，日志文件已经很大了，那么这个扫描就会非常耗时。SQLite维护了一个单独的数据结构，名为<code>wal-index</code>来加快检索。它就是基于哈希索引来将一个页面号p映射到一个合适的日志帧内。</p>\n<p><code>wal-index</code>通过共享内存或者内存映射文件来实现。被映射的文件和数据库文件在同一个目录下，并且在文件名后追加了’-shm’。(由于使用了共享内存和内存映射文件，因此当数据库文件在一个网络文件系统上，并且用户是位于不同的机器上时，wal日志模式不可使用。因为分布式客户端无法共享内存。)当与数据库的最后一个连接关闭时，SQLite会截断或使<code>wal-index</code>文件无效。这意味着<code>wal-index</code>文件是一个临时文件。崩溃恢复后，将从wal日志文件中重建<code>wal-index</code>文件。</p>\n<p>不像回滚日志的架构，wal日志的架构需要检查点来控制日志文件的大小。应用无需手动执行检查点，但是如果需要的话，也可以关闭自动检查点，从而可以在空闲时间或者其他线程或者其他进程内执行检查点。当wal日志文件的达到阈值为1000个页面的时候，SQLite会自动执行检查点。(可以通过在编译期设置SQLITE_DEFAULT_WAL_AUTOCHECKPOINT宏来设置不同的阈值。)检查点操作按有序执行，并且独占数据库。每次检查点的调用执行期间，SQLite按照如下次序执行:</p>\n<ul>\n<li>首先，flush刷新写入wal日志文件。</li>\n<li>第二，将有效的页面内容转移到数据库文件中去。</li>\n<li>第三，flush刷新写入到数据库文件中(仅当整个wal日志都被拷贝进数据库文件了)。</li>\n<li>第四，wal文件头部的盐-1值递增，盐-2值重随机。(使wal日志文件中的所有日志无效化。)</li>\n<li>第五，更新<code>wal-index</code></li>\n</ul>\n<p>检查点操作可以与读事务并发执行。在这种情况下，检查点操作会在任何一个读事务的wal标记帧前停止操作。因为再执行下去，就有可能会影响到其中一个读事务正在读取的页面。检查点会记住它已经执行到的地方;下一次执行的时候，从那个地方再次继续。当整个wal日志都被检查点操作执行完毕的时候，日志就会被倒回以防止日志文件的无限制增长。因此一个长时间的读事务可能会导致检查点长时间无法执行，但是事务终归会终止，而检查点也终归会继续执行。</p>\n<p>相比于两次flush日志文件来说(对于普通的journal日志来说，第一次需要flush页面镜像，第二次需要flush<code>nRec</code>这个值，因为如果说一个扇区的写入可能是原子的，那么两个扇区的写入必然不是原子的)，WAL的写操作速度会变得非常快，因为它只有一次写和flush。如果应用愿意牺牲在系统掉电情况下数据库的耐久性，那么flush日志内容到磁盘也不是必须的。(可以通过设置<code>PRAGMA synchronous=FULL</code>来让每一个写事务都将日志flush到磁盘，设置<code>PRAGMA synchronous=NORMAL</code>来取消这个强制flush。)</p>\n<p>应用可以通过<code>sqlite3_wal_hook()</code>方法在任何一个事务即将提交给WAL的时候，回调hook的方法。回调方法中可以根据自己的需要来决定何时调用<code>sqlite3_wal_checkpoint()</code> 或 <code>sqlite3_wal_checkpoint_v2()</code> 来执行检查点。自动检查点就是通过<code>sqlite3_wal_hook()</code>做了一个简单实现。checkpoint一共有三种子类型，分别是PASSIVE，FULL，RESTART。通过<code>sqlite3_wal_checkpoint()</code>启动的检查点以及自动检查点都是属于PASSIVE类型，这也是默认的类型。这种子类型的检查点会因为数据库内并发存在读写事务而导致检查点的终止。FULL和RESTART类型均会尽最大能力去完成检查点的执行，这些子类型会通过调用<code>sqlite3_wal_checkpoint_v2()</code>函数来完成检查点。</p>\n<p>**校验和算法:**校验和的算法会将输入值划分为偶数个4字节的字节流。换句话说，校验和的输入值必须是8字节的整数倍。假设输入为x(0)-x(N),每个x为4字节，N为奇数，算法如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s0 = s1 = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i from <span class=\"number\">0</span> to n<span class=\"number\">-1</span> step <span class=\"number\">2</span>:</span><br><span class=\"line\">   s0 += x(i) + s1;</span><br><span class=\"line\">   s1 += x(i+<span class=\"number\">1</span>) + s0;</span><br><span class=\"line\">end <span class=\"keyword\">for</span></span><br><span class=\"line\"><span class=\"comment\">//result in s0 and s1</span></span><br></pre></td></tr></table></figure>\n\n<p>输出s0和s1均为加权校验和，使用斐波纳契权重以相反的顺序进行。(最大斐波那契权重出现在求和序列的第一个元素上。)s1值覆盖序列的所有32位整数项，而s0省略最后一项。</p>\n<p>此功能有一些优点和缺点。</p>\n<p>优点是:</p>\n<ol>\n<li>减少数据库文件上的flush刷新。</li>\n<li>提高读写并发。</li>\n<li>事务处理在大部分场景下更快。</li>\n</ol>\n<p>缺点是:</p>\n<ol>\n<li>操作系统需要支持内存文件映射。</li>\n<li>数据库文件等需要在本地机器上。</li>\n<li>数据库文件不得挂载在NFS上。</li>\n<li>数据库事务尽管在单个数据库中是原子的，但是跨数据库事务可能不是原子的。</li>\n<li>事务回滚会更慢。</li>\n<li>需要两个文件来支持(-wal,-shm)</li>\n<li>检查点的存在。</li>\n</ol>"},{"title":"ARM64汇编分析常用指令、寄存器","date":"2022-07-19T16:00:00.000Z","top":501,"_content":"\nARM64 汇编快速查阅表 -- 持续更新...\n\n<!-- more -->\n\n## 常用寄存器\n\n### FP(x29) 寄存器\n\n64bit 栈底地址 通用寄存器\n\n### LR(x30) 寄存器\n\n64bit 程序链接寄存器，保存了当前程序执行完毕后返回的地址\n\n### SP寄存器\n\n64bit 栈顶地址 专用寄存器\n\n## 常用指令\n\n### 伪操作命令\n\n伪操作命令不是一个真正的命令，一般是在汇编代码中做标识符。例如对静态数据段中的数据类型进行描述\n\ndd命令: 双字型，即4个字节。\ndq命令: 4字型，即8个字节。\n\n### str 指令\n\n存储指令：将某个寄存器内的32位的值存到存储器中\n\n`str x0, [x1], #0x8`; 将x0中的4字节写入x1指向地址的存储器内，并将(x1 + 0x8)这个新地址写入 x1\n`str x0, [x1, #0x8]`; 将x0中的4字节写入(x1 + 0x8)指向地址的存储器内\n\n### sub 指令\n\n减法指令：\n\n`sub x0, x1, x2` ; 将寄存器 x1 和 x2 的值相减后保存到寄存器 x0 中 \n\n### stp 指令\n\n入栈指令：(str 指令的变种，可以同时操作两个寄存器)\n\n`stp x29, x30, [sp x10]`; 将 x29, x30 的值存入 sp 偏移 16 个字节的位置\n\n### adrp 指令\n\nPC寄存器偏移指令：将pc寄存器和立即数按照规则计算后将值赋值给另一个寄存器\n\n`adrp x8, #0x10011000`; 将PC寄存器的16进制的值，后三位清零后，加上立即数左移3位后的值，赋值给x8寄存器。\n\n\n## Q&A\n\n### FP/SP 寄存器\n\nFP是一个通用寄存器，在「某些时刻」会保存栈底的地址。而SP是一个专用寄存器，它在任何时刻保存的都是当前栈的栈顶位置。\n","source":"_posts/2022-07-20_ARM64_assmble.md","raw":"---\ntitle: ARM64汇编分析常用指令、寄存器\ndate: 2022-07-20\ntags: [汇编]\ntop: 501\ncategories: 汇编\n---\n\nARM64 汇编快速查阅表 -- 持续更新...\n\n<!-- more -->\n\n## 常用寄存器\n\n### FP(x29) 寄存器\n\n64bit 栈底地址 通用寄存器\n\n### LR(x30) 寄存器\n\n64bit 程序链接寄存器，保存了当前程序执行完毕后返回的地址\n\n### SP寄存器\n\n64bit 栈顶地址 专用寄存器\n\n## 常用指令\n\n### 伪操作命令\n\n伪操作命令不是一个真正的命令，一般是在汇编代码中做标识符。例如对静态数据段中的数据类型进行描述\n\ndd命令: 双字型，即4个字节。\ndq命令: 4字型，即8个字节。\n\n### str 指令\n\n存储指令：将某个寄存器内的32位的值存到存储器中\n\n`str x0, [x1], #0x8`; 将x0中的4字节写入x1指向地址的存储器内，并将(x1 + 0x8)这个新地址写入 x1\n`str x0, [x1, #0x8]`; 将x0中的4字节写入(x1 + 0x8)指向地址的存储器内\n\n### sub 指令\n\n减法指令：\n\n`sub x0, x1, x2` ; 将寄存器 x1 和 x2 的值相减后保存到寄存器 x0 中 \n\n### stp 指令\n\n入栈指令：(str 指令的变种，可以同时操作两个寄存器)\n\n`stp x29, x30, [sp x10]`; 将 x29, x30 的值存入 sp 偏移 16 个字节的位置\n\n### adrp 指令\n\nPC寄存器偏移指令：将pc寄存器和立即数按照规则计算后将值赋值给另一个寄存器\n\n`adrp x8, #0x10011000`; 将PC寄存器的16进制的值，后三位清零后，加上立即数左移3位后的值，赋值给x8寄存器。\n\n\n## Q&A\n\n### FP/SP 寄存器\n\nFP是一个通用寄存器，在「某些时刻」会保存栈底的地址。而SP是一个专用寄存器，它在任何时刻保存的都是当前栈的栈顶位置。\n","slug":"2022-07-20_ARM64_assmble","published":1,"updated":"2022-08-21T06:26:20.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwod001qp9c98kaih6hz","content":"<p>ARM64 汇编快速查阅表 – 持续更新…</p>\n<span id=\"more\"></span>\n\n<h2 id=\"常用寄存器\"><a href=\"#常用寄存器\" class=\"headerlink\" title=\"常用寄存器\"></a>常用寄存器</h2><h3 id=\"FP-x29-寄存器\"><a href=\"#FP-x29-寄存器\" class=\"headerlink\" title=\"FP(x29) 寄存器\"></a>FP(x29) 寄存器</h3><p>64bit 栈底地址 通用寄存器</p>\n<h3 id=\"LR-x30-寄存器\"><a href=\"#LR-x30-寄存器\" class=\"headerlink\" title=\"LR(x30) 寄存器\"></a>LR(x30) 寄存器</h3><p>64bit 程序链接寄存器，保存了当前程序执行完毕后返回的地址</p>\n<h3 id=\"SP寄存器\"><a href=\"#SP寄存器\" class=\"headerlink\" title=\"SP寄存器\"></a>SP寄存器</h3><p>64bit 栈顶地址 专用寄存器</p>\n<h2 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><h3 id=\"伪操作命令\"><a href=\"#伪操作命令\" class=\"headerlink\" title=\"伪操作命令\"></a>伪操作命令</h3><p>伪操作命令不是一个真正的命令，一般是在汇编代码中做标识符。例如对静态数据段中的数据类型进行描述</p>\n<p>dd命令: 双字型，即4个字节。<br>dq命令: 4字型，即8个字节。</p>\n<h3 id=\"str-指令\"><a href=\"#str-指令\" class=\"headerlink\" title=\"str 指令\"></a>str 指令</h3><p>存储指令：将某个寄存器内的32位的值存到存储器中</p>\n<p><code>str x0, [x1], #0x8</code>; 将x0中的4字节写入x1指向地址的存储器内，并将(x1 + 0x8)这个新地址写入 x1<br><code>str x0, [x1, #0x8]</code>; 将x0中的4字节写入(x1 + 0x8)指向地址的存储器内</p>\n<h3 id=\"sub-指令\"><a href=\"#sub-指令\" class=\"headerlink\" title=\"sub 指令\"></a>sub 指令</h3><p>减法指令：</p>\n<p><code>sub x0, x1, x2</code> ; 将寄存器 x1 和 x2 的值相减后保存到寄存器 x0 中 </p>\n<h3 id=\"stp-指令\"><a href=\"#stp-指令\" class=\"headerlink\" title=\"stp 指令\"></a>stp 指令</h3><p>入栈指令：(str 指令的变种，可以同时操作两个寄存器)</p>\n<p><code>stp x29, x30, [sp x10]</code>; 将 x29, x30 的值存入 sp 偏移 16 个字节的位置</p>\n<h3 id=\"adrp-指令\"><a href=\"#adrp-指令\" class=\"headerlink\" title=\"adrp 指令\"></a>adrp 指令</h3><p>PC寄存器偏移指令：将pc寄存器和立即数按照规则计算后将值赋值给另一个寄存器</p>\n<p><code>adrp x8, #0x10011000</code>; 将PC寄存器的16进制的值，后三位清零后，加上立即数左移3位后的值，赋值给x8寄存器。</p>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><h3 id=\"FP-x2F-SP-寄存器\"><a href=\"#FP-x2F-SP-寄存器\" class=\"headerlink\" title=\"FP&#x2F;SP 寄存器\"></a>FP&#x2F;SP 寄存器</h3><p>FP是一个通用寄存器，在「某些时刻」会保存栈底的地址。而SP是一个专用寄存器，它在任何时刻保存的都是当前栈的栈顶位置。</p>\n","site":{"data":{}},"excerpt":"<p>ARM64 汇编快速查阅表 – 持续更新…</p>","more":"<h2 id=\"常用寄存器\"><a href=\"#常用寄存器\" class=\"headerlink\" title=\"常用寄存器\"></a>常用寄存器</h2><h3 id=\"FP-x29-寄存器\"><a href=\"#FP-x29-寄存器\" class=\"headerlink\" title=\"FP(x29) 寄存器\"></a>FP(x29) 寄存器</h3><p>64bit 栈底地址 通用寄存器</p>\n<h3 id=\"LR-x30-寄存器\"><a href=\"#LR-x30-寄存器\" class=\"headerlink\" title=\"LR(x30) 寄存器\"></a>LR(x30) 寄存器</h3><p>64bit 程序链接寄存器，保存了当前程序执行完毕后返回的地址</p>\n<h3 id=\"SP寄存器\"><a href=\"#SP寄存器\" class=\"headerlink\" title=\"SP寄存器\"></a>SP寄存器</h3><p>64bit 栈顶地址 专用寄存器</p>\n<h2 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><h3 id=\"伪操作命令\"><a href=\"#伪操作命令\" class=\"headerlink\" title=\"伪操作命令\"></a>伪操作命令</h3><p>伪操作命令不是一个真正的命令，一般是在汇编代码中做标识符。例如对静态数据段中的数据类型进行描述</p>\n<p>dd命令: 双字型，即4个字节。<br>dq命令: 4字型，即8个字节。</p>\n<h3 id=\"str-指令\"><a href=\"#str-指令\" class=\"headerlink\" title=\"str 指令\"></a>str 指令</h3><p>存储指令：将某个寄存器内的32位的值存到存储器中</p>\n<p><code>str x0, [x1], #0x8</code>; 将x0中的4字节写入x1指向地址的存储器内，并将(x1 + 0x8)这个新地址写入 x1<br><code>str x0, [x1, #0x8]</code>; 将x0中的4字节写入(x1 + 0x8)指向地址的存储器内</p>\n<h3 id=\"sub-指令\"><a href=\"#sub-指令\" class=\"headerlink\" title=\"sub 指令\"></a>sub 指令</h3><p>减法指令：</p>\n<p><code>sub x0, x1, x2</code> ; 将寄存器 x1 和 x2 的值相减后保存到寄存器 x0 中 </p>\n<h3 id=\"stp-指令\"><a href=\"#stp-指令\" class=\"headerlink\" title=\"stp 指令\"></a>stp 指令</h3><p>入栈指令：(str 指令的变种，可以同时操作两个寄存器)</p>\n<p><code>stp x29, x30, [sp x10]</code>; 将 x29, x30 的值存入 sp 偏移 16 个字节的位置</p>\n<h3 id=\"adrp-指令\"><a href=\"#adrp-指令\" class=\"headerlink\" title=\"adrp 指令\"></a>adrp 指令</h3><p>PC寄存器偏移指令：将pc寄存器和立即数按照规则计算后将值赋值给另一个寄存器</p>\n<p><code>adrp x8, #0x10011000</code>; 将PC寄存器的16进制的值，后三位清零后，加上立即数左移3位后的值，赋值给x8寄存器。</p>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><h3 id=\"FP-x2F-SP-寄存器\"><a href=\"#FP-x2F-SP-寄存器\" class=\"headerlink\" title=\"FP&#x2F;SP 寄存器\"></a>FP&#x2F;SP 寄存器</h3><p>FP是一个通用寄存器，在「某些时刻」会保存栈底的地址。而SP是一个专用寄存器，它在任何时刻保存的都是当前栈的栈顶位置。</p>"},{"title":"理解C++内存排序和可见性","date":"2022-07-19T16:00:00.000Z","top":500,"_content":"\n本文主要总结了C++在原子操作上的内存模型以及内存排序标准。\n\n**相对**来说，C++已经是比较接近系统底层的语言了，C++设计也是希望如此，毕竟它本身已经如此复杂了。在C++ 11的标准里，推出了非常多的新特性，它们让C++变得非常灵活，而它们都依赖于标准里的多线程内存模型。但可能大部分的开发者都不知道这些，因为一般情况下，他们只需要通过mutex这一类高级的同步锁，来在多线程下解决数据竞争问题。至于这些锁是如何实现的，对他们来说并不重要。但是如果要接触到更底层的原理，或需要编写`lock-free`数据结构，亦或者是需要做更高性能的优化时，那么我们就需要理解这些更接近「机器语言」的数据结构和设计。有时候，一些原子类型或者原子操作，甚至可以让代码缩减到只有1-2个CPU指令。\n\n<!-- more -->\n\n## 为什么会有这篇文章\n\n`objc-block`的源码中，有一段C++实现的 objc-block-trampolines.mm 部分，其中有一个`lock-free`的设计。\n\n> 首先什么是`lock-free`？\n\n字面意思，`lock-free`就是无锁，简单的解释就是：一个系统设计，在**没有阻塞，没有锁**的情况下，实现多线程之间的数据同步。\n\n> 接下来直接看下这段剔除了无关代码之后的核心部分\n\n``` cpp\n// fixme C++ compilers don't implemement memory_order_consume efficiently.\n// Use memory_order_relaxed and cross our fingers.\n#define MEMORY_ORDER_CONSUME std::memory_order_relaxed\n\nstruct TrampolinePointers {\n    std::atomic<TrampolinePointers *> trampolines{nil};\n\n    TrampolinePointers *get() {\n        return trampolines.load(MEMORY_ORDER_CONSUME);\n    }\n\npublic:\n    void Initialize() {\n        if (get()) return;\n\n        // This code may be called concurrently.\n        // In the worst case we perform extra dyld operations.\n        void *dylib = dlopen(\"./libobjc-trampolines.dylib\",\n                             RTLD_NOW | RTLD_LOCAL | RTLD_FIRST);\n        if (!dylib) {\n            _objc_fatal(\"couldn't dlopen libobjc-trampolines.dylib: %s\",\n                        dlerror());\n        }\n\n        auto t = new TrampolinePointers(dylib);\n        TrampolinePointers *old = nil;\n        if (! trampolines.compare_exchange_strong(old, t, memory_order_release))\n        {\n            delete t;  // Lost an initialization race.\n        }\n    }\n};\n```\n\n代码实现了一个无锁的单例，单例对象为`trampolines`。其中`get()`和`Initialize()`函数是可以多线程并发执行的。\n\n首先`get()`无需解释，直接返回当前的单例对象。如果只有读操作，那在多线程环境下本身也没什么问题。（PS：这种设计下，单例是**有可能**返回空的）\n\n接着看`Initialize()`，它的本质其实是一个双判初始化操作，其中`if (get()) return;`是第一次判断，第二次判断就是`trampolines.compare_exchange_strong(old, t, memory_order_release)`：\n\n它将`trampolines`变量和`old`变量相比较，如果相等，那么就让`t`「替换」掉`trampolines`。\n\n这句代码等价于\n```cpp\nif (trampolines == null) {\n    trampolines = t;\n}\n```\n唯一不同的是，前者是一个**原子操作**。也就是说，虽然`Initialize()`函数可以有多线程并发执行，但是`compare_exchange_strong()`函数同时只有一个CPU可以执行，并且这个操作是不能被中断的。\n\n假设当前有两个线程在同时执行，在第一个线程将`trampolines`通过`compare_exchange_strong()`赋值后，第二个线程`compare_exchange_strong()`判断一定会返回false，这也就是为什么返回false，需要**释放**已创建的`t`。\n\n一切都可以合理解释，但是其中的第三个参数`memory_order_release`和`MEMORY_ORDER_CONSUME(memory_order_relaxed)`是用来做什么的？\n\n## 前序\n### 谈谈指令乱序\n\n在学校从导论中就已经了解到，现代CPU早已经进入了多核时代，现代的编程技术，也早已支持并发编程。分支预测，乱序执行，指令优化，都会让最终运行在机器上的代码，不再是我们编写代码的时候所预期的那样。\n\n除了这些以外，各类编译器还会根据自己的实现和规则，对编译的目标代码进行优化，指令重排就是这些优化中重要的一项，但指令重排对这些代码的开发者来说完全黑盒。\n\n下面用一段简单的代码来举个例子:\n``` cpp\nint A = 0;\nint B = 0;\n\nvoid func(void) {\n    A = 1;\n    if (B == 0) {\n        A = 2;\n    }\n}\n```\n\nClang编译上面这段代码后会产出如下的汇编：\n![memory_reorder_case1](memory_reorder_case1.jpg)\n\n可以很明显看到，先比较了B == 0，后加载了 A = 1；😱\n\n我们把我们看到的理解代码的顺序，暂且叫`代码顺序`，而这种不按照`代码顺序`来执行的编译器行为称之为`指令乱序`。从编译器的角度来看，它只需要保证**在单线程的情况下，代码能够正确地执行，并且符合单线程的预期即可**。就上面的代码而言，「看起来」和「执行结果」的确是没有问题的。但是在多线程环境下，这个结论就不再成立了。因为**编译器是不知道多线程环境下代码执行的先后顺序，也不知道哪些变量会在线程之间共享**，这个时候`指令乱序`会导致严重的后果。了解一下关于「锁」的反面例子：\n\n「锁」是绝大部分开发者在编程的时候，会选择用来解决多线程下的数据竞争问题。不论是mutex，还是自旋锁，用锁来保护临界区，是一个程序员的基本操作。那么按照上面编译器不可预知的`指令乱序`行为，如果「锁住」的临界区内的代码，在被编译优化后，理论上不会跑出临界区吗？比如我们把上面的代码稍微改一下。\n\n``` cpp\nint A = 0;\nmutex lck;\n\nvoid func(void) {\n    mutex.lock();\n    A = 1;\n    mutex.unlock();\n}\n```\n`A = 1`会不会跑出来？？\n\n线上暂无故障，我们肯定可以理直气壮地说，这个代码100%不会有问题的，那为什么呢？？？\n\n### 内存可见性\n\n除了指令乱序，还有一个问题会影响代码的一致性，那就是内存可见性。我们知道，CPU执行指令的速度，和内存的读写速度不是一个量级的，因此CPU引入了多级缓存，就像下面这样（原谅我的画功）：\n\n![2022-07-20_C++_memory_order](CPU_memory_struct.jpg)\n\n每个内核都有自己的L1，L2甚至L3缓存，为了提升运行速度，在内核读某个内存值的时候，如果在缓存内命中，那么很有可能就会直接使用缓存内的值；同样的，写入操作也有可能只会临时写入缓存；当触发缺页，或者某个回写机制的时候，这些缓存中的值才会真正刷新到主存中去。从这张图垂直得来看，其实每一个内核都有自己独立的缓存，而各个缓存之间的同步机制，会影响内存的「可见性」。\n\n举个例子 \n```cpp\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <atomic>         // std::atomic\nint v = 0;\nvoid plus()\n{\n    for(int i=0; i<10000; i++)\n    {\n        ++v;\n    }\n}\nint main()\n{\n    std::thread t1(plus);\n    std::thread t2(plus);\n    t1.join();\n    t2.join();\n    std::cout << \"v: \" << v << std::endl;\n}\n```\n\n上面这个例子, 在多核CPU上执行最终结果大概率是小于2000的。当一个内核(线程)在读取变量之后，另一个内核(线程)对它做了修改，但没有回写主存，也没有同步到其他内核(线程)中去的时候，就会出现不一致的情况。这块内存对于不同的线程的可见性也就不一致了。\n\n### 原子操作\n\n原子操作，就是在单核CPU上，一个CPU指令就能完成的操作，比如MOV，INC等等。如果一个操作需要多个指令来完成，那么在多个指令之间，有可能会触发系统中断，在中断过程中，修改了这个操作的中间变量，这个操作就不再「原子」。\n\nC++提供了`std::atomic`来实现原子操作, 还是上面那个例子，稍微改一下:\n```cpp\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <atomic>         // std::atomic\nstd::atomic<int> v(0);\nvoid plus()\n{\n    for(int i=0; i<10000; i++)\n    {\n        ++v;\n    }\n}\nint main()\n{\n    std::thread t1(plus);\n    std::thread t2(plus);\n    t1.join();\n    t2.join();\n    std::cout << \"v: \" << v << std::endl;\n}\n```\n这里的`++v`等价于 `v.fetch_add(1)`，它可以保证任意一个线程对v的修改，对其他线程是立刻可见的。保证了任意一个线程每次读到的v一定是当前的最新值。\n\n## 内存排序\n\n原子变量和原子操作其实已经解决了内存可见性问题，内存排序就是用来解决乱序问题。\n\n### 概念\n网文有很多在解释内存排序，都会提到这些概念，他们都来自[C++并发编程的标准文档](https://en.cppreference.com/w/cpp/thread)中。在解释模型之前，确实需要理清这些概念，避免后续解释混淆。\n\n> 先整体解释一下 `std:memory_order`\n\n`std:memory_order` 指定了一个原子操作的周围是如何来排序一些非原子操作的内存访问顺序的。在多核CPU上，某个线程观察到的变量的变化顺序，可能和真正修改这个变量的线程的写入顺序完全不一样，就是因为上面提到的`指令乱序`，甚至可能在单核CPU系统上依旧会存在相似的问题。标准库给到的默认行为是顺序一致性行为，这种会影响性能。但是除了原子能力，标准库提供了`std:memory_order`这个参数来指定特定约束。\n\n#### \"Sequence Before\"(**排序上在...之前**)\n\"Sequence Before\"是一种在单个线程内的两个调用(表达式)之间，非对称的，可传递的关系。\n* A **排序上在** B **之前** 等价于 B **排序上在** A **之后**, 前者 A 计算会在 B 计算开始之前结束。\n* 如果 A 不是**排序上在** B **之前**，并且 B 也不是**排序上在** A **之前**，那么就会有两种可能：\n  * A B 两次计算是无序的: A B计算可能在任一顺序，并且有多个重叠部分的情况下发生。\n  * A B 两次计算的顺序是随机的: A B计算可能是在任一顺序，但是没有重叠。如 A 在 B 开始之前结束，或者 B 在 A 开始之前结束。\n\n举个例子\n\n```cpp\nr1 = y.load(std::memory_order_relaxed); // A\nx.store(r1, std::memory_order_relaxed); // B\n```\n称 A 排序上在 B 之前\n\n#### \"Happens Before\"(在...之前发生)\n除了\"Sequence Before\"关系之外，\"Happens Before\"还包含了\"Inter-thread happens-before(**线程间，在...之前发生**)\"的关系\n\n#### 依赖关系\n在同一个线程内，A 计算**排序上在** B **之前**，还会给B附带上一个依赖关系（那就是 B 依赖 A），下面的表述都是 B 依赖 A。\n* A 计算的值被用来作为 B 计算的操作数，除了\n  * B 是 std::kill_dependency\n  * A 是内置的操作符 `&&` `||` `?:` 或者 `,`的左值\n  * A 向标量对象 M 写入，B 从 M 读取\n  * A 给另一个计算 X 引入依赖关系，而 X 给 B 又引入依赖关系。（即依赖的传递）\n\n\n\n### 三种内存模型\n\n**对原子操作**，C++有6种内存序列，分别是：\n1. `memory_order_relaxed`\n2. `memory_order_consume`\n3. `memory_order_acquire`\n4. `memory_order_release`\n5. `memory_order_acq_rel`\n6. `memory_order_seq_cst`\n\n在不指定的情况下，默认是`memory_order_seq_cst`。\n\n虽然有6种内存序列，但他们只对应了3种模型(其实是4种)，分别是：\n1. `sequentially consistent`（顺序一致性排序） 「`memory_order_seq_cst`」\n2. `acquire-release`（获取-释放序列）「`memory_order_acquire`, `memory_order_release`, `memory_order_acq_rel`」\n3. `relaxed`（松散序列）「`memory_order_relaxed`」\n\n第四种`consume-release`模型因为`memory_order_consume`序列目前在实现上有性能问题，不建议使用，也就不讨论这个。\n\n#### 顺序一致性的模型\n上面提到了，内存排序默认就是`memory_order_seq_cst`，对应的模型就是「顺序一致性排序模型」。\n\n顺序一致性，意思是在程序执行过程中，所有对于原子类型数据的操作，就像是我们从源码看上去，以我们所看到的那样。\n\n换句话说，顺序一致性，在多线程的环境下，原子类型的数据，将会像在单线程下处理一样 —— 一个操作接一个操作排好顺序来执行。到目前为止，这个顺序是最好理解的，在多线程环境下，每一个线程，对原子数据进行操作的优先级都是一样的。\n\n但是这也就意味着，多线程下对于这个原子的操作是无法被排序的，也就是说CPU是无法针对这些原子操作的前后进行编译优化的。\n\n#### 非顺序一致性的模型\n非顺序一致性的模型，包含两种，一种是「松散序列」，另一种是「获取-释放序列」。\n\n在这种模型下，就不再和上面一样有一个「全局有序的事件队列」了，细想一下这个模型在多线程下就会变得非常复杂了。在理解这种模型的时候，我们必须要抛开我们固有的多线程操作的心理预期模型，原子操作在不同线程中看到的将会是不同的样子。\n\n##### 松散序列\n\n松散序列是非顺序一致性模型中的一种，简单的来说，因为`指令乱序`的存在，使用「`memory_order_relaxed`」这一种模型，会让这个原子操作，「可能」出现在这个原子操作序列的任一阶段。换句话说，它只会保证操作的原子性与修改顺序的一致性（它只起到了原子操作的作用）。\n\n举一个例子来理解\n\n```cpp\nstd::automic<int> x = 0;\nstd::automic<int> y = 0;\n\n// 线程1\nr1 = y.load(std::memory_order_relaxed); // A\nx.store(r1, std::memory_order_relaxed); // B\n\n// 线程2\nr2 = x.load(std::memory_order_relaxed); // C \ny.store(42, std::memory_order_relaxed); // D\n```\n\n线程1 的操作为 A -> B, 线程B的操作为 C -> D, 所以如果按照顺序一致性的模型来理解的话，那么就会有下面的几种可能性\n1. A -> B -> C -> D\n2. A -> C -> B -> D\n3. A -> C -> D -> B\n4. C -> D -> A -> B\n5. C -> A -> D -> B\n6. C -> A -> B -> D\n\n这6种可能性执行完之后，r1=r2=0, 或 r1 = 42,r2 = 0;\n\n但是在松散序列下就不一样了，线程2中，y原子操作并不依赖任何操作，所以编译器可以选择将 D 操作顺序移动到 C 操作之前。\n所以，在上面的6种可能性中，C，D可以交换，产生12种可能性。结果中可能会产生 r1=42,r2=42 这种情况。\n\n再举个例子，这个例子来自「C++ Concurrency In Action」\n\n```cpp\n#include <atomic>\n#include <thread>\n#include <assert.h>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x_then_y()\n{\n    x.store(true,std::memory_order_relaxed); // A\n    y.store(true,std::memory_order_relaxed); // B\n}\n\nvoid read_y_then_x()\n{\n    while(!y.load(std::memory_order_relaxed)); // C\n    if(x.load(std::memory_order_relaxed)) { // D\n        ++z;\n    }\n}\n\nint main() {\n    x=false;\n    y=false;\n    z=0;\n    std::thread a(write_x_then_y);\n    std::thread b(read_y_then_x);\n    a.join();\n    b.join();\n    assert(z.load()!=0);\n}\n```\n\nx, y在同一个线程内「依次」原子写入 true。另一个线程内，在y写入true之后，判断x是否已经是true了，如果是则z++。\n\n从顺序一致性的模型来理解的话，断言是肯定不会触发的，因为在y变为true的时候，x一定已经是true了。\n\n但是同样的，在松散序列下，x,y 没有任何相互依赖关系。A，B操作是有可能会指令乱序的。所以在这个情况下，断言是有可能触发的。\n\n「`memory_order_relaxed`」这个模式最典型的运用就是`shared_ptr`引用计数中的计数+1部分\n\n```cpp\n#include <vector>\n#include <iostream>\n#include <thread>\n#include <atomic>\n \nstd::atomic<int> cnt = {0};\n \nvoid f()\n{\n    for (int n = 0; n < 1000; ++n) {\n        cnt.fetch_add(1, std::memory_order_relaxed);\n    }\n}\n \nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n    std::cout << \"Final counter value is \" << cnt << '\\n';\n}\n```\n\n因为`fetch_add`可以保证操作的原子性和修改内存的一致性，所以计数不会出错，而目的也只需要保证最终计数的准确性，这里使用`memory_order_relaxed`就可以达成目的。\n\n##### 获取-释放序列\n上面两个序列是两个极端，一种是非常严格的策略，另一种则是非常宽松，而`获取-释放序列`则是位于两者之间。\n\n| memory_order | description |\n| --- | --- |\n| memory_order_release | 仅用于 store 操作，当前线程内在 store 操作之后的任何内存读写操作都无法被重排到store操作之前 |\n| memory_order_acquire | 仅用于 load 操作，当前线程内在 load 操作之后的任何内存读写操作都无法被重排到load操作之后 |\n\n当线程A中的原子变量的`store`操作被标记为`memory_order_release`，而线程B中同一个原子变量的`load`操作被标记为`memory_order_acquire`属性的时候，**在**A线程中`store`操作**之前发生**的所有(非原子的和relax的)操作，都会在B线程`load`操作之后全部可见。也就是说，**需也仅需**`load`操作完成，那么B线程内可以看到A线程之前的所有写入操作。\n\n这种同步关系，只会建立在不同线程对于同一个原子变量的`release`和`acquire`操作之间，其他线程看到的顺序就不可预知了。\n\n一些互斥锁，例如std::mutex或者自旋锁，就是`release-acquire`内存同步的一个典型案例: 在线程A`release`之前，临界区内发生的所有事情，都必须在B`acquire`进入临界区后可见。\n\n![mutex_memory_case](mutex_memory_case.jpg)\n\n上图完整的解释了锁内临界区内的代码，是不可以被重排到临界区外的。\n\n再来看一个引用计数的减一例子：\n```cpp\ncontrol_block_ptr->Write(); \nif(control_block_ptr->refs.fetch_sub(1, std::memory_order_acq_rel) == 0)\n    delete control_block_ptr;\n```\n\n引用计数减一的时候这里用的是`acq_rel`, 而不再是`relax`了。因为这里涉及到了数据的销毁，看下如果依旧使用`relax`会发生什么。\n\n![shared_ptr_delete](shared_ptr_delete.jpg)\n\n对象的读写可能会被重排到 `fetch_sub` 之后，而此刻如果另一个线程同时也正在销毁对象的时候，发现`fetch_sub`已经是0了，随后就将数据销毁了。从线程B单个视角来看的话，销毁发生在对象写入之后，不会有异常产生。但是线程A和B同时执行的时候，A线程的写入操作，就有可能会发生在线程B的销毁之后了。\n\n如果这里对`fetch_sub`指定为`release`排序模型，禁止对象写入重排到原子操作后面。\n\n![shared_ptr_delete2](shared_ptr_delete2.jpg)\n\n这样一来，因为对象的写入操作永远保证在`fetch_sub`之前，那么`delete`操作之后也就不可能会出现对象写入操作（这里是指在引用计数的环境之下）。\n\n同样的原理需要考虑对象操作在`fetch_sub`之后，这时候就需要`acquire`操作。同时需要`acquire`和`release`，即`memory_order_acq_rel`。\n\n## 解释开始的问题\n\n> 为什么锁内临界区的代码不会被重排序到临界区之外？\n\n这个问题已经解释过了，`release-acquire`模型可以保证临界区的数据竞争问题。\n\n> 回头再来分析最开始的`lock-free`的代码\n\n`memory_order_consume` 这个模型在`cppreference`中定义和`memory_order_acquire`相似，只是其中只是依赖当前原子变量的读写操作，无法被排序到`consume`操作之前。\n\n是不是很眼熟？和`mutex`的设计如出一辙，只是它不再像`mutex`一样会阻塞线程。\n\n换个角度想，`Initialize()`函数内`get()`和`compare_exchange_strong()`之间的代码就是\"临界区\"，临界区的核心代码就是**将`trampolines`修改为t**\n\n但是因为实现的性能问题，`cppreference`不建议使用`consume`, 源码里更是直接将它改为了`relax`。\n\n从`临界区`的角度来思考，就是会将`临界区`内的代码重排到`get()`之前，比如说dlopen之后，调用了`get()`，然后`return`，造成内存泄漏。\n\n但是这里苹果还是将它改为了`relax`，然后只能在注释里祈祷🙏🏻`cross our fingers`，别出问题。\n\n## 参考文献\n[浅析C++ atomic 和 memory ordering](https://www.jb51.net/article/246087.htm)\n[聊一聊原子操作](https://www.huliujia.com/blog/df3c2e8a9ef77bd2ed0d83292778734eb395970c/)\n[内存乱序与C++内存模型详解](https://www.huliujia.com/blog/f85f72a3b3e3018ffe9c9d3c15dda0f5db079859/)\n[聊聊内存模型与内存序](https://www.ccppcoding.com/archives/221)\n[C++ 内存模型](https://paul.pub/cpp-memory-model/)\n[lock-free 编程介绍](https://colobu.com/2014/12/19/an-introduction-to-lock-free-programming/)\n[confusion-about-implementation-error-within-shared-ptr-destructor](https://stackoverflow.com/questions/14881056/confusion-about-implementation-error-within-shared-ptr-destructor)\n[memory-order-in-shared-pointer-destructor](https://stackoverflow.com/questions/49112732/)\n[cppreference](https://en.cppreference.com/w/cpp/language/eval_order)","source":"_posts/2022-07-20_C++_memory_order.md","raw":"---\ntitle: 理解C++内存排序和可见性\ndate: 2022-07-20\ntags: [C++]\ntop: 500\ncategories: C++\n---\n\n本文主要总结了C++在原子操作上的内存模型以及内存排序标准。\n\n**相对**来说，C++已经是比较接近系统底层的语言了，C++设计也是希望如此，毕竟它本身已经如此复杂了。在C++ 11的标准里，推出了非常多的新特性，它们让C++变得非常灵活，而它们都依赖于标准里的多线程内存模型。但可能大部分的开发者都不知道这些，因为一般情况下，他们只需要通过mutex这一类高级的同步锁，来在多线程下解决数据竞争问题。至于这些锁是如何实现的，对他们来说并不重要。但是如果要接触到更底层的原理，或需要编写`lock-free`数据结构，亦或者是需要做更高性能的优化时，那么我们就需要理解这些更接近「机器语言」的数据结构和设计。有时候，一些原子类型或者原子操作，甚至可以让代码缩减到只有1-2个CPU指令。\n\n<!-- more -->\n\n## 为什么会有这篇文章\n\n`objc-block`的源码中，有一段C++实现的 objc-block-trampolines.mm 部分，其中有一个`lock-free`的设计。\n\n> 首先什么是`lock-free`？\n\n字面意思，`lock-free`就是无锁，简单的解释就是：一个系统设计，在**没有阻塞，没有锁**的情况下，实现多线程之间的数据同步。\n\n> 接下来直接看下这段剔除了无关代码之后的核心部分\n\n``` cpp\n// fixme C++ compilers don't implemement memory_order_consume efficiently.\n// Use memory_order_relaxed and cross our fingers.\n#define MEMORY_ORDER_CONSUME std::memory_order_relaxed\n\nstruct TrampolinePointers {\n    std::atomic<TrampolinePointers *> trampolines{nil};\n\n    TrampolinePointers *get() {\n        return trampolines.load(MEMORY_ORDER_CONSUME);\n    }\n\npublic:\n    void Initialize() {\n        if (get()) return;\n\n        // This code may be called concurrently.\n        // In the worst case we perform extra dyld operations.\n        void *dylib = dlopen(\"./libobjc-trampolines.dylib\",\n                             RTLD_NOW | RTLD_LOCAL | RTLD_FIRST);\n        if (!dylib) {\n            _objc_fatal(\"couldn't dlopen libobjc-trampolines.dylib: %s\",\n                        dlerror());\n        }\n\n        auto t = new TrampolinePointers(dylib);\n        TrampolinePointers *old = nil;\n        if (! trampolines.compare_exchange_strong(old, t, memory_order_release))\n        {\n            delete t;  // Lost an initialization race.\n        }\n    }\n};\n```\n\n代码实现了一个无锁的单例，单例对象为`trampolines`。其中`get()`和`Initialize()`函数是可以多线程并发执行的。\n\n首先`get()`无需解释，直接返回当前的单例对象。如果只有读操作，那在多线程环境下本身也没什么问题。（PS：这种设计下，单例是**有可能**返回空的）\n\n接着看`Initialize()`，它的本质其实是一个双判初始化操作，其中`if (get()) return;`是第一次判断，第二次判断就是`trampolines.compare_exchange_strong(old, t, memory_order_release)`：\n\n它将`trampolines`变量和`old`变量相比较，如果相等，那么就让`t`「替换」掉`trampolines`。\n\n这句代码等价于\n```cpp\nif (trampolines == null) {\n    trampolines = t;\n}\n```\n唯一不同的是，前者是一个**原子操作**。也就是说，虽然`Initialize()`函数可以有多线程并发执行，但是`compare_exchange_strong()`函数同时只有一个CPU可以执行，并且这个操作是不能被中断的。\n\n假设当前有两个线程在同时执行，在第一个线程将`trampolines`通过`compare_exchange_strong()`赋值后，第二个线程`compare_exchange_strong()`判断一定会返回false，这也就是为什么返回false，需要**释放**已创建的`t`。\n\n一切都可以合理解释，但是其中的第三个参数`memory_order_release`和`MEMORY_ORDER_CONSUME(memory_order_relaxed)`是用来做什么的？\n\n## 前序\n### 谈谈指令乱序\n\n在学校从导论中就已经了解到，现代CPU早已经进入了多核时代，现代的编程技术，也早已支持并发编程。分支预测，乱序执行，指令优化，都会让最终运行在机器上的代码，不再是我们编写代码的时候所预期的那样。\n\n除了这些以外，各类编译器还会根据自己的实现和规则，对编译的目标代码进行优化，指令重排就是这些优化中重要的一项，但指令重排对这些代码的开发者来说完全黑盒。\n\n下面用一段简单的代码来举个例子:\n``` cpp\nint A = 0;\nint B = 0;\n\nvoid func(void) {\n    A = 1;\n    if (B == 0) {\n        A = 2;\n    }\n}\n```\n\nClang编译上面这段代码后会产出如下的汇编：\n![memory_reorder_case1](memory_reorder_case1.jpg)\n\n可以很明显看到，先比较了B == 0，后加载了 A = 1；😱\n\n我们把我们看到的理解代码的顺序，暂且叫`代码顺序`，而这种不按照`代码顺序`来执行的编译器行为称之为`指令乱序`。从编译器的角度来看，它只需要保证**在单线程的情况下，代码能够正确地执行，并且符合单线程的预期即可**。就上面的代码而言，「看起来」和「执行结果」的确是没有问题的。但是在多线程环境下，这个结论就不再成立了。因为**编译器是不知道多线程环境下代码执行的先后顺序，也不知道哪些变量会在线程之间共享**，这个时候`指令乱序`会导致严重的后果。了解一下关于「锁」的反面例子：\n\n「锁」是绝大部分开发者在编程的时候，会选择用来解决多线程下的数据竞争问题。不论是mutex，还是自旋锁，用锁来保护临界区，是一个程序员的基本操作。那么按照上面编译器不可预知的`指令乱序`行为，如果「锁住」的临界区内的代码，在被编译优化后，理论上不会跑出临界区吗？比如我们把上面的代码稍微改一下。\n\n``` cpp\nint A = 0;\nmutex lck;\n\nvoid func(void) {\n    mutex.lock();\n    A = 1;\n    mutex.unlock();\n}\n```\n`A = 1`会不会跑出来？？\n\n线上暂无故障，我们肯定可以理直气壮地说，这个代码100%不会有问题的，那为什么呢？？？\n\n### 内存可见性\n\n除了指令乱序，还有一个问题会影响代码的一致性，那就是内存可见性。我们知道，CPU执行指令的速度，和内存的读写速度不是一个量级的，因此CPU引入了多级缓存，就像下面这样（原谅我的画功）：\n\n![2022-07-20_C++_memory_order](CPU_memory_struct.jpg)\n\n每个内核都有自己的L1，L2甚至L3缓存，为了提升运行速度，在内核读某个内存值的时候，如果在缓存内命中，那么很有可能就会直接使用缓存内的值；同样的，写入操作也有可能只会临时写入缓存；当触发缺页，或者某个回写机制的时候，这些缓存中的值才会真正刷新到主存中去。从这张图垂直得来看，其实每一个内核都有自己独立的缓存，而各个缓存之间的同步机制，会影响内存的「可见性」。\n\n举个例子 \n```cpp\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <atomic>         // std::atomic\nint v = 0;\nvoid plus()\n{\n    for(int i=0; i<10000; i++)\n    {\n        ++v;\n    }\n}\nint main()\n{\n    std::thread t1(plus);\n    std::thread t2(plus);\n    t1.join();\n    t2.join();\n    std::cout << \"v: \" << v << std::endl;\n}\n```\n\n上面这个例子, 在多核CPU上执行最终结果大概率是小于2000的。当一个内核(线程)在读取变量之后，另一个内核(线程)对它做了修改，但没有回写主存，也没有同步到其他内核(线程)中去的时候，就会出现不一致的情况。这块内存对于不同的线程的可见性也就不一致了。\n\n### 原子操作\n\n原子操作，就是在单核CPU上，一个CPU指令就能完成的操作，比如MOV，INC等等。如果一个操作需要多个指令来完成，那么在多个指令之间，有可能会触发系统中断，在中断过程中，修改了这个操作的中间变量，这个操作就不再「原子」。\n\nC++提供了`std::atomic`来实现原子操作, 还是上面那个例子，稍微改一下:\n```cpp\n#include <iostream>       // std::cout\n#include <thread>         // std::thread\n#include <atomic>         // std::atomic\nstd::atomic<int> v(0);\nvoid plus()\n{\n    for(int i=0; i<10000; i++)\n    {\n        ++v;\n    }\n}\nint main()\n{\n    std::thread t1(plus);\n    std::thread t2(plus);\n    t1.join();\n    t2.join();\n    std::cout << \"v: \" << v << std::endl;\n}\n```\n这里的`++v`等价于 `v.fetch_add(1)`，它可以保证任意一个线程对v的修改，对其他线程是立刻可见的。保证了任意一个线程每次读到的v一定是当前的最新值。\n\n## 内存排序\n\n原子变量和原子操作其实已经解决了内存可见性问题，内存排序就是用来解决乱序问题。\n\n### 概念\n网文有很多在解释内存排序，都会提到这些概念，他们都来自[C++并发编程的标准文档](https://en.cppreference.com/w/cpp/thread)中。在解释模型之前，确实需要理清这些概念，避免后续解释混淆。\n\n> 先整体解释一下 `std:memory_order`\n\n`std:memory_order` 指定了一个原子操作的周围是如何来排序一些非原子操作的内存访问顺序的。在多核CPU上，某个线程观察到的变量的变化顺序，可能和真正修改这个变量的线程的写入顺序完全不一样，就是因为上面提到的`指令乱序`，甚至可能在单核CPU系统上依旧会存在相似的问题。标准库给到的默认行为是顺序一致性行为，这种会影响性能。但是除了原子能力，标准库提供了`std:memory_order`这个参数来指定特定约束。\n\n#### \"Sequence Before\"(**排序上在...之前**)\n\"Sequence Before\"是一种在单个线程内的两个调用(表达式)之间，非对称的，可传递的关系。\n* A **排序上在** B **之前** 等价于 B **排序上在** A **之后**, 前者 A 计算会在 B 计算开始之前结束。\n* 如果 A 不是**排序上在** B **之前**，并且 B 也不是**排序上在** A **之前**，那么就会有两种可能：\n  * A B 两次计算是无序的: A B计算可能在任一顺序，并且有多个重叠部分的情况下发生。\n  * A B 两次计算的顺序是随机的: A B计算可能是在任一顺序，但是没有重叠。如 A 在 B 开始之前结束，或者 B 在 A 开始之前结束。\n\n举个例子\n\n```cpp\nr1 = y.load(std::memory_order_relaxed); // A\nx.store(r1, std::memory_order_relaxed); // B\n```\n称 A 排序上在 B 之前\n\n#### \"Happens Before\"(在...之前发生)\n除了\"Sequence Before\"关系之外，\"Happens Before\"还包含了\"Inter-thread happens-before(**线程间，在...之前发生**)\"的关系\n\n#### 依赖关系\n在同一个线程内，A 计算**排序上在** B **之前**，还会给B附带上一个依赖关系（那就是 B 依赖 A），下面的表述都是 B 依赖 A。\n* A 计算的值被用来作为 B 计算的操作数，除了\n  * B 是 std::kill_dependency\n  * A 是内置的操作符 `&&` `||` `?:` 或者 `,`的左值\n  * A 向标量对象 M 写入，B 从 M 读取\n  * A 给另一个计算 X 引入依赖关系，而 X 给 B 又引入依赖关系。（即依赖的传递）\n\n\n\n### 三种内存模型\n\n**对原子操作**，C++有6种内存序列，分别是：\n1. `memory_order_relaxed`\n2. `memory_order_consume`\n3. `memory_order_acquire`\n4. `memory_order_release`\n5. `memory_order_acq_rel`\n6. `memory_order_seq_cst`\n\n在不指定的情况下，默认是`memory_order_seq_cst`。\n\n虽然有6种内存序列，但他们只对应了3种模型(其实是4种)，分别是：\n1. `sequentially consistent`（顺序一致性排序） 「`memory_order_seq_cst`」\n2. `acquire-release`（获取-释放序列）「`memory_order_acquire`, `memory_order_release`, `memory_order_acq_rel`」\n3. `relaxed`（松散序列）「`memory_order_relaxed`」\n\n第四种`consume-release`模型因为`memory_order_consume`序列目前在实现上有性能问题，不建议使用，也就不讨论这个。\n\n#### 顺序一致性的模型\n上面提到了，内存排序默认就是`memory_order_seq_cst`，对应的模型就是「顺序一致性排序模型」。\n\n顺序一致性，意思是在程序执行过程中，所有对于原子类型数据的操作，就像是我们从源码看上去，以我们所看到的那样。\n\n换句话说，顺序一致性，在多线程的环境下，原子类型的数据，将会像在单线程下处理一样 —— 一个操作接一个操作排好顺序来执行。到目前为止，这个顺序是最好理解的，在多线程环境下，每一个线程，对原子数据进行操作的优先级都是一样的。\n\n但是这也就意味着，多线程下对于这个原子的操作是无法被排序的，也就是说CPU是无法针对这些原子操作的前后进行编译优化的。\n\n#### 非顺序一致性的模型\n非顺序一致性的模型，包含两种，一种是「松散序列」，另一种是「获取-释放序列」。\n\n在这种模型下，就不再和上面一样有一个「全局有序的事件队列」了，细想一下这个模型在多线程下就会变得非常复杂了。在理解这种模型的时候，我们必须要抛开我们固有的多线程操作的心理预期模型，原子操作在不同线程中看到的将会是不同的样子。\n\n##### 松散序列\n\n松散序列是非顺序一致性模型中的一种，简单的来说，因为`指令乱序`的存在，使用「`memory_order_relaxed`」这一种模型，会让这个原子操作，「可能」出现在这个原子操作序列的任一阶段。换句话说，它只会保证操作的原子性与修改顺序的一致性（它只起到了原子操作的作用）。\n\n举一个例子来理解\n\n```cpp\nstd::automic<int> x = 0;\nstd::automic<int> y = 0;\n\n// 线程1\nr1 = y.load(std::memory_order_relaxed); // A\nx.store(r1, std::memory_order_relaxed); // B\n\n// 线程2\nr2 = x.load(std::memory_order_relaxed); // C \ny.store(42, std::memory_order_relaxed); // D\n```\n\n线程1 的操作为 A -> B, 线程B的操作为 C -> D, 所以如果按照顺序一致性的模型来理解的话，那么就会有下面的几种可能性\n1. A -> B -> C -> D\n2. A -> C -> B -> D\n3. A -> C -> D -> B\n4. C -> D -> A -> B\n5. C -> A -> D -> B\n6. C -> A -> B -> D\n\n这6种可能性执行完之后，r1=r2=0, 或 r1 = 42,r2 = 0;\n\n但是在松散序列下就不一样了，线程2中，y原子操作并不依赖任何操作，所以编译器可以选择将 D 操作顺序移动到 C 操作之前。\n所以，在上面的6种可能性中，C，D可以交换，产生12种可能性。结果中可能会产生 r1=42,r2=42 这种情况。\n\n再举个例子，这个例子来自「C++ Concurrency In Action」\n\n```cpp\n#include <atomic>\n#include <thread>\n#include <assert.h>\nstd::atomic<bool> x,y;\nstd::atomic<int> z;\nvoid write_x_then_y()\n{\n    x.store(true,std::memory_order_relaxed); // A\n    y.store(true,std::memory_order_relaxed); // B\n}\n\nvoid read_y_then_x()\n{\n    while(!y.load(std::memory_order_relaxed)); // C\n    if(x.load(std::memory_order_relaxed)) { // D\n        ++z;\n    }\n}\n\nint main() {\n    x=false;\n    y=false;\n    z=0;\n    std::thread a(write_x_then_y);\n    std::thread b(read_y_then_x);\n    a.join();\n    b.join();\n    assert(z.load()!=0);\n}\n```\n\nx, y在同一个线程内「依次」原子写入 true。另一个线程内，在y写入true之后，判断x是否已经是true了，如果是则z++。\n\n从顺序一致性的模型来理解的话，断言是肯定不会触发的，因为在y变为true的时候，x一定已经是true了。\n\n但是同样的，在松散序列下，x,y 没有任何相互依赖关系。A，B操作是有可能会指令乱序的。所以在这个情况下，断言是有可能触发的。\n\n「`memory_order_relaxed`」这个模式最典型的运用就是`shared_ptr`引用计数中的计数+1部分\n\n```cpp\n#include <vector>\n#include <iostream>\n#include <thread>\n#include <atomic>\n \nstd::atomic<int> cnt = {0};\n \nvoid f()\n{\n    for (int n = 0; n < 1000; ++n) {\n        cnt.fetch_add(1, std::memory_order_relaxed);\n    }\n}\n \nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n    std::cout << \"Final counter value is \" << cnt << '\\n';\n}\n```\n\n因为`fetch_add`可以保证操作的原子性和修改内存的一致性，所以计数不会出错，而目的也只需要保证最终计数的准确性，这里使用`memory_order_relaxed`就可以达成目的。\n\n##### 获取-释放序列\n上面两个序列是两个极端，一种是非常严格的策略，另一种则是非常宽松，而`获取-释放序列`则是位于两者之间。\n\n| memory_order | description |\n| --- | --- |\n| memory_order_release | 仅用于 store 操作，当前线程内在 store 操作之后的任何内存读写操作都无法被重排到store操作之前 |\n| memory_order_acquire | 仅用于 load 操作，当前线程内在 load 操作之后的任何内存读写操作都无法被重排到load操作之后 |\n\n当线程A中的原子变量的`store`操作被标记为`memory_order_release`，而线程B中同一个原子变量的`load`操作被标记为`memory_order_acquire`属性的时候，**在**A线程中`store`操作**之前发生**的所有(非原子的和relax的)操作，都会在B线程`load`操作之后全部可见。也就是说，**需也仅需**`load`操作完成，那么B线程内可以看到A线程之前的所有写入操作。\n\n这种同步关系，只会建立在不同线程对于同一个原子变量的`release`和`acquire`操作之间，其他线程看到的顺序就不可预知了。\n\n一些互斥锁，例如std::mutex或者自旋锁，就是`release-acquire`内存同步的一个典型案例: 在线程A`release`之前，临界区内发生的所有事情，都必须在B`acquire`进入临界区后可见。\n\n![mutex_memory_case](mutex_memory_case.jpg)\n\n上图完整的解释了锁内临界区内的代码，是不可以被重排到临界区外的。\n\n再来看一个引用计数的减一例子：\n```cpp\ncontrol_block_ptr->Write(); \nif(control_block_ptr->refs.fetch_sub(1, std::memory_order_acq_rel) == 0)\n    delete control_block_ptr;\n```\n\n引用计数减一的时候这里用的是`acq_rel`, 而不再是`relax`了。因为这里涉及到了数据的销毁，看下如果依旧使用`relax`会发生什么。\n\n![shared_ptr_delete](shared_ptr_delete.jpg)\n\n对象的读写可能会被重排到 `fetch_sub` 之后，而此刻如果另一个线程同时也正在销毁对象的时候，发现`fetch_sub`已经是0了，随后就将数据销毁了。从线程B单个视角来看的话，销毁发生在对象写入之后，不会有异常产生。但是线程A和B同时执行的时候，A线程的写入操作，就有可能会发生在线程B的销毁之后了。\n\n如果这里对`fetch_sub`指定为`release`排序模型，禁止对象写入重排到原子操作后面。\n\n![shared_ptr_delete2](shared_ptr_delete2.jpg)\n\n这样一来，因为对象的写入操作永远保证在`fetch_sub`之前，那么`delete`操作之后也就不可能会出现对象写入操作（这里是指在引用计数的环境之下）。\n\n同样的原理需要考虑对象操作在`fetch_sub`之后，这时候就需要`acquire`操作。同时需要`acquire`和`release`，即`memory_order_acq_rel`。\n\n## 解释开始的问题\n\n> 为什么锁内临界区的代码不会被重排序到临界区之外？\n\n这个问题已经解释过了，`release-acquire`模型可以保证临界区的数据竞争问题。\n\n> 回头再来分析最开始的`lock-free`的代码\n\n`memory_order_consume` 这个模型在`cppreference`中定义和`memory_order_acquire`相似，只是其中只是依赖当前原子变量的读写操作，无法被排序到`consume`操作之前。\n\n是不是很眼熟？和`mutex`的设计如出一辙，只是它不再像`mutex`一样会阻塞线程。\n\n换个角度想，`Initialize()`函数内`get()`和`compare_exchange_strong()`之间的代码就是\"临界区\"，临界区的核心代码就是**将`trampolines`修改为t**\n\n但是因为实现的性能问题，`cppreference`不建议使用`consume`, 源码里更是直接将它改为了`relax`。\n\n从`临界区`的角度来思考，就是会将`临界区`内的代码重排到`get()`之前，比如说dlopen之后，调用了`get()`，然后`return`，造成内存泄漏。\n\n但是这里苹果还是将它改为了`relax`，然后只能在注释里祈祷🙏🏻`cross our fingers`，别出问题。\n\n## 参考文献\n[浅析C++ atomic 和 memory ordering](https://www.jb51.net/article/246087.htm)\n[聊一聊原子操作](https://www.huliujia.com/blog/df3c2e8a9ef77bd2ed0d83292778734eb395970c/)\n[内存乱序与C++内存模型详解](https://www.huliujia.com/blog/f85f72a3b3e3018ffe9c9d3c15dda0f5db079859/)\n[聊聊内存模型与内存序](https://www.ccppcoding.com/archives/221)\n[C++ 内存模型](https://paul.pub/cpp-memory-model/)\n[lock-free 编程介绍](https://colobu.com/2014/12/19/an-introduction-to-lock-free-programming/)\n[confusion-about-implementation-error-within-shared-ptr-destructor](https://stackoverflow.com/questions/14881056/confusion-about-implementation-error-within-shared-ptr-destructor)\n[memory-order-in-shared-pointer-destructor](https://stackoverflow.com/questions/49112732/)\n[cppreference](https://en.cppreference.com/w/cpp/language/eval_order)","slug":"2022-07-20_C++_memory_order","published":1,"updated":"2022-08-21T14:40:17.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwoe001tp9c96nsd2s8m","content":"<p>本文主要总结了C++在原子操作上的内存模型以及内存排序标准。</p>\n<p><strong>相对</strong>来说，C++已经是比较接近系统底层的语言了，C++设计也是希望如此，毕竟它本身已经如此复杂了。在C++ 11的标准里，推出了非常多的新特性，它们让C++变得非常灵活，而它们都依赖于标准里的多线程内存模型。但可能大部分的开发者都不知道这些，因为一般情况下，他们只需要通过mutex这一类高级的同步锁，来在多线程下解决数据竞争问题。至于这些锁是如何实现的，对他们来说并不重要。但是如果要接触到更底层的原理，或需要编写<code>lock-free</code>数据结构，亦或者是需要做更高性能的优化时，那么我们就需要理解这些更接近「机器语言」的数据结构和设计。有时候，一些原子类型或者原子操作，甚至可以让代码缩减到只有1-2个CPU指令。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"为什么会有这篇文章\"><a href=\"#为什么会有这篇文章\" class=\"headerlink\" title=\"为什么会有这篇文章\"></a>为什么会有这篇文章</h2><p><code>objc-block</code>的源码中，有一段C++实现的 objc-block-trampolines.mm 部分，其中有一个<code>lock-free</code>的设计。</p>\n<blockquote>\n<p>首先什么是<code>lock-free</code>？</p>\n</blockquote>\n<p>字面意思，<code>lock-free</code>就是无锁，简单的解释就是：一个系统设计，在<strong>没有阻塞，没有锁</strong>的情况下，实现多线程之间的数据同步。</p>\n<blockquote>\n<p>接下来直接看下这段剔除了无关代码之后的核心部分</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fixme C++ compilers don&#x27;t implemement memory_order_consume efficiently.</span></span><br><span class=\"line\"><span class=\"comment\">// Use memory_order_relaxed and cross our fingers.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MEMORY_ORDER_CONSUME std::memory_order_relaxed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrampolinePointers</span> &#123;</span><br><span class=\"line\">    std::atomic&lt;TrampolinePointers *&gt; trampolines&#123;nil&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TrampolinePointers *<span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trampolines.<span class=\"built_in\">load</span>(MEMORY_ORDER_CONSUME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">get</span>()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This code may be called concurrently.</span></span><br><span class=\"line\">        <span class=\"comment\">// In the worst case we perform extra dyld operations.</span></span><br><span class=\"line\">        <span class=\"type\">void</span> *dylib = <span class=\"built_in\">dlopen</span>(<span class=\"string\">&quot;./libobjc-trampolines.dylib&quot;</span>,</span><br><span class=\"line\">                             RTLD_NOW | RTLD_LOCAL | RTLD_FIRST);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!dylib) &#123;</span><br><span class=\"line\">            _objc_fatal(<span class=\"string\">&quot;couldn&#x27;t dlopen libobjc-trampolines.dylib: %s&quot;</span>,</span><br><span class=\"line\">                        <span class=\"built_in\">dlerror</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">TrampolinePointers</span>(dylib);</span><br><span class=\"line\">        TrampolinePointers *old = nil;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! trampolines.<span class=\"built_in\">compare_exchange_strong</span>(old, t, memory_order_release))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> t;  <span class=\"comment\">// Lost an initialization race.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>代码实现了一个无锁的单例，单例对象为<code>trampolines</code>。其中<code>get()</code>和<code>Initialize()</code>函数是可以多线程并发执行的。</p>\n<p>首先<code>get()</code>无需解释，直接返回当前的单例对象。如果只有读操作，那在多线程环境下本身也没什么问题。（PS：这种设计下，单例是<strong>有可能</strong>返回空的）</p>\n<p>接着看<code>Initialize()</code>，它的本质其实是一个双判初始化操作，其中<code>if (get()) return;</code>是第一次判断，第二次判断就是<code>trampolines.compare_exchange_strong(old, t, memory_order_release)</code>：</p>\n<p>它将<code>trampolines</code>变量和<code>old</code>变量相比较，如果相等，那么就让<code>t</code>「替换」掉<code>trampolines</code>。</p>\n<p>这句代码等价于</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (trampolines == null) &#123;</span><br><span class=\"line\">    trampolines = t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>唯一不同的是，前者是一个<strong>原子操作</strong>。也就是说，虽然<code>Initialize()</code>函数可以有多线程并发执行，但是<code>compare_exchange_strong()</code>函数同时只有一个CPU可以执行，并且这个操作是不能被中断的。</p>\n<p>假设当前有两个线程在同时执行，在第一个线程将<code>trampolines</code>通过<code>compare_exchange_strong()</code>赋值后，第二个线程<code>compare_exchange_strong()</code>判断一定会返回false，这也就是为什么返回false，需要<strong>释放</strong>已创建的<code>t</code>。</p>\n<p>一切都可以合理解释，但是其中的第三个参数<code>memory_order_release</code>和<code>MEMORY_ORDER_CONSUME(memory_order_relaxed)</code>是用来做什么的？</p>\n<h2 id=\"前序\"><a href=\"#前序\" class=\"headerlink\" title=\"前序\"></a>前序</h2><h3 id=\"谈谈指令乱序\"><a href=\"#谈谈指令乱序\" class=\"headerlink\" title=\"谈谈指令乱序\"></a>谈谈指令乱序</h3><p>在学校从导论中就已经了解到，现代CPU早已经进入了多核时代，现代的编程技术，也早已支持并发编程。分支预测，乱序执行，指令优化，都会让最终运行在机器上的代码，不再是我们编写代码的时候所预期的那样。</p>\n<p>除了这些以外，各类编译器还会根据自己的实现和规则，对编译的目标代码进行优化，指令重排就是这些优化中重要的一项，但指令重排对这些代码的开发者来说完全黑盒。</p>\n<p>下面用一段简单的代码来举个例子:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> A = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> B = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    A = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (B == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        A = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Clang编译上面这段代码后会产出如下的汇编：<br><img src=\"/2022/07/20/2022-07-20_C++_memory_order/memory_reorder_case1.jpg\" alt=\"memory_reorder_case1\"></p>\n<p>可以很明显看到，先比较了B &#x3D;&#x3D; 0，后加载了 A &#x3D; 1；😱</p>\n<p>我们把我们看到的理解代码的顺序，暂且叫<code>代码顺序</code>，而这种不按照<code>代码顺序</code>来执行的编译器行为称之为<code>指令乱序</code>。从编译器的角度来看，它只需要保证<strong>在单线程的情况下，代码能够正确地执行，并且符合单线程的预期即可</strong>。就上面的代码而言，「看起来」和「执行结果」的确是没有问题的。但是在多线程环境下，这个结论就不再成立了。因为<strong>编译器是不知道多线程环境下代码执行的先后顺序，也不知道哪些变量会在线程之间共享</strong>，这个时候<code>指令乱序</code>会导致严重的后果。了解一下关于「锁」的反面例子：</p>\n<p>「锁」是绝大部分开发者在编程的时候，会选择用来解决多线程下的数据竞争问题。不论是mutex，还是自旋锁，用锁来保护临界区，是一个程序员的基本操作。那么按照上面编译器不可预知的<code>指令乱序</code>行为，如果「锁住」的临界区内的代码，在被编译优化后，理论上不会跑出临界区吗？比如我们把上面的代码稍微改一下。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> A = <span class=\"number\">0</span>;</span><br><span class=\"line\">mutex lck;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    mutex.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">    A = <span class=\"number\">1</span>;</span><br><span class=\"line\">    mutex.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>A = 1</code>会不会跑出来？？</p>\n<p>线上暂无故障，我们肯定可以理直气壮地说，这个代码100%不会有问题的，那为什么呢？？？</p>\n<h3 id=\"内存可见性\"><a href=\"#内存可见性\" class=\"headerlink\" title=\"内存可见性\"></a>内存可见性</h3><p>除了指令乱序，还有一个问题会影响代码的一致性，那就是内存可见性。我们知道，CPU执行指令的速度，和内存的读写速度不是一个量级的，因此CPU引入了多级缓存，就像下面这样（原谅我的画功）：</p>\n<p><img src=\"/2022/07/20/2022-07-20_C++_memory_order/CPU_memory_struct.jpg\" alt=\"2022-07-20_C++_memory_order\"></p>\n<p>每个内核都有自己的L1，L2甚至L3缓存，为了提升运行速度，在内核读某个内存值的时候，如果在缓存内命中，那么很有可能就会直接使用缓存内的值；同样的，写入操作也有可能只会临时写入缓存；当触发缺页，或者某个回写机制的时候，这些缓存中的值才会真正刷新到主存中去。从这张图垂直得来看，其实每一个内核都有自己独立的缓存，而各个缓存之间的同步机制，会影响内存的「可见性」。</p>\n<p>举个例子 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>       <span class=\"comment\">// std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span>         <span class=\"comment\">// std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span>         <span class=\"comment\">// std::atomic</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> v = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">plus</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ++v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">t1</span><span class=\"params\">(plus)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">t2</span><span class=\"params\">(plus)</span></span>;</span><br><span class=\"line\">    t1.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    t2.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;v: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个例子, 在多核CPU上执行最终结果大概率是小于2000的。当一个内核(线程)在读取变量之后，另一个内核(线程)对它做了修改，但没有回写主存，也没有同步到其他内核(线程)中去的时候，就会出现不一致的情况。这块内存对于不同的线程的可见性也就不一致了。</p>\n<h3 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h3><p>原子操作，就是在单核CPU上，一个CPU指令就能完成的操作，比如MOV，INC等等。如果一个操作需要多个指令来完成，那么在多个指令之间，有可能会触发系统中断，在中断过程中，修改了这个操作的中间变量，这个操作就不再「原子」。</p>\n<p>C++提供了<code>std::atomic</code>来实现原子操作, 还是上面那个例子，稍微改一下:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>       <span class=\"comment\">// std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span>         <span class=\"comment\">// std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span>         <span class=\"comment\">// std::atomic</span></span></span><br><span class=\"line\"><span class=\"function\">std::atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">plus</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ++v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">t1</span><span class=\"params\">(plus)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">t2</span><span class=\"params\">(plus)</span></span>;</span><br><span class=\"line\">    t1.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    t2.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;v: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的<code>++v</code>等价于 <code>v.fetch_add(1)</code>，它可以保证任意一个线程对v的修改，对其他线程是立刻可见的。保证了任意一个线程每次读到的v一定是当前的最新值。</p>\n<h2 id=\"内存排序\"><a href=\"#内存排序\" class=\"headerlink\" title=\"内存排序\"></a>内存排序</h2><p>原子变量和原子操作其实已经解决了内存可见性问题，内存排序就是用来解决乱序问题。</p>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>网文有很多在解释内存排序，都会提到这些概念，他们都来自<a href=\"https://en.cppreference.com/w/cpp/thread\">C++并发编程的标准文档</a>中。在解释模型之前，确实需要理清这些概念，避免后续解释混淆。</p>\n<blockquote>\n<p>先整体解释一下 <code>std:memory_order</code></p>\n</blockquote>\n<p><code>std:memory_order</code> 指定了一个原子操作的周围是如何来排序一些非原子操作的内存访问顺序的。在多核CPU上，某个线程观察到的变量的变化顺序，可能和真正修改这个变量的线程的写入顺序完全不一样，就是因为上面提到的<code>指令乱序</code>，甚至可能在单核CPU系统上依旧会存在相似的问题。标准库给到的默认行为是顺序一致性行为，这种会影响性能。但是除了原子能力，标准库提供了<code>std:memory_order</code>这个参数来指定特定约束。</p>\n<h4 id=\"“Sequence-Before”-排序上在…之前\"><a href=\"#“Sequence-Before”-排序上在…之前\" class=\"headerlink\" title=\"“Sequence Before”(排序上在…之前)\"></a>“Sequence Before”(<strong>排序上在…之前</strong>)</h4><p>“Sequence Before”是一种在单个线程内的两个调用(表达式)之间，非对称的，可传递的关系。</p>\n<ul>\n<li>A <strong>排序上在</strong> B <strong>之前</strong> 等价于 B <strong>排序上在</strong> A <strong>之后</strong>, 前者 A 计算会在 B 计算开始之前结束。</li>\n<li>如果 A 不是<strong>排序上在</strong> B <strong>之前</strong>，并且 B 也不是<strong>排序上在</strong> A <strong>之前</strong>，那么就会有两种可能：<ul>\n<li>A B 两次计算是无序的: A B计算可能在任一顺序，并且有多个重叠部分的情况下发生。</li>\n<li>A B 两次计算的顺序是随机的: A B计算可能是在任一顺序，但是没有重叠。如 A 在 B 开始之前结束，或者 B 在 A 开始之前结束。</li>\n</ul>\n</li>\n</ul>\n<p>举个例子</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r1 = y.<span class=\"built_in\">load</span>(std::memory_order_relaxed); <span class=\"comment\">// A</span></span><br><span class=\"line\">x.<span class=\"built_in\">store</span>(r1, std::memory_order_relaxed); <span class=\"comment\">// B</span></span><br></pre></td></tr></table></figure>\n<p>称 A 排序上在 B 之前</p>\n<h4 id=\"“Happens-Before”-在…之前发生\"><a href=\"#“Happens-Before”-在…之前发生\" class=\"headerlink\" title=\"“Happens Before”(在…之前发生)\"></a>“Happens Before”(在…之前发生)</h4><p>除了”Sequence Before”关系之外，”Happens Before”还包含了”Inter-thread happens-before(<strong>线程间，在…之前发生</strong>)”的关系</p>\n<h4 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h4><p>在同一个线程内，A 计算<strong>排序上在</strong> B <strong>之前</strong>，还会给B附带上一个依赖关系（那就是 B 依赖 A），下面的表述都是 B 依赖 A。</p>\n<ul>\n<li>A 计算的值被用来作为 B 计算的操作数，除了<ul>\n<li>B 是 std::kill_dependency</li>\n<li>A 是内置的操作符 <code>&amp;&amp;</code> <code>||</code> <code>?:</code> 或者 <code>,</code>的左值</li>\n<li>A 向标量对象 M 写入，B 从 M 读取</li>\n<li>A 给另一个计算 X 引入依赖关系，而 X 给 B 又引入依赖关系。（即依赖的传递）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三种内存模型\"><a href=\"#三种内存模型\" class=\"headerlink\" title=\"三种内存模型\"></a>三种内存模型</h3><p><strong>对原子操作</strong>，C++有6种内存序列，分别是：</p>\n<ol>\n<li><code>memory_order_relaxed</code></li>\n<li><code>memory_order_consume</code></li>\n<li><code>memory_order_acquire</code></li>\n<li><code>memory_order_release</code></li>\n<li><code>memory_order_acq_rel</code></li>\n<li><code>memory_order_seq_cst</code></li>\n</ol>\n<p>在不指定的情况下，默认是<code>memory_order_seq_cst</code>。</p>\n<p>虽然有6种内存序列，但他们只对应了3种模型(其实是4种)，分别是：</p>\n<ol>\n<li><code>sequentially consistent</code>（顺序一致性排序） 「<code>memory_order_seq_cst</code>」</li>\n<li><code>acquire-release</code>（获取-释放序列）「<code>memory_order_acquire</code>, <code>memory_order_release</code>, <code>memory_order_acq_rel</code>」</li>\n<li><code>relaxed</code>（松散序列）「<code>memory_order_relaxed</code>」</li>\n</ol>\n<p>第四种<code>consume-release</code>模型因为<code>memory_order_consume</code>序列目前在实现上有性能问题，不建议使用，也就不讨论这个。</p>\n<h4 id=\"顺序一致性的模型\"><a href=\"#顺序一致性的模型\" class=\"headerlink\" title=\"顺序一致性的模型\"></a>顺序一致性的模型</h4><p>上面提到了，内存排序默认就是<code>memory_order_seq_cst</code>，对应的模型就是「顺序一致性排序模型」。</p>\n<p>顺序一致性，意思是在程序执行过程中，所有对于原子类型数据的操作，就像是我们从源码看上去，以我们所看到的那样。</p>\n<p>换句话说，顺序一致性，在多线程的环境下，原子类型的数据，将会像在单线程下处理一样 —— 一个操作接一个操作排好顺序来执行。到目前为止，这个顺序是最好理解的，在多线程环境下，每一个线程，对原子数据进行操作的优先级都是一样的。</p>\n<p>但是这也就意味着，多线程下对于这个原子的操作是无法被排序的，也就是说CPU是无法针对这些原子操作的前后进行编译优化的。</p>\n<h4 id=\"非顺序一致性的模型\"><a href=\"#非顺序一致性的模型\" class=\"headerlink\" title=\"非顺序一致性的模型\"></a>非顺序一致性的模型</h4><p>非顺序一致性的模型，包含两种，一种是「松散序列」，另一种是「获取-释放序列」。</p>\n<p>在这种模型下，就不再和上面一样有一个「全局有序的事件队列」了，细想一下这个模型在多线程下就会变得非常复杂了。在理解这种模型的时候，我们必须要抛开我们固有的多线程操作的心理预期模型，原子操作在不同线程中看到的将会是不同的样子。</p>\n<h5 id=\"松散序列\"><a href=\"#松散序列\" class=\"headerlink\" title=\"松散序列\"></a>松散序列</h5><p>松散序列是非顺序一致性模型中的一种，简单的来说，因为<code>指令乱序</code>的存在，使用「<code>memory_order_relaxed</code>」这一种模型，会让这个原子操作，「可能」出现在这个原子操作序列的任一阶段。换句话说，它只会保证操作的原子性与修改顺序的一致性（它只起到了原子操作的作用）。</p>\n<p>举一个例子来理解</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::automic&lt;<span class=\"type\">int</span>&gt; x = <span class=\"number\">0</span>;</span><br><span class=\"line\">std::automic&lt;<span class=\"type\">int</span>&gt; y = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\">r1 = y.<span class=\"built_in\">load</span>(std::memory_order_relaxed); <span class=\"comment\">// A</span></span><br><span class=\"line\">x.<span class=\"built_in\">store</span>(r1, std::memory_order_relaxed); <span class=\"comment\">// B</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\">r2 = x.<span class=\"built_in\">load</span>(std::memory_order_relaxed); <span class=\"comment\">// C </span></span><br><span class=\"line\">y.<span class=\"built_in\">store</span>(<span class=\"number\">42</span>, std::memory_order_relaxed); <span class=\"comment\">// D</span></span><br></pre></td></tr></table></figure>\n\n<p>线程1 的操作为 A -&gt; B, 线程B的操作为 C -&gt; D, 所以如果按照顺序一致性的模型来理解的话，那么就会有下面的几种可能性</p>\n<ol>\n<li>A -&gt; B -&gt; C -&gt; D</li>\n<li>A -&gt; C -&gt; B -&gt; D</li>\n<li>A -&gt; C -&gt; D -&gt; B</li>\n<li>C -&gt; D -&gt; A -&gt; B</li>\n<li>C -&gt; A -&gt; D -&gt; B</li>\n<li>C -&gt; A -&gt; B -&gt; D</li>\n</ol>\n<p>这6种可能性执行完之后，r1&#x3D;r2&#x3D;0, 或 r1 &#x3D; 42,r2 &#x3D; 0;</p>\n<p>但是在松散序列下就不一样了，线程2中，y原子操作并不依赖任何操作，所以编译器可以选择将 D 操作顺序移动到 C 操作之前。<br>所以，在上面的6种可能性中，C，D可以交换，产生12种可能性。结果中可能会产生 r1&#x3D;42,r2&#x3D;42 这种情况。</p>\n<p>再举个例子，这个例子来自「C++ Concurrency In Action」</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\">std::atomic&lt;<span class=\"type\">bool</span>&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;<span class=\"type\">int</span>&gt; z;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">write_x_then_y</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    x.<span class=\"built_in\">store</span>(<span class=\"literal\">true</span>,std::memory_order_relaxed); <span class=\"comment\">// A</span></span><br><span class=\"line\">    y.<span class=\"built_in\">store</span>(<span class=\"literal\">true</span>,std::memory_order_relaxed); <span class=\"comment\">// B</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">read_y_then_x</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!y.<span class=\"built_in\">load</span>(std::memory_order_relaxed)); <span class=\"comment\">// C</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x.<span class=\"built_in\">load</span>(std::memory_order_relaxed)) &#123; <span class=\"comment\">// D</span></span><br><span class=\"line\">        ++z;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    x=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    y=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    z=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">a</span><span class=\"params\">(write_x_then_y)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">b</span><span class=\"params\">(read_y_then_x)</span></span>;</span><br><span class=\"line\">    a.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    b.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(z.<span class=\"built_in\">load</span>()!=<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>x, y在同一个线程内「依次」原子写入 true。另一个线程内，在y写入true之后，判断x是否已经是true了，如果是则z++。</p>\n<p>从顺序一致性的模型来理解的话，断言是肯定不会触发的，因为在y变为true的时候，x一定已经是true了。</p>\n<p>但是同样的，在松散序列下，x,y 没有任何相互依赖关系。A，B操作是有可能会指令乱序的。所以在这个情况下，断言是有可能触发的。</p>\n<p>「<code>memory_order_relaxed</code>」这个模式最典型的运用就是<code>shared_ptr</code>引用计数中的计数+1部分</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\">std::atomic&lt;<span class=\"type\">int</span>&gt; cnt = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> n = <span class=\"number\">0</span>; n &lt; <span class=\"number\">1000</span>; ++n) &#123;</span><br><span class=\"line\">        cnt.<span class=\"built_in\">fetch_add</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::thread&gt; v;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> n = <span class=\"number\">0</span>; n &lt; <span class=\"number\">10</span>; ++n) &#123;</span><br><span class=\"line\">        v.<span class=\"built_in\">emplace_back</span>(f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; t : v) &#123;</span><br><span class=\"line\">        t.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Final counter value is &quot;</span> &lt;&lt; cnt &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>fetch_add</code>可以保证操作的原子性和修改内存的一致性，所以计数不会出错，而目的也只需要保证最终计数的准确性，这里使用<code>memory_order_relaxed</code>就可以达成目的。</p>\n<h5 id=\"获取-释放序列\"><a href=\"#获取-释放序列\" class=\"headerlink\" title=\"获取-释放序列\"></a>获取-释放序列</h5><p>上面两个序列是两个极端，一种是非常严格的策略，另一种则是非常宽松，而<code>获取-释放序列</code>则是位于两者之间。</p>\n<table>\n<thead>\n<tr>\n<th>memory_order</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>memory_order_release</td>\n<td>仅用于 store 操作，当前线程内在 store 操作之后的任何内存读写操作都无法被重排到store操作之前</td>\n</tr>\n<tr>\n<td>memory_order_acquire</td>\n<td>仅用于 load 操作，当前线程内在 load 操作之后的任何内存读写操作都无法被重排到load操作之后</td>\n</tr>\n</tbody></table>\n<p>当线程A中的原子变量的<code>store</code>操作被标记为<code>memory_order_release</code>，而线程B中同一个原子变量的<code>load</code>操作被标记为<code>memory_order_acquire</code>属性的时候，<strong>在</strong>A线程中<code>store</code>操作<strong>之前发生</strong>的所有(非原子的和relax的)操作，都会在B线程<code>load</code>操作之后全部可见。也就是说，<strong>需也仅需</strong><code>load</code>操作完成，那么B线程内可以看到A线程之前的所有写入操作。</p>\n<p>这种同步关系，只会建立在不同线程对于同一个原子变量的<code>release</code>和<code>acquire</code>操作之间，其他线程看到的顺序就不可预知了。</p>\n<p>一些互斥锁，例如std::mutex或者自旋锁，就是<code>release-acquire</code>内存同步的一个典型案例: 在线程A<code>release</code>之前，临界区内发生的所有事情，都必须在B<code>acquire</code>进入临界区后可见。</p>\n<p><img src=\"/2022/07/20/2022-07-20_C++_memory_order/mutex_memory_case.jpg\" alt=\"mutex_memory_case\"></p>\n<p>上图完整的解释了锁内临界区内的代码，是不可以被重排到临界区外的。</p>\n<p>再来看一个引用计数的减一例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">control_block_ptr-&gt;<span class=\"built_in\">Write</span>(); </span><br><span class=\"line\"><span class=\"keyword\">if</span>(control_block_ptr-&gt;refs.<span class=\"built_in\">fetch_sub</span>(<span class=\"number\">1</span>, std::memory_order_acq_rel) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> control_block_ptr;</span><br></pre></td></tr></table></figure>\n\n<p>引用计数减一的时候这里用的是<code>acq_rel</code>, 而不再是<code>relax</code>了。因为这里涉及到了数据的销毁，看下如果依旧使用<code>relax</code>会发生什么。</p>\n<p><img src=\"/2022/07/20/2022-07-20_C++_memory_order/shared_ptr_delete.jpg\" alt=\"shared_ptr_delete\"></p>\n<p>对象的读写可能会被重排到 <code>fetch_sub</code> 之后，而此刻如果另一个线程同时也正在销毁对象的时候，发现<code>fetch_sub</code>已经是0了，随后就将数据销毁了。从线程B单个视角来看的话，销毁发生在对象写入之后，不会有异常产生。但是线程A和B同时执行的时候，A线程的写入操作，就有可能会发生在线程B的销毁之后了。</p>\n<p>如果这里对<code>fetch_sub</code>指定为<code>release</code>排序模型，禁止对象写入重排到原子操作后面。</p>\n<p><img src=\"/2022/07/20/2022-07-20_C++_memory_order/shared_ptr_delete2.jpg\" alt=\"shared_ptr_delete2\"></p>\n<p>这样一来，因为对象的写入操作永远保证在<code>fetch_sub</code>之前，那么<code>delete</code>操作之后也就不可能会出现对象写入操作（这里是指在引用计数的环境之下）。</p>\n<p>同样的原理需要考虑对象操作在<code>fetch_sub</code>之后，这时候就需要<code>acquire</code>操作。同时需要<code>acquire</code>和<code>release</code>，即<code>memory_order_acq_rel</code>。</p>\n<h2 id=\"解释开始的问题\"><a href=\"#解释开始的问题\" class=\"headerlink\" title=\"解释开始的问题\"></a>解释开始的问题</h2><blockquote>\n<p>为什么锁内临界区的代码不会被重排序到临界区之外？</p>\n</blockquote>\n<p>这个问题已经解释过了，<code>release-acquire</code>模型可以保证临界区的数据竞争问题。</p>\n<blockquote>\n<p>回头再来分析最开始的<code>lock-free</code>的代码</p>\n</blockquote>\n<p><code>memory_order_consume</code> 这个模型在<code>cppreference</code>中定义和<code>memory_order_acquire</code>相似，只是其中只是依赖当前原子变量的读写操作，无法被排序到<code>consume</code>操作之前。</p>\n<p>是不是很眼熟？和<code>mutex</code>的设计如出一辙，只是它不再像<code>mutex</code>一样会阻塞线程。</p>\n<p>换个角度想，<code>Initialize()</code>函数内<code>get()</code>和<code>compare_exchange_strong()</code>之间的代码就是”临界区”，临界区的核心代码就是<strong>将<code>trampolines</code>修改为t</strong></p>\n<p>但是因为实现的性能问题，<code>cppreference</code>不建议使用<code>consume</code>, 源码里更是直接将它改为了<code>relax</code>。</p>\n<p>从<code>临界区</code>的角度来思考，就是会将<code>临界区</code>内的代码重排到<code>get()</code>之前，比如说dlopen之后，调用了<code>get()</code>，然后<code>return</code>，造成内存泄漏。</p>\n<p>但是这里苹果还是将它改为了<code>relax</code>，然后只能在注释里祈祷🙏🏻<code>cross our fingers</code>，别出问题。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.jb51.net/article/246087.htm\">浅析C++ atomic 和 memory ordering</a><br><a href=\"https://www.huliujia.com/blog/df3c2e8a9ef77bd2ed0d83292778734eb395970c/\">聊一聊原子操作</a><br><a href=\"https://www.huliujia.com/blog/f85f72a3b3e3018ffe9c9d3c15dda0f5db079859/\">内存乱序与C++内存模型详解</a><br><a href=\"https://www.ccppcoding.com/archives/221\">聊聊内存模型与内存序</a><br><a href=\"https://paul.pub/cpp-memory-model/\">C++ 内存模型</a><br><a href=\"https://colobu.com/2014/12/19/an-introduction-to-lock-free-programming/\">lock-free 编程介绍</a><br><a href=\"https://stackoverflow.com/questions/14881056/confusion-about-implementation-error-within-shared-ptr-destructor\">confusion-about-implementation-error-within-shared-ptr-destructor</a><br><a href=\"https://stackoverflow.com/questions/49112732/\">memory-order-in-shared-pointer-destructor</a><br><a href=\"https://en.cppreference.com/w/cpp/language/eval_order\">cppreference</a></p>\n","site":{"data":{}},"excerpt":"<p>本文主要总结了C++在原子操作上的内存模型以及内存排序标准。</p>\n<p><strong>相对</strong>来说，C++已经是比较接近系统底层的语言了，C++设计也是希望如此，毕竟它本身已经如此复杂了。在C++ 11的标准里，推出了非常多的新特性，它们让C++变得非常灵活，而它们都依赖于标准里的多线程内存模型。但可能大部分的开发者都不知道这些，因为一般情况下，他们只需要通过mutex这一类高级的同步锁，来在多线程下解决数据竞争问题。至于这些锁是如何实现的，对他们来说并不重要。但是如果要接触到更底层的原理，或需要编写<code>lock-free</code>数据结构，亦或者是需要做更高性能的优化时，那么我们就需要理解这些更接近「机器语言」的数据结构和设计。有时候，一些原子类型或者原子操作，甚至可以让代码缩减到只有1-2个CPU指令。</p>","more":"<h2 id=\"为什么会有这篇文章\"><a href=\"#为什么会有这篇文章\" class=\"headerlink\" title=\"为什么会有这篇文章\"></a>为什么会有这篇文章</h2><p><code>objc-block</code>的源码中，有一段C++实现的 objc-block-trampolines.mm 部分，其中有一个<code>lock-free</code>的设计。</p>\n<blockquote>\n<p>首先什么是<code>lock-free</code>？</p>\n</blockquote>\n<p>字面意思，<code>lock-free</code>就是无锁，简单的解释就是：一个系统设计，在<strong>没有阻塞，没有锁</strong>的情况下，实现多线程之间的数据同步。</p>\n<blockquote>\n<p>接下来直接看下这段剔除了无关代码之后的核心部分</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fixme C++ compilers don&#x27;t implemement memory_order_consume efficiently.</span></span><br><span class=\"line\"><span class=\"comment\">// Use memory_order_relaxed and cross our fingers.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MEMORY_ORDER_CONSUME std::memory_order_relaxed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TrampolinePointers</span> &#123;</span><br><span class=\"line\">    std::atomic&lt;TrampolinePointers *&gt; trampolines&#123;nil&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TrampolinePointers *<span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trampolines.<span class=\"built_in\">load</span>(MEMORY_ORDER_CONSUME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">get</span>()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This code may be called concurrently.</span></span><br><span class=\"line\">        <span class=\"comment\">// In the worst case we perform extra dyld operations.</span></span><br><span class=\"line\">        <span class=\"type\">void</span> *dylib = <span class=\"built_in\">dlopen</span>(<span class=\"string\">&quot;./libobjc-trampolines.dylib&quot;</span>,</span><br><span class=\"line\">                             RTLD_NOW | RTLD_LOCAL | RTLD_FIRST);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!dylib) &#123;</span><br><span class=\"line\">            _objc_fatal(<span class=\"string\">&quot;couldn&#x27;t dlopen libobjc-trampolines.dylib: %s&quot;</span>,</span><br><span class=\"line\">                        <span class=\"built_in\">dlerror</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> t = <span class=\"keyword\">new</span> <span class=\"built_in\">TrampolinePointers</span>(dylib);</span><br><span class=\"line\">        TrampolinePointers *old = nil;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! trampolines.<span class=\"built_in\">compare_exchange_strong</span>(old, t, memory_order_release))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> t;  <span class=\"comment\">// Lost an initialization race.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>代码实现了一个无锁的单例，单例对象为<code>trampolines</code>。其中<code>get()</code>和<code>Initialize()</code>函数是可以多线程并发执行的。</p>\n<p>首先<code>get()</code>无需解释，直接返回当前的单例对象。如果只有读操作，那在多线程环境下本身也没什么问题。（PS：这种设计下，单例是<strong>有可能</strong>返回空的）</p>\n<p>接着看<code>Initialize()</code>，它的本质其实是一个双判初始化操作，其中<code>if (get()) return;</code>是第一次判断，第二次判断就是<code>trampolines.compare_exchange_strong(old, t, memory_order_release)</code>：</p>\n<p>它将<code>trampolines</code>变量和<code>old</code>变量相比较，如果相等，那么就让<code>t</code>「替换」掉<code>trampolines</code>。</p>\n<p>这句代码等价于</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (trampolines == null) &#123;</span><br><span class=\"line\">    trampolines = t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>唯一不同的是，前者是一个<strong>原子操作</strong>。也就是说，虽然<code>Initialize()</code>函数可以有多线程并发执行，但是<code>compare_exchange_strong()</code>函数同时只有一个CPU可以执行，并且这个操作是不能被中断的。</p>\n<p>假设当前有两个线程在同时执行，在第一个线程将<code>trampolines</code>通过<code>compare_exchange_strong()</code>赋值后，第二个线程<code>compare_exchange_strong()</code>判断一定会返回false，这也就是为什么返回false，需要<strong>释放</strong>已创建的<code>t</code>。</p>\n<p>一切都可以合理解释，但是其中的第三个参数<code>memory_order_release</code>和<code>MEMORY_ORDER_CONSUME(memory_order_relaxed)</code>是用来做什么的？</p>\n<h2 id=\"前序\"><a href=\"#前序\" class=\"headerlink\" title=\"前序\"></a>前序</h2><h3 id=\"谈谈指令乱序\"><a href=\"#谈谈指令乱序\" class=\"headerlink\" title=\"谈谈指令乱序\"></a>谈谈指令乱序</h3><p>在学校从导论中就已经了解到，现代CPU早已经进入了多核时代，现代的编程技术，也早已支持并发编程。分支预测，乱序执行，指令优化，都会让最终运行在机器上的代码，不再是我们编写代码的时候所预期的那样。</p>\n<p>除了这些以外，各类编译器还会根据自己的实现和规则，对编译的目标代码进行优化，指令重排就是这些优化中重要的一项，但指令重排对这些代码的开发者来说完全黑盒。</p>\n<p>下面用一段简单的代码来举个例子:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> A = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> B = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    A = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (B == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        A = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Clang编译上面这段代码后会产出如下的汇编：<br><img src=\"/2022/07/20/2022-07-20_C++_memory_order/memory_reorder_case1.jpg\" alt=\"memory_reorder_case1\"></p>\n<p>可以很明显看到，先比较了B &#x3D;&#x3D; 0，后加载了 A &#x3D; 1；😱</p>\n<p>我们把我们看到的理解代码的顺序，暂且叫<code>代码顺序</code>，而这种不按照<code>代码顺序</code>来执行的编译器行为称之为<code>指令乱序</code>。从编译器的角度来看，它只需要保证<strong>在单线程的情况下，代码能够正确地执行，并且符合单线程的预期即可</strong>。就上面的代码而言，「看起来」和「执行结果」的确是没有问题的。但是在多线程环境下，这个结论就不再成立了。因为<strong>编译器是不知道多线程环境下代码执行的先后顺序，也不知道哪些变量会在线程之间共享</strong>，这个时候<code>指令乱序</code>会导致严重的后果。了解一下关于「锁」的反面例子：</p>\n<p>「锁」是绝大部分开发者在编程的时候，会选择用来解决多线程下的数据竞争问题。不论是mutex，还是自旋锁，用锁来保护临界区，是一个程序员的基本操作。那么按照上面编译器不可预知的<code>指令乱序</code>行为，如果「锁住」的临界区内的代码，在被编译优化后，理论上不会跑出临界区吗？比如我们把上面的代码稍微改一下。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> A = <span class=\"number\">0</span>;</span><br><span class=\"line\">mutex lck;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    mutex.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">    A = <span class=\"number\">1</span>;</span><br><span class=\"line\">    mutex.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>A = 1</code>会不会跑出来？？</p>\n<p>线上暂无故障，我们肯定可以理直气壮地说，这个代码100%不会有问题的，那为什么呢？？？</p>\n<h3 id=\"内存可见性\"><a href=\"#内存可见性\" class=\"headerlink\" title=\"内存可见性\"></a>内存可见性</h3><p>除了指令乱序，还有一个问题会影响代码的一致性，那就是内存可见性。我们知道，CPU执行指令的速度，和内存的读写速度不是一个量级的，因此CPU引入了多级缓存，就像下面这样（原谅我的画功）：</p>\n<p><img src=\"/2022/07/20/2022-07-20_C++_memory_order/CPU_memory_struct.jpg\" alt=\"2022-07-20_C++_memory_order\"></p>\n<p>每个内核都有自己的L1，L2甚至L3缓存，为了提升运行速度，在内核读某个内存值的时候，如果在缓存内命中，那么很有可能就会直接使用缓存内的值；同样的，写入操作也有可能只会临时写入缓存；当触发缺页，或者某个回写机制的时候，这些缓存中的值才会真正刷新到主存中去。从这张图垂直得来看，其实每一个内核都有自己独立的缓存，而各个缓存之间的同步机制，会影响内存的「可见性」。</p>\n<p>举个例子 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>       <span class=\"comment\">// std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span>         <span class=\"comment\">// std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span>         <span class=\"comment\">// std::atomic</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> v = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">plus</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ++v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">t1</span><span class=\"params\">(plus)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">t2</span><span class=\"params\">(plus)</span></span>;</span><br><span class=\"line\">    t1.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    t2.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;v: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个例子, 在多核CPU上执行最终结果大概率是小于2000的。当一个内核(线程)在读取变量之后，另一个内核(线程)对它做了修改，但没有回写主存，也没有同步到其他内核(线程)中去的时候，就会出现不一致的情况。这块内存对于不同的线程的可见性也就不一致了。</p>\n<h3 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h3><p>原子操作，就是在单核CPU上，一个CPU指令就能完成的操作，比如MOV，INC等等。如果一个操作需要多个指令来完成，那么在多个指令之间，有可能会触发系统中断，在中断过程中，修改了这个操作的中间变量，这个操作就不再「原子」。</p>\n<p>C++提供了<code>std::atomic</code>来实现原子操作, 还是上面那个例子，稍微改一下:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>       <span class=\"comment\">// std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span>         <span class=\"comment\">// std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span>         <span class=\"comment\">// std::atomic</span></span></span><br><span class=\"line\"><span class=\"function\">std::atomic&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">plus</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ++v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">t1</span><span class=\"params\">(plus)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">t2</span><span class=\"params\">(plus)</span></span>;</span><br><span class=\"line\">    t1.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    t2.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;v: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的<code>++v</code>等价于 <code>v.fetch_add(1)</code>，它可以保证任意一个线程对v的修改，对其他线程是立刻可见的。保证了任意一个线程每次读到的v一定是当前的最新值。</p>\n<h2 id=\"内存排序\"><a href=\"#内存排序\" class=\"headerlink\" title=\"内存排序\"></a>内存排序</h2><p>原子变量和原子操作其实已经解决了内存可见性问题，内存排序就是用来解决乱序问题。</p>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>网文有很多在解释内存排序，都会提到这些概念，他们都来自<a href=\"https://en.cppreference.com/w/cpp/thread\">C++并发编程的标准文档</a>中。在解释模型之前，确实需要理清这些概念，避免后续解释混淆。</p>\n<blockquote>\n<p>先整体解释一下 <code>std:memory_order</code></p>\n</blockquote>\n<p><code>std:memory_order</code> 指定了一个原子操作的周围是如何来排序一些非原子操作的内存访问顺序的。在多核CPU上，某个线程观察到的变量的变化顺序，可能和真正修改这个变量的线程的写入顺序完全不一样，就是因为上面提到的<code>指令乱序</code>，甚至可能在单核CPU系统上依旧会存在相似的问题。标准库给到的默认行为是顺序一致性行为，这种会影响性能。但是除了原子能力，标准库提供了<code>std:memory_order</code>这个参数来指定特定约束。</p>\n<h4 id=\"“Sequence-Before”-排序上在…之前\"><a href=\"#“Sequence-Before”-排序上在…之前\" class=\"headerlink\" title=\"“Sequence Before”(排序上在…之前)\"></a>“Sequence Before”(<strong>排序上在…之前</strong>)</h4><p>“Sequence Before”是一种在单个线程内的两个调用(表达式)之间，非对称的，可传递的关系。</p>\n<ul>\n<li>A <strong>排序上在</strong> B <strong>之前</strong> 等价于 B <strong>排序上在</strong> A <strong>之后</strong>, 前者 A 计算会在 B 计算开始之前结束。</li>\n<li>如果 A 不是<strong>排序上在</strong> B <strong>之前</strong>，并且 B 也不是<strong>排序上在</strong> A <strong>之前</strong>，那么就会有两种可能：<ul>\n<li>A B 两次计算是无序的: A B计算可能在任一顺序，并且有多个重叠部分的情况下发生。</li>\n<li>A B 两次计算的顺序是随机的: A B计算可能是在任一顺序，但是没有重叠。如 A 在 B 开始之前结束，或者 B 在 A 开始之前结束。</li>\n</ul>\n</li>\n</ul>\n<p>举个例子</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r1 = y.<span class=\"built_in\">load</span>(std::memory_order_relaxed); <span class=\"comment\">// A</span></span><br><span class=\"line\">x.<span class=\"built_in\">store</span>(r1, std::memory_order_relaxed); <span class=\"comment\">// B</span></span><br></pre></td></tr></table></figure>\n<p>称 A 排序上在 B 之前</p>\n<h4 id=\"“Happens-Before”-在…之前发生\"><a href=\"#“Happens-Before”-在…之前发生\" class=\"headerlink\" title=\"“Happens Before”(在…之前发生)\"></a>“Happens Before”(在…之前发生)</h4><p>除了”Sequence Before”关系之外，”Happens Before”还包含了”Inter-thread happens-before(<strong>线程间，在…之前发生</strong>)”的关系</p>\n<h4 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h4><p>在同一个线程内，A 计算<strong>排序上在</strong> B <strong>之前</strong>，还会给B附带上一个依赖关系（那就是 B 依赖 A），下面的表述都是 B 依赖 A。</p>\n<ul>\n<li>A 计算的值被用来作为 B 计算的操作数，除了<ul>\n<li>B 是 std::kill_dependency</li>\n<li>A 是内置的操作符 <code>&amp;&amp;</code> <code>||</code> <code>?:</code> 或者 <code>,</code>的左值</li>\n<li>A 向标量对象 M 写入，B 从 M 读取</li>\n<li>A 给另一个计算 X 引入依赖关系，而 X 给 B 又引入依赖关系。（即依赖的传递）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三种内存模型\"><a href=\"#三种内存模型\" class=\"headerlink\" title=\"三种内存模型\"></a>三种内存模型</h3><p><strong>对原子操作</strong>，C++有6种内存序列，分别是：</p>\n<ol>\n<li><code>memory_order_relaxed</code></li>\n<li><code>memory_order_consume</code></li>\n<li><code>memory_order_acquire</code></li>\n<li><code>memory_order_release</code></li>\n<li><code>memory_order_acq_rel</code></li>\n<li><code>memory_order_seq_cst</code></li>\n</ol>\n<p>在不指定的情况下，默认是<code>memory_order_seq_cst</code>。</p>\n<p>虽然有6种内存序列，但他们只对应了3种模型(其实是4种)，分别是：</p>\n<ol>\n<li><code>sequentially consistent</code>（顺序一致性排序） 「<code>memory_order_seq_cst</code>」</li>\n<li><code>acquire-release</code>（获取-释放序列）「<code>memory_order_acquire</code>, <code>memory_order_release</code>, <code>memory_order_acq_rel</code>」</li>\n<li><code>relaxed</code>（松散序列）「<code>memory_order_relaxed</code>」</li>\n</ol>\n<p>第四种<code>consume-release</code>模型因为<code>memory_order_consume</code>序列目前在实现上有性能问题，不建议使用，也就不讨论这个。</p>\n<h4 id=\"顺序一致性的模型\"><a href=\"#顺序一致性的模型\" class=\"headerlink\" title=\"顺序一致性的模型\"></a>顺序一致性的模型</h4><p>上面提到了，内存排序默认就是<code>memory_order_seq_cst</code>，对应的模型就是「顺序一致性排序模型」。</p>\n<p>顺序一致性，意思是在程序执行过程中，所有对于原子类型数据的操作，就像是我们从源码看上去，以我们所看到的那样。</p>\n<p>换句话说，顺序一致性，在多线程的环境下，原子类型的数据，将会像在单线程下处理一样 —— 一个操作接一个操作排好顺序来执行。到目前为止，这个顺序是最好理解的，在多线程环境下，每一个线程，对原子数据进行操作的优先级都是一样的。</p>\n<p>但是这也就意味着，多线程下对于这个原子的操作是无法被排序的，也就是说CPU是无法针对这些原子操作的前后进行编译优化的。</p>\n<h4 id=\"非顺序一致性的模型\"><a href=\"#非顺序一致性的模型\" class=\"headerlink\" title=\"非顺序一致性的模型\"></a>非顺序一致性的模型</h4><p>非顺序一致性的模型，包含两种，一种是「松散序列」，另一种是「获取-释放序列」。</p>\n<p>在这种模型下，就不再和上面一样有一个「全局有序的事件队列」了，细想一下这个模型在多线程下就会变得非常复杂了。在理解这种模型的时候，我们必须要抛开我们固有的多线程操作的心理预期模型，原子操作在不同线程中看到的将会是不同的样子。</p>\n<h5 id=\"松散序列\"><a href=\"#松散序列\" class=\"headerlink\" title=\"松散序列\"></a>松散序列</h5><p>松散序列是非顺序一致性模型中的一种，简单的来说，因为<code>指令乱序</code>的存在，使用「<code>memory_order_relaxed</code>」这一种模型，会让这个原子操作，「可能」出现在这个原子操作序列的任一阶段。换句话说，它只会保证操作的原子性与修改顺序的一致性（它只起到了原子操作的作用）。</p>\n<p>举一个例子来理解</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::automic&lt;<span class=\"type\">int</span>&gt; x = <span class=\"number\">0</span>;</span><br><span class=\"line\">std::automic&lt;<span class=\"type\">int</span>&gt; y = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\">r1 = y.<span class=\"built_in\">load</span>(std::memory_order_relaxed); <span class=\"comment\">// A</span></span><br><span class=\"line\">x.<span class=\"built_in\">store</span>(r1, std::memory_order_relaxed); <span class=\"comment\">// B</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\">r2 = x.<span class=\"built_in\">load</span>(std::memory_order_relaxed); <span class=\"comment\">// C </span></span><br><span class=\"line\">y.<span class=\"built_in\">store</span>(<span class=\"number\">42</span>, std::memory_order_relaxed); <span class=\"comment\">// D</span></span><br></pre></td></tr></table></figure>\n\n<p>线程1 的操作为 A -&gt; B, 线程B的操作为 C -&gt; D, 所以如果按照顺序一致性的模型来理解的话，那么就会有下面的几种可能性</p>\n<ol>\n<li>A -&gt; B -&gt; C -&gt; D</li>\n<li>A -&gt; C -&gt; B -&gt; D</li>\n<li>A -&gt; C -&gt; D -&gt; B</li>\n<li>C -&gt; D -&gt; A -&gt; B</li>\n<li>C -&gt; A -&gt; D -&gt; B</li>\n<li>C -&gt; A -&gt; B -&gt; D</li>\n</ol>\n<p>这6种可能性执行完之后，r1&#x3D;r2&#x3D;0, 或 r1 &#x3D; 42,r2 &#x3D; 0;</p>\n<p>但是在松散序列下就不一样了，线程2中，y原子操作并不依赖任何操作，所以编译器可以选择将 D 操作顺序移动到 C 操作之前。<br>所以，在上面的6种可能性中，C，D可以交换，产生12种可能性。结果中可能会产生 r1&#x3D;42,r2&#x3D;42 这种情况。</p>\n<p>再举个例子，这个例子来自「C++ Concurrency In Action」</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\">std::atomic&lt;<span class=\"type\">bool</span>&gt; x,y;</span><br><span class=\"line\">std::atomic&lt;<span class=\"type\">int</span>&gt; z;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">write_x_then_y</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    x.<span class=\"built_in\">store</span>(<span class=\"literal\">true</span>,std::memory_order_relaxed); <span class=\"comment\">// A</span></span><br><span class=\"line\">    y.<span class=\"built_in\">store</span>(<span class=\"literal\">true</span>,std::memory_order_relaxed); <span class=\"comment\">// B</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">read_y_then_x</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!y.<span class=\"built_in\">load</span>(std::memory_order_relaxed)); <span class=\"comment\">// C</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x.<span class=\"built_in\">load</span>(std::memory_order_relaxed)) &#123; <span class=\"comment\">// D</span></span><br><span class=\"line\">        ++z;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    x=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    y=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    z=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">a</span><span class=\"params\">(write_x_then_y)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::thread <span class=\"title\">b</span><span class=\"params\">(read_y_then_x)</span></span>;</span><br><span class=\"line\">    a.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    b.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(z.<span class=\"built_in\">load</span>()!=<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>x, y在同一个线程内「依次」原子写入 true。另一个线程内，在y写入true之后，判断x是否已经是true了，如果是则z++。</p>\n<p>从顺序一致性的模型来理解的话，断言是肯定不会触发的，因为在y变为true的时候，x一定已经是true了。</p>\n<p>但是同样的，在松散序列下，x,y 没有任何相互依赖关系。A，B操作是有可能会指令乱序的。所以在这个情况下，断言是有可能触发的。</p>\n<p>「<code>memory_order_relaxed</code>」这个模式最典型的运用就是<code>shared_ptr</code>引用计数中的计数+1部分</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\">std::atomic&lt;<span class=\"type\">int</span>&gt; cnt = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> n = <span class=\"number\">0</span>; n &lt; <span class=\"number\">1000</span>; ++n) &#123;</span><br><span class=\"line\">        cnt.<span class=\"built_in\">fetch_add</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::thread&gt; v;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> n = <span class=\"number\">0</span>; n &lt; <span class=\"number\">10</span>; ++n) &#123;</span><br><span class=\"line\">        v.<span class=\"built_in\">emplace_back</span>(f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; t : v) &#123;</span><br><span class=\"line\">        t.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Final counter value is &quot;</span> &lt;&lt; cnt &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>fetch_add</code>可以保证操作的原子性和修改内存的一致性，所以计数不会出错，而目的也只需要保证最终计数的准确性，这里使用<code>memory_order_relaxed</code>就可以达成目的。</p>\n<h5 id=\"获取-释放序列\"><a href=\"#获取-释放序列\" class=\"headerlink\" title=\"获取-释放序列\"></a>获取-释放序列</h5><p>上面两个序列是两个极端，一种是非常严格的策略，另一种则是非常宽松，而<code>获取-释放序列</code>则是位于两者之间。</p>\n<table>\n<thead>\n<tr>\n<th>memory_order</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>memory_order_release</td>\n<td>仅用于 store 操作，当前线程内在 store 操作之后的任何内存读写操作都无法被重排到store操作之前</td>\n</tr>\n<tr>\n<td>memory_order_acquire</td>\n<td>仅用于 load 操作，当前线程内在 load 操作之后的任何内存读写操作都无法被重排到load操作之后</td>\n</tr>\n</tbody></table>\n<p>当线程A中的原子变量的<code>store</code>操作被标记为<code>memory_order_release</code>，而线程B中同一个原子变量的<code>load</code>操作被标记为<code>memory_order_acquire</code>属性的时候，<strong>在</strong>A线程中<code>store</code>操作<strong>之前发生</strong>的所有(非原子的和relax的)操作，都会在B线程<code>load</code>操作之后全部可见。也就是说，<strong>需也仅需</strong><code>load</code>操作完成，那么B线程内可以看到A线程之前的所有写入操作。</p>\n<p>这种同步关系，只会建立在不同线程对于同一个原子变量的<code>release</code>和<code>acquire</code>操作之间，其他线程看到的顺序就不可预知了。</p>\n<p>一些互斥锁，例如std::mutex或者自旋锁，就是<code>release-acquire</code>内存同步的一个典型案例: 在线程A<code>release</code>之前，临界区内发生的所有事情，都必须在B<code>acquire</code>进入临界区后可见。</p>\n<p><img src=\"/2022/07/20/2022-07-20_C++_memory_order/mutex_memory_case.jpg\" alt=\"mutex_memory_case\"></p>\n<p>上图完整的解释了锁内临界区内的代码，是不可以被重排到临界区外的。</p>\n<p>再来看一个引用计数的减一例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">control_block_ptr-&gt;<span class=\"built_in\">Write</span>(); </span><br><span class=\"line\"><span class=\"keyword\">if</span>(control_block_ptr-&gt;refs.<span class=\"built_in\">fetch_sub</span>(<span class=\"number\">1</span>, std::memory_order_acq_rel) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> control_block_ptr;</span><br></pre></td></tr></table></figure>\n\n<p>引用计数减一的时候这里用的是<code>acq_rel</code>, 而不再是<code>relax</code>了。因为这里涉及到了数据的销毁，看下如果依旧使用<code>relax</code>会发生什么。</p>\n<p><img src=\"/2022/07/20/2022-07-20_C++_memory_order/shared_ptr_delete.jpg\" alt=\"shared_ptr_delete\"></p>\n<p>对象的读写可能会被重排到 <code>fetch_sub</code> 之后，而此刻如果另一个线程同时也正在销毁对象的时候，发现<code>fetch_sub</code>已经是0了，随后就将数据销毁了。从线程B单个视角来看的话，销毁发生在对象写入之后，不会有异常产生。但是线程A和B同时执行的时候，A线程的写入操作，就有可能会发生在线程B的销毁之后了。</p>\n<p>如果这里对<code>fetch_sub</code>指定为<code>release</code>排序模型，禁止对象写入重排到原子操作后面。</p>\n<p><img src=\"/2022/07/20/2022-07-20_C++_memory_order/shared_ptr_delete2.jpg\" alt=\"shared_ptr_delete2\"></p>\n<p>这样一来，因为对象的写入操作永远保证在<code>fetch_sub</code>之前，那么<code>delete</code>操作之后也就不可能会出现对象写入操作（这里是指在引用计数的环境之下）。</p>\n<p>同样的原理需要考虑对象操作在<code>fetch_sub</code>之后，这时候就需要<code>acquire</code>操作。同时需要<code>acquire</code>和<code>release</code>，即<code>memory_order_acq_rel</code>。</p>\n<h2 id=\"解释开始的问题\"><a href=\"#解释开始的问题\" class=\"headerlink\" title=\"解释开始的问题\"></a>解释开始的问题</h2><blockquote>\n<p>为什么锁内临界区的代码不会被重排序到临界区之外？</p>\n</blockquote>\n<p>这个问题已经解释过了，<code>release-acquire</code>模型可以保证临界区的数据竞争问题。</p>\n<blockquote>\n<p>回头再来分析最开始的<code>lock-free</code>的代码</p>\n</blockquote>\n<p><code>memory_order_consume</code> 这个模型在<code>cppreference</code>中定义和<code>memory_order_acquire</code>相似，只是其中只是依赖当前原子变量的读写操作，无法被排序到<code>consume</code>操作之前。</p>\n<p>是不是很眼熟？和<code>mutex</code>的设计如出一辙，只是它不再像<code>mutex</code>一样会阻塞线程。</p>\n<p>换个角度想，<code>Initialize()</code>函数内<code>get()</code>和<code>compare_exchange_strong()</code>之间的代码就是”临界区”，临界区的核心代码就是<strong>将<code>trampolines</code>修改为t</strong></p>\n<p>但是因为实现的性能问题，<code>cppreference</code>不建议使用<code>consume</code>, 源码里更是直接将它改为了<code>relax</code>。</p>\n<p>从<code>临界区</code>的角度来思考，就是会将<code>临界区</code>内的代码重排到<code>get()</code>之前，比如说dlopen之后，调用了<code>get()</code>，然后<code>return</code>，造成内存泄漏。</p>\n<p>但是这里苹果还是将它改为了<code>relax</code>，然后只能在注释里祈祷🙏🏻<code>cross our fingers</code>，别出问题。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.jb51.net/article/246087.htm\">浅析C++ atomic 和 memory ordering</a><br><a href=\"https://www.huliujia.com/blog/df3c2e8a9ef77bd2ed0d83292778734eb395970c/\">聊一聊原子操作</a><br><a href=\"https://www.huliujia.com/blog/f85f72a3b3e3018ffe9c9d3c15dda0f5db079859/\">内存乱序与C++内存模型详解</a><br><a href=\"https://www.ccppcoding.com/archives/221\">聊聊内存模型与内存序</a><br><a href=\"https://paul.pub/cpp-memory-model/\">C++ 内存模型</a><br><a href=\"https://colobu.com/2014/12/19/an-introduction-to-lock-free-programming/\">lock-free 编程介绍</a><br><a href=\"https://stackoverflow.com/questions/14881056/confusion-about-implementation-error-within-shared-ptr-destructor\">confusion-about-implementation-error-within-shared-ptr-destructor</a><br><a href=\"https://stackoverflow.com/questions/49112732/\">memory-order-in-shared-pointer-destructor</a><br><a href=\"https://en.cppreference.com/w/cpp/language/eval_order\">cppreference</a></p>"},{"title":"动态库的符号地址绑定","date":"2019-12-16T16:00:00.000Z","top":200,"_content":"\n## Linux的共享库的重定位和符号绑定\n\n动态共享库在进程间共享时，有两种符号链接方式：\n1. 装载时重定位\n2. PIC（位置无关代码）\n\n<!-- more -->\n\n### 装载时重定位\n\n在首次使用某个动态库的时候，动态链接器会把磁盘上的这个库文件，映射到某块物理内存上。\n\n在此之后，动态链接器加载动态库的时候，会根据当前内存的情况，分配对应的一块虚拟内存来映射这个动态库。所以不论有多少进程在使用这个动态库，物理内存中这个动态库始终只有一份。\n\n然后...因为载入后不同进程的基地址不同，加上动态库内都是绝对寻址，所以需要修改动态库TEXT段内的指令。\n\n所以最终动态库内的寻址地址都是由动态库被加载的虚拟内存的基地址来决定的，而不同进程的基地址必然不会一样，那最终导致这部分的代码不可复用。\n\n另外，如果这部分的寻址过多，还容易引起链接时间过长（启动时间过久）。\n\n再另外，TEXT段的可写入，使得安全性的大大降低。\n\n由此引入了PIC\n\n### PIC（位置无关代码）\n\nPIC实际上需要解决两个问题，一个是寻址问题，另一个是绑定问题。解决这两个问题，至少可以缓解以上的所有问题。\n\n1. 寻址问题\n\n如果可以把绝对地址寻址改为相对地址寻址，那么也就不需要根据基地址来修改TEXT段的指令了。\n\n在此之前，相对地址有两个要素 基址+偏移。\n\n先看偏移，编译器可以把所有的TEXT段和DATA段分离（即使不放在一起也没关系）。当前指令需要的数据与指令的偏移，与编译器是可以确定的。\n\n即在链接器链接的时候，也是可以知道，当前指令需要的数据在此之后偏移多少。具体看下图：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019121711225490-300x280.png)\n\n再看基址，基址可以通过一些“手段”获取到。\n\n例如在x86上，\n```\n    call TMPLABEL\nTMPLABEL:\n    pop ebx\n```\n\ncall TMPLABEL 调用的时候，会把TMPLABEL的第一个命令地址（即 pop ebx）的地址入栈。而执行到当前命令的时候，又会弹出栈顶的值到ebx，那么此时ebx代表的就是当前的指令的地址了。\n\n2. 绑定问题\n\n在做到相对寻址之后，如何把对应的符号绑定到对应真正的符号上？这里引入了GOT（全局偏移表）。GOT是一张全局的地址表，记录了指令内使用的符号或者数据的具体地址。\n\n寻址访问的过程中，TEXT段中某一个指令想要访问某一个全局数据的地址，(姑且叫使用全局数据A吧)TEXT段不会直接访问这个数据A的地址。而是编译器在会把这个地址，指向GOT中的某一个记录，这个记录就是数据A的地址，这样通过相对寻址来指向这个数据。\n\n但是这个过程中，还缺少一步就是对GOT表的重定向，因为数据在动态库被加载至虚拟内存的时才会被确定基地址。所以，在加载后，还需要通过重定向来修改这个数据的地址。\n\n似乎过程比装载时重定位一点都没有少，那么PIC的优势又在哪呢？\n1. PIC可以复用的GOT表。装载时重定位需要对所有的引用这个符号或者数据的地方都做指令修改，而PIC只需要修改GOT表一次就可以了。\n2. PIC无需修改代码段。上文提及的修改代码段是及其危险的一件事，而数据段本身也不是进程间共享的，PIC可以做到只修改数据段。而且这样可以让代码段在进程间共享。\n\n### PIC函数调用时延迟绑定\n\nPIC解决了以上两个问题，但是还有一个启动时间的问题。虽然PIC只需要修改一次GOT的地址就可以了，但是还是架不住函数多啊，函数的数量肯定远多于全局变量的数量。\n\n程序80%的时间都在执行20%的代码\n\n所以，函数地址的重定位可以延迟到第一次调用的时候。\n\n另外，对于函数的地址的解析，我们称为绑定（Bind）。\n\n通俗的来说，延迟绑定的机制就是：\n\n编译器在代码段中，插入一段“桩代码”，源代码指令中的函数跳转会通过相对寻址，直接指向PLT表中这个符号对应的桩代码。这段“桩代码”的执行过是：\n\n1. 执行\"桩代码\",先跳转到GOT表中这个符号指向的函数地址.\n2. 编译器会把GOT表中这个地址的默认值写为“桩代码”中的下一个指令地址。即跳转回桩代码中的下一条指令。\n3. 而下一个指令地址就是执行GOT表中这个符号的绑定过程（一般都由动态链接器负责）\n\n这个桩代码，称为PLT(程序链接表)。具体的流程看下图：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019121711250179-300x154.png)\n\n等到下一次再执行的时候，GOT表内的符号地址已经是真正函数对应的地址了（Bind过程就是把GOT表中的符号地址替换为真正的函数地址）：\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/201912171125358-300x184.png)\n\n## iOS动态库的符号\n接下来，我们通过代码和实现来看看iOS的动态库是否和Linux的动态库一样。\n\n写一个简单Demo，看看NSLog的符号绑定吧。\n\n```\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    NSLog(@\"1\");\n    NSLog(@\"2\");\n}\n@end\n```\n\n### 静态分析\n编译完成后，因为代码量不多，我们先做静态分析。\n\n在 __TEXT 段的 __text 节中所有代码可以一眼望到底了。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2995f8ee2c76a2b85054185cc0fe56c4.png)\n\n迅速找到第一个NSLog，这里bl 跳转到 0x100006558。（第二个NSLog也是跳转到这个地址）\n\n那找到偏移为0x6558的地址（Text段的虚拟地址起始地址是0x100000000,在Load Commands中声明了）。\n\n0x6558是在__TEXT段的__stubs节中，顾名思义是符号桩。根据上面Linux的动态库的理解，符号桩是一个假想的NSLog的实现，所有的指令都会向这个地址跳转。\n\n但是很僵硬...MachOView这个工具把某些细节汇编隐藏了。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/e401b01710523114905587681e611b87.png)\n\n我们换个工具...\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/8fd0ad5d02a843cfe7f22f291972a7bd.png)\n\n找到__stubs节，第一个符号就是imp__sthubs_NSLog。\n```\nldr x16，#0x10000c000\nbl x16\n```\n这个假想的NSLog实现就是跳转到 #0x10000c000 地址内存储的地址。再找这个地址...\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/acca5b46a20c2d549fbbe8e53bfc21d0.png)\n\n这个地址是数据段的！__la_symbol_ptr,通过名字也可以看出来---懒加载符号指针表。也就是对应上面提到的GOT表。GOT表内的NSLog又指向了0x660C。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/fd4c678b7b1035438732b918cd91d426.png)\n\n__stub_helper...按照上面的逻辑，这个地址应该就是对应的PLT（程序链接表）。\n\n```\nldr w16,0x100006614\nb 0x1000065f4\n.long 0x000000000\n```\n把 0x100006614 的值存储到w16内，也就是0，然后跳转到 0x1000065f4\n0x1000065f4 就是这个__stub_helper的开头，可以观察到最终会跳转到 dyld_stub_binder，这个代码是在动态链接器内。\n而 0x100006614 的值是为了告诉dyld需要链接的是哪个符号。\n\n至此第一次绑定的绑定过程已经全部完成了，如果第二次再调用的时候 __la_symbol_ptr 内函数符号对应的地址就已经是Bind之后的值了。\n\n**iOS动态库的首次绑定过程**\n1. 指令跳转到符号的”桩代码“\n2. ”桩代码“直接跳转GOT，GOT指向”__stub_helper“代码。\n3. 这个helper代码的目的是跳转到dyld链接器的Bind入口处，执行Bind。\n\n可以看到，iOS和Linux的动态库绑定还是有点区别的：iOS把”桩代码“后面的跳转dyld部分直接抽离出来，放入了\"__stub_helper\" 中。（其实本质上是没有区别的）\n\n### 运行时分析\n我们在第一个NSLog处打一个断点，然后看汇编代码...\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0ed614a79304fe82ebd32bbd65cff51a.png)\n\n直接 bl 0x100f46558 (第二个NSLog也是)\n\n我不会 Xcode 设置地址断点（不知道支不支持），用dis看一下这个地址的汇编代码吧。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/12b7e4719dd20339a6cbd1ba7020ed7c.png)\n\n这里改成了相对寻址`ldr  x16, #0x5aa4` x1 最终的值是 当前指令地址+0x5aa4 = 0x100F4C000 使用Xcode工具查看内存值。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b03ec9a2e1f26e74a557fed9bd87db79.png)\n\n根据静态分析的逻辑，这个地址 0x100f4660c（注意大小端） 应该是 __la_symbol_ptr 中存储的 __stubs_helper 内这个符号的地址，\n\n再看看这个地址的代码确认一下:\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/036b6c1e611cf344da64f74cf774626a.png)\n\n在下一个NSLog处再打一个断点...验证一下第二次执行。\n\n依旧是通过查看内存地址，看 0x100F4C000 这个地址的值。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/099695463b49a2eb7f6f2972f6ceb739.png)\n\n值变成了 0x109c76e754\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/826557c3c1e53c4da1529fbfe29dc6ed.png)\n\n而这个地址就已经变成真正的NSLog的函数地址了~\n\n> 本文只是通过Linux 的动态库的实现来理解iOS的动态库，通过一些实验和汇编分析验证我们的猜想。关于iOS的dyld的具体源码和细节，我会单开文章。\n\n\n参考\n[iOS 系统的延迟绑定机制 - 简书](https://www.jianshu.com/p/857855cda602)\n[动态共享对象的装载时重定位](https://blog.csdn.net/parallelyk/article/details/42747239)\n[共享库载入时重定位](https://blog.csdn.net/wuhui_gdnt/article/details/51035557)\n[共享库中的位置无关代码（PIC）](https://blog.csdn.net/wuhui_gdnt/article/details/51094732)\n\n","source":"_posts/3.binding-symbols.md","raw":"---\ntitle: 动态库的符号地址绑定\ndate: 2019-12-17\ntags: [动态链接,符号绑定]\ncategories: 动态库\ntop: 200\n---\n\n## Linux的共享库的重定位和符号绑定\n\n动态共享库在进程间共享时，有两种符号链接方式：\n1. 装载时重定位\n2. PIC（位置无关代码）\n\n<!-- more -->\n\n### 装载时重定位\n\n在首次使用某个动态库的时候，动态链接器会把磁盘上的这个库文件，映射到某块物理内存上。\n\n在此之后，动态链接器加载动态库的时候，会根据当前内存的情况，分配对应的一块虚拟内存来映射这个动态库。所以不论有多少进程在使用这个动态库，物理内存中这个动态库始终只有一份。\n\n然后...因为载入后不同进程的基地址不同，加上动态库内都是绝对寻址，所以需要修改动态库TEXT段内的指令。\n\n所以最终动态库内的寻址地址都是由动态库被加载的虚拟内存的基地址来决定的，而不同进程的基地址必然不会一样，那最终导致这部分的代码不可复用。\n\n另外，如果这部分的寻址过多，还容易引起链接时间过长（启动时间过久）。\n\n再另外，TEXT段的可写入，使得安全性的大大降低。\n\n由此引入了PIC\n\n### PIC（位置无关代码）\n\nPIC实际上需要解决两个问题，一个是寻址问题，另一个是绑定问题。解决这两个问题，至少可以缓解以上的所有问题。\n\n1. 寻址问题\n\n如果可以把绝对地址寻址改为相对地址寻址，那么也就不需要根据基地址来修改TEXT段的指令了。\n\n在此之前，相对地址有两个要素 基址+偏移。\n\n先看偏移，编译器可以把所有的TEXT段和DATA段分离（即使不放在一起也没关系）。当前指令需要的数据与指令的偏移，与编译器是可以确定的。\n\n即在链接器链接的时候，也是可以知道，当前指令需要的数据在此之后偏移多少。具体看下图：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019121711225490-300x280.png)\n\n再看基址，基址可以通过一些“手段”获取到。\n\n例如在x86上，\n```\n    call TMPLABEL\nTMPLABEL:\n    pop ebx\n```\n\ncall TMPLABEL 调用的时候，会把TMPLABEL的第一个命令地址（即 pop ebx）的地址入栈。而执行到当前命令的时候，又会弹出栈顶的值到ebx，那么此时ebx代表的就是当前的指令的地址了。\n\n2. 绑定问题\n\n在做到相对寻址之后，如何把对应的符号绑定到对应真正的符号上？这里引入了GOT（全局偏移表）。GOT是一张全局的地址表，记录了指令内使用的符号或者数据的具体地址。\n\n寻址访问的过程中，TEXT段中某一个指令想要访问某一个全局数据的地址，(姑且叫使用全局数据A吧)TEXT段不会直接访问这个数据A的地址。而是编译器在会把这个地址，指向GOT中的某一个记录，这个记录就是数据A的地址，这样通过相对寻址来指向这个数据。\n\n但是这个过程中，还缺少一步就是对GOT表的重定向，因为数据在动态库被加载至虚拟内存的时才会被确定基地址。所以，在加载后，还需要通过重定向来修改这个数据的地址。\n\n似乎过程比装载时重定位一点都没有少，那么PIC的优势又在哪呢？\n1. PIC可以复用的GOT表。装载时重定位需要对所有的引用这个符号或者数据的地方都做指令修改，而PIC只需要修改GOT表一次就可以了。\n2. PIC无需修改代码段。上文提及的修改代码段是及其危险的一件事，而数据段本身也不是进程间共享的，PIC可以做到只修改数据段。而且这样可以让代码段在进程间共享。\n\n### PIC函数调用时延迟绑定\n\nPIC解决了以上两个问题，但是还有一个启动时间的问题。虽然PIC只需要修改一次GOT的地址就可以了，但是还是架不住函数多啊，函数的数量肯定远多于全局变量的数量。\n\n程序80%的时间都在执行20%的代码\n\n所以，函数地址的重定位可以延迟到第一次调用的时候。\n\n另外，对于函数的地址的解析，我们称为绑定（Bind）。\n\n通俗的来说，延迟绑定的机制就是：\n\n编译器在代码段中，插入一段“桩代码”，源代码指令中的函数跳转会通过相对寻址，直接指向PLT表中这个符号对应的桩代码。这段“桩代码”的执行过是：\n\n1. 执行\"桩代码\",先跳转到GOT表中这个符号指向的函数地址.\n2. 编译器会把GOT表中这个地址的默认值写为“桩代码”中的下一个指令地址。即跳转回桩代码中的下一条指令。\n3. 而下一个指令地址就是执行GOT表中这个符号的绑定过程（一般都由动态链接器负责）\n\n这个桩代码，称为PLT(程序链接表)。具体的流程看下图：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019121711250179-300x154.png)\n\n等到下一次再执行的时候，GOT表内的符号地址已经是真正函数对应的地址了（Bind过程就是把GOT表中的符号地址替换为真正的函数地址）：\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/201912171125358-300x184.png)\n\n## iOS动态库的符号\n接下来，我们通过代码和实现来看看iOS的动态库是否和Linux的动态库一样。\n\n写一个简单Demo，看看NSLog的符号绑定吧。\n\n```\n@interface ViewController ()\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    NSLog(@\"1\");\n    NSLog(@\"2\");\n}\n@end\n```\n\n### 静态分析\n编译完成后，因为代码量不多，我们先做静态分析。\n\n在 __TEXT 段的 __text 节中所有代码可以一眼望到底了。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2995f8ee2c76a2b85054185cc0fe56c4.png)\n\n迅速找到第一个NSLog，这里bl 跳转到 0x100006558。（第二个NSLog也是跳转到这个地址）\n\n那找到偏移为0x6558的地址（Text段的虚拟地址起始地址是0x100000000,在Load Commands中声明了）。\n\n0x6558是在__TEXT段的__stubs节中，顾名思义是符号桩。根据上面Linux的动态库的理解，符号桩是一个假想的NSLog的实现，所有的指令都会向这个地址跳转。\n\n但是很僵硬...MachOView这个工具把某些细节汇编隐藏了。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/e401b01710523114905587681e611b87.png)\n\n我们换个工具...\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/8fd0ad5d02a843cfe7f22f291972a7bd.png)\n\n找到__stubs节，第一个符号就是imp__sthubs_NSLog。\n```\nldr x16，#0x10000c000\nbl x16\n```\n这个假想的NSLog实现就是跳转到 #0x10000c000 地址内存储的地址。再找这个地址...\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/acca5b46a20c2d549fbbe8e53bfc21d0.png)\n\n这个地址是数据段的！__la_symbol_ptr,通过名字也可以看出来---懒加载符号指针表。也就是对应上面提到的GOT表。GOT表内的NSLog又指向了0x660C。\n\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/fd4c678b7b1035438732b918cd91d426.png)\n\n__stub_helper...按照上面的逻辑，这个地址应该就是对应的PLT（程序链接表）。\n\n```\nldr w16,0x100006614\nb 0x1000065f4\n.long 0x000000000\n```\n把 0x100006614 的值存储到w16内，也就是0，然后跳转到 0x1000065f4\n0x1000065f4 就是这个__stub_helper的开头，可以观察到最终会跳转到 dyld_stub_binder，这个代码是在动态链接器内。\n而 0x100006614 的值是为了告诉dyld需要链接的是哪个符号。\n\n至此第一次绑定的绑定过程已经全部完成了，如果第二次再调用的时候 __la_symbol_ptr 内函数符号对应的地址就已经是Bind之后的值了。\n\n**iOS动态库的首次绑定过程**\n1. 指令跳转到符号的”桩代码“\n2. ”桩代码“直接跳转GOT，GOT指向”__stub_helper“代码。\n3. 这个helper代码的目的是跳转到dyld链接器的Bind入口处，执行Bind。\n\n可以看到，iOS和Linux的动态库绑定还是有点区别的：iOS把”桩代码“后面的跳转dyld部分直接抽离出来，放入了\"__stub_helper\" 中。（其实本质上是没有区别的）\n\n### 运行时分析\n我们在第一个NSLog处打一个断点，然后看汇编代码...\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0ed614a79304fe82ebd32bbd65cff51a.png)\n\n直接 bl 0x100f46558 (第二个NSLog也是)\n\n我不会 Xcode 设置地址断点（不知道支不支持），用dis看一下这个地址的汇编代码吧。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/12b7e4719dd20339a6cbd1ba7020ed7c.png)\n\n这里改成了相对寻址`ldr  x16, #0x5aa4` x1 最终的值是 当前指令地址+0x5aa4 = 0x100F4C000 使用Xcode工具查看内存值。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b03ec9a2e1f26e74a557fed9bd87db79.png)\n\n根据静态分析的逻辑，这个地址 0x100f4660c（注意大小端） 应该是 __la_symbol_ptr 中存储的 __stubs_helper 内这个符号的地址，\n\n再看看这个地址的代码确认一下:\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/036b6c1e611cf344da64f74cf774626a.png)\n\n在下一个NSLog处再打一个断点...验证一下第二次执行。\n\n依旧是通过查看内存地址，看 0x100F4C000 这个地址的值。\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/099695463b49a2eb7f6f2972f6ceb739.png)\n\n值变成了 0x109c76e754\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/826557c3c1e53c4da1529fbfe29dc6ed.png)\n\n而这个地址就已经变成真正的NSLog的函数地址了~\n\n> 本文只是通过Linux 的动态库的实现来理解iOS的动态库，通过一些实验和汇编分析验证我们的猜想。关于iOS的dyld的具体源码和细节，我会单开文章。\n\n\n参考\n[iOS 系统的延迟绑定机制 - 简书](https://www.jianshu.com/p/857855cda602)\n[动态共享对象的装载时重定位](https://blog.csdn.net/parallelyk/article/details/42747239)\n[共享库载入时重定位](https://blog.csdn.net/wuhui_gdnt/article/details/51035557)\n[共享库中的位置无关代码（PIC）](https://blog.csdn.net/wuhui_gdnt/article/details/51094732)\n\n","slug":"3.binding-symbols","published":1,"updated":"2022-07-28T13:38:40.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwof001xp9c98d6g00yo","content":"<h2 id=\"Linux的共享库的重定位和符号绑定\"><a href=\"#Linux的共享库的重定位和符号绑定\" class=\"headerlink\" title=\"Linux的共享库的重定位和符号绑定\"></a>Linux的共享库的重定位和符号绑定</h2><p>动态共享库在进程间共享时，有两种符号链接方式：</p>\n<ol>\n<li>装载时重定位</li>\n<li>PIC（位置无关代码）</li>\n</ol>\n<span id=\"more\"></span>\n\n<h3 id=\"装载时重定位\"><a href=\"#装载时重定位\" class=\"headerlink\" title=\"装载时重定位\"></a>装载时重定位</h3><p>在首次使用某个动态库的时候，动态链接器会把磁盘上的这个库文件，映射到某块物理内存上。</p>\n<p>在此之后，动态链接器加载动态库的时候，会根据当前内存的情况，分配对应的一块虚拟内存来映射这个动态库。所以不论有多少进程在使用这个动态库，物理内存中这个动态库始终只有一份。</p>\n<p>然后…因为载入后不同进程的基地址不同，加上动态库内都是绝对寻址，所以需要修改动态库TEXT段内的指令。</p>\n<p>所以最终动态库内的寻址地址都是由动态库被加载的虚拟内存的基地址来决定的，而不同进程的基地址必然不会一样，那最终导致这部分的代码不可复用。</p>\n<p>另外，如果这部分的寻址过多，还容易引起链接时间过长（启动时间过久）。</p>\n<p>再另外，TEXT段的可写入，使得安全性的大大降低。</p>\n<p>由此引入了PIC</p>\n<h3 id=\"PIC（位置无关代码）\"><a href=\"#PIC（位置无关代码）\" class=\"headerlink\" title=\"PIC（位置无关代码）\"></a>PIC（位置无关代码）</h3><p>PIC实际上需要解决两个问题，一个是寻址问题，另一个是绑定问题。解决这两个问题，至少可以缓解以上的所有问题。</p>\n<ol>\n<li>寻址问题</li>\n</ol>\n<p>如果可以把绝对地址寻址改为相对地址寻址，那么也就不需要根据基地址来修改TEXT段的指令了。</p>\n<p>在此之前，相对地址有两个要素 基址+偏移。</p>\n<p>先看偏移，编译器可以把所有的TEXT段和DATA段分离（即使不放在一起也没关系）。当前指令需要的数据与指令的偏移，与编译器是可以确定的。</p>\n<p>即在链接器链接的时候，也是可以知道，当前指令需要的数据在此之后偏移多少。具体看下图：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019121711225490-300x280.png\"></p>\n<p>再看基址，基址可以通过一些“手段”获取到。</p>\n<p>例如在x86上，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    call TMPLABEL</span><br><span class=\"line\">TMPLABEL:</span><br><span class=\"line\">    pop ebx</span><br></pre></td></tr></table></figure>\n\n<p>call TMPLABEL 调用的时候，会把TMPLABEL的第一个命令地址（即 pop ebx）的地址入栈。而执行到当前命令的时候，又会弹出栈顶的值到ebx，那么此时ebx代表的就是当前的指令的地址了。</p>\n<ol start=\"2\">\n<li>绑定问题</li>\n</ol>\n<p>在做到相对寻址之后，如何把对应的符号绑定到对应真正的符号上？这里引入了GOT（全局偏移表）。GOT是一张全局的地址表，记录了指令内使用的符号或者数据的具体地址。</p>\n<p>寻址访问的过程中，TEXT段中某一个指令想要访问某一个全局数据的地址，(姑且叫使用全局数据A吧)TEXT段不会直接访问这个数据A的地址。而是编译器在会把这个地址，指向GOT中的某一个记录，这个记录就是数据A的地址，这样通过相对寻址来指向这个数据。</p>\n<p>但是这个过程中，还缺少一步就是对GOT表的重定向，因为数据在动态库被加载至虚拟内存的时才会被确定基地址。所以，在加载后，还需要通过重定向来修改这个数据的地址。</p>\n<p>似乎过程比装载时重定位一点都没有少，那么PIC的优势又在哪呢？</p>\n<ol>\n<li>PIC可以复用的GOT表。装载时重定位需要对所有的引用这个符号或者数据的地方都做指令修改，而PIC只需要修改GOT表一次就可以了。</li>\n<li>PIC无需修改代码段。上文提及的修改代码段是及其危险的一件事，而数据段本身也不是进程间共享的，PIC可以做到只修改数据段。而且这样可以让代码段在进程间共享。</li>\n</ol>\n<h3 id=\"PIC函数调用时延迟绑定\"><a href=\"#PIC函数调用时延迟绑定\" class=\"headerlink\" title=\"PIC函数调用时延迟绑定\"></a>PIC函数调用时延迟绑定</h3><p>PIC解决了以上两个问题，但是还有一个启动时间的问题。虽然PIC只需要修改一次GOT的地址就可以了，但是还是架不住函数多啊，函数的数量肯定远多于全局变量的数量。</p>\n<p>程序80%的时间都在执行20%的代码</p>\n<p>所以，函数地址的重定位可以延迟到第一次调用的时候。</p>\n<p>另外，对于函数的地址的解析，我们称为绑定（Bind）。</p>\n<p>通俗的来说，延迟绑定的机制就是：</p>\n<p>编译器在代码段中，插入一段“桩代码”，源代码指令中的函数跳转会通过相对寻址，直接指向PLT表中这个符号对应的桩代码。这段“桩代码”的执行过是：</p>\n<ol>\n<li>执行”桩代码”,先跳转到GOT表中这个符号指向的函数地址.</li>\n<li>编译器会把GOT表中这个地址的默认值写为“桩代码”中的下一个指令地址。即跳转回桩代码中的下一条指令。</li>\n<li>而下一个指令地址就是执行GOT表中这个符号的绑定过程（一般都由动态链接器负责）</li>\n</ol>\n<p>这个桩代码，称为PLT(程序链接表)。具体的流程看下图：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019121711250179-300x154.png\"></p>\n<p>等到下一次再执行的时候，GOT表内的符号地址已经是真正函数对应的地址了（Bind过程就是把GOT表中的符号地址替换为真正的函数地址）：</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/201912171125358-300x184.png\"></p>\n<h2 id=\"iOS动态库的符号\"><a href=\"#iOS动态库的符号\" class=\"headerlink\" title=\"iOS动态库的符号\"></a>iOS动态库的符号</h2><p>接下来，我们通过代码和实现来看看iOS的动态库是否和Linux的动态库一样。</p>\n<p>写一个简单Demo，看看NSLog的符号绑定吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface ViewController ()</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    // Do any additional setup after loading the view.</span><br><span class=\"line\">    NSLog(@&quot;1&quot;);</span><br><span class=\"line\">    NSLog(@&quot;2&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"静态分析\"><a href=\"#静态分析\" class=\"headerlink\" title=\"静态分析\"></a>静态分析</h3><p>编译完成后，因为代码量不多，我们先做静态分析。</p>\n<p>在 __TEXT 段的 __text 节中所有代码可以一眼望到底了。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2995f8ee2c76a2b85054185cc0fe56c4.png\"></p>\n<p>迅速找到第一个NSLog，这里bl 跳转到 0x100006558。（第二个NSLog也是跳转到这个地址）</p>\n<p>那找到偏移为0x6558的地址（Text段的虚拟地址起始地址是0x100000000,在Load Commands中声明了）。</p>\n<p>0x6558是在__TEXT段的__stubs节中，顾名思义是符号桩。根据上面Linux的动态库的理解，符号桩是一个假想的NSLog的实现，所有的指令都会向这个地址跳转。</p>\n<p>但是很僵硬…MachOView这个工具把某些细节汇编隐藏了。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/e401b01710523114905587681e611b87.png\"></p>\n<p>我们换个工具…<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/8fd0ad5d02a843cfe7f22f291972a7bd.png\"></p>\n<p>找到__stubs节，第一个符号就是imp__sthubs_NSLog。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldr x16，#0x10000c000</span><br><span class=\"line\">bl x16</span><br></pre></td></tr></table></figure>\n<p>这个假想的NSLog实现就是跳转到 #0x10000c000 地址内存储的地址。再找这个地址…<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/acca5b46a20c2d549fbbe8e53bfc21d0.png\"></p>\n<p>这个地址是数据段的！__la_symbol_ptr,通过名字也可以看出来—懒加载符号指针表。也就是对应上面提到的GOT表。GOT表内的NSLog又指向了0x660C。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/fd4c678b7b1035438732b918cd91d426.png\"></p>\n<p>__stub_helper…按照上面的逻辑，这个地址应该就是对应的PLT（程序链接表）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldr w16,0x100006614</span><br><span class=\"line\">b 0x1000065f4</span><br><span class=\"line\">.long 0x000000000</span><br></pre></td></tr></table></figure>\n<p>把 0x100006614 的值存储到w16内，也就是0，然后跳转到 0x1000065f4<br>0x1000065f4 就是这个__stub_helper的开头，可以观察到最终会跳转到 dyld_stub_binder，这个代码是在动态链接器内。<br>而 0x100006614 的值是为了告诉dyld需要链接的是哪个符号。</p>\n<p>至此第一次绑定的绑定过程已经全部完成了，如果第二次再调用的时候 __la_symbol_ptr 内函数符号对应的地址就已经是Bind之后的值了。</p>\n<p><strong>iOS动态库的首次绑定过程</strong></p>\n<ol>\n<li>指令跳转到符号的”桩代码“</li>\n<li>”桩代码“直接跳转GOT，GOT指向”__stub_helper“代码。</li>\n<li>这个helper代码的目的是跳转到dyld链接器的Bind入口处，执行Bind。</li>\n</ol>\n<p>可以看到，iOS和Linux的动态库绑定还是有点区别的：iOS把”桩代码“后面的跳转dyld部分直接抽离出来，放入了”__stub_helper” 中。（其实本质上是没有区别的）</p>\n<h3 id=\"运行时分析\"><a href=\"#运行时分析\" class=\"headerlink\" title=\"运行时分析\"></a>运行时分析</h3><p>我们在第一个NSLog处打一个断点，然后看汇编代码…<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0ed614a79304fe82ebd32bbd65cff51a.png\"></p>\n<p>直接 bl 0x100f46558 (第二个NSLog也是)</p>\n<p>我不会 Xcode 设置地址断点（不知道支不支持），用dis看一下这个地址的汇编代码吧。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/12b7e4719dd20339a6cbd1ba7020ed7c.png\"></p>\n<p>这里改成了相对寻址<code>ldr  x16, #0x5aa4</code> x1 最终的值是 当前指令地址+0x5aa4 &#x3D; 0x100F4C000 使用Xcode工具查看内存值。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b03ec9a2e1f26e74a557fed9bd87db79.png\"></p>\n<p>根据静态分析的逻辑，这个地址 0x100f4660c（注意大小端） 应该是 __la_symbol_ptr 中存储的 __stubs_helper 内这个符号的地址，</p>\n<p>再看看这个地址的代码确认一下:<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/036b6c1e611cf344da64f74cf774626a.png\"></p>\n<p>在下一个NSLog处再打一个断点…验证一下第二次执行。</p>\n<p>依旧是通过查看内存地址，看 0x100F4C000 这个地址的值。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/099695463b49a2eb7f6f2972f6ceb739.png\"></p>\n<p>值变成了 0x109c76e754<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/826557c3c1e53c4da1529fbfe29dc6ed.png\"></p>\n<p>而这个地址就已经变成真正的NSLog的函数地址了~</p>\n<blockquote>\n<p>本文只是通过Linux 的动态库的实现来理解iOS的动态库，通过一些实验和汇编分析验证我们的猜想。关于iOS的dyld的具体源码和细节，我会单开文章。</p>\n</blockquote>\n<p>参考<br><a href=\"https://www.jianshu.com/p/857855cda602\">iOS 系统的延迟绑定机制 - 简书</a><br><a href=\"https://blog.csdn.net/parallelyk/article/details/42747239\">动态共享对象的装载时重定位</a><br><a href=\"https://blog.csdn.net/wuhui_gdnt/article/details/51035557\">共享库载入时重定位</a><br><a href=\"https://blog.csdn.net/wuhui_gdnt/article/details/51094732\">共享库中的位置无关代码（PIC）</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Linux的共享库的重定位和符号绑定\"><a href=\"#Linux的共享库的重定位和符号绑定\" class=\"headerlink\" title=\"Linux的共享库的重定位和符号绑定\"></a>Linux的共享库的重定位和符号绑定</h2><p>动态共享库在进程间共享时，有两种符号链接方式：</p>\n<ol>\n<li>装载时重定位</li>\n<li>PIC（位置无关代码）</li>\n</ol>","more":"<h3 id=\"装载时重定位\"><a href=\"#装载时重定位\" class=\"headerlink\" title=\"装载时重定位\"></a>装载时重定位</h3><p>在首次使用某个动态库的时候，动态链接器会把磁盘上的这个库文件，映射到某块物理内存上。</p>\n<p>在此之后，动态链接器加载动态库的时候，会根据当前内存的情况，分配对应的一块虚拟内存来映射这个动态库。所以不论有多少进程在使用这个动态库，物理内存中这个动态库始终只有一份。</p>\n<p>然后…因为载入后不同进程的基地址不同，加上动态库内都是绝对寻址，所以需要修改动态库TEXT段内的指令。</p>\n<p>所以最终动态库内的寻址地址都是由动态库被加载的虚拟内存的基地址来决定的，而不同进程的基地址必然不会一样，那最终导致这部分的代码不可复用。</p>\n<p>另外，如果这部分的寻址过多，还容易引起链接时间过长（启动时间过久）。</p>\n<p>再另外，TEXT段的可写入，使得安全性的大大降低。</p>\n<p>由此引入了PIC</p>\n<h3 id=\"PIC（位置无关代码）\"><a href=\"#PIC（位置无关代码）\" class=\"headerlink\" title=\"PIC（位置无关代码）\"></a>PIC（位置无关代码）</h3><p>PIC实际上需要解决两个问题，一个是寻址问题，另一个是绑定问题。解决这两个问题，至少可以缓解以上的所有问题。</p>\n<ol>\n<li>寻址问题</li>\n</ol>\n<p>如果可以把绝对地址寻址改为相对地址寻址，那么也就不需要根据基地址来修改TEXT段的指令了。</p>\n<p>在此之前，相对地址有两个要素 基址+偏移。</p>\n<p>先看偏移，编译器可以把所有的TEXT段和DATA段分离（即使不放在一起也没关系）。当前指令需要的数据与指令的偏移，与编译器是可以确定的。</p>\n<p>即在链接器链接的时候，也是可以知道，当前指令需要的数据在此之后偏移多少。具体看下图：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019121711225490-300x280.png\"></p>\n<p>再看基址，基址可以通过一些“手段”获取到。</p>\n<p>例如在x86上，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    call TMPLABEL</span><br><span class=\"line\">TMPLABEL:</span><br><span class=\"line\">    pop ebx</span><br></pre></td></tr></table></figure>\n\n<p>call TMPLABEL 调用的时候，会把TMPLABEL的第一个命令地址（即 pop ebx）的地址入栈。而执行到当前命令的时候，又会弹出栈顶的值到ebx，那么此时ebx代表的就是当前的指令的地址了。</p>\n<ol start=\"2\">\n<li>绑定问题</li>\n</ol>\n<p>在做到相对寻址之后，如何把对应的符号绑定到对应真正的符号上？这里引入了GOT（全局偏移表）。GOT是一张全局的地址表，记录了指令内使用的符号或者数据的具体地址。</p>\n<p>寻址访问的过程中，TEXT段中某一个指令想要访问某一个全局数据的地址，(姑且叫使用全局数据A吧)TEXT段不会直接访问这个数据A的地址。而是编译器在会把这个地址，指向GOT中的某一个记录，这个记录就是数据A的地址，这样通过相对寻址来指向这个数据。</p>\n<p>但是这个过程中，还缺少一步就是对GOT表的重定向，因为数据在动态库被加载至虚拟内存的时才会被确定基地址。所以，在加载后，还需要通过重定向来修改这个数据的地址。</p>\n<p>似乎过程比装载时重定位一点都没有少，那么PIC的优势又在哪呢？</p>\n<ol>\n<li>PIC可以复用的GOT表。装载时重定位需要对所有的引用这个符号或者数据的地方都做指令修改，而PIC只需要修改GOT表一次就可以了。</li>\n<li>PIC无需修改代码段。上文提及的修改代码段是及其危险的一件事，而数据段本身也不是进程间共享的，PIC可以做到只修改数据段。而且这样可以让代码段在进程间共享。</li>\n</ol>\n<h3 id=\"PIC函数调用时延迟绑定\"><a href=\"#PIC函数调用时延迟绑定\" class=\"headerlink\" title=\"PIC函数调用时延迟绑定\"></a>PIC函数调用时延迟绑定</h3><p>PIC解决了以上两个问题，但是还有一个启动时间的问题。虽然PIC只需要修改一次GOT的地址就可以了，但是还是架不住函数多啊，函数的数量肯定远多于全局变量的数量。</p>\n<p>程序80%的时间都在执行20%的代码</p>\n<p>所以，函数地址的重定位可以延迟到第一次调用的时候。</p>\n<p>另外，对于函数的地址的解析，我们称为绑定（Bind）。</p>\n<p>通俗的来说，延迟绑定的机制就是：</p>\n<p>编译器在代码段中，插入一段“桩代码”，源代码指令中的函数跳转会通过相对寻址，直接指向PLT表中这个符号对应的桩代码。这段“桩代码”的执行过是：</p>\n<ol>\n<li>执行”桩代码”,先跳转到GOT表中这个符号指向的函数地址.</li>\n<li>编译器会把GOT表中这个地址的默认值写为“桩代码”中的下一个指令地址。即跳转回桩代码中的下一条指令。</li>\n<li>而下一个指令地址就是执行GOT表中这个符号的绑定过程（一般都由动态链接器负责）</li>\n</ol>\n<p>这个桩代码，称为PLT(程序链接表)。具体的流程看下图：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019121711250179-300x154.png\"></p>\n<p>等到下一次再执行的时候，GOT表内的符号地址已经是真正函数对应的地址了（Bind过程就是把GOT表中的符号地址替换为真正的函数地址）：</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/201912171125358-300x184.png\"></p>\n<h2 id=\"iOS动态库的符号\"><a href=\"#iOS动态库的符号\" class=\"headerlink\" title=\"iOS动态库的符号\"></a>iOS动态库的符号</h2><p>接下来，我们通过代码和实现来看看iOS的动态库是否和Linux的动态库一样。</p>\n<p>写一个简单Demo，看看NSLog的符号绑定吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface ViewController ()</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    // Do any additional setup after loading the view.</span><br><span class=\"line\">    NSLog(@&quot;1&quot;);</span><br><span class=\"line\">    NSLog(@&quot;2&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"静态分析\"><a href=\"#静态分析\" class=\"headerlink\" title=\"静态分析\"></a>静态分析</h3><p>编译完成后，因为代码量不多，我们先做静态分析。</p>\n<p>在 __TEXT 段的 __text 节中所有代码可以一眼望到底了。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2995f8ee2c76a2b85054185cc0fe56c4.png\"></p>\n<p>迅速找到第一个NSLog，这里bl 跳转到 0x100006558。（第二个NSLog也是跳转到这个地址）</p>\n<p>那找到偏移为0x6558的地址（Text段的虚拟地址起始地址是0x100000000,在Load Commands中声明了）。</p>\n<p>0x6558是在__TEXT段的__stubs节中，顾名思义是符号桩。根据上面Linux的动态库的理解，符号桩是一个假想的NSLog的实现，所有的指令都会向这个地址跳转。</p>\n<p>但是很僵硬…MachOView这个工具把某些细节汇编隐藏了。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/e401b01710523114905587681e611b87.png\"></p>\n<p>我们换个工具…<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/8fd0ad5d02a843cfe7f22f291972a7bd.png\"></p>\n<p>找到__stubs节，第一个符号就是imp__sthubs_NSLog。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldr x16，#0x10000c000</span><br><span class=\"line\">bl x16</span><br></pre></td></tr></table></figure>\n<p>这个假想的NSLog实现就是跳转到 #0x10000c000 地址内存储的地址。再找这个地址…<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/acca5b46a20c2d549fbbe8e53bfc21d0.png\"></p>\n<p>这个地址是数据段的！__la_symbol_ptr,通过名字也可以看出来—懒加载符号指针表。也就是对应上面提到的GOT表。GOT表内的NSLog又指向了0x660C。</p>\n<p><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/fd4c678b7b1035438732b918cd91d426.png\"></p>\n<p>__stub_helper…按照上面的逻辑，这个地址应该就是对应的PLT（程序链接表）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldr w16,0x100006614</span><br><span class=\"line\">b 0x1000065f4</span><br><span class=\"line\">.long 0x000000000</span><br></pre></td></tr></table></figure>\n<p>把 0x100006614 的值存储到w16内，也就是0，然后跳转到 0x1000065f4<br>0x1000065f4 就是这个__stub_helper的开头，可以观察到最终会跳转到 dyld_stub_binder，这个代码是在动态链接器内。<br>而 0x100006614 的值是为了告诉dyld需要链接的是哪个符号。</p>\n<p>至此第一次绑定的绑定过程已经全部完成了，如果第二次再调用的时候 __la_symbol_ptr 内函数符号对应的地址就已经是Bind之后的值了。</p>\n<p><strong>iOS动态库的首次绑定过程</strong></p>\n<ol>\n<li>指令跳转到符号的”桩代码“</li>\n<li>”桩代码“直接跳转GOT，GOT指向”__stub_helper“代码。</li>\n<li>这个helper代码的目的是跳转到dyld链接器的Bind入口处，执行Bind。</li>\n</ol>\n<p>可以看到，iOS和Linux的动态库绑定还是有点区别的：iOS把”桩代码“后面的跳转dyld部分直接抽离出来，放入了”__stub_helper” 中。（其实本质上是没有区别的）</p>\n<h3 id=\"运行时分析\"><a href=\"#运行时分析\" class=\"headerlink\" title=\"运行时分析\"></a>运行时分析</h3><p>我们在第一个NSLog处打一个断点，然后看汇编代码…<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0ed614a79304fe82ebd32bbd65cff51a.png\"></p>\n<p>直接 bl 0x100f46558 (第二个NSLog也是)</p>\n<p>我不会 Xcode 设置地址断点（不知道支不支持），用dis看一下这个地址的汇编代码吧。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/12b7e4719dd20339a6cbd1ba7020ed7c.png\"></p>\n<p>这里改成了相对寻址<code>ldr  x16, #0x5aa4</code> x1 最终的值是 当前指令地址+0x5aa4 &#x3D; 0x100F4C000 使用Xcode工具查看内存值。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b03ec9a2e1f26e74a557fed9bd87db79.png\"></p>\n<p>根据静态分析的逻辑，这个地址 0x100f4660c（注意大小端） 应该是 __la_symbol_ptr 中存储的 __stubs_helper 内这个符号的地址，</p>\n<p>再看看这个地址的代码确认一下:<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/036b6c1e611cf344da64f74cf774626a.png\"></p>\n<p>在下一个NSLog处再打一个断点…验证一下第二次执行。</p>\n<p>依旧是通过查看内存地址，看 0x100F4C000 这个地址的值。<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/099695463b49a2eb7f6f2972f6ceb739.png\"></p>\n<p>值变成了 0x109c76e754<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/826557c3c1e53c4da1529fbfe29dc6ed.png\"></p>\n<p>而这个地址就已经变成真正的NSLog的函数地址了~</p>\n<blockquote>\n<p>本文只是通过Linux 的动态库的实现来理解iOS的动态库，通过一些实验和汇编分析验证我们的猜想。关于iOS的dyld的具体源码和细节，我会单开文章。</p>\n</blockquote>\n<p>参考<br><a href=\"https://www.jianshu.com/p/857855cda602\">iOS 系统的延迟绑定机制 - 简书</a><br><a href=\"https://blog.csdn.net/parallelyk/article/details/42747239\">动态共享对象的装载时重定位</a><br><a href=\"https://blog.csdn.net/wuhui_gdnt/article/details/51035557\">共享库载入时重定位</a><br><a href=\"https://blog.csdn.net/wuhui_gdnt/article/details/51094732\">共享库中的位置无关代码（PIC）</a></p>"},{"title":"老生常谈，oc block的实现","date":"2019-12-20T16:00:00.000Z","top":400,"_content":"\n## Block是什么？\n\n一般来说OC上的语法糖，都可以使用 `clang --rewrite-objc code.m` 让clang 编译为 c 或 c++ ，由此可以窥探这些语法糖的具体实现。例如，oc的block，@autoreleasepool，[@synchronized](https://caio.ink/article-for-synchronized/)等等\n\n<!-- more -->\n\n## 说明\n\n1. Block的本质是个C的Struct，所以可以像C的Struct一样使用。\n```c\ntypedef int (^blk_t) (int)\nblk_t blk = ^(int count){return count;};\nblk_t *blkptr = &blk;\n(*blkptr)(10);\n```\n2. Block 没有实现截获C语言数组，只能通过指针截获。\n```c\n//const char text[] = “hello”;编译失败\nconst char *text = “hello”;\nvoid (^blk)(void) = ^{\n\ttext[0];\n};\n```\n\n## 实验&实现\n本文用一些实验，来通过实验现象来了解Block的具体实现\n\n### 没有任何截获\n源码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/e26327c7a8252fbb2df5b1fc39d64cda.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/1c595347ea6f38eb59d8d6801db5a5a0.png)\n\n可以看到Block的在C语言的实现中是一个struct。struct中记录了Block具体方法实现的imp（即void *FuncPtr）。在调用Block的时候，实际上是调用了这个struct（__block_impl）内存储的函数指针。\n\n### 截获基本数据类型的自动变量\n源码:\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/9982c40af54e96e97aa13b0b29efdfdc.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b317fc859fa2d1b0afc1477a73cc7f39.png)\n\n如果在Block内截获了外部的基本数据类型，那么这个基本数据类型就会在Block初始化的时候，以当时的“快照”被存储到Block结构体的成员变量内。在调用void *FuncPtr的时候，方法内部使用的数据就是这些被截获的数据。\n\n**为什么不支持C语言数组？？**\n```c\n//如果支持C语言数组，那么必然会出现如下代码\n//但是在C语言规范上，是不允许把一个数组类型的变量赋给另一个数组变量\nvoid funcA(char a[20]){\n    char b[20] = a;\n}\n```\n\n### 截获全局变量 && 静态全局变量 && 静态变量\n源码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/d24f45909549cba411ff8ef19e8dc548.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0af0536f3686b6366a21ed365e22f437.png)\n\n全局变量和静态全局变量没有什么区别，重写之后访问这些变量的方式依旧不变。\n\n不同的是静态变量，静态变量在Block内会被截获这个静态变量的地址。如果是普通变量，在作用域结束的时候就会随着函数的结束，栈的弹出而销毁。但是静态变量是在程序执行前就分配好的数据区，并不会随着函数作用域而释放，所以Block可以通过截获这个变量的地址来访问这个变量。\n\n### 截获对象(指针)类型的自动变量\n源码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/dd51589cfa5279abd032d17d217173d6.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/ae2340f59a762a58e2d0edbfadc9c397.png)\n\n在Block被copy的时候调用desc0中的__main_block_copy_0持有OC对象\n\n在Block被release的时候调用desc0中的__main_block_dispose_0释放持有的OC对象\n\n### 截获__block修饰的基本数据类型\n源码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/6215c228093c8e9d52dc2e9568e56fa7.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/29e2701bbf1eb9514c8aa230801bc576.png)\n\n变量 i 变成了一个结构体对象__Block_byref_val_0，并且block_imp中持有的也是这个结构体指针\n\n### 截获__block修饰的指针类型的自动变量\n源码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0f6bf9053dada99721d8e83858e6e709.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/63595834f2342745c0191f4babc0ca94.png)\n\n`__Block_byref` 对象新增Copy函数指针和dispose函数指针\n\n`__Block_byref` 也是一个对象，所以在BlockCopy的时候会调用`__Block_byref`的copy，同样释放的时候也会调用dispose\n\n注:在ARC无效的时候，byref不会调用对象的retain。（可以被用来在MRC下避免循环引用）\n\n## QA.\n###  __block变量超出变量作用域存在的理由？\n\n根据上面带`__block`变量基本类型变量和指针类型变量的描述，可以解释这个问题\n\n### forwarding存在的理由？\n\n这张图来自于（Objective-C高级编程 iOS与OS X多线程和内存管理）\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/053f17c28960744f29a443720914d877.png)\n\n栈上的__block变量的结构体实例，在__block变量从栈上复制到堆上的时候（`__Block_byref_id_object_copy_131`参数中一个是堆上的，一个是栈上的），会将成员变量`__forwarding`的值替换为堆上的值。\n\n**当Block被Copy的时候就会Copy `__Block_byref`,并且改变原有 __forwarding 指针**\n\n### Block的存储域？\n\n1. 在 ARC 环境下，只要给一个自动变量赋值一个堆栈`__NSStackBlock__`上block，那么就会调用block的copy\n2. 如果Block不截获任何变量那么生成`__NSGlobalBlock__` 存储在数据区\n3. GCD的参数block和Cocoa框架中的UsingBlock传入的参数会被copy\n4. `__NSStackBlock__`会被copy到`__NSMallocBlock__`\n5. `__NSMallocBlock__`copy会增加引用计数\n6. `__NSGlobalBlock__`copy没有任何影响\n\n### 为什么说Block是Objc对象？\n\n1. block 的结构体可以直接转换为oc对象 objc_object的结构体。objc_object中的isa指向的是class，同样的Block也是指向 `__NSMallocBlock__`、`__NSMallocBlock__`、`__NSMallocBlock__`class，这是三个class在runtime初始化的时候会被注册到class表中。\n2. block 和 object在同样的内存管理机制下进行创建和释放。\n","source":"_posts/5.OC-Block-imp.md","raw":"---\ntitle: 老生常谈，oc block的实现\ndate: 2019-12-21\ntags: [object-c]\ntop: 400\ncategories: 语法糖\n---\n\n## Block是什么？\n\n一般来说OC上的语法糖，都可以使用 `clang --rewrite-objc code.m` 让clang 编译为 c 或 c++ ，由此可以窥探这些语法糖的具体实现。例如，oc的block，@autoreleasepool，[@synchronized](https://caio.ink/article-for-synchronized/)等等\n\n<!-- more -->\n\n## 说明\n\n1. Block的本质是个C的Struct，所以可以像C的Struct一样使用。\n```c\ntypedef int (^blk_t) (int)\nblk_t blk = ^(int count){return count;};\nblk_t *blkptr = &blk;\n(*blkptr)(10);\n```\n2. Block 没有实现截获C语言数组，只能通过指针截获。\n```c\n//const char text[] = “hello”;编译失败\nconst char *text = “hello”;\nvoid (^blk)(void) = ^{\n\ttext[0];\n};\n```\n\n## 实验&实现\n本文用一些实验，来通过实验现象来了解Block的具体实现\n\n### 没有任何截获\n源码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/e26327c7a8252fbb2df5b1fc39d64cda.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/1c595347ea6f38eb59d8d6801db5a5a0.png)\n\n可以看到Block的在C语言的实现中是一个struct。struct中记录了Block具体方法实现的imp（即void *FuncPtr）。在调用Block的时候，实际上是调用了这个struct（__block_impl）内存储的函数指针。\n\n### 截获基本数据类型的自动变量\n源码:\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/9982c40af54e96e97aa13b0b29efdfdc.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b317fc859fa2d1b0afc1477a73cc7f39.png)\n\n如果在Block内截获了外部的基本数据类型，那么这个基本数据类型就会在Block初始化的时候，以当时的“快照”被存储到Block结构体的成员变量内。在调用void *FuncPtr的时候，方法内部使用的数据就是这些被截获的数据。\n\n**为什么不支持C语言数组？？**\n```c\n//如果支持C语言数组，那么必然会出现如下代码\n//但是在C语言规范上，是不允许把一个数组类型的变量赋给另一个数组变量\nvoid funcA(char a[20]){\n    char b[20] = a;\n}\n```\n\n### 截获全局变量 && 静态全局变量 && 静态变量\n源码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/d24f45909549cba411ff8ef19e8dc548.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0af0536f3686b6366a21ed365e22f437.png)\n\n全局变量和静态全局变量没有什么区别，重写之后访问这些变量的方式依旧不变。\n\n不同的是静态变量，静态变量在Block内会被截获这个静态变量的地址。如果是普通变量，在作用域结束的时候就会随着函数的结束，栈的弹出而销毁。但是静态变量是在程序执行前就分配好的数据区，并不会随着函数作用域而释放，所以Block可以通过截获这个变量的地址来访问这个变量。\n\n### 截获对象(指针)类型的自动变量\n源码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/dd51589cfa5279abd032d17d217173d6.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/ae2340f59a762a58e2d0edbfadc9c397.png)\n\n在Block被copy的时候调用desc0中的__main_block_copy_0持有OC对象\n\n在Block被release的时候调用desc0中的__main_block_dispose_0释放持有的OC对象\n\n### 截获__block修饰的基本数据类型\n源码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/6215c228093c8e9d52dc2e9568e56fa7.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/29e2701bbf1eb9514c8aa230801bc576.png)\n\n变量 i 变成了一个结构体对象__Block_byref_val_0，并且block_imp中持有的也是这个结构体指针\n\n### 截获__block修饰的指针类型的自动变量\n源码：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0f6bf9053dada99721d8e83858e6e709.png)\n\nclang 重写之后：\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/63595834f2342745c0191f4babc0ca94.png)\n\n`__Block_byref` 对象新增Copy函数指针和dispose函数指针\n\n`__Block_byref` 也是一个对象，所以在BlockCopy的时候会调用`__Block_byref`的copy，同样释放的时候也会调用dispose\n\n注:在ARC无效的时候，byref不会调用对象的retain。（可以被用来在MRC下避免循环引用）\n\n## QA.\n###  __block变量超出变量作用域存在的理由？\n\n根据上面带`__block`变量基本类型变量和指针类型变量的描述，可以解释这个问题\n\n### forwarding存在的理由？\n\n这张图来自于（Objective-C高级编程 iOS与OS X多线程和内存管理）\n![](https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/053f17c28960744f29a443720914d877.png)\n\n栈上的__block变量的结构体实例，在__block变量从栈上复制到堆上的时候（`__Block_byref_id_object_copy_131`参数中一个是堆上的，一个是栈上的），会将成员变量`__forwarding`的值替换为堆上的值。\n\n**当Block被Copy的时候就会Copy `__Block_byref`,并且改变原有 __forwarding 指针**\n\n### Block的存储域？\n\n1. 在 ARC 环境下，只要给一个自动变量赋值一个堆栈`__NSStackBlock__`上block，那么就会调用block的copy\n2. 如果Block不截获任何变量那么生成`__NSGlobalBlock__` 存储在数据区\n3. GCD的参数block和Cocoa框架中的UsingBlock传入的参数会被copy\n4. `__NSStackBlock__`会被copy到`__NSMallocBlock__`\n5. `__NSMallocBlock__`copy会增加引用计数\n6. `__NSGlobalBlock__`copy没有任何影响\n\n### 为什么说Block是Objc对象？\n\n1. block 的结构体可以直接转换为oc对象 objc_object的结构体。objc_object中的isa指向的是class，同样的Block也是指向 `__NSMallocBlock__`、`__NSMallocBlock__`、`__NSMallocBlock__`class，这是三个class在runtime初始化的时候会被注册到class表中。\n2. block 和 object在同样的内存管理机制下进行创建和释放。\n","slug":"5.OC-Block-imp","published":1,"updated":"2022-07-28T13:38:40.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwof001zp9c91np0f8re","content":"<h2 id=\"Block是什么？\"><a href=\"#Block是什么？\" class=\"headerlink\" title=\"Block是什么？\"></a>Block是什么？</h2><p>一般来说OC上的语法糖，都可以使用 <code>clang --rewrite-objc code.m</code> 让clang 编译为 c 或 c++ ，由此可以窥探这些语法糖的具体实现。例如，oc的block，@autoreleasepool，<a href=\"https://caio.ink/article-for-synchronized/\">@synchronized</a>等等</p>\n<span id=\"more\"></span>\n\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><ol>\n<li>Block的本质是个C的Struct，所以可以像C的Struct一样使用。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">int</span> <span class=\"params\">(^<span class=\"type\">blk_t</span>)</span> <span class=\"params\">(<span class=\"type\">int</span>)</span></span><br><span class=\"line\"><span class=\"type\">blk_t</span> blk = ^(<span class=\"type\">int</span> count)&#123;<span class=\"keyword\">return</span> count;&#125;;</span><br><span class=\"line\"><span class=\"type\">blk_t</span> *blkptr = &amp;blk;</span><br><span class=\"line\">(*blkptr)(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure></li>\n<li>Block 没有实现截获C语言数组，只能通过指针截获。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//const char text[] = “hello”;编译失败</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> *text = “hello”;</span><br><span class=\"line\"><span class=\"type\">void</span> (^blk)(<span class=\"type\">void</span>) = ^&#123;</span><br><span class=\"line\">\ttext[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"实验-amp-实现\"><a href=\"#实验-amp-实现\" class=\"headerlink\" title=\"实验&amp;实现\"></a>实验&amp;实现</h2><p>本文用一些实验，来通过实验现象来了解Block的具体实现</p>\n<h3 id=\"没有任何截获\"><a href=\"#没有任何截获\" class=\"headerlink\" title=\"没有任何截获\"></a>没有任何截获</h3><p>源码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/e26327c7a8252fbb2df5b1fc39d64cda.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/1c595347ea6f38eb59d8d6801db5a5a0.png\"></p>\n<p>可以看到Block的在C语言的实现中是一个struct。struct中记录了Block具体方法实现的imp（即void *FuncPtr）。在调用Block的时候，实际上是调用了这个struct（__block_impl）内存储的函数指针。</p>\n<h3 id=\"截获基本数据类型的自动变量\"><a href=\"#截获基本数据类型的自动变量\" class=\"headerlink\" title=\"截获基本数据类型的自动变量\"></a>截获基本数据类型的自动变量</h3><p>源码:<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/9982c40af54e96e97aa13b0b29efdfdc.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b317fc859fa2d1b0afc1477a73cc7f39.png\"></p>\n<p>如果在Block内截获了外部的基本数据类型，那么这个基本数据类型就会在Block初始化的时候，以当时的“快照”被存储到Block结构体的成员变量内。在调用void *FuncPtr的时候，方法内部使用的数据就是这些被截获的数据。</p>\n<p><strong>为什么不支持C语言数组？？</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果支持C语言数组，那么必然会出现如下代码</span></span><br><span class=\"line\"><span class=\"comment\">//但是在C语言规范上，是不允许把一个数组类型的变量赋给另一个数组变量</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">funcA</span><span class=\"params\">(<span class=\"type\">char</span> a[<span class=\"number\">20</span>])</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> b[<span class=\"number\">20</span>] = a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"截获全局变量-amp-amp-静态全局变量-amp-amp-静态变量\"><a href=\"#截获全局变量-amp-amp-静态全局变量-amp-amp-静态变量\" class=\"headerlink\" title=\"截获全局变量 &amp;&amp; 静态全局变量 &amp;&amp; 静态变量\"></a>截获全局变量 &amp;&amp; 静态全局变量 &amp;&amp; 静态变量</h3><p>源码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/d24f45909549cba411ff8ef19e8dc548.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0af0536f3686b6366a21ed365e22f437.png\"></p>\n<p>全局变量和静态全局变量没有什么区别，重写之后访问这些变量的方式依旧不变。</p>\n<p>不同的是静态变量，静态变量在Block内会被截获这个静态变量的地址。如果是普通变量，在作用域结束的时候就会随着函数的结束，栈的弹出而销毁。但是静态变量是在程序执行前就分配好的数据区，并不会随着函数作用域而释放，所以Block可以通过截获这个变量的地址来访问这个变量。</p>\n<h3 id=\"截获对象-指针-类型的自动变量\"><a href=\"#截获对象-指针-类型的自动变量\" class=\"headerlink\" title=\"截获对象(指针)类型的自动变量\"></a>截获对象(指针)类型的自动变量</h3><p>源码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/dd51589cfa5279abd032d17d217173d6.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/ae2340f59a762a58e2d0edbfadc9c397.png\"></p>\n<p>在Block被copy的时候调用desc0中的__main_block_copy_0持有OC对象</p>\n<p>在Block被release的时候调用desc0中的__main_block_dispose_0释放持有的OC对象</p>\n<h3 id=\"截获-block修饰的基本数据类型\"><a href=\"#截获-block修饰的基本数据类型\" class=\"headerlink\" title=\"截获__block修饰的基本数据类型\"></a>截获__block修饰的基本数据类型</h3><p>源码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/6215c228093c8e9d52dc2e9568e56fa7.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/29e2701bbf1eb9514c8aa230801bc576.png\"></p>\n<p>变量 i 变成了一个结构体对象__Block_byref_val_0，并且block_imp中持有的也是这个结构体指针</p>\n<h3 id=\"截获-block修饰的指针类型的自动变量\"><a href=\"#截获-block修饰的指针类型的自动变量\" class=\"headerlink\" title=\"截获__block修饰的指针类型的自动变量\"></a>截获__block修饰的指针类型的自动变量</h3><p>源码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0f6bf9053dada99721d8e83858e6e709.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/63595834f2342745c0191f4babc0ca94.png\"></p>\n<p><code>__Block_byref</code> 对象新增Copy函数指针和dispose函数指针</p>\n<p><code>__Block_byref</code> 也是一个对象，所以在BlockCopy的时候会调用<code>__Block_byref</code>的copy，同样释放的时候也会调用dispose</p>\n<p>注:在ARC无效的时候，byref不会调用对象的retain。（可以被用来在MRC下避免循环引用）</p>\n<h2 id=\"QA\"><a href=\"#QA\" class=\"headerlink\" title=\"QA.\"></a>QA.</h2><h3 id=\"block变量超出变量作用域存在的理由？\"><a href=\"#block变量超出变量作用域存在的理由？\" class=\"headerlink\" title=\"__block变量超出变量作用域存在的理由？\"></a>__block变量超出变量作用域存在的理由？</h3><p>根据上面带<code>__block</code>变量基本类型变量和指针类型变量的描述，可以解释这个问题</p>\n<h3 id=\"forwarding存在的理由？\"><a href=\"#forwarding存在的理由？\" class=\"headerlink\" title=\"forwarding存在的理由？\"></a>forwarding存在的理由？</h3><p>这张图来自于（Objective-C高级编程 iOS与OS X多线程和内存管理）<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/053f17c28960744f29a443720914d877.png\"></p>\n<p>栈上的__block变量的结构体实例，在__block变量从栈上复制到堆上的时候（<code>__Block_byref_id_object_copy_131</code>参数中一个是堆上的，一个是栈上的），会将成员变量<code>__forwarding</code>的值替换为堆上的值。</p>\n<p><strong>当Block被Copy的时候就会Copy <code>__Block_byref</code>,并且改变原有 __forwarding 指针</strong></p>\n<h3 id=\"Block的存储域？\"><a href=\"#Block的存储域？\" class=\"headerlink\" title=\"Block的存储域？\"></a>Block的存储域？</h3><ol>\n<li>在 ARC 环境下，只要给一个自动变量赋值一个堆栈<code>__NSStackBlock__</code>上block，那么就会调用block的copy</li>\n<li>如果Block不截获任何变量那么生成<code>__NSGlobalBlock__</code> 存储在数据区</li>\n<li>GCD的参数block和Cocoa框架中的UsingBlock传入的参数会被copy</li>\n<li><code>__NSStackBlock__</code>会被copy到<code>__NSMallocBlock__</code></li>\n<li><code>__NSMallocBlock__</code>copy会增加引用计数</li>\n<li><code>__NSGlobalBlock__</code>copy没有任何影响</li>\n</ol>\n<h3 id=\"为什么说Block是Objc对象？\"><a href=\"#为什么说Block是Objc对象？\" class=\"headerlink\" title=\"为什么说Block是Objc对象？\"></a>为什么说Block是Objc对象？</h3><ol>\n<li>block 的结构体可以直接转换为oc对象 objc_object的结构体。objc_object中的isa指向的是class，同样的Block也是指向 <code>__NSMallocBlock__</code>、<code>__NSMallocBlock__</code>、<code>__NSMallocBlock__</code>class，这是三个class在runtime初始化的时候会被注册到class表中。</li>\n<li>block 和 object在同样的内存管理机制下进行创建和释放。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"Block是什么？\"><a href=\"#Block是什么？\" class=\"headerlink\" title=\"Block是什么？\"></a>Block是什么？</h2><p>一般来说OC上的语法糖，都可以使用 <code>clang --rewrite-objc code.m</code> 让clang 编译为 c 或 c++ ，由此可以窥探这些语法糖的具体实现。例如，oc的block，@autoreleasepool，<a href=\"https://caio.ink/article-for-synchronized/\">@synchronized</a>等等</p>","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><ol>\n<li>Block的本质是个C的Struct，所以可以像C的Struct一样使用。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">int</span> <span class=\"params\">(^<span class=\"type\">blk_t</span>)</span> <span class=\"params\">(<span class=\"type\">int</span>)</span></span><br><span class=\"line\"><span class=\"type\">blk_t</span> blk = ^(<span class=\"type\">int</span> count)&#123;<span class=\"keyword\">return</span> count;&#125;;</span><br><span class=\"line\"><span class=\"type\">blk_t</span> *blkptr = &amp;blk;</span><br><span class=\"line\">(*blkptr)(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure></li>\n<li>Block 没有实现截获C语言数组，只能通过指针截获。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//const char text[] = “hello”;编译失败</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> *text = “hello”;</span><br><span class=\"line\"><span class=\"type\">void</span> (^blk)(<span class=\"type\">void</span>) = ^&#123;</span><br><span class=\"line\">\ttext[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"实验-amp-实现\"><a href=\"#实验-amp-实现\" class=\"headerlink\" title=\"实验&amp;实现\"></a>实验&amp;实现</h2><p>本文用一些实验，来通过实验现象来了解Block的具体实现</p>\n<h3 id=\"没有任何截获\"><a href=\"#没有任何截获\" class=\"headerlink\" title=\"没有任何截获\"></a>没有任何截获</h3><p>源码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/e26327c7a8252fbb2df5b1fc39d64cda.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/1c595347ea6f38eb59d8d6801db5a5a0.png\"></p>\n<p>可以看到Block的在C语言的实现中是一个struct。struct中记录了Block具体方法实现的imp（即void *FuncPtr）。在调用Block的时候，实际上是调用了这个struct（__block_impl）内存储的函数指针。</p>\n<h3 id=\"截获基本数据类型的自动变量\"><a href=\"#截获基本数据类型的自动变量\" class=\"headerlink\" title=\"截获基本数据类型的自动变量\"></a>截获基本数据类型的自动变量</h3><p>源码:<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/9982c40af54e96e97aa13b0b29efdfdc.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/b317fc859fa2d1b0afc1477a73cc7f39.png\"></p>\n<p>如果在Block内截获了外部的基本数据类型，那么这个基本数据类型就会在Block初始化的时候，以当时的“快照”被存储到Block结构体的成员变量内。在调用void *FuncPtr的时候，方法内部使用的数据就是这些被截获的数据。</p>\n<p><strong>为什么不支持C语言数组？？</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果支持C语言数组，那么必然会出现如下代码</span></span><br><span class=\"line\"><span class=\"comment\">//但是在C语言规范上，是不允许把一个数组类型的变量赋给另一个数组变量</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">funcA</span><span class=\"params\">(<span class=\"type\">char</span> a[<span class=\"number\">20</span>])</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> b[<span class=\"number\">20</span>] = a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"截获全局变量-amp-amp-静态全局变量-amp-amp-静态变量\"><a href=\"#截获全局变量-amp-amp-静态全局变量-amp-amp-静态变量\" class=\"headerlink\" title=\"截获全局变量 &amp;&amp; 静态全局变量 &amp;&amp; 静态变量\"></a>截获全局变量 &amp;&amp; 静态全局变量 &amp;&amp; 静态变量</h3><p>源码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/d24f45909549cba411ff8ef19e8dc548.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0af0536f3686b6366a21ed365e22f437.png\"></p>\n<p>全局变量和静态全局变量没有什么区别，重写之后访问这些变量的方式依旧不变。</p>\n<p>不同的是静态变量，静态变量在Block内会被截获这个静态变量的地址。如果是普通变量，在作用域结束的时候就会随着函数的结束，栈的弹出而销毁。但是静态变量是在程序执行前就分配好的数据区，并不会随着函数作用域而释放，所以Block可以通过截获这个变量的地址来访问这个变量。</p>\n<h3 id=\"截获对象-指针-类型的自动变量\"><a href=\"#截获对象-指针-类型的自动变量\" class=\"headerlink\" title=\"截获对象(指针)类型的自动变量\"></a>截获对象(指针)类型的自动变量</h3><p>源码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/dd51589cfa5279abd032d17d217173d6.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/ae2340f59a762a58e2d0edbfadc9c397.png\"></p>\n<p>在Block被copy的时候调用desc0中的__main_block_copy_0持有OC对象</p>\n<p>在Block被release的时候调用desc0中的__main_block_dispose_0释放持有的OC对象</p>\n<h3 id=\"截获-block修饰的基本数据类型\"><a href=\"#截获-block修饰的基本数据类型\" class=\"headerlink\" title=\"截获__block修饰的基本数据类型\"></a>截获__block修饰的基本数据类型</h3><p>源码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/6215c228093c8e9d52dc2e9568e56fa7.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/29e2701bbf1eb9514c8aa230801bc576.png\"></p>\n<p>变量 i 变成了一个结构体对象__Block_byref_val_0，并且block_imp中持有的也是这个结构体指针</p>\n<h3 id=\"截获-block修饰的指针类型的自动变量\"><a href=\"#截获-block修饰的指针类型的自动变量\" class=\"headerlink\" title=\"截获__block修饰的指针类型的自动变量\"></a>截获__block修饰的指针类型的自动变量</h3><p>源码：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/0f6bf9053dada99721d8e83858e6e709.png\"></p>\n<p>clang 重写之后：<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/63595834f2342745c0191f4babc0ca94.png\"></p>\n<p><code>__Block_byref</code> 对象新增Copy函数指针和dispose函数指针</p>\n<p><code>__Block_byref</code> 也是一个对象，所以在BlockCopy的时候会调用<code>__Block_byref</code>的copy，同样释放的时候也会调用dispose</p>\n<p>注:在ARC无效的时候，byref不会调用对象的retain。（可以被用来在MRC下避免循环引用）</p>\n<h2 id=\"QA\"><a href=\"#QA\" class=\"headerlink\" title=\"QA.\"></a>QA.</h2><h3 id=\"block变量超出变量作用域存在的理由？\"><a href=\"#block变量超出变量作用域存在的理由？\" class=\"headerlink\" title=\"__block变量超出变量作用域存在的理由？\"></a>__block变量超出变量作用域存在的理由？</h3><p>根据上面带<code>__block</code>变量基本类型变量和指针类型变量的描述，可以解释这个问题</p>\n<h3 id=\"forwarding存在的理由？\"><a href=\"#forwarding存在的理由？\" class=\"headerlink\" title=\"forwarding存在的理由？\"></a>forwarding存在的理由？</h3><p>这张图来自于（Objective-C高级编程 iOS与OS X多线程和内存管理）<br><img src=\"https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2019/12/053f17c28960744f29a443720914d877.png\"></p>\n<p>栈上的__block变量的结构体实例，在__block变量从栈上复制到堆上的时候（<code>__Block_byref_id_object_copy_131</code>参数中一个是堆上的，一个是栈上的），会将成员变量<code>__forwarding</code>的值替换为堆上的值。</p>\n<p><strong>当Block被Copy的时候就会Copy <code>__Block_byref</code>,并且改变原有 __forwarding 指针</strong></p>\n<h3 id=\"Block的存储域？\"><a href=\"#Block的存储域？\" class=\"headerlink\" title=\"Block的存储域？\"></a>Block的存储域？</h3><ol>\n<li>在 ARC 环境下，只要给一个自动变量赋值一个堆栈<code>__NSStackBlock__</code>上block，那么就会调用block的copy</li>\n<li>如果Block不截获任何变量那么生成<code>__NSGlobalBlock__</code> 存储在数据区</li>\n<li>GCD的参数block和Cocoa框架中的UsingBlock传入的参数会被copy</li>\n<li><code>__NSStackBlock__</code>会被copy到<code>__NSMallocBlock__</code></li>\n<li><code>__NSMallocBlock__</code>copy会增加引用计数</li>\n<li><code>__NSGlobalBlock__</code>copy没有任何影响</li>\n</ol>\n<h3 id=\"为什么说Block是Objc对象？\"><a href=\"#为什么说Block是Objc对象？\" class=\"headerlink\" title=\"为什么说Block是Objc对象？\"></a>为什么说Block是Objc对象？</h3><ol>\n<li>block 的结构体可以直接转换为oc对象 objc_object的结构体。objc_object中的isa指向的是class，同样的Block也是指向 <code>__NSMallocBlock__</code>、<code>__NSMallocBlock__</code>、<code>__NSMallocBlock__</code>class，这是三个class在runtime初始化的时候会被注册到class表中。</li>\n<li>block 和 object在同样的内存管理机制下进行创建和释放。</li>\n</ol>"},{"title":"全排列 -- LeetCode[46]","date":"2020-01-04T16:00:00.000Z","_content":"\n> 【Medium】给定一个没有重复数字的序列，返回其所有可能的全排列。\n\n<!-- more -->\n\n举例:\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n**回溯法**\n关于回溯法的其他题型，看[这里](https://caio.ink/tag/arg-backtrack/)\n\n回溯法的算法原型是：\n通过探索所有可能的候选解来找出所有的解。如果候选解被确认 不是 一个解的话（或者至少不是 最后一个 解），回溯算法会通过在上一步进行一些变化抛弃该解，即 **回溯** 并且再次尝试。\n\n其实回溯算法关键在于:\n不合适就退回上一步\n然后通过约束条件, 减少时间复杂度。\n\n### 题解一\n\n```java\npublic class Solution46 {\n  public List<List<Integer>> permute(int[] nums) {\n\n    List<List<Integer>> res = new ArrayList<>();\n    int[] visited = new int[nums.length];//用来标识，当前递归链中，某个索引下的值是否被使用过了。\n    backtrack(res, nums, new ArrayList<Integer>(), visited);\n    return res;\n\n  }\n\n  private void backtrack(List<List<Integer>> res, int[] nums, ArrayList<Integer> tmp, int[] visited) {\n    if (tmp.size() == nums.length) {\n      res.add(new ArrayList<>(tmp));\n      return;\n    }\n    for (int i = 0; i < nums.length; i++) {\n      if (visited[i] == 1)//如果这个值被使用过了，那么就继续用下一个\n        continue;\n      tmp.add(nums[i]);//加入链表\n      visited[i] = 1;//标记这个值被使用过了\n\n      backtrack(res, nums, tmp, visited);\n      //回溯\n      visited[i] = 0;\n      tmp.remove(tmp.size() - 1);\n    }\n  }\n}\n```\n\n这个解法是我看到的第二个解法（因为第一个解法，也就是下面的解法，第一次没看懂[哭]）。这个解法其实一眼就看出来了。\n\n和概率论中的摸球题思想有点类似。\n\nN个Value，先固定第一个，N个值里去找第二个。\n怎么去找N个Value里的那个第二个值，而不和第一个重复呢？题解里，用一个visited来标识这个值是否已经被用过。\n找到一个解之后，就通过回溯的方式，再去寻找下一个解。\n\n这就是回溯的基本思想。\n\n看完上一个题解之后，其实发现，在N个value中找第二个值的方式似乎可以优化。\n于是有了下面这个题解。\n\n### 题解二\n\n```java\nclass Solution {\n    public void backtrack(int n, ArrayList<Integer> nums, List<List<Integer>> output, int first) {\n        // if all integers are used up\n        if (first == n)\n            output.add(new ArrayList<Integer>(nums));\n\n        for (int i = first; i < n; i++) {\n            // place i-th integer first\n            // in the current permutation\n            Collections.swap(nums, first, i);\n            // use next integers to complete the permutations\n            backtrack(n, nums, output, first + 1);\n            // backtrack\n            Collections.swap(nums, first, i);\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        // init output list\n        List<List<Integer>> output = new LinkedList<List<Integer>>();\n\n        // convert nums into list since the output is a list of lists\n        ArrayList<Integer> nums_lst = new ArrayList<Integer>();\n        for (int num : nums)\n            nums_lst.add(num);\n\n        int n = nums.length;\n        backtrack(n, nums_lst, output, 0);\n        return output;\n    }\n}\n```\n\n这是这道题 LeetCode的官方题解。\n\n题解一中的tmp链表，其实是用来探索并且存储一个解。但是这个解其实可以直接存储在原始链表内，通过swap，交换元素位置，来得到一个解。而回溯的时候，只需逆向的swap即可。\n\n举个例子，加入有N个value，记作 Arr[N]，算法流程：\n1. 固定第一个value，一共有N种可能性。所以遍历索引i<N，并且把Arr[i]与第一个交换。那么剩下来的事情，就变成：把剩余N-1个值排列出所有的可能性。\n2. 不断的递归 第1步 ，只不过每次固定的是剩余的Value中的第一个值，一直到最后一个值。这个时候，Arr中的就是其中的一个解了。\n3. 接下来就是回溯，回溯的方法就是反向swap。每次循环都是一个回溯。\n\n### 算法复杂度：\n第一个递归是N次循环，第二个递归是N-1次，第三个是N-2次...\n时间复杂度应该是：O(n!)题解一的时间复杂度为O(n^n)\n空间复杂度应该是：O(1) 题解一的空间复杂度是O(n)\n\n与此题型类似的有:\n1. [39组合总和](https://leetcode-cn.com/problems/combination-sum)\n2. [40组合总和II](https://leetcode-cn.com/problems/combination-sum-ii)\n3. [46全排列](https://leetcode-cn.com/problems/permutations)--看[站内文章](https://caio.ink/leetcode46/)\n4. [47全排列II](https://leetcode-cn.com/problems/permutations-ii)--看[站内文章](https://caio.ink/leetcode47/)\n5. [77组合](https://leetcode-cn.com/problems/combinations)\n6. [78子集](https://leetcode-cn.com/problems/subsets)\n7. [90子集II](https://leetcode-cn.com/problems/subsets-ii)\n","source":"_posts/7.leetcode46.md","raw":"---\ntitle: 全排列 -- LeetCode[46]\ndate: 2020-01-05\ntags: [leetcode,回溯法]\ncategories: 算法\n---\n\n> 【Medium】给定一个没有重复数字的序列，返回其所有可能的全排列。\n\n<!-- more -->\n\n举例:\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n**回溯法**\n关于回溯法的其他题型，看[这里](https://caio.ink/tag/arg-backtrack/)\n\n回溯法的算法原型是：\n通过探索所有可能的候选解来找出所有的解。如果候选解被确认 不是 一个解的话（或者至少不是 最后一个 解），回溯算法会通过在上一步进行一些变化抛弃该解，即 **回溯** 并且再次尝试。\n\n其实回溯算法关键在于:\n不合适就退回上一步\n然后通过约束条件, 减少时间复杂度。\n\n### 题解一\n\n```java\npublic class Solution46 {\n  public List<List<Integer>> permute(int[] nums) {\n\n    List<List<Integer>> res = new ArrayList<>();\n    int[] visited = new int[nums.length];//用来标识，当前递归链中，某个索引下的值是否被使用过了。\n    backtrack(res, nums, new ArrayList<Integer>(), visited);\n    return res;\n\n  }\n\n  private void backtrack(List<List<Integer>> res, int[] nums, ArrayList<Integer> tmp, int[] visited) {\n    if (tmp.size() == nums.length) {\n      res.add(new ArrayList<>(tmp));\n      return;\n    }\n    for (int i = 0; i < nums.length; i++) {\n      if (visited[i] == 1)//如果这个值被使用过了，那么就继续用下一个\n        continue;\n      tmp.add(nums[i]);//加入链表\n      visited[i] = 1;//标记这个值被使用过了\n\n      backtrack(res, nums, tmp, visited);\n      //回溯\n      visited[i] = 0;\n      tmp.remove(tmp.size() - 1);\n    }\n  }\n}\n```\n\n这个解法是我看到的第二个解法（因为第一个解法，也就是下面的解法，第一次没看懂[哭]）。这个解法其实一眼就看出来了。\n\n和概率论中的摸球题思想有点类似。\n\nN个Value，先固定第一个，N个值里去找第二个。\n怎么去找N个Value里的那个第二个值，而不和第一个重复呢？题解里，用一个visited来标识这个值是否已经被用过。\n找到一个解之后，就通过回溯的方式，再去寻找下一个解。\n\n这就是回溯的基本思想。\n\n看完上一个题解之后，其实发现，在N个value中找第二个值的方式似乎可以优化。\n于是有了下面这个题解。\n\n### 题解二\n\n```java\nclass Solution {\n    public void backtrack(int n, ArrayList<Integer> nums, List<List<Integer>> output, int first) {\n        // if all integers are used up\n        if (first == n)\n            output.add(new ArrayList<Integer>(nums));\n\n        for (int i = first; i < n; i++) {\n            // place i-th integer first\n            // in the current permutation\n            Collections.swap(nums, first, i);\n            // use next integers to complete the permutations\n            backtrack(n, nums, output, first + 1);\n            // backtrack\n            Collections.swap(nums, first, i);\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        // init output list\n        List<List<Integer>> output = new LinkedList<List<Integer>>();\n\n        // convert nums into list since the output is a list of lists\n        ArrayList<Integer> nums_lst = new ArrayList<Integer>();\n        for (int num : nums)\n            nums_lst.add(num);\n\n        int n = nums.length;\n        backtrack(n, nums_lst, output, 0);\n        return output;\n    }\n}\n```\n\n这是这道题 LeetCode的官方题解。\n\n题解一中的tmp链表，其实是用来探索并且存储一个解。但是这个解其实可以直接存储在原始链表内，通过swap，交换元素位置，来得到一个解。而回溯的时候，只需逆向的swap即可。\n\n举个例子，加入有N个value，记作 Arr[N]，算法流程：\n1. 固定第一个value，一共有N种可能性。所以遍历索引i<N，并且把Arr[i]与第一个交换。那么剩下来的事情，就变成：把剩余N-1个值排列出所有的可能性。\n2. 不断的递归 第1步 ，只不过每次固定的是剩余的Value中的第一个值，一直到最后一个值。这个时候，Arr中的就是其中的一个解了。\n3. 接下来就是回溯，回溯的方法就是反向swap。每次循环都是一个回溯。\n\n### 算法复杂度：\n第一个递归是N次循环，第二个递归是N-1次，第三个是N-2次...\n时间复杂度应该是：O(n!)题解一的时间复杂度为O(n^n)\n空间复杂度应该是：O(1) 题解一的空间复杂度是O(n)\n\n与此题型类似的有:\n1. [39组合总和](https://leetcode-cn.com/problems/combination-sum)\n2. [40组合总和II](https://leetcode-cn.com/problems/combination-sum-ii)\n3. [46全排列](https://leetcode-cn.com/problems/permutations)--看[站内文章](https://caio.ink/leetcode46/)\n4. [47全排列II](https://leetcode-cn.com/problems/permutations-ii)--看[站内文章](https://caio.ink/leetcode47/)\n5. [77组合](https://leetcode-cn.com/problems/combinations)\n6. [78子集](https://leetcode-cn.com/problems/subsets)\n7. [90子集II](https://leetcode-cn.com/problems/subsets-ii)\n","slug":"7.leetcode46","published":1,"updated":"2020-08-29T14:42:58.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwog0022p9c95l1m1ufm","content":"<blockquote>\n<p>【Medium】给定一个没有重复数字的序列，返回其所有可能的全排列。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>举例:<br>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>\n<p><strong>回溯法</strong><br>关于回溯法的其他题型，看<a href=\"https://caio.ink/tag/arg-backtrack/\">这里</a></p>\n<p>回溯法的算法原型是：<br>通过探索所有可能的候选解来找出所有的解。如果候选解被确认 不是 一个解的话（或者至少不是 最后一个 解），回溯算法会通过在上一步进行一些变化抛弃该解，即 <strong>回溯</strong> 并且再次尝试。</p>\n<p>其实回溯算法关键在于:<br>不合适就退回上一步<br>然后通过约束条件, 减少时间复杂度。</p>\n<h3 id=\"题解一\"><a href=\"#题解一\" class=\"headerlink\" title=\"题解一\"></a>题解一</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution46</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permute</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] visited = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];<span class=\"comment\">//用来标识，当前递归链中，某个索引下的值是否被使用过了。</span></span><br><span class=\"line\">    backtrack(res, nums, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;(), visited);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; res, <span class=\"type\">int</span>[] nums, ArrayList&lt;Integer&gt; tmp, <span class=\"type\">int</span>[] visited)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp.size() == nums.length) &#123;</span><br><span class=\"line\">      res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(tmp));</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (visited[i] == <span class=\"number\">1</span>)<span class=\"comment\">//如果这个值被使用过了，那么就继续用下一个</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      tmp.add(nums[i]);<span class=\"comment\">//加入链表</span></span><br><span class=\"line\">      visited[i] = <span class=\"number\">1</span>;<span class=\"comment\">//标记这个值被使用过了</span></span><br><span class=\"line\"></span><br><span class=\"line\">      backtrack(res, nums, tmp, visited);</span><br><span class=\"line\">      <span class=\"comment\">//回溯</span></span><br><span class=\"line\">      visited[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      tmp.remove(tmp.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个解法是我看到的第二个解法（因为第一个解法，也就是下面的解法，第一次没看懂[哭]）。这个解法其实一眼就看出来了。</p>\n<p>和概率论中的摸球题思想有点类似。</p>\n<p>N个Value，先固定第一个，N个值里去找第二个。<br>怎么去找N个Value里的那个第二个值，而不和第一个重复呢？题解里，用一个visited来标识这个值是否已经被用过。<br>找到一个解之后，就通过回溯的方式，再去寻找下一个解。</p>\n<p>这就是回溯的基本思想。</p>\n<p>看完上一个题解之后，其实发现，在N个value中找第二个值的方式似乎可以优化。<br>于是有了下面这个题解。</p>\n<h3 id=\"题解二\"><a href=\"#题解二\" class=\"headerlink\" title=\"题解二\"></a>题解二</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span> n, ArrayList&lt;Integer&gt; nums, List&lt;List&lt;Integer&gt;&gt; output, <span class=\"type\">int</span> first)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// if all integers are used up</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == n)</span><br><span class=\"line\">            output.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;(nums));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> first; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// place i-th integer first</span></span><br><span class=\"line\">            <span class=\"comment\">// in the current permutation</span></span><br><span class=\"line\">            Collections.swap(nums, first, i);</span><br><span class=\"line\">            <span class=\"comment\">// use next integers to complete the permutations</span></span><br><span class=\"line\">            backtrack(n, nums, output, first + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// backtrack</span></span><br><span class=\"line\">            Collections.swap(nums, first, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permute</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// init output list</span></span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; output = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// convert nums into list since the output is a list of lists</span></span><br><span class=\"line\">        ArrayList&lt;Integer&gt; nums_lst = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : nums)</span><br><span class=\"line\">            nums_lst.add(num);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        backtrack(n, nums_lst, output, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是这道题 LeetCode的官方题解。</p>\n<p>题解一中的tmp链表，其实是用来探索并且存储一个解。但是这个解其实可以直接存储在原始链表内，通过swap，交换元素位置，来得到一个解。而回溯的时候，只需逆向的swap即可。</p>\n<p>举个例子，加入有N个value，记作 Arr[N]，算法流程：</p>\n<ol>\n<li>固定第一个value，一共有N种可能性。所以遍历索引i&lt;N，并且把Arr[i]与第一个交换。那么剩下来的事情，就变成：把剩余N-1个值排列出所有的可能性。</li>\n<li>不断的递归 第1步 ，只不过每次固定的是剩余的Value中的第一个值，一直到最后一个值。这个时候，Arr中的就是其中的一个解了。</li>\n<li>接下来就是回溯，回溯的方法就是反向swap。每次循环都是一个回溯。</li>\n</ol>\n<h3 id=\"算法复杂度：\"><a href=\"#算法复杂度：\" class=\"headerlink\" title=\"算法复杂度：\"></a>算法复杂度：</h3><p>第一个递归是N次循环，第二个递归是N-1次，第三个是N-2次…<br>时间复杂度应该是：O(n!)题解一的时间复杂度为O(n^n)<br>空间复杂度应该是：O(1) 题解一的空间复杂度是O(n)</p>\n<p>与此题型类似的有:</p>\n<ol>\n<li><a href=\"https://leetcode-cn.com/problems/combination-sum\">39组合总和</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/combination-sum-ii\">40组合总和II</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/permutations\">46全排列</a>–看<a href=\"https://caio.ink/leetcode46/\">站内文章</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/permutations-ii\">47全排列II</a>–看<a href=\"https://caio.ink/leetcode47/\">站内文章</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/combinations\">77组合</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/subsets\">78子集</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/subsets-ii\">90子集II</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>【Medium】给定一个没有重复数字的序列，返回其所有可能的全排列。</p>\n</blockquote>","more":"<p>举例:<br>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>\n<p><strong>回溯法</strong><br>关于回溯法的其他题型，看<a href=\"https://caio.ink/tag/arg-backtrack/\">这里</a></p>\n<p>回溯法的算法原型是：<br>通过探索所有可能的候选解来找出所有的解。如果候选解被确认 不是 一个解的话（或者至少不是 最后一个 解），回溯算法会通过在上一步进行一些变化抛弃该解，即 <strong>回溯</strong> 并且再次尝试。</p>\n<p>其实回溯算法关键在于:<br>不合适就退回上一步<br>然后通过约束条件, 减少时间复杂度。</p>\n<h3 id=\"题解一\"><a href=\"#题解一\" class=\"headerlink\" title=\"题解一\"></a>题解一</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution46</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permute</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] visited = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];<span class=\"comment\">//用来标识，当前递归链中，某个索引下的值是否被使用过了。</span></span><br><span class=\"line\">    backtrack(res, nums, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;(), visited);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; res, <span class=\"type\">int</span>[] nums, ArrayList&lt;Integer&gt; tmp, <span class=\"type\">int</span>[] visited)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp.size() == nums.length) &#123;</span><br><span class=\"line\">      res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(tmp));</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (visited[i] == <span class=\"number\">1</span>)<span class=\"comment\">//如果这个值被使用过了，那么就继续用下一个</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      tmp.add(nums[i]);<span class=\"comment\">//加入链表</span></span><br><span class=\"line\">      visited[i] = <span class=\"number\">1</span>;<span class=\"comment\">//标记这个值被使用过了</span></span><br><span class=\"line\"></span><br><span class=\"line\">      backtrack(res, nums, tmp, visited);</span><br><span class=\"line\">      <span class=\"comment\">//回溯</span></span><br><span class=\"line\">      visited[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      tmp.remove(tmp.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个解法是我看到的第二个解法（因为第一个解法，也就是下面的解法，第一次没看懂[哭]）。这个解法其实一眼就看出来了。</p>\n<p>和概率论中的摸球题思想有点类似。</p>\n<p>N个Value，先固定第一个，N个值里去找第二个。<br>怎么去找N个Value里的那个第二个值，而不和第一个重复呢？题解里，用一个visited来标识这个值是否已经被用过。<br>找到一个解之后，就通过回溯的方式，再去寻找下一个解。</p>\n<p>这就是回溯的基本思想。</p>\n<p>看完上一个题解之后，其实发现，在N个value中找第二个值的方式似乎可以优化。<br>于是有了下面这个题解。</p>\n<h3 id=\"题解二\"><a href=\"#题解二\" class=\"headerlink\" title=\"题解二\"></a>题解二</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span> n, ArrayList&lt;Integer&gt; nums, List&lt;List&lt;Integer&gt;&gt; output, <span class=\"type\">int</span> first)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// if all integers are used up</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == n)</span><br><span class=\"line\">            output.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;(nums));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> first; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// place i-th integer first</span></span><br><span class=\"line\">            <span class=\"comment\">// in the current permutation</span></span><br><span class=\"line\">            Collections.swap(nums, first, i);</span><br><span class=\"line\">            <span class=\"comment\">// use next integers to complete the permutations</span></span><br><span class=\"line\">            backtrack(n, nums, output, first + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// backtrack</span></span><br><span class=\"line\">            Collections.swap(nums, first, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permute</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// init output list</span></span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; output = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// convert nums into list since the output is a list of lists</span></span><br><span class=\"line\">        ArrayList&lt;Integer&gt; nums_lst = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : nums)</span><br><span class=\"line\">            nums_lst.add(num);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        backtrack(n, nums_lst, output, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是这道题 LeetCode的官方题解。</p>\n<p>题解一中的tmp链表，其实是用来探索并且存储一个解。但是这个解其实可以直接存储在原始链表内，通过swap，交换元素位置，来得到一个解。而回溯的时候，只需逆向的swap即可。</p>\n<p>举个例子，加入有N个value，记作 Arr[N]，算法流程：</p>\n<ol>\n<li>固定第一个value，一共有N种可能性。所以遍历索引i&lt;N，并且把Arr[i]与第一个交换。那么剩下来的事情，就变成：把剩余N-1个值排列出所有的可能性。</li>\n<li>不断的递归 第1步 ，只不过每次固定的是剩余的Value中的第一个值，一直到最后一个值。这个时候，Arr中的就是其中的一个解了。</li>\n<li>接下来就是回溯，回溯的方法就是反向swap。每次循环都是一个回溯。</li>\n</ol>\n<h3 id=\"算法复杂度：\"><a href=\"#算法复杂度：\" class=\"headerlink\" title=\"算法复杂度：\"></a>算法复杂度：</h3><p>第一个递归是N次循环，第二个递归是N-1次，第三个是N-2次…<br>时间复杂度应该是：O(n!)题解一的时间复杂度为O(n^n)<br>空间复杂度应该是：O(1) 题解一的空间复杂度是O(n)</p>\n<p>与此题型类似的有:</p>\n<ol>\n<li><a href=\"https://leetcode-cn.com/problems/combination-sum\">39组合总和</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/combination-sum-ii\">40组合总和II</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/permutations\">46全排列</a>–看<a href=\"https://caio.ink/leetcode46/\">站内文章</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/permutations-ii\">47全排列II</a>–看<a href=\"https://caio.ink/leetcode47/\">站内文章</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/combinations\">77组合</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/subsets\">78子集</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/subsets-ii\">90子集II</a></li>\n</ol>"},{"title":"最长有效括号 -- LeetCode[32]","date":"2019-12-20T16:00:00.000Z","_content":"\n> 【Hard】给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n\n<!-- more -->\n\n假设字符串为S\n\n## 动态规划\n\n一开始我连动态规划的“通项式”都想的稀里糊涂的...\n\n动态规划的要点在于写出第i项的通项公式。在这个题中，dp[i]的值表示以第i个字符为结束字符的最长有效子串的长度。那么S[i]必然要求得是 `)` ，以 `(` 结尾的 dp 值应该都是0。所以只需要计算 `)` 的dp值，取最大的即可。\n\n根据经验，想象一下，一般来说的有效括号是 `e()` 或者 `(e)`。其中e是已知的有效子串，即dp[i-1]。\n\n1. 如果S[i] == `)` && S[i-1] == `(`:\n\tdp[i] = dp[i-2] + 2\n\t\n2. 如果S[i] == `)` && S[i-1] == `)` && S[i-dp[i-1]-1] == `(`\n\tdp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n\t\n重点在于：还要加一个dp[i-dp[i-1]-2]，你细品...\n\n算法复杂度没什么好说\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n当我以为动态规划法应该是效率最高的，结果看了一下discuss，还是“山外有山，人外有人”啊。\n\n## 栈\n\n栈确实是括号的匹配的常用算法。不过之前只见过用于判断字符串是否合法。**一般可以通过A用法...衍生一下...变为B用法**。\n\n遍历字符串\n1. 如果是 `(` ，那么把当前的索引入栈。\n2. 如果是 `)`，那么把栈顶的出栈，与当前的索引值求差值，这个差值，便可用于更新最大值。如果栈底空了，就放弃当前这个字符。\n\n不过这里再细品一下，似乎栈的使用与动态规划如出一辙，只不过动态规划中的dp[<i]存储的是每一个i下的结果值，而本题目只需要一个最大值。栈存储的是索引，所以也可以求出最大值。\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n## 计数器法\n\n我一直在思考这个方法应该怎么去理解它...\n\n括号匹配的子串其实只需要满足以下 两 个条件就可以：\n1. `(` 和 `)` 的数量一致\n2. 第一个必须得是 `(`, 最后一个必须得是`)`\n\n第一个条件，可以通过计数来搞定。第二个可以通过正反两次遍历来搞定。\n\n正向遍历的时候，如果`)`的数量 >`(`的数量了（其实也就是出现了 `e)` 的情况，e是有效子串），那么就重置数量计算。\n\n反向遍历的时候，如果`(`的数量 >`)`的数量了（其实也就是出现了 `(e` 的情况，e是有效子串），那么就重置数量计算。\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n","source":"_posts/6.leetcode32.md","raw":"---\ntitle: 最长有效括号 -- LeetCode[32]\ndate: 2019-12-21\ntags: [leetcode,动态规划]\ncategories: 算法\n---\n\n> 【Hard】给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n\n<!-- more -->\n\n假设字符串为S\n\n## 动态规划\n\n一开始我连动态规划的“通项式”都想的稀里糊涂的...\n\n动态规划的要点在于写出第i项的通项公式。在这个题中，dp[i]的值表示以第i个字符为结束字符的最长有效子串的长度。那么S[i]必然要求得是 `)` ，以 `(` 结尾的 dp 值应该都是0。所以只需要计算 `)` 的dp值，取最大的即可。\n\n根据经验，想象一下，一般来说的有效括号是 `e()` 或者 `(e)`。其中e是已知的有效子串，即dp[i-1]。\n\n1. 如果S[i] == `)` && S[i-1] == `(`:\n\tdp[i] = dp[i-2] + 2\n\t\n2. 如果S[i] == `)` && S[i-1] == `)` && S[i-dp[i-1]-1] == `(`\n\tdp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n\t\n重点在于：还要加一个dp[i-dp[i-1]-2]，你细品...\n\n算法复杂度没什么好说\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n当我以为动态规划法应该是效率最高的，结果看了一下discuss，还是“山外有山，人外有人”啊。\n\n## 栈\n\n栈确实是括号的匹配的常用算法。不过之前只见过用于判断字符串是否合法。**一般可以通过A用法...衍生一下...变为B用法**。\n\n遍历字符串\n1. 如果是 `(` ，那么把当前的索引入栈。\n2. 如果是 `)`，那么把栈顶的出栈，与当前的索引值求差值，这个差值，便可用于更新最大值。如果栈底空了，就放弃当前这个字符。\n\n不过这里再细品一下，似乎栈的使用与动态规划如出一辙，只不过动态规划中的dp[<i]存储的是每一个i下的结果值，而本题目只需要一个最大值。栈存储的是索引，所以也可以求出最大值。\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n## 计数器法\n\n我一直在思考这个方法应该怎么去理解它...\n\n括号匹配的子串其实只需要满足以下 两 个条件就可以：\n1. `(` 和 `)` 的数量一致\n2. 第一个必须得是 `(`, 最后一个必须得是`)`\n\n第一个条件，可以通过计数来搞定。第二个可以通过正反两次遍历来搞定。\n\n正向遍历的时候，如果`)`的数量 >`(`的数量了（其实也就是出现了 `e)` 的情况，e是有效子串），那么就重置数量计算。\n\n反向遍历的时候，如果`(`的数量 >`)`的数量了（其实也就是出现了 `(e` 的情况，e是有效子串），那么就重置数量计算。\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n","slug":"6.leetcode32","published":1,"updated":"2020-08-29T14:42:58.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwoh0026p9c90bfabpqc","content":"<blockquote>\n<p>【Hard】给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>假设字符串为S</p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>一开始我连动态规划的“通项式”都想的稀里糊涂的…</p>\n<p>动态规划的要点在于写出第i项的通项公式。在这个题中，dp[i]的值表示以第i个字符为结束字符的最长有效子串的长度。那么S[i]必然要求得是 <code>)</code> ，以 <code>(</code> 结尾的 dp 值应该都是0。所以只需要计算 <code>)</code> 的dp值，取最大的即可。</p>\n<p>根据经验，想象一下，一般来说的有效括号是 <code>e()</code> 或者 <code>(e)</code>。其中e是已知的有效子串，即dp[i-1]。</p>\n<ol>\n<li><p>如果S[i] &#x3D;&#x3D; <code>)</code> &amp;&amp; S[i-1] &#x3D;&#x3D; <code>(</code>:<br> dp[i] &#x3D; dp[i-2] + 2</p>\n</li>\n<li><p>如果S[i] &#x3D;&#x3D; <code>)</code> &amp;&amp; S[i-1] &#x3D;&#x3D; <code>)</code> &amp;&amp; S[i-dp[i-1]-1] &#x3D;&#x3D; <code>(</code><br> dp[i] &#x3D; dp[i-1] + dp[i-dp[i-1]-2] + 2</p>\n</li>\n</ol>\n<p>重点在于：还要加一个dp[i-dp[i-1]-2]，你细品…</p>\n<p>算法复杂度没什么好说<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p>\n<p>当我以为动态规划法应该是效率最高的，结果看了一下discuss，还是“山外有山，人外有人”啊。</p>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>栈确实是括号的匹配的常用算法。不过之前只见过用于判断字符串是否合法。<strong>一般可以通过A用法…衍生一下…变为B用法</strong>。</p>\n<p>遍历字符串</p>\n<ol>\n<li>如果是 <code>(</code> ，那么把当前的索引入栈。</li>\n<li>如果是 <code>)</code>，那么把栈顶的出栈，与当前的索引值求差值，这个差值，便可用于更新最大值。如果栈底空了，就放弃当前这个字符。</li>\n</ol>\n<p>不过这里再细品一下，似乎栈的使用与动态规划如出一辙，只不过动态规划中的dp[&lt;i]存储的是每一个i下的结果值，而本题目只需要一个最大值。栈存储的是索引，所以也可以求出最大值。</p>\n<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>\n<h2 id=\"计数器法\"><a href=\"#计数器法\" class=\"headerlink\" title=\"计数器法\"></a>计数器法</h2><p>我一直在思考这个方法应该怎么去理解它…</p>\n<p>括号匹配的子串其实只需要满足以下 两 个条件就可以：</p>\n<ol>\n<li><code>(</code> 和 <code>)</code> 的数量一致</li>\n<li>第一个必须得是 <code>(</code>, 最后一个必须得是<code>)</code></li>\n</ol>\n<p>第一个条件，可以通过计数来搞定。第二个可以通过正反两次遍历来搞定。</p>\n<p>正向遍历的时候，如果<code>)</code>的数量 &gt;<code>(</code>的数量了（其实也就是出现了 <code>e)</code> 的情况，e是有效子串），那么就重置数量计算。</p>\n<p>反向遍历的时候，如果<code>(</code>的数量 &gt;<code>)</code>的数量了（其实也就是出现了 <code>(e</code> 的情况，e是有效子串），那么就重置数量计算。</p>\n<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>【Hard】给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>\n</blockquote>","more":"<p>假设字符串为S</p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>一开始我连动态规划的“通项式”都想的稀里糊涂的…</p>\n<p>动态规划的要点在于写出第i项的通项公式。在这个题中，dp[i]的值表示以第i个字符为结束字符的最长有效子串的长度。那么S[i]必然要求得是 <code>)</code> ，以 <code>(</code> 结尾的 dp 值应该都是0。所以只需要计算 <code>)</code> 的dp值，取最大的即可。</p>\n<p>根据经验，想象一下，一般来说的有效括号是 <code>e()</code> 或者 <code>(e)</code>。其中e是已知的有效子串，即dp[i-1]。</p>\n<ol>\n<li><p>如果S[i] &#x3D;&#x3D; <code>)</code> &amp;&amp; S[i-1] &#x3D;&#x3D; <code>(</code>:<br> dp[i] &#x3D; dp[i-2] + 2</p>\n</li>\n<li><p>如果S[i] &#x3D;&#x3D; <code>)</code> &amp;&amp; S[i-1] &#x3D;&#x3D; <code>)</code> &amp;&amp; S[i-dp[i-1]-1] &#x3D;&#x3D; <code>(</code><br> dp[i] &#x3D; dp[i-1] + dp[i-dp[i-1]-2] + 2</p>\n</li>\n</ol>\n<p>重点在于：还要加一个dp[i-dp[i-1]-2]，你细品…</p>\n<p>算法复杂度没什么好说<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p>\n<p>当我以为动态规划法应该是效率最高的，结果看了一下discuss，还是“山外有山，人外有人”啊。</p>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>栈确实是括号的匹配的常用算法。不过之前只见过用于判断字符串是否合法。<strong>一般可以通过A用法…衍生一下…变为B用法</strong>。</p>\n<p>遍历字符串</p>\n<ol>\n<li>如果是 <code>(</code> ，那么把当前的索引入栈。</li>\n<li>如果是 <code>)</code>，那么把栈顶的出栈，与当前的索引值求差值，这个差值，便可用于更新最大值。如果栈底空了，就放弃当前这个字符。</li>\n</ol>\n<p>不过这里再细品一下，似乎栈的使用与动态规划如出一辙，只不过动态规划中的dp[&lt;i]存储的是每一个i下的结果值，而本题目只需要一个最大值。栈存储的是索引，所以也可以求出最大值。</p>\n<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>\n<h2 id=\"计数器法\"><a href=\"#计数器法\" class=\"headerlink\" title=\"计数器法\"></a>计数器法</h2><p>我一直在思考这个方法应该怎么去理解它…</p>\n<p>括号匹配的子串其实只需要满足以下 两 个条件就可以：</p>\n<ol>\n<li><code>(</code> 和 <code>)</code> 的数量一致</li>\n<li>第一个必须得是 <code>(</code>, 最后一个必须得是<code>)</code></li>\n</ol>\n<p>第一个条件，可以通过计数来搞定。第二个可以通过正反两次遍历来搞定。</p>\n<p>正向遍历的时候，如果<code>)</code>的数量 &gt;<code>(</code>的数量了（其实也就是出现了 <code>e)</code> 的情况，e是有效子串），那么就重置数量计算。</p>\n<p>反向遍历的时候，如果<code>(</code>的数量 &gt;<code>)</code>的数量了（其实也就是出现了 <code>(e</code> 的情况，e是有效子串），那么就重置数量计算。</p>\n<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>"},{"title":"全排列II -- LeetCode[37]","date":"2020-01-06T16:00:00.000Z","_content":"\n> 【Medium】给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n<!-- more -->\n\n举例:\n输入: [1,1,2]\n输出:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n\n**回溯法**\n关于回溯法的其他题型，看[这里](https://caio.ink/tag/arg-backtrack/)\n\n这个问题是 [LeetCode 46](https://caio.ink/leetcode46/) 的一个变形，在回溯法的基础上增加剪枝，来排除掉重复的case。\n\n根据 [LeetCode 46](https://caio.ink/leetcode46/) 的两种解法，分别来看，这两个题解如何剪枝。\n\n第一个想法就是按照46的解法，找到所有的解之后，再去去重。可行，但是肯定不是我们想要的。\n\n### 题解一\n\n```java\npublic class Solution47 {\n    public void backTrace(int[] nums, int[] usedMark, List<List<Integer>> output, LinkedList<Integer> tmp) {\n        if (tmp.size() == nums.length) {\n            output.add(new LinkedList<Integer>(tmp));\n        }\n\n        for (int i = 0; i < nums.length;) {\n            if (usedMark[i] == 1){\n                i++;\n                continue;\n            }\n\n            tmp.add(nums[i]);\n\n            usedMark[i] = 1;\n\n            int startIndex = i;\n            int endIndex = i;\n\n            while ((endIndex != (nums.length - 1)) && (nums[endIndex + 1] == nums[i])) {\n                endIndex++;\n            }\n\n            backTrace(nums, usedMark, output, tmp);\n\n            // backtrace\n            tmp.remove(tmp.size() - 1);\n            usedMark[i] = 0;\n            // next index 跳过相同的\n            i = endIndex + 1;\n        }\n\n    }\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        quickSort(nums, 0, nums.length - 1);\n        List<List<Integer>> output = new LinkedList<List<Integer>>();\n\n        LinkedList<Integer> tmp = new LinkedList<Integer>();\n\n        int[] usedMark = new int[nums.length];\n\n        backTrace(nums, usedMark, output, tmp);\n        return output;\n    }\n}\n```\n\n在之前46题的解法一中，用一个used数组来标识本次回溯是否用过这个元素。但是怎么知道是否重复的用过某一个相同的元素呢？\n\n一种就是在每次固定一个元素之后，用map记录下本轮用的元素，下次循环的时候判断是否用过，这种方法是一个解。\n\n还有一种，也是上文给出的题解使用的。优先把整个数组排序，因为每固定一个数的时候，都是从index=0开始，根据used数组来判断是否被使用了。如果数组是有序的，那么遍历的时候，只需要跳过之后所有和上一个相同的元素，就可以了。\n\n回溯方法依旧不变。\n\n\n### 题解二\n\n```java\npublic class Solution47_2 {\n    private void backTrace(List<List<Integer>> output, ArrayList<Integer> data, int start) {\n        if (start == data.size()) {\n            output.add(new LinkedList<>(data));\n        }\n\n        int lastValue = 0;\n        for (int i = start; i < data.size(); i++) {\n            int value = data.get(i);\n            if (i != start && lastValue == value){\n                continue;\n            }\n            lastValue = value;\n            // 把所有的值都换到后面去\n            for (int j = i; j > start; j--) {\n                data.set(j, data.get(j-1));\n            }\n            data.set(start, value);\n\n            backTrace(output, data, start+1);\n            // 把所有的值再换回来\n            for (int j = start; j < i; j++) {\n                data.set(j, data.get(j+1));\n            }\n            data.set(i, value);\n        }\n    }\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        quickSort(nums, 0, nums.length - 1);\n\n        List<List<Integer>> output = new LinkedList<List<Integer>>();\n\n        ArrayList<Integer> data = new ArrayList<>();\n\n        for (int value : nums) {\n            data.add(value);\n        }\n\n        backTrace(output, data, 0);\n\n        return output;\n    }\n}\n```\n\n在前一题的基础上，看看如果使用46题的题解二的思路，是否可以解决47题。\n\n在46题的题解二中，其实是利用数组的元素交换来 `固定一个元素`。每次把`固定`的元素与当前可选range的第一个元素交换，再在剩余的元素中继续递归 `固定下一个元素`。也就是说，每次在新一轮`固定元素`的时候，可选range前的所有元素，均是已被`选择固定`，不可再选。\n\n那么怎么去重呢？\n\n同样的先使用排序，保证数组有序。\n\n假设有一个数组  `a a b c`（a<b<c）\n第一轮，第一个元素 固定了第一个 `a`，假设后面找到了以 第一个`a`开头的所有的解。\n第二轮，回溯到原始序列，根据去重，应该忽略第二个 `a`，选择`b`,那么第一个`a`和`b`交换，即固定在第一个位置。再假设后面找到了以 第二个`a`开头的所有的解。\n第三轮，第一个元素 固定了`c`，交换`a`,`c`之后，发现问题来了，`c`后面的大小顺序乱了...\n\n所以假设，当前的range为 start -> N (N是元素个数)，选择了第 i 个元素作为本轮`固定元素`。\n\n那么把`[start i)` 区间的所有元素往后挪一位,把第i个元素放在start上。这样就保证了，下一个`固定`的range内的所有元素是有序的。\n\n回溯的时候，就把`(start i]`区间的所有元素往前挪一位，然后把第start个元素放回到第i位。\n\n### 算法复杂度\n\n题解一：\n空间复杂度：不变 O(n)\n时间复杂度：根据重复元素的多少，最差 O(n^n)\n\n题解二：\n空间复杂度：不变 O(1)\n时间复杂度：根据重复元素的多少，最差O(n!)\n\n题解二的时间复杂度，在相同数据下，优于题解一。因为题解二无需遍历已经`固定`的元素，而题解一需要通过usedMark这个数组来判断是否已被`固定`\n\n与此题型类似的有:\n1. [39组合总和](https://leetcode-cn.com/problems/combination-sum)\n2. [40组合总和II](https://leetcode-cn.com/problems/combination-sum-ii)\n3. [46全排列](https://leetcode-cn.com/problems/permutations)--看[站内文章](https://caio.ink/leetcode46/)\n4. [47全排列II](https://leetcode-cn.com/problems/permutations-ii)--看[站内文章](https://caio.ink/leetcode47/)\n5. [77组合](https://leetcode-cn.com/problems/combinations)\n6. [78子集](https://leetcode-cn.com/problems/subsets)\n7. [90子集II](https://leetcode-cn.com/problems/subsets-ii)","source":"_posts/8.leetcode47.md","raw":"---\ntitle: 全排列II -- LeetCode[37]\ndate: 2020-01-07\ntags: [leetcode,回溯法]\ncategories: 算法\n---\n\n> 【Medium】给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n<!-- more -->\n\n举例:\n输入: [1,1,2]\n输出:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n\n**回溯法**\n关于回溯法的其他题型，看[这里](https://caio.ink/tag/arg-backtrack/)\n\n这个问题是 [LeetCode 46](https://caio.ink/leetcode46/) 的一个变形，在回溯法的基础上增加剪枝，来排除掉重复的case。\n\n根据 [LeetCode 46](https://caio.ink/leetcode46/) 的两种解法，分别来看，这两个题解如何剪枝。\n\n第一个想法就是按照46的解法，找到所有的解之后，再去去重。可行，但是肯定不是我们想要的。\n\n### 题解一\n\n```java\npublic class Solution47 {\n    public void backTrace(int[] nums, int[] usedMark, List<List<Integer>> output, LinkedList<Integer> tmp) {\n        if (tmp.size() == nums.length) {\n            output.add(new LinkedList<Integer>(tmp));\n        }\n\n        for (int i = 0; i < nums.length;) {\n            if (usedMark[i] == 1){\n                i++;\n                continue;\n            }\n\n            tmp.add(nums[i]);\n\n            usedMark[i] = 1;\n\n            int startIndex = i;\n            int endIndex = i;\n\n            while ((endIndex != (nums.length - 1)) && (nums[endIndex + 1] == nums[i])) {\n                endIndex++;\n            }\n\n            backTrace(nums, usedMark, output, tmp);\n\n            // backtrace\n            tmp.remove(tmp.size() - 1);\n            usedMark[i] = 0;\n            // next index 跳过相同的\n            i = endIndex + 1;\n        }\n\n    }\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        quickSort(nums, 0, nums.length - 1);\n        List<List<Integer>> output = new LinkedList<List<Integer>>();\n\n        LinkedList<Integer> tmp = new LinkedList<Integer>();\n\n        int[] usedMark = new int[nums.length];\n\n        backTrace(nums, usedMark, output, tmp);\n        return output;\n    }\n}\n```\n\n在之前46题的解法一中，用一个used数组来标识本次回溯是否用过这个元素。但是怎么知道是否重复的用过某一个相同的元素呢？\n\n一种就是在每次固定一个元素之后，用map记录下本轮用的元素，下次循环的时候判断是否用过，这种方法是一个解。\n\n还有一种，也是上文给出的题解使用的。优先把整个数组排序，因为每固定一个数的时候，都是从index=0开始，根据used数组来判断是否被使用了。如果数组是有序的，那么遍历的时候，只需要跳过之后所有和上一个相同的元素，就可以了。\n\n回溯方法依旧不变。\n\n\n### 题解二\n\n```java\npublic class Solution47_2 {\n    private void backTrace(List<List<Integer>> output, ArrayList<Integer> data, int start) {\n        if (start == data.size()) {\n            output.add(new LinkedList<>(data));\n        }\n\n        int lastValue = 0;\n        for (int i = start; i < data.size(); i++) {\n            int value = data.get(i);\n            if (i != start && lastValue == value){\n                continue;\n            }\n            lastValue = value;\n            // 把所有的值都换到后面去\n            for (int j = i; j > start; j--) {\n                data.set(j, data.get(j-1));\n            }\n            data.set(start, value);\n\n            backTrace(output, data, start+1);\n            // 把所有的值再换回来\n            for (int j = start; j < i; j++) {\n                data.set(j, data.get(j+1));\n            }\n            data.set(i, value);\n        }\n    }\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        quickSort(nums, 0, nums.length - 1);\n\n        List<List<Integer>> output = new LinkedList<List<Integer>>();\n\n        ArrayList<Integer> data = new ArrayList<>();\n\n        for (int value : nums) {\n            data.add(value);\n        }\n\n        backTrace(output, data, 0);\n\n        return output;\n    }\n}\n```\n\n在前一题的基础上，看看如果使用46题的题解二的思路，是否可以解决47题。\n\n在46题的题解二中，其实是利用数组的元素交换来 `固定一个元素`。每次把`固定`的元素与当前可选range的第一个元素交换，再在剩余的元素中继续递归 `固定下一个元素`。也就是说，每次在新一轮`固定元素`的时候，可选range前的所有元素，均是已被`选择固定`，不可再选。\n\n那么怎么去重呢？\n\n同样的先使用排序，保证数组有序。\n\n假设有一个数组  `a a b c`（a<b<c）\n第一轮，第一个元素 固定了第一个 `a`，假设后面找到了以 第一个`a`开头的所有的解。\n第二轮，回溯到原始序列，根据去重，应该忽略第二个 `a`，选择`b`,那么第一个`a`和`b`交换，即固定在第一个位置。再假设后面找到了以 第二个`a`开头的所有的解。\n第三轮，第一个元素 固定了`c`，交换`a`,`c`之后，发现问题来了，`c`后面的大小顺序乱了...\n\n所以假设，当前的range为 start -> N (N是元素个数)，选择了第 i 个元素作为本轮`固定元素`。\n\n那么把`[start i)` 区间的所有元素往后挪一位,把第i个元素放在start上。这样就保证了，下一个`固定`的range内的所有元素是有序的。\n\n回溯的时候，就把`(start i]`区间的所有元素往前挪一位，然后把第start个元素放回到第i位。\n\n### 算法复杂度\n\n题解一：\n空间复杂度：不变 O(n)\n时间复杂度：根据重复元素的多少，最差 O(n^n)\n\n题解二：\n空间复杂度：不变 O(1)\n时间复杂度：根据重复元素的多少，最差O(n!)\n\n题解二的时间复杂度，在相同数据下，优于题解一。因为题解二无需遍历已经`固定`的元素，而题解一需要通过usedMark这个数组来判断是否已被`固定`\n\n与此题型类似的有:\n1. [39组合总和](https://leetcode-cn.com/problems/combination-sum)\n2. [40组合总和II](https://leetcode-cn.com/problems/combination-sum-ii)\n3. [46全排列](https://leetcode-cn.com/problems/permutations)--看[站内文章](https://caio.ink/leetcode46/)\n4. [47全排列II](https://leetcode-cn.com/problems/permutations-ii)--看[站内文章](https://caio.ink/leetcode47/)\n5. [77组合](https://leetcode-cn.com/problems/combinations)\n6. [78子集](https://leetcode-cn.com/problems/subsets)\n7. [90子集II](https://leetcode-cn.com/problems/subsets-ii)","slug":"8.leetcode47","published":1,"updated":"2020-08-29T14:42:58.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwoh002ap9c98zccewtb","content":"<blockquote>\n<p>【Medium】给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>举例:<br>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>\n<p><strong>回溯法</strong><br>关于回溯法的其他题型，看<a href=\"https://caio.ink/tag/arg-backtrack/\">这里</a></p>\n<p>这个问题是 <a href=\"https://caio.ink/leetcode46/\">LeetCode 46</a> 的一个变形，在回溯法的基础上增加剪枝，来排除掉重复的case。</p>\n<p>根据 <a href=\"https://caio.ink/leetcode46/\">LeetCode 46</a> 的两种解法，分别来看，这两个题解如何剪枝。</p>\n<p>第一个想法就是按照46的解法，找到所有的解之后，再去去重。可行，但是肯定不是我们想要的。</p>\n<h3 id=\"题解一\"><a href=\"#题解一\" class=\"headerlink\" title=\"题解一\"></a>题解一</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution47</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backTrace</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span>[] usedMark, List&lt;List&lt;Integer&gt;&gt; output, LinkedList&lt;Integer&gt; tmp)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp.size() == nums.length) &#123;</span><br><span class=\"line\">            output.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;(tmp));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (usedMark[i] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            tmp.add(nums[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">            usedMark[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">startIndex</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">endIndex</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((endIndex != (nums.length - <span class=\"number\">1</span>)) &amp;&amp; (nums[endIndex + <span class=\"number\">1</span>] == nums[i])) &#123;</span><br><span class=\"line\">                endIndex++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            backTrace(nums, usedMark, output, tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// backtrace</span></span><br><span class=\"line\">            tmp.remove(tmp.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            usedMark[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// next index 跳过相同的</span></span><br><span class=\"line\">            i = endIndex + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permuteUnique</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        quickSort(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; output = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[] usedMark = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\"></span><br><span class=\"line\">        backTrace(nums, usedMark, output, tmp);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在之前46题的解法一中，用一个used数组来标识本次回溯是否用过这个元素。但是怎么知道是否重复的用过某一个相同的元素呢？</p>\n<p>一种就是在每次固定一个元素之后，用map记录下本轮用的元素，下次循环的时候判断是否用过，这种方法是一个解。</p>\n<p>还有一种，也是上文给出的题解使用的。优先把整个数组排序，因为每固定一个数的时候，都是从index&#x3D;0开始，根据used数组来判断是否被使用了。如果数组是有序的，那么遍历的时候，只需要跳过之后所有和上一个相同的元素，就可以了。</p>\n<p>回溯方法依旧不变。</p>\n<h3 id=\"题解二\"><a href=\"#题解二\" class=\"headerlink\" title=\"题解二\"></a>题解二</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution47_2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backTrace</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; output, ArrayList&lt;Integer&gt; data, <span class=\"type\">int</span> start)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == data.size()) &#123;</span><br><span class=\"line\">            output.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;(data));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lastValue</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; data.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> data.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != start &amp;&amp; lastValue == value)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lastValue = value;</span><br><span class=\"line\">            <span class=\"comment\">// 把所有的值都换到后面去</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i; j &gt; start; j--) &#123;</span><br><span class=\"line\">                data.set(j, data.get(j-<span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            data.set(start, value);</span><br><span class=\"line\"></span><br><span class=\"line\">            backTrace(output, data, start+<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 把所有的值再换回来</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> start; j &lt; i; j++) &#123;</span><br><span class=\"line\">                data.set(j, data.get(j+<span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            data.set(i, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permuteUnique</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        quickSort(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; output = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;Integer&gt; data = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> value : nums) &#123;</span><br><span class=\"line\">            data.add(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        backTrace(output, data, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在前一题的基础上，看看如果使用46题的题解二的思路，是否可以解决47题。</p>\n<p>在46题的题解二中，其实是利用数组的元素交换来 <code>固定一个元素</code>。每次把<code>固定</code>的元素与当前可选range的第一个元素交换，再在剩余的元素中继续递归 <code>固定下一个元素</code>。也就是说，每次在新一轮<code>固定元素</code>的时候，可选range前的所有元素，均是已被<code>选择固定</code>，不可再选。</p>\n<p>那么怎么去重呢？</p>\n<p>同样的先使用排序，保证数组有序。</p>\n<p>假设有一个数组  <code>a a b c</code>（a&lt;b&lt;c）<br>第一轮，第一个元素 固定了第一个 <code>a</code>，假设后面找到了以 第一个<code>a</code>开头的所有的解。<br>第二轮，回溯到原始序列，根据去重，应该忽略第二个 <code>a</code>，选择<code>b</code>,那么第一个<code>a</code>和<code>b</code>交换，即固定在第一个位置。再假设后面找到了以 第二个<code>a</code>开头的所有的解。<br>第三轮，第一个元素 固定了<code>c</code>，交换<code>a</code>,<code>c</code>之后，发现问题来了，<code>c</code>后面的大小顺序乱了…</p>\n<p>所以假设，当前的range为 start -&gt; N (N是元素个数)，选择了第 i 个元素作为本轮<code>固定元素</code>。</p>\n<p>那么把<code>[start i)</code> 区间的所有元素往后挪一位,把第i个元素放在start上。这样就保证了，下一个<code>固定</code>的range内的所有元素是有序的。</p>\n<p>回溯的时候，就把<code>(start i]</code>区间的所有元素往前挪一位，然后把第start个元素放回到第i位。</p>\n<h3 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h3><p>题解一：<br>空间复杂度：不变 O(n)<br>时间复杂度：根据重复元素的多少，最差 O(n^n)</p>\n<p>题解二：<br>空间复杂度：不变 O(1)<br>时间复杂度：根据重复元素的多少，最差O(n!)</p>\n<p>题解二的时间复杂度，在相同数据下，优于题解一。因为题解二无需遍历已经<code>固定</code>的元素，而题解一需要通过usedMark这个数组来判断是否已被<code>固定</code></p>\n<p>与此题型类似的有:</p>\n<ol>\n<li><a href=\"https://leetcode-cn.com/problems/combination-sum\">39组合总和</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/combination-sum-ii\">40组合总和II</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/permutations\">46全排列</a>–看<a href=\"https://caio.ink/leetcode46/\">站内文章</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/permutations-ii\">47全排列II</a>–看<a href=\"https://caio.ink/leetcode47/\">站内文章</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/combinations\">77组合</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/subsets\">78子集</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/subsets-ii\">90子集II</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>【Medium】给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>\n</blockquote>","more":"<p>举例:<br>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>\n<p><strong>回溯法</strong><br>关于回溯法的其他题型，看<a href=\"https://caio.ink/tag/arg-backtrack/\">这里</a></p>\n<p>这个问题是 <a href=\"https://caio.ink/leetcode46/\">LeetCode 46</a> 的一个变形，在回溯法的基础上增加剪枝，来排除掉重复的case。</p>\n<p>根据 <a href=\"https://caio.ink/leetcode46/\">LeetCode 46</a> 的两种解法，分别来看，这两个题解如何剪枝。</p>\n<p>第一个想法就是按照46的解法，找到所有的解之后，再去去重。可行，但是肯定不是我们想要的。</p>\n<h3 id=\"题解一\"><a href=\"#题解一\" class=\"headerlink\" title=\"题解一\"></a>题解一</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution47</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backTrace</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span>[] usedMark, List&lt;List&lt;Integer&gt;&gt; output, LinkedList&lt;Integer&gt; tmp)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp.size() == nums.length) &#123;</span><br><span class=\"line\">            output.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;(tmp));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (usedMark[i] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            tmp.add(nums[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">            usedMark[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">startIndex</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">endIndex</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((endIndex != (nums.length - <span class=\"number\">1</span>)) &amp;&amp; (nums[endIndex + <span class=\"number\">1</span>] == nums[i])) &#123;</span><br><span class=\"line\">                endIndex++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            backTrace(nums, usedMark, output, tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// backtrace</span></span><br><span class=\"line\">            tmp.remove(tmp.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            usedMark[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// next index 跳过相同的</span></span><br><span class=\"line\">            i = endIndex + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permuteUnique</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        quickSort(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; output = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[] usedMark = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\"></span><br><span class=\"line\">        backTrace(nums, usedMark, output, tmp);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在之前46题的解法一中，用一个used数组来标识本次回溯是否用过这个元素。但是怎么知道是否重复的用过某一个相同的元素呢？</p>\n<p>一种就是在每次固定一个元素之后，用map记录下本轮用的元素，下次循环的时候判断是否用过，这种方法是一个解。</p>\n<p>还有一种，也是上文给出的题解使用的。优先把整个数组排序，因为每固定一个数的时候，都是从index&#x3D;0开始，根据used数组来判断是否被使用了。如果数组是有序的，那么遍历的时候，只需要跳过之后所有和上一个相同的元素，就可以了。</p>\n<p>回溯方法依旧不变。</p>\n<h3 id=\"题解二\"><a href=\"#题解二\" class=\"headerlink\" title=\"题解二\"></a>题解二</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution47_2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backTrace</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; output, ArrayList&lt;Integer&gt; data, <span class=\"type\">int</span> start)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == data.size()) &#123;</span><br><span class=\"line\">            output.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;(data));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lastValue</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; data.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> data.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != start &amp;&amp; lastValue == value)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lastValue = value;</span><br><span class=\"line\">            <span class=\"comment\">// 把所有的值都换到后面去</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i; j &gt; start; j--) &#123;</span><br><span class=\"line\">                data.set(j, data.get(j-<span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            data.set(start, value);</span><br><span class=\"line\"></span><br><span class=\"line\">            backTrace(output, data, start+<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 把所有的值再换回来</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> start; j &lt; i; j++) &#123;</span><br><span class=\"line\">                data.set(j, data.get(j+<span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            data.set(i, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permuteUnique</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        quickSort(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; output = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;Integer&gt; data = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> value : nums) &#123;</span><br><span class=\"line\">            data.add(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        backTrace(output, data, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在前一题的基础上，看看如果使用46题的题解二的思路，是否可以解决47题。</p>\n<p>在46题的题解二中，其实是利用数组的元素交换来 <code>固定一个元素</code>。每次把<code>固定</code>的元素与当前可选range的第一个元素交换，再在剩余的元素中继续递归 <code>固定下一个元素</code>。也就是说，每次在新一轮<code>固定元素</code>的时候，可选range前的所有元素，均是已被<code>选择固定</code>，不可再选。</p>\n<p>那么怎么去重呢？</p>\n<p>同样的先使用排序，保证数组有序。</p>\n<p>假设有一个数组  <code>a a b c</code>（a&lt;b&lt;c）<br>第一轮，第一个元素 固定了第一个 <code>a</code>，假设后面找到了以 第一个<code>a</code>开头的所有的解。<br>第二轮，回溯到原始序列，根据去重，应该忽略第二个 <code>a</code>，选择<code>b</code>,那么第一个<code>a</code>和<code>b</code>交换，即固定在第一个位置。再假设后面找到了以 第二个<code>a</code>开头的所有的解。<br>第三轮，第一个元素 固定了<code>c</code>，交换<code>a</code>,<code>c</code>之后，发现问题来了，<code>c</code>后面的大小顺序乱了…</p>\n<p>所以假设，当前的range为 start -&gt; N (N是元素个数)，选择了第 i 个元素作为本轮<code>固定元素</code>。</p>\n<p>那么把<code>[start i)</code> 区间的所有元素往后挪一位,把第i个元素放在start上。这样就保证了，下一个<code>固定</code>的range内的所有元素是有序的。</p>\n<p>回溯的时候，就把<code>(start i]</code>区间的所有元素往前挪一位，然后把第start个元素放回到第i位。</p>\n<h3 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h3><p>题解一：<br>空间复杂度：不变 O(n)<br>时间复杂度：根据重复元素的多少，最差 O(n^n)</p>\n<p>题解二：<br>空间复杂度：不变 O(1)<br>时间复杂度：根据重复元素的多少，最差O(n!)</p>\n<p>题解二的时间复杂度，在相同数据下，优于题解一。因为题解二无需遍历已经<code>固定</code>的元素，而题解一需要通过usedMark这个数组来判断是否已被<code>固定</code></p>\n<p>与此题型类似的有:</p>\n<ol>\n<li><a href=\"https://leetcode-cn.com/problems/combination-sum\">39组合总和</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/combination-sum-ii\">40组合总和II</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/permutations\">46全排列</a>–看<a href=\"https://caio.ink/leetcode46/\">站内文章</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/permutations-ii\">47全排列II</a>–看<a href=\"https://caio.ink/leetcode47/\">站内文章</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/combinations\">77组合</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/subsets\">78子集</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/subsets-ii\">90子集II</a></li>\n</ol>"},{"title":"leetcode -- 周赛双周赛","date":"2020-01-12T16:00:00.000Z","_content":"\n## 周赛和双周赛\n\n<!-- more -->\n\n### 2020-01-11 第17场双周赛\n\n#### 解压缩编码列表\n[题目地址]()\n\n#### 矩阵区域和\n[题目地址]()\n\n简单动态规划。\n#### 祖父节点值为偶数的节点和\n[题目地址](https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/)\n\n深度遍历的**同时**，递归地把计算左右子节点的sumEvenGrandparent值都返回并且求和。\n#### 不同的循环子字符串\n[题目地址](https://leetcode-cn.com/problems/distinct-echo-substrings/)\n这个题目最终还是使用暴力解法。\n\n---","source":"_posts/9.LeetCode-week-match.md","raw":"---\ntitle: leetcode -- 周赛双周赛\ndate: 2020-01-13\ntags: [leetcode,周赛]\ncategories: 算法\n---\n\n## 周赛和双周赛\n\n<!-- more -->\n\n### 2020-01-11 第17场双周赛\n\n#### 解压缩编码列表\n[题目地址]()\n\n#### 矩阵区域和\n[题目地址]()\n\n简单动态规划。\n#### 祖父节点值为偶数的节点和\n[题目地址](https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/)\n\n深度遍历的**同时**，递归地把计算左右子节点的sumEvenGrandparent值都返回并且求和。\n#### 不同的循环子字符串\n[题目地址](https://leetcode-cn.com/problems/distinct-echo-substrings/)\n这个题目最终还是使用暴力解法。\n\n---","slug":"9.LeetCode-week-match","published":1,"updated":"2020-08-29T14:42:58.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwoi002dp9c9h4s84pf0","content":"<h2 id=\"周赛和双周赛\"><a href=\"#周赛和双周赛\" class=\"headerlink\" title=\"周赛和双周赛\"></a>周赛和双周赛</h2><span id=\"more\"></span>\n\n<h3 id=\"2020-01-11-第17场双周赛\"><a href=\"#2020-01-11-第17场双周赛\" class=\"headerlink\" title=\"2020-01-11 第17场双周赛\"></a>2020-01-11 第17场双周赛</h3><h4 id=\"解压缩编码列表\"><a href=\"#解压缩编码列表\" class=\"headerlink\" title=\"解压缩编码列表\"></a>解压缩编码列表</h4><p><a href=\"\">题目地址</a></p>\n<h4 id=\"矩阵区域和\"><a href=\"#矩阵区域和\" class=\"headerlink\" title=\"矩阵区域和\"></a>矩阵区域和</h4><p><a href=\"\">题目地址</a></p>\n<p>简单动态规划。</p>\n<h4 id=\"祖父节点值为偶数的节点和\"><a href=\"#祖父节点值为偶数的节点和\" class=\"headerlink\" title=\"祖父节点值为偶数的节点和\"></a>祖父节点值为偶数的节点和</h4><p><a href=\"https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/\">题目地址</a></p>\n<p>深度遍历的<strong>同时</strong>，递归地把计算左右子节点的sumEvenGrandparent值都返回并且求和。</p>\n<h4 id=\"不同的循环子字符串\"><a href=\"#不同的循环子字符串\" class=\"headerlink\" title=\"不同的循环子字符串\"></a>不同的循环子字符串</h4><p><a href=\"https://leetcode-cn.com/problems/distinct-echo-substrings/\">题目地址</a><br>这个题目最终还是使用暴力解法。</p>\n<hr>\n","site":{"data":{}},"excerpt":"<h2 id=\"周赛和双周赛\"><a href=\"#周赛和双周赛\" class=\"headerlink\" title=\"周赛和双周赛\"></a>周赛和双周赛</h2>","more":"<h3 id=\"2020-01-11-第17场双周赛\"><a href=\"#2020-01-11-第17场双周赛\" class=\"headerlink\" title=\"2020-01-11 第17场双周赛\"></a>2020-01-11 第17场双周赛</h3><h4 id=\"解压缩编码列表\"><a href=\"#解压缩编码列表\" class=\"headerlink\" title=\"解压缩编码列表\"></a>解压缩编码列表</h4><p><a href=\"\">题目地址</a></p>\n<h4 id=\"矩阵区域和\"><a href=\"#矩阵区域和\" class=\"headerlink\" title=\"矩阵区域和\"></a>矩阵区域和</h4><p><a href=\"\">题目地址</a></p>\n<p>简单动态规划。</p>\n<h4 id=\"祖父节点值为偶数的节点和\"><a href=\"#祖父节点值为偶数的节点和\" class=\"headerlink\" title=\"祖父节点值为偶数的节点和\"></a>祖父节点值为偶数的节点和</h4><p><a href=\"https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/\">题目地址</a></p>\n<p>深度遍历的<strong>同时</strong>，递归地把计算左右子节点的sumEvenGrandparent值都返回并且求和。</p>\n<h4 id=\"不同的循环子字符串\"><a href=\"#不同的循环子字符串\" class=\"headerlink\" title=\"不同的循环子字符串\"></a>不同的循环子字符串</h4><p><a href=\"https://leetcode-cn.com/problems/distinct-echo-substrings/\">题目地址</a><br>这个题目最终还是使用暴力解法。</p>\n<hr>"},{"title":"Spragure-Grundy定理","date":"2021-05-21T16:00:00.000Z","_content":"\n\n\n## 策梅洛定理\n\n策梅洛定理指出，如果一个游戏满足以下几个条件：\n1. 双人、回合制；\n2. 信息完全公开（perfect information）；\n3. 无随机因素（deterministic）；\n4. 必然在有限步内结束；\n5. 没有平局；\n\n那么游戏中的任何一个状态，要么先手有策略必赢，要么后手有策略必赢。\n\n其中，第四个条件：\n策梅洛定理不仅仅要求总体步数有限，并且要求每一步内的可能走法步数也是有限的，这种游戏我们成为**有限游戏**。换句话说，不考虑树的层数和","source":"_drafts/Sprague-Grundy定理/Sprague-Grundy定理.md","raw":"---\ntitle: Spragure-Grundy定理\ndate: 2021-05-22\ntags: [算法]\ncategories: 算法\n---\n\n\n\n## 策梅洛定理\n\n策梅洛定理指出，如果一个游戏满足以下几个条件：\n1. 双人、回合制；\n2. 信息完全公开（perfect information）；\n3. 无随机因素（deterministic）；\n4. 必然在有限步内结束；\n5. 没有平局；\n\n那么游戏中的任何一个状态，要么先手有策略必赢，要么后手有策略必赢。\n\n其中，第四个条件：\n策梅洛定理不仅仅要求总体步数有限，并且要求每一步内的可能走法步数也是有限的，这种游戏我们成为**有限游戏**。换句话说，不考虑树的层数和","slug":"Sprague-Grundy定理/Sprague-Grundy定理","published":0,"updated":"2022-07-28T13:36:06.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl73fvwoj002hp9c927lmcg6c","content":"<h2 id=\"策梅洛定理\"><a href=\"#策梅洛定理\" class=\"headerlink\" title=\"策梅洛定理\"></a>策梅洛定理</h2><p>策梅洛定理指出，如果一个游戏满足以下几个条件：</p>\n<ol>\n<li>双人、回合制；</li>\n<li>信息完全公开（perfect information）；</li>\n<li>无随机因素（deterministic）；</li>\n<li>必然在有限步内结束；</li>\n<li>没有平局；</li>\n</ol>\n<p>那么游戏中的任何一个状态，要么先手有策略必赢，要么后手有策略必赢。</p>\n<p>其中，第四个条件：<br>策梅洛定理不仅仅要求总体步数有限，并且要求每一步内的可能走法步数也是有限的，这种游戏我们成为<strong>有限游戏</strong>。换句话说，不考虑树的层数和</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"策梅洛定理\"><a href=\"#策梅洛定理\" class=\"headerlink\" title=\"策梅洛定理\"></a>策梅洛定理</h2><p>策梅洛定理指出，如果一个游戏满足以下几个条件：</p>\n<ol>\n<li>双人、回合制；</li>\n<li>信息完全公开（perfect information）；</li>\n<li>无随机因素（deterministic）；</li>\n<li>必然在有限步内结束；</li>\n<li>没有平局；</li>\n</ol>\n<p>那么游戏中的任何一个状态，要么先手有策略必赢，要么后手有策略必赢。</p>\n<p>其中，第四个条件：<br>策梅洛定理不仅仅要求总体步数有限，并且要求每一步内的可能走法步数也是有限的，这种游戏我们成为<strong>有限游戏</strong>。换句话说，不考虑树的层数和</p>\n"}],"PostAsset":[{"_id":"source/_posts/2022-07-20_C++_memory_order/CPU_memory_struct.jpg","post":"cl73fvwoe001tp9c96nsd2s8m","slug":"CPU_memory_struct.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2022-07-20_C++_memory_order/memory_reorder_case1.jpg","post":"cl73fvwoe001tp9c96nsd2s8m","slug":"memory_reorder_case1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2022-07-20_C++_memory_order/mutex_memory_case.jpg","post":"cl73fvwoe001tp9c96nsd2s8m","slug":"mutex_memory_case.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2022-07-20_C++_memory_order/shared_ptr_delete.jpg","post":"cl73fvwoe001tp9c96nsd2s8m","slug":"shared_ptr_delete.jpg","modified":1,"renderable":1},{"_id":"source/_posts/2022-07-20_C++_memory_order/shared_ptr_delete2.jpg","post":"cl73fvwoe001tp9c96nsd2s8m","slug":"shared_ptr_delete2.jpg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cl73fvwnu0001p9c91wff9lf6","category_id":"cl73fvwnx0004p9c9ft9agv21","_id":"cl73fvwo2000ep9c9g97udrom"},{"post_id":"cl73fvwo1000cp9c9buwt4cfl","category_id":"cl73fvwo00009p9c9botc3v98","_id":"cl73fvwo4000kp9c97se33b2a"},{"post_id":"cl73fvwny0006p9c943knbpsu","category_id":"cl73fvwo00009p9c9botc3v98","_id":"cl73fvwo5000op9c96b5nfwvh"},{"post_id":"cl73fvwnz0007p9c99q026vlk","category_id":"cl73fvwo00009p9c9botc3v98","_id":"cl73fvwo6000qp9c911cueek3"},{"post_id":"cl73fvwo1000dp9c94e31e2ws","category_id":"cl73fvwo4000lp9c969j92pzs","_id":"cl73fvwo7000wp9c93qq87txq"},{"post_id":"cl73fvwo6000tp9c92z617a4j","category_id":"cl73fvwo6000rp9c96bvs15c7","_id":"cl73fvwo90012p9c9h8kofjtx"},{"post_id":"cl73fvwo3000hp9c950810gyr","category_id":"cl73fvwo6000rp9c96bvs15c7","_id":"cl73fvwo90014p9c96az0a7kq"},{"post_id":"cl73fvwo7000vp9c93dzbhx5v","category_id":"cl73fvwo6000rp9c96bvs15c7","_id":"cl73fvwoa0018p9c96w3rgeqo"},{"post_id":"cl73fvwo8000zp9c93ekf9x2p","category_id":"cl73fvwo00009p9c9botc3v98","_id":"cl73fvwob001bp9c9gjbmaa5n"},{"post_id":"cl73fvwo80011p9c91fqsbmcj","category_id":"cl73fvwo6000rp9c96bvs15c7","_id":"cl73fvwoc001gp9c97ce16dks"},{"post_id":"cl73fvwo4000jp9c92cvhffsh","category_id":"cl73fvwo7000yp9c984hpc9qm","_id":"cl73fvwoc001jp9c95tpabjsc"},{"post_id":"cl73fvwo90013p9c9f6rn3w43","category_id":"cl73fvwo6000rp9c96bvs15c7","_id":"cl73fvwod001op9c97zmcg4r6"},{"post_id":"cl73fvwo5000np9c92lag7t6e","category_id":"cl73fvwo90015p9c9bvfd9bq4","_id":"cl73fvwoe001rp9c9ewf7fm2k"},{"post_id":"cl73fvwoa001ap9c9gmet47ly","category_id":"cl73fvwo6000rp9c96bvs15c7","_id":"cl73fvwoe001up9c9focwaf0x"},{"post_id":"cl73fvwob001fp9c99kg08lta","category_id":"cl73fvwo6000rp9c96bvs15c7","_id":"cl73fvwof001yp9c9etbx3msk"},{"post_id":"cl73fvwo6000pp9c967jt56rg","category_id":"cl73fvwo6000rp9c96bvs15c7","_id":"cl73fvwof0020p9c97nvz183z"},{"post_id":"cl73fvwoc001ip9c99lbobm13","category_id":"cl73fvwo6000rp9c96bvs15c7","_id":"cl73fvwog0024p9c973u3aora"},{"post_id":"cl73fvwod001np9c9c9cv86bf","category_id":"cl73fvwo6000rp9c96bvs15c7","_id":"cl73fvwoh0027p9c9h4doc843"},{"post_id":"cl73fvwoa0017p9c9a6a91ay3","category_id":"cl73fvwoc001kp9c9h6nu61rn","_id":"cl73fvwoi002bp9c9axdp5fif"},{"post_id":"cl73fvwof001xp9c98d6g00yo","category_id":"cl73fvwo4000lp9c969j92pzs","_id":"cl73fvwoi002ep9c9gx7vgmy1"},{"post_id":"cl73fvwof001zp9c91np0f8re","category_id":"cl73fvwoc001kp9c9h6nu61rn","_id":"cl73fvwoj002ip9c990f8hkkr"},{"post_id":"cl73fvwod001qp9c98kaih6hz","category_id":"cl73fvwoe001wp9c9gvkmajyh","_id":"cl73fvwoj002kp9c9483l0y3u"},{"post_id":"cl73fvwog0022p9c95l1m1ufm","category_id":"cl73fvwo00009p9c9botc3v98","_id":"cl73fvwok002np9c91kqgc3bu"},{"post_id":"cl73fvwoh0026p9c90bfabpqc","category_id":"cl73fvwo00009p9c9botc3v98","_id":"cl73fvwok002op9c9h1123nus"},{"post_id":"cl73fvwoe001tp9c96nsd2s8m","category_id":"cl73fvwog0023p9c960krhgk4","_id":"cl73fvwok002qp9c9by8fb97b"},{"post_id":"cl73fvwoh002ap9c98zccewtb","category_id":"cl73fvwo00009p9c9botc3v98","_id":"cl73fvwok002sp9c96isq6a87"},{"post_id":"cl73fvwoi002dp9c9h4s84pf0","category_id":"cl73fvwo00009p9c9botc3v98","_id":"cl73fvwok002vp9c93whmfbnj"},{"post_id":"cl73fvwoj002hp9c927lmcg6c","category_id":"cl73fvwo00009p9c9botc3v98","_id":"cl73fvwok002xp9c9eorjds4t"}],"PostTag":[{"post_id":"cl73fvwnu0001p9c91wff9lf6","tag_id":"cl73fvwny0005p9c9apg373fz","_id":"cl73fvwo1000bp9c99xd896qn"},{"post_id":"cl73fvwny0006p9c943knbpsu","tag_id":"cl73fvwo0000ap9c9eg3l7nog","_id":"cl73fvwo4000ip9c9gx7wbp1j"},{"post_id":"cl73fvwnz0007p9c99q026vlk","tag_id":"cl73fvwo2000gp9c98akw76nu","_id":"cl73fvwo7000up9c92jq950ow"},{"post_id":"cl73fvwnz0007p9c99q026vlk","tag_id":"cl73fvwo5000mp9c90n0b2w12","_id":"cl73fvwo7000xp9c922rn965o"},{"post_id":"cl73fvwo1000cp9c9buwt4cfl","tag_id":"cl73fvwo6000sp9c9anxqdgvx","_id":"cl73fvwoa0019p9c9ga2wgs6n"},{"post_id":"cl73fvwo1000cp9c9buwt4cfl","tag_id":"cl73fvwo80010p9c90x2d727s","_id":"cl73fvwob001cp9c9giig2eeb"},{"post_id":"cl73fvwo1000dp9c94e31e2ws","tag_id":"cl73fvwo90016p9c9hpmc6tru","_id":"cl73fvwoc001hp9c9bwa1d1tg"},{"post_id":"cl73fvwob001fp9c99kg08lta","tag_id":"cl73fvwob001ep9c92b7g1g4m","_id":"cl73fvwoc001lp9c9a3la6mn4"},{"post_id":"cl73fvwoc001ip9c99lbobm13","tag_id":"cl73fvwob001ep9c92b7g1g4m","_id":"cl73fvwod001pp9c9hbz7634g"},{"post_id":"cl73fvwod001np9c9c9cv86bf","tag_id":"cl73fvwob001ep9c92b7g1g4m","_id":"cl73fvwoe001sp9c9ammh3b1x"},{"post_id":"cl73fvwo3000hp9c950810gyr","tag_id":"cl73fvwob001ep9c92b7g1g4m","_id":"cl73fvwog0025p9c9gncq9a29"},{"post_id":"cl73fvwo3000hp9c950810gyr","tag_id":"cl73fvwoc001mp9c9b55x5hgi","_id":"cl73fvwoh0028p9c93ce1huth"},{"post_id":"cl73fvwo3000hp9c950810gyr","tag_id":"cl73fvwoe001vp9c94i4bbt1l","_id":"cl73fvwoi002cp9c93ow35o6c"},{"post_id":"cl73fvwof001zp9c91np0f8re","tag_id":"cl73fvwo6000sp9c9anxqdgvx","_id":"cl73fvwoi002fp9c9344v145p"},{"post_id":"cl73fvwo4000jp9c92cvhffsh","tag_id":"cl73fvwo6000sp9c9anxqdgvx","_id":"cl73fvwoj002jp9c99g0sf6l1"},{"post_id":"cl73fvwo5000np9c92lag7t6e","tag_id":"cl73fvwoh0029p9c9as9p18ni","_id":"cl73fvwoj002lp9c95bt11oow"},{"post_id":"cl73fvwo6000pp9c967jt56rg","tag_id":"cl73fvwob001ep9c92b7g1g4m","_id":"cl73fvwok002rp9c9cq1nb3nd"},{"post_id":"cl73fvwo6000pp9c967jt56rg","tag_id":"cl73fvwoc001mp9c9b55x5hgi","_id":"cl73fvwok002tp9c9gnun82ak"},{"post_id":"cl73fvwo6000tp9c92z617a4j","tag_id":"cl73fvwob001ep9c92b7g1g4m","_id":"cl73fvwok002wp9c973wq2i5n"},{"post_id":"cl73fvwo7000vp9c93dzbhx5v","tag_id":"cl73fvwob001ep9c92b7g1g4m","_id":"cl73fvwol002zp9c94dew52gp"},{"post_id":"cl73fvwo8000zp9c93ekf9x2p","tag_id":"cl73fvwo2000gp9c98akw76nu","_id":"cl73fvwol0031p9c94o704ril"},{"post_id":"cl73fvwo8000zp9c93ekf9x2p","tag_id":"cl73fvwok002yp9c9bgr14dhu","_id":"cl73fvwol0032p9c911mn1keh"},{"post_id":"cl73fvwo80011p9c91fqsbmcj","tag_id":"cl73fvwob001ep9c92b7g1g4m","_id":"cl73fvwol0034p9c9ecdsg6kc"},{"post_id":"cl73fvwo90013p9c9f6rn3w43","tag_id":"cl73fvwob001ep9c92b7g1g4m","_id":"cl73fvwol0036p9c99jk40y29"},{"post_id":"cl73fvwoa0017p9c9a6a91ay3","tag_id":"cl73fvwo6000sp9c9anxqdgvx","_id":"cl73fvwom0038p9c9hyng5vxh"},{"post_id":"cl73fvwoa0017p9c9a6a91ay3","tag_id":"cl73fvwol0035p9c9gne79o4w","_id":"cl73fvwom0039p9c9cv69dsxu"},{"post_id":"cl73fvwoa001ap9c9gmet47ly","tag_id":"cl73fvwob001ep9c92b7g1g4m","_id":"cl73fvwom003bp9c9b2vag6hp"},{"post_id":"cl73fvwod001qp9c98kaih6hz","tag_id":"cl73fvwom003ap9c96xz1ghlr","_id":"cl73fvwom003dp9c94r2x9nco"},{"post_id":"cl73fvwoe001tp9c96nsd2s8m","tag_id":"cl73fvwom003cp9c94c8u9al2","_id":"cl73fvwom003fp9c9hffv7ifk"},{"post_id":"cl73fvwof001xp9c98d6g00yo","tag_id":"cl73fvwo90016p9c9hpmc6tru","_id":"cl73fvwom003hp9c9cfvb13s6"},{"post_id":"cl73fvwof001xp9c98d6g00yo","tag_id":"cl73fvwom003ep9c9ha2u7aga","_id":"cl73fvwon003ip9c9fgb8dkth"},{"post_id":"cl73fvwog0022p9c95l1m1ufm","tag_id":"cl73fvwo2000gp9c98akw76nu","_id":"cl73fvwon003kp9c9e6usfzzs"},{"post_id":"cl73fvwog0022p9c95l1m1ufm","tag_id":"cl73fvwom003gp9c99easghek","_id":"cl73fvwon003lp9c9htbpbdec"},{"post_id":"cl73fvwoh0026p9c90bfabpqc","tag_id":"cl73fvwo2000gp9c98akw76nu","_id":"cl73fvwon003np9c98oit6bcu"},{"post_id":"cl73fvwoh0026p9c90bfabpqc","tag_id":"cl73fvwon003jp9c96uo4b621","_id":"cl73fvwon003op9c935i3crm1"},{"post_id":"cl73fvwoh002ap9c98zccewtb","tag_id":"cl73fvwo2000gp9c98akw76nu","_id":"cl73fvwon003qp9c97lqd3nfv"},{"post_id":"cl73fvwoh002ap9c98zccewtb","tag_id":"cl73fvwom003gp9c99easghek","_id":"cl73fvwon003rp9c97llx2753"},{"post_id":"cl73fvwoi002dp9c9h4s84pf0","tag_id":"cl73fvwo2000gp9c98akw76nu","_id":"cl73fvwoo003tp9c9ec8p0ukd"},{"post_id":"cl73fvwoi002dp9c9h4s84pf0","tag_id":"cl73fvwon003pp9c957eeh0vo","_id":"cl73fvwoo003up9c957tm4ahj"},{"post_id":"cl73fvwoj002hp9c927lmcg6c","tag_id":"cl73fvwoo003sp9c9hbed53pd","_id":"cl73fvwoo003vp9c9hkz7dryk"}],"Tag":[{"name":"Swift","_id":"cl73fvwny0005p9c9apg373fz"},{"name":"Segment-Tree","_id":"cl73fvwo0000ap9c9eg3l7nog"},{"name":"leetcode","_id":"cl73fvwo2000gp9c98akw76nu"},{"name":"数组","_id":"cl73fvwo5000mp9c90n0b2w12"},{"name":"object-c","_id":"cl73fvwo6000sp9c9anxqdgvx"},{"name":"二分法","_id":"cl73fvwo80010p9c90x2d727s"},{"name":"动态链接","_id":"cl73fvwo90016p9c9hpmc6tru"},{"name":"sqlite3","_id":"cl73fvwob001ep9c92b7g1g4m"},{"name":"os","_id":"cl73fvwoc001mp9c9b55x5hgi"},{"name":"shm","_id":"cl73fvwoe001vp9c94i4bbt1l"},{"name":"GoMobile","_id":"cl73fvwoh0029p9c9as9p18ni"},{"name":"回文","_id":"cl73fvwok002yp9c9bgr14dhu"},{"name":"锁","_id":"cl73fvwol0035p9c9gne79o4w"},{"name":"汇编","_id":"cl73fvwom003ap9c96xz1ghlr"},{"name":"C++","_id":"cl73fvwom003cp9c94c8u9al2"},{"name":"符号绑定","_id":"cl73fvwom003ep9c9ha2u7aga"},{"name":"回溯法","_id":"cl73fvwom003gp9c99easghek"},{"name":"动态规划","_id":"cl73fvwon003jp9c96uo4b621"},{"name":"周赛","_id":"cl73fvwon003pp9c957eeh0vo"},{"name":"算法","_id":"cl73fvwoo003sp9c9hbed53pd"}]}}