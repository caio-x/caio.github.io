<!DOCTYPE html>
<html lang="zh-CH">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/spade-logo-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/spade-logo-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/spade-logo-next.png">
  <link rel="mask-icon" href="/images/spade-logo-next.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-big-counter.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.spade-ace.tech","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="超长预警……. 本文将会从dyld接管进程开始，超级详细的分析&#x2F;解释，dyld 是如何把若干个动态库“组装”在一起，在ASLR的影响下形成一个完整的可执行进程，以及objc的runtime如何在dyld的初始化过程中进行实例化。">
<meta property="og:type" content="article">
<meta property="og:title" content="详解 dyld 加载过程">
<meta property="og:url" content="https://blog.spade-ace.tech/2020/03/13/11.dyld/index.html">
<meta property="og:site_name" content="Spade-Ace">
<meta property="og:description" content="超长预警……. 本文将会从dyld接管进程开始，超级详细的分析&#x2F;解释，dyld 是如何把若干个动态库“组装”在一起，在ASLR的影响下形成一个完整的可执行进程，以及objc的runtime如何在dyld的初始化过程中进行实例化。">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/81503ddc20aec519b01d09370a4d1628.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d61a14b2aeeb66a2eea1be2d8be6b85f.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/9ac92176b89d0c92d76d1d98ecddd5f4.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/ffdc0da28d16d220f66e8d638a7d5198.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/69f3c8a3511f6c75d8798c62db21d597.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/8479e0316c7f0447ff14dd0a1b98ed69.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/6880c3f245ce10b72f214d8851b959e5.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d26ee1e5057ed5fc0c63d13baac4b77b.png">
<meta property="article:published_time" content="2020-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2022-07-26T10:54:31.140Z">
<meta property="article:author" content="Caio">
<meta property="article:tag" content="动态链接">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/81503ddc20aec519b01d09370a4d1628.png">


<link rel="canonical" href="https://blog.spade-ace.tech/2020/03/13/11.dyld/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CH","comments":true,"permalink":"https://blog.spade-ace.tech/2020/03/13/11.dyld/","path":"2020/03/13/11.dyld/","title":"详解 dyld 加载过程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>详解 dyld 加载过程 | Spade-Ace</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Spade-Ace</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Cpp creates world</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#dyld-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">dyld 加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RebaseDyld"><span class="nav-number">1.1.</span> <span class="nav-text">RebaseDyld</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96Dyld%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">初始化Dyld的构造器函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dyld-main%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">dyld::_main函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">实例化主程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">2.2.</span> <span class="nav-text">加载动态库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Link-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.</span> <span class="nav-text">Link 可执行文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rebase"><span class="nav-number">2.4.</span> <span class="nav-text">Rebase</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#initializeMainExecutable"><span class="nav-number">3.</span> <span class="nav-text">initializeMainExecutable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-number">4.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Caio"
      src="/images/timg.gif">
  <p class="site-author-name" itemprop="name">Caio</p>
  <div class="site-description" itemprop="description">Spade-Ace&apos; Tech Blog</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CH">
    <link itemprop="mainEntityOfPage" href="https://blog.spade-ace.tech/2020/03/13/11.dyld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/timg.gif">
      <meta itemprop="name" content="Caio">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spade-Ace">
      <meta itemprop="description" content="Spade-Ace&apos; Tech Blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="详解 dyld 加载过程 | Spade-Ace">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          详解 dyld 加载过程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-03-13 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-13T00:00:00+08:00">2020-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-26 18:54:31" itemprop="dateModified" datetime="2022-07-26T18:54:31+08:00">2022-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8A%A8%E6%80%81%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">动态库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>超长预警…….</p>
<p>本文将会从dyld接管进程开始，超级详细的分析&#x2F;解释，dyld 是如何把若干个动态库“组装”在一起，在ASLR的影响下形成一个完整的可执行进程，以及objc的runtime如何在dyld的初始化过程中进行实例化。</p>
<span id="more"></span>

<h2 id="dyld-加载过程"><a href="#dyld-加载过程" class="headerlink" title="dyld 加载过程"></a>dyld 加载过程</h2><p>dyld的启动入口在 dyldStartup.s 文件的汇编代码中，代码入口说明了:在内核初始化完成进程，并且load 完可执行文件之后，把环境变量等参数压栈，并且调用dyld的入口函数<code>__dyld_start</code>，而这个函数则根据调用约定，准备完调用参数之后，就直接跳转到<code>dyld::start</code> 这个函数。</p>
<p>接下来看<code>dyld::start</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> macho_header* appsMachHeader, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[], </span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="type">intptr_t</span> slide, <span class="type">const</span> <span class="keyword">struct</span> macho_header* dyldsMachHeader,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="type">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line">	<span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">    <span class="comment">//获取内核对于dyld本身的动态偏移</span></span><br><span class="line">    slide = <span class="built_in">slideOfMainExecutable</span>(dyldsMachHeader);</span><br><span class="line">    <span class="type">bool</span> shouldRebase = slide != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( shouldRebase ) &#123;</span><br><span class="line">        <span class="comment">//rebase Dyld</span></span><br><span class="line">        <span class="built_in">rebaseDyld</span>(dyldsMachHeader, slide);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allow dyld to use mach messaging</span></span><br><span class="line">    <span class="comment">//mach消息初始化。</span></span><br><span class="line">	<span class="built_in">mach_init</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">    <span class="comment">//环境变量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>** apple = envp;</span><br><span class="line">	<span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">	++apple;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set up random value for stack canary</span></span><br><span class="line">	__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">	<span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">    <span class="comment">//初始化 在dyld中的 所有的C++构造器</span></span><br><span class="line">	<span class="built_in">runDyldInitializers</span>(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class="line">    <span class="comment">//至此bootstrap dyld已经全部完成，调用 dyld 的 main 函数</span></span><br><span class="line">	<span class="type">uintptr_t</span> appsSlide = <span class="built_in">slideOfMainExecutable</span>(appsMachHeader);</span><br><span class="line">	<span class="keyword">return</span> dyld::   _main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dyld::start</code>的函数分为以下几步骤：</p>
<ol>
<li><span id="return_rebaseDyld">rebase dyld本身</span><br><a href="#jump_rebaseDyld">rebase dyld</a></li>
<li>初始化进程间通讯 mach_msg<br> 直接调用&lt;mach&#x2F;mach_init.h&gt;内的某个内核调用</li>
<li>初始化环境变量<br> 从调用参数中拿到apple指针，内核会把这个指针紧跟在envp的数组最后</li>
<li>设置栈保护<br> 从第三步拿到的apple指针中找到“stack_guard&#x3D;xx”的字符串，自定义重置栈保护</li>
<li><span id="return_runDyldInitializers">初始化 dyld 中的所有构造器函数</span><br> 因为dyld本身是一个动态库，我们知道，动态库是共享的，但是共享的只是代码段(PIC 位置无关代码)。在内核给每一个进程的虚拟地址映射完dyld之后，dyld本身这个动态库的数据段是没有初始化的，需要自己做自己的初始化。<a href="#jump_runDyldInitializers">具体代码看这里</a></li>
<li>前五步已经完成 dyld 的自启动(bootstrap)，后面就是进入真正的 dyld main函数。</li>
</ol>
<p>这里可以总结一下，start的工作内容主要是一些全局环境，以及dyld自身的初始化。</p>
<p><a href="#jump__main">开始 分析 dyld 的_main函数</a></p>
<h3 id="RebaseDyld"><a href="#RebaseDyld" class="headerlink" title="RebaseDyld"></a><span id="jump_rebaseDyld">RebaseDyld</span></h3><p>因为Dyld也是一个动态库，和普通的动态库一样，会在mach_o的load_command中指定要求需要加载到某个虚拟地址下。但是内核还是会对dyld做地址随机偏移，如果是这样，dyld需要修复数据段的数据。</p>
<ol>
<li>找到Load_Commands中 __LINKEDIT 和 LC_DYLD_INFO_ONLY 两段，__LINKEDIT段内包含了链接信息，符号表，动态符号表等等，而LC_DYLD_INFO_ONLY内标明了：Rebase,Bind,WeakBind,LazyBind,Export 这个5类，而这5类都会存储在Dynamic Loader Info这一节中。</li>
<li>根据rebase 和 bind 的 Opcodes等，循环进行。</li>
</ol>
<p>在后文rebase&#x2F;bind 可执行文件依赖的动态库时，会进行详细说明。</p>
<p><a href="#return_rebaseDyld">回去继续</a></p>
<h3 id="初始化Dyld的构造器函数"><a href="#初始化Dyld的构造器函数" class="headerlink" title="初始化Dyld的构造器函数"></a><span id="jump_runDyldInitializers">初始化Dyld的构造器函数</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> Initializer  inits_start  __asm(<span class="string">&quot;section$start$__DATA$__mod_init_func&quot;</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> Initializer  inits_end    __asm(<span class="string">&quot;section$end$__DATA$__mod_init_func&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For a regular executable, the crt code calls dyld to run the executables initializers.</span></span><br><span class="line"><span class="comment">// For a static executable, crt directly runs the initializers.</span></span><br><span class="line"><span class="comment">// dyld (should be static) but is a dynamic executable and needs this hack to run its own initializers.</span></span><br><span class="line"><span class="comment">// We pass argc, argv, etc in case libc.a uses those arguments</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">runDyldInitializers</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> macho_header* mh, <span class="type">intptr_t</span> slide, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[], <span class="type">const</span> <span class="type">char</span>* envp[], <span class="type">const</span> <span class="type">char</span>* apple[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> Initializer* p = &amp;inits_start; p &lt; &amp;inits_end; ++p) &#123;</span><br><span class="line">		(*p)(argc, argv, envp, apple);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在dyld的该方法的注释上，苹果写的很清楚：对于常规的可执行文件，crt代码会通过调用dyld来初始化这个可执行文件的初始化构造器。但是对于静态可执行文件，crt会自己去执行初始化。dyld可以认为是“静态”的，但是本质是一个动态库，所以需要自己来初始化自己，但是苹果称之为hack的方式。</p>
<p>实际上这是一段内联汇编，<code>__asm(&quot;section$start$__DATA$__mod_init_func&quot;)</code>意思是：获取<code>__DATA</code>段<code>__mod_init_func</code>的起始地址，当然下面那行就是获取结束地址了。</p>
<p>在Demo代码中加入两个构造器：<br><img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/81503ddc20aec519b01d09370a4d1628.png"></p>
<p>然后再看这个mach-o 文件：<br><img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d61a14b2aeeb66a2eea1be2d8be6b85f.png"></p>
<p>可以看到在数据段增加了一节<code>__mod_init_func</code>,编译期会把所有构造器的函数地址，都放在这节中。例如这个Section中第一个地址存储的是demo_init1的函数地址，去掉虚拟起始地址，文件内偏移地址就是0xED0：</p>
<p><img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/9ac92176b89d0c92d76d1d98ecddd5f4.png"></p>
<p>可以直接验证确实是这个函数，<code>demo_init2</code>也是如此。</p>
<p>回过头来看，dyld的代码：这个<code>inits_start</code>中就是构造器列表中第一个构造器的函数地址了。<code>inits_end</code>就是结束地址，循环即可依次按照约定，初始化dyld自己内部的所有构造器函数了。</p>
<p>在dyld的内部还会有很多诸如此类的用法。<br>具体可以看<a href="#jump_end">参考文献</a>中 1 和 2</p>
<p><a href="#return_runDyldInitializers">回去继续</a></p>
<h2 id="dyld-main函数"><a href="#dyld-main函数" class="headerlink" title="dyld::_main函数"></a><span id="jump__main">dyld::_main函数</span></h2><p>在dyld自身的rebase和bind、mach_msg初始化、环境变量初始化、构造函数初始化全部完成之后，开始dyld的真正工作内容，<code>dyld::_main</code> 函数。</p>
<p><code>dyld::_main</code>函数最终是返回了主进程App可执行文件的main函数入口，并且由<code>dyld::start</code>函数再返回给调用它的<code>__dyld_start</code>这个汇编函数，最终由最开始的这个汇编函数，准备好调用参数之后，直接调用我们所熟悉的可执行文件的main函数。</p>
<p>这个_main函数很长，我们只看步骤。</p>
<ol>
<li>进入函数的最开始是对环境变量的初始化加载和控制，例如 crashlog，环境变量控制log，主进程可执行文件路径…</li>
<li>加载共享缓存。<code>// iOS cannot run without shared region</code>,iOS必须开启共享共享缓存。<br> 在所有libpath中搜索不到对应名字的动态库的时候，就会尝试从共享缓存中找。（当然这里为了便于理解，只是简单这样描述，实际的搜索方式远比这个要复杂）</li>
<li><span id="return_initMainExecutable">实例化可执行文件:</span><br> 实例化可执行程序，生成<code>ImageLoaderMachO</code>对象。<a href="#jump_initMainExecutable">实例化主程序</a><br> 实例化可执行文件有两种（Classic和Compressed），分别由<code>ImageLoaderMachOCompressed</code>和<code>ImageLoaderMachOClassic</code>来创建可执行文件对象，这两者均继承于<code>ImageLoaderMachO</code>。</li>
<li>加载从参数插入的动态库<code>loadInsertedDylib</code>，只做加载，不做链接。<a href="#jump_loaddylib">Load 插入的动态库</a><span id="return_loaddylib">.</span></li>
<li><span id="return_link_execution">链接可执行程序。</span><a href="#jump_link_execution">链接可执行程序</a></li>
<li>链接从参数插入的动态库。</li>
<li>从可执行文件，递归开始调用初始化。</li>
</ol>
<h3 id="实例化主程序"><a href="#实例化主程序" class="headerlink" title="实例化主程序"></a><span id="jump_initMainExecutable">实例化主程序</span></h3><p>在dyld获得控制权之前，内核已经把可执行文件映射到了某个线性地址空间了，所以dyld可以直接获取到 macho_header，dyld会为可执行文件创建一个ImageLoader实例对象，每一个MachO在dyld中都会有一个这个对象与之对应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="type">const</span> macho_header* mh, <span class="type">uintptr_t</span> slide, <span class="type">const</span> <span class="type">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="keyword">if</span> ( <span class="built_in">isCompatibleMachO</span>((<span class="type">const</span> <span class="type">uint8_t</span>*)mh, path) ) &#123;</span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::<span class="built_in">instantiateMainExecutable</span>(mh, slide, path, gLinkContext);</span><br><span class="line">		<span class="built_in">addImage</span>(image);</span><br><span class="line">		<span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">&quot;main executable not a known format&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instantiateMainExecutable</code>这个方法内还会根据不同的mach-o类型(compress 或者 classic)来返回ImageLoader的不同实现的子类对象。</p>
<p><code>addImage(image);</code>这个函数有两个作用：</p>
<ol>
<li>把生成的镜像实例（ImageLoader）加入到一个全局镜像容器<code>sAllImages</code>内。之后加载的所有动态库都会被加入这个容器。</li>
<li>把可执行文件的每一个段所占据的实际线性地址范围，映射到一个全局链表 <code>sMappedRangesStart</code>内，而这个全局链表的作用就是为了能够快速的通过 地址 反向获取到对应的<code>ImageLoader</code>。</li>
</ol>
<p><a href="#return_initMainExecutable">回去继续</a></p>
<h3 id="加载动态库"><a href="#加载动态库" class="headerlink" title="加载动态库"></a><span id="jump_loaddylib">加载动态库</span></h3><p>这一步循环遍历DYLD_INSERT_LIBRARIES环境变量中指定的动态库列表，并调用loadInsertedDylib()将其加载。</p>
<p>该函数调用load()完成加载工作。load()会调用loadPhase0()尝试从文件加载，loadPhase0()会向下调用下一层phase来查找动态库的路径，直到loadPhase6()，查找的顺序为DYLD_ROOT_PATH-&gt;LD_LIBRARY_PATH-&gt;DYLD_FRAMEWORK_PATH-&gt;原始路径-&gt;DYLD_FALLBACK_LIBRARY_PATH。</p>
<p>找到后调用ImageLoaderMachO::instantiateFromFile()来实例化一个 ImageLoader，之后调用 checkandAddImage() 验证映像并将其加入到全局镜像列表中。</p>
<p>如果loadPhase0()返回为空，表示在路径中没有找到动态库，就尝试从共享缓存中查找，找到就调用ImageLoaderMachO::instantiateFromCache()从缓存中加载。</p>
<p>否则就抛出没找到镜像的异常。</p>
<p>看加载动态库部分的源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map in file and instantiate an ImageLoader</span></span><br><span class="line"><span class="comment">// 映射某个动态库文件并且实例化一个ImagerLoader</span></span><br><span class="line"><span class="function"><span class="type">static</span> ImageLoader* <span class="title">loadPhase6</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> stat&amp; stat_buf, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> LoadContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log(&quot;%s(%s)\n&quot;, __func__ , path);</span></span><br><span class="line">	<span class="type">uint64_t</span> fileOffset = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint64_t</span> fileLength = stat_buf.st_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// validate it is a file (not directory)</span></span><br><span class="line">	<span class="keyword">if</span> ( (stat_buf.st_mode &amp; S_IFMT) != S_IFREG ) </span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&quot;not a file&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span> firstPages[MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE];</span><br><span class="line">	<span class="type">uint8_t</span> *firstPagesPtr = firstPages;</span><br><span class="line">	<span class="type">bool</span> shortPage = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// min mach-o file is 4K</span></span><br><span class="line">	<span class="comment">// 最小的mach-o文件就是4k（保证一个页框大小）</span></span><br><span class="line">	<span class="keyword">if</span> ( fileLength &lt; <span class="number">4096</span> ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">pread</span>(fd, firstPages, (<span class="type">size_t</span>)fileLength, <span class="number">0</span>) != (<span class="type">ssize_t</span>)fileLength )</span><br><span class="line">			<span class="built_in">throwf</span>(<span class="string">&quot;pread of short file failed: %d&quot;</span>, errno);</span><br><span class="line">		shortPage = <span class="literal">true</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// optimistically read only first 4KB</span></span><br><span class="line">		<span class="comment">// 优先读取header文件的4kb，因为一个分页最小是4k。</span></span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">pread</span>(fd, firstPages, <span class="number">4096</span>, <span class="number">0</span>) != <span class="number">4096</span> )</span><br><span class="line">			<span class="built_in">throwf</span>(<span class="string">&quot;pread of first 4K failed: %d&quot;</span>, errno);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// if fat wrapper, find usable sub-file</span></span><br><span class="line">	<span class="comment">// 如果这个动态库是个fat文件，就直接找到合适的“子文件”</span></span><br><span class="line">	<span class="type">const</span> fat_header* fileStartAsFat = (fat_header*)firstPages;</span><br><span class="line">	<span class="keyword">if</span> ( fileStartAsFat-&gt;magic == <span class="built_in">OSSwapBigToHostInt32</span>(FAT_MAGIC) ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">OSSwapBigToHostInt32</span>(fileStartAsFat-&gt;nfat_arch) &gt; ((<span class="number">4096</span> - <span class="built_in">sizeof</span>(fat_header)) / <span class="built_in">sizeof</span>(fat_arch)) )</span><br><span class="line">			<span class="built_in">throwf</span>(<span class="string">&quot;fat header too large: %u entries&quot;</span>, <span class="built_in">OSSwapBigToHostInt32</span>(fileStartAsFat-&gt;nfat_arch));</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">fatFindBest</span>(fileStartAsFat, &amp;fileOffset, &amp;fileLength) ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( (fileOffset+fileLength) &gt; (<span class="type">uint64_t</span>)(stat_buf.st_size) )</span><br><span class="line">				<span class="built_in">throwf</span>(<span class="string">&quot;truncated fat file.  file length=%llu, but needed slice goes to %llu&quot;</span>, stat_buf.st_size, fileOffset+fileLength);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">pread</span>(fd, firstPages, <span class="number">4096</span>, fileOffset) != <span class="number">4096</span>)</span><br><span class="line">				<span class="built_in">throwf</span>(<span class="string">&quot;pread of fat file failed: %d&quot;</span>, errno);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;no matching architecture in universal wrapper&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="keyword">if</span> ( shortPage ) </span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&quot;file too short&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( <span class="built_in">isCompatibleMachO</span>(firstPages, path) ) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded</span></span><br><span class="line">		<span class="type">const</span> mach_header* mh = (mach_header*)firstPages;</span><br><span class="line">		<span class="keyword">switch</span> ( mh-&gt;filetype ) &#123;</span><br><span class="line">			<span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line">			<span class="keyword">case</span> MH_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> MH_BUNDLE:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">&quot;mach-o, but wrong filetype&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">uint32_t</span> headerAndLoadCommandsSize = <span class="built_in">sizeof</span>(macho_header) + mh-&gt;sizeofcmds;</span><br><span class="line">		<span class="keyword">if</span> ( headerAndLoadCommandsSize &gt; MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE )</span><br><span class="line">			<span class="built_in">throwf</span>(<span class="string">&quot;malformed mach-o: load commands size (%u) &gt; %u&quot;</span>, headerAndLoadCommandsSize, MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( headerAndLoadCommandsSize &gt; fileLength )</span><br><span class="line">			dyld::<span class="built_in">throwf</span>(<span class="string">&quot;malformed mach-o: load commands size (%u) &gt; mach-o file size (%llu)&quot;</span>, headerAndLoadCommandsSize, fileLength);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( headerAndLoadCommandsSize &gt; <span class="number">4096</span> ) &#123;</span><br><span class="line">			<span class="comment">// read more pages</span></span><br><span class="line">			<span class="comment">// 如果 head 和 LC_COMMANDS的大小大于已读取的4096，那么就继续把 headerAndLoadCommandsSize 读完</span></span><br><span class="line">			<span class="type">unsigned</span> readAmount = headerAndLoadCommandsSize - <span class="number">4096</span>;</span><br><span class="line">			<span class="keyword">if</span> ( <span class="built_in">pread</span>(fd, &amp;firstPages[<span class="number">4096</span>], readAmount, fileOffset+<span class="number">4096</span>) != readAmount )</span><br><span class="line">				<span class="built_in">throwf</span>(<span class="string">&quot;pread of extra load commands past 4KB failed: %d&quot;</span>, errno);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_IPHONE_SIMULATOR	</span></span><br><span class="line">		<span class="comment">// &lt;rdar://problem/14168872&gt; dyld_sim should restrict loading osx binaries</span></span><br><span class="line">		<span class="keyword">if</span> ( !<span class="built_in">isSimulatorBinary</span>(firstPages, path) ) &#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> TARGET_OS_WATCH</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;mach-o, but not built for watchOS simulator&quot;</span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">elif</span> TARGET_OS_TV</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;mach-o, but not built for tvOS simulator&quot;</span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;mach-o, but not built for iOS simulator&quot;</span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line">		<span class="keyword">if</span> ( gLinkContext.marzipan ) &#123;</span><br><span class="line">			<span class="type">const</span> dyld3::MachOFile* mf = (dyld3::MachOFile*)firstPages;</span><br><span class="line">			<span class="type">bool</span> isiOSMacBinary = mf-&gt;<span class="built_in">supportsPlatform</span>(dyld3::Platform::iOSMac) || <span class="built_in">iOSMacWhiteListed</span>(path);</span><br><span class="line">			<span class="type">bool</span> isProhibitedMacOSBinary = !isiOSMacBinary &amp;&amp; <span class="built_in">iOSMacBlackListed</span>(path);</span><br><span class="line">			<span class="keyword">if</span> ( (context.enforceIOSMac &amp;&amp; !isiOSMacBinary) || isProhibitedMacOSBinary ) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">&quot;mach-o, but not built for iOSMac&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __arm64e__</span></span><br><span class="line">		<span class="keyword">if</span> ( (sMainExecutableMachHeader-&gt;cpusubtype == CPU_SUBTYPE_ARM64_E) &amp;&amp; (mh-&gt;cpusubtype != CPU_SUBTYPE_ARM64_E) )</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;arm64 dylibs cannot be loaded into arm64e processes&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		ImageLoader* image = <span class="literal">nullptr</span>;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_MAP_IMAGE, path, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="comment">//调用 instantiateFromFile 来实例化 ImageLoader</span></span><br><span class="line">			image = ImageLoaderMachO::<span class="built_in">instantiateFromFile</span>(path, fd, firstPagesPtr, headerAndLoadCommandsSize, fileOffset, fileLength, stat_buf, gLinkContext);</span><br><span class="line">			timer.<span class="built_in">setData4</span>((<span class="type">uint64_t</span>)image-&gt;<span class="built_in">machHeader</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// validate</span></span><br><span class="line">		<span class="comment">// 加入全局链表</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">checkandAddImage</span>(image, context);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try other file formats here...</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// throw error about what was found</span></span><br><span class="line">	<span class="keyword">switch</span> (*(<span class="type">uint32_t</span>*)firstPages) &#123;</span><br><span class="line">		<span class="keyword">case</span> MH_MAGIC:</span><br><span class="line">		<span class="keyword">case</span> MH_CIGAM:</span><br><span class="line">		<span class="keyword">case</span> MH_MAGIC_64:</span><br><span class="line">		<span class="keyword">case</span> MH_CIGAM_64:</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;mach-o, but wrong architecture&quot;</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">throwf</span>(<span class="string">&quot;unknown file type, first eight bytes: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X&quot;</span>, </span><br><span class="line">			firstPages[<span class="number">0</span>], firstPages[<span class="number">1</span>], firstPages[<span class="number">2</span>], firstPages[<span class="number">3</span>], firstPages[<span class="number">4</span>], firstPages[<span class="number">5</span>], firstPages[<span class="number">6</span>],firstPages[<span class="number">7</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分的主要任务就是，从本地文件中加载指定的动态库，并且返回<code>ImageLoader</code>实例对象。</p>
<p>步骤如下：</p>
<ol>
<li>优先读取这个文件的4k，因为一个分页最小是4k,并且解析为 fat_header。</li>
<li>如果这个动态库是个fat文件，就直接找到合适CPU架构的“子文件”</li>
<li>检查文件类型，大小等。</li>
<li>如果 head 和 Load_Commands 的大小大于已读取的4k，那么就继续把剩下的 headerAndLoadCommandsSize 读完，实例化<code>ImageLoader</code>。因为实例化<code>ImageLoader</code>需要整个 Load_Commands 部分。</li>
<li>checkandAddImage。</li>
</ol>
<p>再来看 checkandAddImage：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> ImageLoader* <span class="title">checkandAddImage</span><span class="params">(ImageLoader* image, <span class="type">const</span> LoadContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// now sanity check that this loaded image does not have the same install path as any existing image</span></span><br><span class="line">	<span class="comment">// 在sAllImages 中检查一下，是否有同样路径的动态库，如果有，则返回链表中原有的那个镜像</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* loadedImageInstallPath = image-&gt;<span class="built_in">getInstallPath</span>();</span><br><span class="line">	<span class="keyword">if</span> ( image-&gt;<span class="built_in">isDylib</span>() &amp;&amp; (loadedImageInstallPath != <span class="literal">NULL</span>) &amp;&amp; (loadedImageInstallPath[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) ) &#123;</span><br><span class="line">		<span class="keyword">for</span> (std::vector&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class="built_in">begin</span>(); it != sAllImages.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">			ImageLoader* anImage = *it;</span><br><span class="line">			<span class="type">const</span> <span class="type">char</span>* installPath = anImage-&gt;<span class="built_in">getInstallPath</span>();</span><br><span class="line">			<span class="keyword">if</span> ( installPath != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(loadedImageInstallPath, installPath) == <span class="number">0</span> ) &#123;</span><br><span class="line">					<span class="comment">//dyld::log(&quot;duplicate(%s) =&gt; %p\n&quot;, installPath, anImage);</span></span><br><span class="line">					<span class="built_in">removeImage</span>(image);</span><br><span class="line">					ImageLoader::<span class="built_in">deleteImage</span>(image);</span><br><span class="line">					<span class="keyword">return</span> anImage;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// some API&#x27;s restrict what they can load</span></span><br><span class="line">	<span class="keyword">if</span> ( context.mustBeBundle &amp;&amp; !image-&gt;<span class="built_in">isBundle</span>() )</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&quot;not a bundle&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> ( context.mustBeDylib &amp;&amp; !image-&gt;<span class="built_in">isDylib</span>() )</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&quot;not a dylib&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// regular main executables cannot be loaded </span></span><br><span class="line">	<span class="keyword">if</span> ( image-&gt;<span class="built_in">isExecutable</span>() ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( !context.canBePIE || !image-&gt;<span class="built_in">isPositionIndependentExecutable</span>() )</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;can&#x27;t load a main executable&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// don&#x27;t add bundles to global list, they can be loaded but not linked.  When linked it will be added to list</span></span><br><span class="line">	<span class="keyword">if</span> ( ! image-&gt;<span class="built_in">isBundle</span>() )</span><br><span class="line">		<span class="comment">//加入全局链表中</span></span><br><span class="line">		<span class="built_in">addImage</span>(image);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，判断这个路径的动态库是不是已经在全局链表中了，已经在的话就直接返回，否则就<code>AddImage</code></p>
<p><a href="#return_loaddylib">返回继续</a></p>
<h3 id="Link-可执行文件"><a href="#Link-可执行文件" class="headerlink" title="Link 可执行文件"></a><span id="jump_link_execution">Link 可执行文件</span></h3><p>标题是链接可执行文件，但是因为这是一个递归操作，所以这一节主要是讲述dyld如何链接所有的动态库。</p>
<p><code>void link(ImageLoader* image, bool forceLazysBound, bool neverUnload, const ImageLoader::RPathChain&amp; loaderRPaths, unsigned cacheIndex)</code></p>
<p>上面是这个函数的方法签名，在_main的执行过程中，首先是可执行文件的 mach-o 镜像 调用，其次紧跟着的是环境变量中插入的动态库会依次调用，这个函数内部最终还是调用到了 <code>ImageLoader.link</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageLoader::link</span><span class="params">(<span class="type">const</span> LinkContext&amp; context, <span class="type">bool</span> forceLazysBound, <span class="type">bool</span> preflightOnly, <span class="type">bool</span> neverUnload, <span class="type">const</span> RPathChain&amp; loaderRPaths, <span class="type">const</span> <span class="type">char</span>* imagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// clear error strings</span></span><br><span class="line">	(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> t0 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">recursiveLoadLibraries</span>(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">	context.<span class="built_in">notifyBatch</span>(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we only do the loading step for preflights</span></span><br><span class="line">	<span class="keyword">if</span> ( preflightOnly )</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> t1 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">	context.<span class="built_in">clearAllDepths</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">recursiveUpdateDepth</span>(context.<span class="built_in">imageCount</span>());</span><br><span class="line"></span><br><span class="line">	__block <span class="type">uint64_t</span> t2, t3, t4, t5;</span><br><span class="line">	&#123;</span><br><span class="line">		dyld3::<span class="built_in">ScopedTimer</span>(DBG_DYLD_TIMING_APPLY_FIXUPS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		t2 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">recursiveRebase</span>(context);</span><br><span class="line">		context.<span class="built_in">notifyBatch</span>(dyld_image_state_rebased, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		t3 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">		<span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">recursiveBindWithAccounting</span>(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">		t4 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">		<span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">			<span class="keyword">this</span>-&gt;<span class="built_in">weakBind</span>(context);</span><br><span class="line">		t5 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">        context.<span class="built_in">notifyBatch</span>(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line">	<span class="type">uint64_t</span> t6 = <span class="built_in">mach_absolute_time</span>();	</span><br><span class="line"></span><br><span class="line">	std::vector&lt;DOFInfo&gt; dofs;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">recursiveGetDOFSections</span>(context, dofs);</span><br><span class="line">	context.<span class="built_in">registerDOFs</span>(dofs);</span><br><span class="line">	<span class="type">uint64_t</span> t7 = <span class="built_in">mach_absolute_time</span>();	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// interpose any dynamically loaded images</span></span><br><span class="line">	<span class="keyword">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.<span class="built_in">size</span>() != <span class="number">0</span>) ) &#123;</span><br><span class="line">		<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_APPLY_INTERPOSING, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">recursiveApplyInterposing</span>(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// clear error strings</span></span><br><span class="line">	(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算时间，控制log输出</span></span><br><span class="line">	fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">	fgTotalRebaseTime += t3 - t2;</span><br><span class="line">	fgTotalBindTime += t4 - t3;</span><br><span class="line">	fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">	fgTotalDOF += t7 - t6;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// done with initial dylib loads</span></span><br><span class="line">	fgNextPIEDylibAddress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接函数的操作思路很清晰：</p>
<ol>
<li><code>this-&gt;recursiveLoadLibraries</code> 递归加载依赖的所有动态库 (这里仅仅是Load，Load包含open文件以及实例化ImageLoader)，最终的结果和Load通过参数插入的动态库一样。</li>
<li><code>this-&gt;recursiveUpdateDepth</code> 递归刷新依赖库的层级</li>
<li><span id="return_rebase"><code>this-&gt;recursiveRebase</code></span><br> 每一个动态库的递归rebase无非就是再次依次调用，当前动态库所依赖的其他动态库的recursiveRebase。真正rebase是在<code>rebase(const LinkContext&amp; context, uintptr_t slide)</code>。<a href="#jump_rebase">Rebase</a></li>
<li><code>this-&gt;recursiveBindWithAccounting</code><br> 这里就是经典的non-lazy bind和lazy bind了。和Rebase的代码结构类似，真正的rebind是在<code>doBind(const LinkContext&amp; context, bool forceLazysBound)</code>。</li>
<li><code>this-&gt;weakBind</code> 弱符号绑定</li>
<li><code>this-&gt;recursiveGetDOFSections</code> 注册DOF节</li>
<li><code>this-&gt;recursiveApplyInterposing</code></li>
</ol>
<p>其中每一个步骤都会有一个时间戳，用来根据可控的环境变量来输出log。</p>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a><span id="jump_rebase">Rebase</span></h3><p>首先解释一下 Rebase ：</p>
<p>都知道，Rebase是调整动态库内部的符号，因为ASLR，内核加载的时候会在随机的地址中映射动态库。一开始我的想法是，mach-o的动态库在编译期已经做了PIC（地址无关代码），为什么还会有”rebase”这个过程？</p>
<p>事实上PIC确实存在，但是rebase也是必须的。</p>
<p>举个例子：在动态库&#x2F;可执行文件 初始化 的过程中有一个步骤是构造器初始化(这个步骤本文也有具体说明)，而实现这个这个步骤的，实际上是在mach-o的数据段中有一个名为<code>__mod_init_func</code>的段，而这个段存储的指针数组就是构造器初始化函数的地址。说到这就比较明显了，在dyld 寻找构造器初始化地址指针的时候，已经不再是以数据段中的vmaddr为基准了，而是需要加上一个偏移 – slide。</p>
<p>下面就按照上面例子，看看代码中是如何实现这一步骤的，compressed mach-o(现代版本的好像几乎都是这个压缩的mach-o格式了) 在这一节上做了压缩，因此实现都在<code>ImageLoaderMachOCompressed</code>中。</p>
<p>先分析一下 rebase 这一节在mach-o内的数据结构<br><img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/ffdc0da28d16d220f66e8d638a7d5198.png"></p>
<p>每一个 rebase 信息都由若干个 操作码 – 操作数 来描述，每一个记录都包含两个元素（opcode 和 immediate），可以理解为一个操作码，一个是操作数，这两个都可以通过掩码来获取。</p>
<p>以第一个为例：<br>REBASE_OPCODE_TYPE_IMM &#x3D;&#x3D; 11:标识操作数是一个Type，而Type是个指针<br>REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB &#x3D;&#x3D; 22:当前rebase的数据在第2个segment，并且偏移是用uleb表示<br>uleb128 &#x3D;&#x3D; 24:上面提到的uleb值<br>REBASE_OPCODE_DO_REBASE_IMM_TIMES &#x3D;&#x3D; 2:当前rebase操作执行2次。</p>
<p>总结：在第2个段开始往后偏移24个字节的指针地址，连续执行两次rebase。</p>
<p>再看看：<br><img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/69f3c8a3511f6c75d8798c62db21d597.png"></p>
<p>0是起始段，那么第2段就是数据段。我们再找，段的文件偏移 0x3000 + 偏移 24 &#x3D;0x3018 。</p>
<p><img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/8479e0316c7f0447ff14dd0a1b98ed69.png"></p>
<p>没错，就是这两个构造器，并且当前节就是<code>__mod_init_func</code>~。</p>
<p>下面是rebase的源码，当然在本例中有些 操作码 和 操作数 并没有用到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageLoaderMachOCompressed::rebase</span><span class="params">(<span class="type">const</span> LinkContext&amp; context, <span class="type">uintptr_t</span> slide)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">CRSetCrashLogMessage2</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getPath</span>());</span><br><span class="line">	<span class="comment">// fLinkEditBase 是__LINKEDIT段在 内存实际偏移与预期偏移 的 差值 （== slide？）</span></span><br><span class="line">	<span class="comment">// start 的值是 rebase信息在内存中的实际起始地址</span></span><br><span class="line">	<span class="type">const</span> <span class="type">uint8_t</span>* <span class="type">const</span> start = fLinkEditBase + fDyldInfo-&gt;rebase_off;</span><br><span class="line">	<span class="comment">// end 的值是 rebase信息在内存中的实际结束地址</span></span><br><span class="line">	<span class="type">const</span> <span class="type">uint8_t</span>* <span class="type">const</span> end = &amp;start[fDyldInfo-&gt;rebase_size];</span><br><span class="line">	<span class="type">const</span> <span class="type">uint8_t</span>* p = start;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">uint8_t</span> type = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> segmentIndex = <span class="number">0</span>;</span><br><span class="line">		<span class="type">uintptr_t</span> address = <span class="built_in">segActualLoadAddress</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="type">uintptr_t</span> segmentStartAddress = <span class="built_in">segActualLoadAddress</span>(<span class="number">0</span>);<span class="comment">//第N个段地址的实际开始地址</span></span><br><span class="line">		<span class="type">uintptr_t</span> segmentEndAddress = <span class="built_in">segActualEndAddress</span>(<span class="number">0</span>);<span class="comment">//第N个段的实际结束地址</span></span><br><span class="line">		<span class="type">uintptr_t</span> count;</span><br><span class="line">		<span class="type">uintptr_t</span> skip;</span><br><span class="line">		<span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">while</span> ( !done &amp;&amp; (p &lt; end) ) &#123;</span><br><span class="line">			<span class="type">uint8_t</span> immediate = *p &amp; REBASE_IMMEDIATE_MASK;</span><br><span class="line">			<span class="type">uint8_t</span> opcode = *p &amp; REBASE_OPCODE_MASK;</span><br><span class="line">			++p;</span><br><span class="line">			<span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_DONE:</span><br><span class="line">					done = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_SET_TYPE_IMM:</span><br><span class="line">					type = immediate;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:</span><br><span class="line">					segmentIndex = immediate;</span><br><span class="line">					<span class="keyword">if</span> ( segmentIndex &gt;= fSegmentsCount )</span><br><span class="line">						dyld::<span class="built_in">throwf</span>(<span class="string">&quot;REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is too large (0..%d)&quot;</span>,</span><br><span class="line">								segmentIndex, fSegmentsCount<span class="number">-1</span>);</span><br><span class="line">			<span class="meta">#<span class="keyword">if</span> TEXT_RELOC_SUPPORT</span></span><br><span class="line">					<span class="keyword">if</span> ( !<span class="built_in">segWriteable</span>(segmentIndex) &amp;&amp; !<span class="built_in">segHasRebaseFixUps</span>(segmentIndex) &amp;&amp; !<span class="built_in">segHasBindFixUps</span>(segmentIndex) )</span><br><span class="line">			<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">					<span class="keyword">if</span> ( !<span class="built_in">segWriteable</span>(segmentIndex) )</span><br><span class="line">			<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">						dyld::<span class="built_in">throwf</span>(<span class="string">&quot;REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is not a writable segment (%s)&quot;</span>,</span><br><span class="line">								segmentIndex, <span class="built_in">segName</span>(segmentIndex));</span><br><span class="line">					<span class="comment">//读取当前段的实际开始和结束地址</span></span><br><span class="line">					segmentStartAddress = <span class="built_in">segActualLoadAddress</span>(segmentIndex);</span><br><span class="line">					segmentEndAddress = <span class="built_in">segActualEndAddress</span>(segmentIndex);</span><br><span class="line">					</span><br><span class="line">					address = segmentStartAddress + <span class="built_in">read_uleb128</span>(p, end);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_ADD_ADDR_ULEB:</span><br><span class="line">					address += <span class="built_in">read_uleb128</span>(p, end);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_ADD_ADDR_IMM_SCALED:</span><br><span class="line">					address += immediate*<span class="built_in">sizeof</span>(<span class="type">uintptr_t</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_IMM_TIMES:</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; immediate; ++i) &#123;<span class="comment">//循环N次</span></span><br><span class="line">						<span class="keyword">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class="line">							<span class="built_in">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class="line">						<span class="built_in">rebaseAt</span>(context, address, slide, type);</span><br><span class="line">						address += <span class="built_in">sizeof</span>(<span class="type">uintptr_t</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					fgTotalRebaseFixups += immediate;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_ULEB_TIMES:</span><br><span class="line">					count = <span class="built_in">read_uleb128</span>(p, end);</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">uint32_t</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class="line">							<span class="built_in">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class="line">						<span class="built_in">rebaseAt</span>(context, address, slide, type);</span><br><span class="line">						address += <span class="built_in">sizeof</span>(<span class="type">uintptr_t</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					fgTotalRebaseFixups += count;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB:</span><br><span class="line">					<span class="keyword">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class="line">						<span class="built_in">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class="line">					<span class="built_in">rebaseAt</span>(context, address, slide, type);</span><br><span class="line">					address += <span class="built_in">read_uleb128</span>(p, end) + <span class="built_in">sizeof</span>(<span class="type">uintptr_t</span>);</span><br><span class="line">					++fgTotalRebaseFixups;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB:</span><br><span class="line">					count = <span class="built_in">read_uleb128</span>(p, end);</span><br><span class="line">					skip = <span class="built_in">read_uleb128</span>(p, end);</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">uint32_t</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class="line">							<span class="built_in">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class="line">						<span class="built_in">rebaseAt</span>(context, address, slide, type);</span><br><span class="line">						address += skip + <span class="built_in">sizeof</span>(<span class="type">uintptr_t</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					fgTotalRebaseFixups += count;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					dyld::<span class="built_in">throwf</span>(<span class="string">&quot;bad rebase opcode %d&quot;</span>, *(p<span class="number">-1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* newMsg = dyld::<span class="built_in">mkstringf</span>(<span class="string">&quot;%s in %s&quot;</span>, msg, <span class="keyword">this</span>-&gt;<span class="built_in">getPath</span>());</span><br><span class="line">		<span class="built_in">free</span>((<span class="type">void</span>*)msg);</span><br><span class="line">		<span class="keyword">throw</span> newMsg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CRSetCrashLogMessage2</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="initializeMainExecutable"><a href="#initializeMainExecutable" class="headerlink" title="initializeMainExecutable"></a><span id="jump_init_main_execution">initializeMainExecutable</span></h2><p>其实到这里动态库的加载&#x2F;rebase&#x2F;bind…都已经完成了，而这一步要做的就是初始化构造器函数了，这里也就是runtime初始化的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initializeMainExecutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record that we&#x27;ve reached this step</span></span><br><span class="line">	gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line">	ImageLoader::InitializerTimingList initializerTimes[<span class="built_in">allImagesCount</span>()];</span><br><span class="line">	initializerTimes[<span class="number">0</span>].count = <span class="number">0</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> rootCount = sImageRoots.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> ( rootCount &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class="line">			sImageRoots[i]-&gt;<span class="built_in">runInitializers</span>(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">	sMainExecutable-&gt;<span class="built_in">runInitializers</span>(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line">	<span class="keyword">if</span> ( gLibSystemHelpers != <span class="literal">NULL</span> ) </span><br><span class="line">		(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dump info if requested</span></span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class="line">		ImageLoader::<span class="built_in">printStatistics</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">allImagesCount</span>(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class="line">		ImageLoaderMachO::<span class="built_in">printStatisticsDetails</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">allImagesCount</span>(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优先初始化插入的动态库，再初始化可执行文件。</p>
<p>sMainExecutable-&gt;runInitializers 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageLoader::runInitializers</span><span class="params">(<span class="type">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">uint64_t</span> t1 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">	<span class="type">mach_port_t</span> thisThread = <span class="built_in">mach_thread_self</span>();</span><br><span class="line">	ImageLoader::UninitedUpwards up;</span><br><span class="line">	up.count = <span class="number">1</span>;</span><br><span class="line">	up.images[<span class="number">0</span>] = <span class="keyword">this</span>;</span><br><span class="line">	<span class="built_in">processInitializers</span>(context, thisThread, timingInfo, up);</span><br><span class="line">	context.<span class="built_in">notifyBatch</span>(dyld_image_state_initialized, <span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">mach_port_deallocate</span>(<span class="built_in">mach_task_self</span>(), thisThread);</span><br><span class="line">	<span class="type">uint64_t</span> t2 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">	fgTotalInitTime += (t2 - t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processInitializers 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageLoader::processInitializers</span><span class="params">(<span class="type">const</span> LinkContext&amp; context, <span class="type">mach_port_t</span> thisThread,</span></span></span><br><span class="line"><span class="params"><span class="function">									 InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">uint32_t</span> maxImageCount = context.<span class="built_in">imageCount</span>()+<span class="number">2</span>;</span><br><span class="line">	ImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class="line">	ImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class="number">0</span>];</span><br><span class="line">	ups.count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class="line">	<span class="comment">// uninitialized upward dependencies.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uintptr_t</span> i=<span class="number">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class="line">		images.images[i]-&gt;<span class="built_in">recursiveInitialization</span>(context, thisThread, images.images[i]-&gt;<span class="built_in">getPath</span>(), timingInfo, ups);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If any upward dependencies remain, init them.</span></span><br><span class="line">	<span class="keyword">if</span> ( ups.count &gt; <span class="number">0</span> )</span><br><span class="line">		<span class="built_in">processInitializers</span>(context, thisThread, timingInfo, ups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>recursiveInitialization 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageLoader::recursiveInitialization</span><span class="params">(<span class="type">const</span> LinkContext&amp; context, <span class="type">mach_port_t</span> this_thread, <span class="type">const</span> <span class="type">char</span>* pathToInitialize,</span></span></span><br><span class="line"><span class="params"><span class="function">										  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">recursive_lock <span class="title">lock_info</span><span class="params">(this_thread)</span></span>;</span><br><span class="line">	<span class="built_in">recursiveSpinLock</span>(lock_info);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="number">-1</span> ) &#123;</span><br><span class="line">		<span class="type">uint8_t</span> oldState = fState;</span><br><span class="line">		<span class="comment">// break cycles</span></span><br><span class="line">		fState = dyld_image_state_dependents_initialized<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// initialize lower level libraries first</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="built_in">libraryCount</span>(); ++i) &#123;</span><br><span class="line">				ImageLoader* dependentImage = <span class="built_in">libImage</span>(i);</span><br><span class="line">				<span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">					<span class="comment">// don&#x27;t try to initialize stuff &quot;above&quot; me yet</span></span><br><span class="line">					<span class="keyword">if</span> ( <span class="built_in">libIsUpward</span>(i) ) &#123;</span><br><span class="line">						uninitUps.images[uninitUps.count] = dependentImage;</span><br><span class="line">						uninitUps.count++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class="line">						dependentImage-&gt;<span class="built_in">recursiveInitialization</span>(context, this_thread, <span class="built_in">libPath</span>(i), timingInfo, uninitUps);</span><br><span class="line">					&#125;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// record termination order</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;<span class="built_in">needsTermination</span>() )</span><br><span class="line">				context.<span class="built_in">terminationRecorder</span>(<span class="keyword">this</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line">			<span class="type">uint64_t</span> t1 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">			fState = dyld_image_state_dependents_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			context.<span class="built_in">notifySingle</span>(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// initialize this image</span></span><br><span class="line">			<span class="type">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;<span class="built_in">doInitialization</span>(context);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">			fState = dyld_image_state_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			context.<span class="built_in">notifySingle</span>(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> ( hasInitializers ) &#123;</span><br><span class="line">				<span class="type">uint64_t</span> t2 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">				timingInfo.<span class="built_in">addTime</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getShortName</span>(), t2-t1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">			<span class="comment">// this image is not initialized</span></span><br><span class="line">			fState = oldState;</span><br><span class="line">			<span class="built_in">recursiveSpinUnLock</span>();</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">recursiveSpinUnLock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doInitialization 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ImageLoaderMachO::doInitialization</span><span class="params">(<span class="type">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">CRSetCrashLogMessage2</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getPath</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mach-o has -init and static initializers</span></span><br><span class="line">	<span class="built_in">doImageInit</span>(context);</span><br><span class="line">	<span class="built_in">doModInitFunctions</span>(context);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">CRSetCrashLogMessage2</span>(<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (fHasDashInit || fHasInitializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调到 doModInitFunctions 函数，实现逻辑和上文提到的dyld的自身的初始化一样，遍历调用_mod_init_func中的方法指针。</p>
<p>runtime就是在这里被初始化的，调试一下就可以看到:<br><img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/6880c3f245ce10b72f214d8851b959e5.png"></p>
<p>调用栈和上面描述的一样，最终由 libSystem.B.dylib -&gt; libdispatch.dylib -&gt; libobjc.A.dylib 这个调用顺序初始化了runtime。<br>而runtime 的这个函数，在dyld反向注册了三个回调函数。<br><code>_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</code></p>
<p>而这个注册函数会把每个已经load完的镜像同步地回调给runtime：</p>
<p><img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d26ee1e5057ed5fc0c63d13baac4b77b.png"></p>
<p>从代码中我们也可以确认：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record functions to call</span></span><br><span class="line">	sNotifyObjCMapped	= mapped;</span><br><span class="line">	sNotifyObjCInit		= init;</span><br><span class="line">	sNotifyObjCUnmapped = unmapped;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call &#x27;mapped&#x27; function with all images mapped so far</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">notifyBatchPartial</span>(dyld_image_state_bound, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">		<span class="comment">// ignore request to abort during registration</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/32209809&gt; call &#x27;init&#x27; function on all images already init&#x27;ed (below libSystem)</span></span><br><span class="line">	<span class="keyword">for</span> (std::vector&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class="built_in">begin</span>(); it != sAllImages.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		ImageLoader* image = *it;</span><br><span class="line">		<span class="keyword">if</span> ( (image-&gt;<span class="built_in">getState</span>() == dyld_image_state_initialized) &amp;&amp; image-&gt;<span class="built_in">notifyObjC</span>() ) &#123;</span><br><span class="line">			<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="type">uint64_t</span>)image-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			(*sNotifyObjCInit)(image-&gt;<span class="built_in">getRealPath</span>(), image-&gt;<span class="built_in">machHeader</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历 sAllImages ，回调给 <code>_dyld_objc_notify_init init</code>函数。runtime就可以根据mach-o的 class 有关的 section 开始初始化了。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><span id="jump_end">参考文献</span></h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.dllhook.com/post/249.html">内嵌汇编的一些黑科技：访问自身Mach-O、调用函数等</a></li>
<li><a target="_blank" rel="noopener" href="https://paper.seebug.org/202/">Mach-O脱壳技巧</a></li>
<li><a target="_blank" rel="noopener" href="https://www.dllhook.com/post/238.html">dyld详解</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></li>
<li><a target="_blank" rel="noopener" href="https://feicong.github.io/2017/01/14/dylib/index.html">dylib动态库加载过程分析</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" rel="tag"># 动态链接</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/03/04/10.runloop-binary-search/" rel="prev" title="RunLoop中"奇怪"的二分查找">
                  <i class="fa fa-chevron-left"></i> RunLoop中"奇怪"的二分查找
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/03/15/12.compiler-autorelease-opt/" rel="next" title="当编译优化遇上AutoRelease优化">
                  当编译优化遇上AutoRelease优化 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Caio</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  





</body>
</html>
